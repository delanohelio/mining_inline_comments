{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NjAzNjk5", "number": 1706, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0MzowM1rOECn14A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjoyNDoyMVrOEDBN2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTg1Mzc2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0MzowM1rOGfMSEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo0MzoxOVrOGfab0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2MDI3NQ==", "bodyText": "No Deployment is happening here.  Change the message. May be cut-n-paste error", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435360275", "createdAt": "2020-06-04T15:43:03Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "diffHunk": "@@ -0,0 +1,77 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+import sys, traceback\n+\n+def change_server_count():\n+  try:\n+    connect_to_adminserver()\n+    edit()\n+    startEdit()\n+    cd('/Clusters/' + cluster_name + '/DynamicServers/' + cluster_name)\n+    cmo.setDynamicClusterSize(6)\n+    cmo.setMaxDynamicClusterSize(6)\n+    cmo.setMinDynamicClusterSize(2)\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])    \n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MjE0Ng==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435592146", "createdAt": "2020-06-04T22:43:19Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "diffHunk": "@@ -0,0 +1,77 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+import sys, traceback\n+\n+def change_server_count():\n+  try:\n+    connect_to_adminserver()\n+    edit()\n+    startEdit()\n+    cd('/Clusters/' + cluster_name + '/DynamicServers/' + cluster_name)\n+    cmo.setDynamicClusterSize(6)\n+    cmo.setMaxDynamicClusterSize(6)\n+    cmo.setMinDynamicClusterSize(2)\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])    \n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2MDI3NQ=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTg1Njc5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0Mzo0OVrOGfMUBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo0MzoyNlrOGfab8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2MDc3Mg==", "bodyText": "Modify the Deployment Message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435360772", "createdAt": "2020-06-04T15:43:49Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "diffHunk": "@@ -0,0 +1,77 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+import sys, traceback\n+\n+def change_server_count():\n+  try:\n+    connect_to_adminserver()\n+    edit()\n+    startEdit()\n+    cd('/Clusters/' + cluster_name + '/DynamicServers/' + cluster_name)\n+    cmo.setDynamicClusterSize(6)\n+    cmo.setMaxDynamicClusterSize(6)\n+    cmo.setMinDynamicClusterSize(2)\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])    \n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'\n+    print dumpStack()\n+    apply(traceback.print_exception, sys.exc_info())\n+    exit(exitcode=1)\n+\n+def change_admin_port():\n+  try:\n+    connect_to_adminserver()\n+    admin_server_name = get_admin_server_name()\n+    edit()\n+    startEdit()\n+    cd('/Servers/' + admin_server_name)\n+    cmo.setListenPort(int(new_admin_port))\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])\n+    exit(exitcode=1)\n+  except:\n+    print 'Changing admin port failed'\n+    print dumpStack()\n+    apply(traceback.print_exception, sys.exc_info())\n+    exit(exitcode=1)\n+\n+def connect_to_adminserver():\n+  try:\n+    if connected == 'false':    \n+      print 'connecting to admin server'\n+      connect(admin_username, admin_password, 't3://' + admin_host + ':' + admin_port)\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])\n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MjE3OQ==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435592179", "createdAt": "2020-06-04T22:43:26Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/resources/python-scripts/introspect_version_script.py", "diffHunk": "@@ -0,0 +1,77 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+import sys, traceback\n+\n+def change_server_count():\n+  try:\n+    connect_to_adminserver()\n+    edit()\n+    startEdit()\n+    cd('/Clusters/' + cluster_name + '/DynamicServers/' + cluster_name)\n+    cmo.setDynamicClusterSize(6)\n+    cmo.setMaxDynamicClusterSize(6)\n+    cmo.setMinDynamicClusterSize(2)\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])    \n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'\n+    print dumpStack()\n+    apply(traceback.print_exception, sys.exc_info())\n+    exit(exitcode=1)\n+\n+def change_admin_port():\n+  try:\n+    connect_to_adminserver()\n+    admin_server_name = get_admin_server_name()\n+    edit()\n+    startEdit()\n+    cd('/Servers/' + admin_server_name)\n+    cmo.setListenPort(int(new_admin_port))\n+    save()\n+    activate()\n+    disconnect()\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])\n+    exit(exitcode=1)\n+  except:\n+    print 'Changing admin port failed'\n+    print dumpStack()\n+    apply(traceback.print_exception, sys.exc_info())\n+    exit(exitcode=1)\n+\n+def connect_to_adminserver():\n+  try:\n+    if connected == 'false':    \n+      print 'connecting to admin server'\n+      connect(admin_username, admin_password, 't3://' + admin_host + ':' + admin_port)\n+  except NameError, e:\n+    print('Apparently properties not set.')\n+    print('Please check the property: ', sys.exc_info()[0], sys.exc_info()[1])\n+    exit(exitcode=1)\n+  except:\n+    print 'Deployment failed'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2MDc3Mg=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTg3ODc1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0OToyNlrOGfMikQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNzoyN1rOGfZ4oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2NDQ5Nw==", "bodyText": "Will the Job fail if the corresponding WLST script fails ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435364497", "createdAt": "2020-06-04T15:49:26Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "diffHunk": "@@ -0,0 +1,207 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class WLSTUtils {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/scripts/\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Execute WLST script.\n+   *\n+   * @param wlstScript WLST script path\n+   * @param domainProperties domain property file path\n+   * @param namespace namespace in which to run the job\n+   */\n+  public static void executeWLSTScript(Path wlstScript, Path domainProperties, String namespace) {\n+\n+    setImage(namespace);\n+\n+    String wlstScriptFileName = wlstScript.getFileName().toString();\n+    String wlstPropertiesFile = domainProperties.getFileName().toString();\n+\n+    logger.info(\"Creating a config map to hold wlst script files\");\n+    String uniqueName = Namespace.uniqueName();\n+    String wlstScriptConfigMapName = \"wlst-scripts-cm-\" + uniqueName;\n+    String wlstJobName = \"wlst-job-\" + uniqueName;\n+\n+    createConfigMapFromFiles(wlstScriptConfigMapName,\n+        Arrays.asList(wlstScript, domainProperties), namespace);\n+\n+    logger.info(\"Preparing to run WLST job\");\n+    // create a V1Container with specific scripts and properties for running WLST script\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(MOUNT_POINT + \"/\" + wlstScriptFileName) //wlst deploy py script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(MOUNT_POINT + \"/\" + wlstPropertiesFile); //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to execute WLST script\");\n+    assertDoesNotThrow(()\n+        -> createWLSTJob(wlstJobName, wlstScriptConfigMapName, namespace, jobCreationContainer),\n+        \"WLST execution failed\");\n+  }\n+\n+  /**\n+   * Create a job to execute WLST script.\n+   *\n+   * @param uniqueName a unique job name\n+   * @param wlstScriptConfigMapName configmap holding wlst script file\n+   * @param namespace name of the namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to execute WLST script\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static void createWLSTJob(String uniqueName, String wlstScriptConfigMapName, String namespace,\n+      V1Container jobContainer) throws ApiException {\n+    logger.info(\"Running Kubernetes job to execute WLST script\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(uniqueName)\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .containers(Arrays.asList(jobContainer\n+                        .name(\"execute-wlst-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"wlst-job-cm-volume\") // wlst script volume\n+                                .mountPath(MOUNT_POINT))))) // mounted under /sctipts inside pod\n+                    .volumes(Arrays.asList(new V1Volume()\n+                        .name(\"wlst-job-cm-volume\") // deployment scripts volume\n+                        .configMap(new V1ConfigMapVolumeSource()\n+                            .name(wlstScriptConfigMapName)))) //config map containing wlst script\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create WLST execution Job\");\n+\n+    logger.info(\"Checking if the WLST job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to execute WLST", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MzEzNw==", "bodyText": "Yes if there are any exceptions or cannot connect to the admin server the job will fail.\nOf course whoever calling this utility by supplying py script will have to make sure that they exit the WLST script with exit code 1 when something goes wrong.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435583137", "createdAt": "2020-06-04T22:17:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "diffHunk": "@@ -0,0 +1,207 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class WLSTUtils {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/scripts/\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Execute WLST script.\n+   *\n+   * @param wlstScript WLST script path\n+   * @param domainProperties domain property file path\n+   * @param namespace namespace in which to run the job\n+   */\n+  public static void executeWLSTScript(Path wlstScript, Path domainProperties, String namespace) {\n+\n+    setImage(namespace);\n+\n+    String wlstScriptFileName = wlstScript.getFileName().toString();\n+    String wlstPropertiesFile = domainProperties.getFileName().toString();\n+\n+    logger.info(\"Creating a config map to hold wlst script files\");\n+    String uniqueName = Namespace.uniqueName();\n+    String wlstScriptConfigMapName = \"wlst-scripts-cm-\" + uniqueName;\n+    String wlstJobName = \"wlst-job-\" + uniqueName;\n+\n+    createConfigMapFromFiles(wlstScriptConfigMapName,\n+        Arrays.asList(wlstScript, domainProperties), namespace);\n+\n+    logger.info(\"Preparing to run WLST job\");\n+    // create a V1Container with specific scripts and properties for running WLST script\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(MOUNT_POINT + \"/\" + wlstScriptFileName) //wlst deploy py script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(MOUNT_POINT + \"/\" + wlstPropertiesFile); //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to execute WLST script\");\n+    assertDoesNotThrow(()\n+        -> createWLSTJob(wlstJobName, wlstScriptConfigMapName, namespace, jobCreationContainer),\n+        \"WLST execution failed\");\n+  }\n+\n+  /**\n+   * Create a job to execute WLST script.\n+   *\n+   * @param uniqueName a unique job name\n+   * @param wlstScriptConfigMapName configmap holding wlst script file\n+   * @param namespace name of the namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to execute WLST script\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static void createWLSTJob(String uniqueName, String wlstScriptConfigMapName, String namespace,\n+      V1Container jobContainer) throws ApiException {\n+    logger.info(\"Running Kubernetes job to execute WLST script\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(uniqueName)\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .containers(Arrays.asList(jobContainer\n+                        .name(\"execute-wlst-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"wlst-job-cm-volume\") // wlst script volume\n+                                .mountPath(MOUNT_POINT))))) // mounted under /sctipts inside pod\n+                    .volumes(Arrays.asList(new V1Volume()\n+                        .name(\"wlst-job-cm-volume\") // deployment scripts volume\n+                        .configMap(new V1ConfigMapVolumeSource()\n+                            .name(wlstScriptConfigMapName)))) //config map containing wlst script\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create WLST execution Job\");\n+\n+    logger.info(\"Checking if the WLST job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to execute WLST", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2NDQ5Nw=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTg4NzcyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo1MTo0M1rOGfMogA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxMTowMlrOGfZvgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2NjAxNg==", "bodyText": "Can I get the standout of the WLST script after the Job is complected ?  May be thru job log or some other mechanism", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435366016", "createdAt": "2020-06-04T15:51:43Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "diffHunk": "@@ -0,0 +1,207 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class WLSTUtils {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/scripts/\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Execute WLST script.\n+   *\n+   * @param wlstScript WLST script path\n+   * @param domainProperties domain property file path\n+   * @param namespace namespace in which to run the job\n+   */\n+  public static void executeWLSTScript(Path wlstScript, Path domainProperties, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MDgwMw==", "bodyText": "I  am printing it when job is done executing, so you don't need to look for it under diagnostic_logs. It will be available in console log itself.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435580803", "createdAt": "2020-06-04T22:11:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/WLSTUtils.java", "diffHunk": "@@ -0,0 +1,207 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class WLSTUtils {\n+\n+  private static String image;\n+  private static boolean isUseSecret;\n+  private static final String MOUNT_POINT = \"/scripts/\";\n+\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Execute WLST script.\n+   *\n+   * @param wlstScript WLST script path\n+   * @param domainProperties domain property file path\n+   * @param namespace namespace in which to run the job\n+   */\n+  public static void executeWLSTScript(Path wlstScript, Path domainProperties, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2NjAxNg=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTkyMTk1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo1OToyNVrOGfM-Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo0NToxNlrOGfaeuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MTU3NA==", "bodyText": "For a dynamic config.xml change (e.g. changing  cluster size) updating the introSpectVersion will initiate a simultaneous re-start.\nFor a non-dynamic config.xml change (e.g. changing  admin server port ) updating the introSpectVersion will initiate a rolling re-start.\nIs this assumption is true ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435371574", "createdAt": "2020-06-04T15:59:25Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NjU5NQ==", "bodyText": "I don't think so. As far as I know, the re-introspect behavior is the same with either type of change, and an introspectVersion change is not expected to trigger a roll.  @russgold ^^^", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435376595", "createdAt": "2020-06-04T16:07:01Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MTU3NA=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5Mjg4OA==", "bodyText": "For a dynamic config.xml change (e.g. changing cluster size) updating the introSpectVersion will initiate\n\nIt will only start the new pod if replica is also changed, won't restart existing pods", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435592888", "createdAt": "2020-06-04T22:45:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MTU3NA=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk0NzUwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowNjowNlrOGfNO1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo0OToyOFrOGfakYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NTgyOQ==", "bodyText": "Here we can use the logic used in TestActions.patchDomainResourceWithNewRestartVersion to dynamically generate the introspectVersion string, instead of hard-coding.\nThis utility can be moved to TestActions class as patchDomainResourceWithNewIntrospectVersion", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435375829", "createdAt": "2020-06-04T16:06:06Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.\n+   * Test Creates a domain in pv using WLST.\n+   * Updates the cluster configuration, cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and cluster maximum and minimum replicas are updated\n+   * under domain status.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n     }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // construct a patch string to update introspectVersion\n+    StringBuffer patchStr = new StringBuffer(\"[{\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDMzNg==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435594336", "createdAt": "2020-06-04T22:49:28Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.\n+   * Test Creates a domain in pv using WLST.\n+   * Updates the cluster configuration, cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and cluster maximum and minimum replicas are updated\n+   * under domain status.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n     }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // construct a patch string to update introspectVersion\n+    StringBuffer patchStr = new StringBuffer(\"[{\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NTgyOQ=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk2Mjg0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowOTozM1rOGfNYWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MDozN1rOGfamBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3ODI2Nw==", "bodyText": "Description should be read as  \"Verifies the introspector runs and pods are restated in a rolling  fashion\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435378267", "createdAt": "2020-06-04T16:09:33Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.\n+   * Test Creates a domain in pv using WLST.\n+   * Updates the cluster configuration, cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and cluster maximum and minimum replicas are updated\n+   * under domain status.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n     }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // construct a patch string to update introspectVersion\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"add\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/introspectVersion\\\", \")\n+        .append(\"\\\"value\\\": \\\"2\")\n+        .append(\"\\\"}]\");\n+    logger.info(\"Patch String \\n{0}\", patchStr);\n+\n+    logger.info(\"Adding introspectVersion for domain {0} in namespace {1} using patch string: {2}\",\n+        domainUid, introDomainNamespace, patchStr.toString());\n+\n+    // patch the custom resource\n+    V1Patch patch = new V1Patch(new String(patchStr));\n+    patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, run and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, introDomainNamespace);\n+\n+    //verify the maximum and minimum cluster size is updated to expected values\n+    withStandardRetryPolicy.conditionEvaluationListener(new ConditionEvaluationListener() {\n+        @Override\n+        public void conditionEvaluated(EvaluatedCondition condition) {\n+          logger.info(\"Waiting for Domain.status.clusters.{0}.maximumReplicas to be 6\", clusterName);\n+        }\n+      })\n+        .until((Callable<Boolean>) () -> {\n+          Domain res = TestActions.getDomainCustomResource(domainUid, introDomainNamespace);\n+          return (res.getStatus().getClusters().get(0).getMaximumReplicas() == 6)\n+              && (res.getStatus().getClusters().get(0).getMinimumReplicas() == 2);\n+        }\n+        );\n+  }\n+\n+  /**\n+   * Test server pods are rolled and updated when introspector run triggered by introSpectVersion.\n+   * Updates the admin server listen port using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and pods are rolled in rolling fashion.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDc1Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435594756", "createdAt": "2020-06-04T22:50:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.\n+   * Test Creates a domain in pv using WLST.\n+   * Updates the cluster configuration, cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and cluster maximum and minimum replicas are updated\n+   * under domain status.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Order(3)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n     }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // construct a patch string to update introspectVersion\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"add\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/introspectVersion\\\", \")\n+        .append(\"\\\"value\\\": \\\"2\")\n+        .append(\"\\\"}]\");\n+    logger.info(\"Patch String \\n{0}\", patchStr);\n+\n+    logger.info(\"Adding introspectVersion for domain {0} in namespace {1} using patch string: {2}\",\n+        domainUid, introDomainNamespace, patchStr.toString());\n+\n+    // patch the custom resource\n+    V1Patch patch = new V1Patch(new String(patchStr));\n+    patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, run and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, introDomainNamespace);\n+\n+    //verify the maximum and minimum cluster size is updated to expected values\n+    withStandardRetryPolicy.conditionEvaluationListener(new ConditionEvaluationListener() {\n+        @Override\n+        public void conditionEvaluated(EvaluatedCondition condition) {\n+          logger.info(\"Waiting for Domain.status.clusters.{0}.maximumReplicas to be 6\", clusterName);\n+        }\n+      })\n+        .until((Callable<Boolean>) () -> {\n+          Domain res = TestActions.getDomainCustomResource(domainUid, introDomainNamespace);\n+          return (res.getStatus().getClusters().get(0).getMaximumReplicas() == 6)\n+              && (res.getStatus().getClusters().get(0).getMinimumReplicas() == 2);\n+        }\n+        );\n+  }\n+\n+  /**\n+   * Test server pods are rolled and updated when introspector run triggered by introSpectVersion.\n+   * Updates the admin server listen port using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and pods are rolled in rolling fashion.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3ODI2Nw=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk3NDUwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxMjozMFrOGfNgJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MToyM1rOGfanHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDI2MQ==", "bodyText": "Should we have a test to just update the introSpectVersion with out any config change.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435380261", "createdAt": "2020-06-04T16:12:30Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NTAzNg==", "bodyText": "we can but what is the purpose of it?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435595036", "createdAt": "2020-06-04T22:51:23Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -573,20 +596,291 @@ public void testDomainInPvUsingWdt() {\n         .isTrue();\n   }\n \n+\n   /**\n-   * Uninstall Nginx.\n-   * The cleanup framework does not uninstall Nginx release.\n-   * Do it here for now.\n+   * Test domain status updated when introspector run triggered by introSpectVersion.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MDI2MQ=="}, "originalCommit": {"oid": "73741338352636450722ef150cf08d294d748c62"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjcwNTMyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToyOToxNFrOGfUytQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MzoxNlrOGfapjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5OTcwMQ==", "bodyText": "do we really need this? if the domain shutdown fails for some reason, the test will be marked as failed which is not correct ...if its really needed, this should be done in afterEach or afterAll methods or without assert IMO.\nAlso domain custom resource is deleted as part of cleanup test infra, all the pods will be deleted as the Operator is still up at that time?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435499701", "createdAt": "2020-06-04T19:29:14Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -375,6 +380,8 @@ public void testDomainInPvUsingWlst() {\n         .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n         .isTrue();\n \n+    assertTrue(shutdownDomain(domainUid, wlstDomainNamespace), \"Failed to shutdown domain\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f2cc9a4c20509a68536dc424b61cb60bcece49"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NTY2Mw==", "bodyText": "Initially I added the tests in ItDominInPV.java and these tests were running after the first 2 which created 4 server pods. In order not to strain the cluster I thought of shutting down the domain before the introspectVersion test runs.\nSince the introspectVersion tests are moved to a different class I removed these shutdown calls.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435595663", "createdAt": "2020-06-04T22:53:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -375,6 +380,8 @@ public void testDomainInPvUsingWlst() {\n         .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n         .isTrue();\n \n+    assertTrue(shutdownDomain(domainUid, wlstDomainNamespace), \"Failed to shutdown domain\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5OTcwMQ=="}, "originalCommit": {"oid": "c1f2cc9a4c20509a68536dc424b61cb60bcece49"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjcxMDgxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTozMToxN1rOGfU2bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTozMToxN1rOGfU2bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwMDY1Mg==", "bodyText": "same as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435500652", "createdAt": "2020-06-04T19:31:17Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -571,6 +579,8 @@ public void testDomainInPvUsingWdt() {\n         .as(\"Verify NGINX can access the test web app from all managed servers in the domain\")\n         .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n         .isTrue();\n+\n+    assertTrue(shutdownDomain(domainUid, wdtDomainNamespace), \"Failed to shutdown domain\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f2cc9a4c20509a68536dc424b61cb60bcece49"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjcxMzcwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTozMjoyMVrOGfU4XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxODozNFrOGfZ6Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwMTE0OQ==", "bodyText": "fix javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435501149", "createdAt": "2020-06-04T19:32:21Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,846 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainWithIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1f2cc9a4c20509a68536dc424b61cb60bcece49"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MzUyMg==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r435583522", "createdAt": "2020-06-04T22:18:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,846 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainWithIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwMTE0OQ=="}, "originalCommit": {"oid": "c1f2cc9a4c20509a68536dc424b61cb60bcece49"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjAwODU1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjoyMzoyN1rOGf1GAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0OTowNFrOGf146w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyODkzMA==", "bodyText": "I think this will be fine, but I'm wondering if we can eventually do better... What I mean is that this could fail in two different ways: 1) unlikely -- but the introspector could run very fast and the test would miss that the pod ever existed, and 2) the introspector could run but fail quickly and similarly be missed. Let's see if this test starts to fail intermittently.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r436028930", "createdAt": "2020-06-05T16:23:27Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,854 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to introspectVersion attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the introspectVersion runs the introspector\")\n+@IntegrationTest\n+public class ItIntrospectVersion implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String introDomainNamespace = null;\n+\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static HelmParams nginxHelmParams = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    introDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, introDomainNamespace);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+\n+  /**\n+   * Test domain status gets updated when introspectVersion attribute is added under domain.spec.\n+   * Test Creates a domain in persistent volume using WLST.\n+   * Updates the cluster configuration; cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and the cluster maximum replica is updated\n+   * under domain status.\n+   * Verifies that the new pod comes up and sample application deployment works.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int managedServerPort = 8001;\n+\n+    int replicaCount = 2;\n+\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // get the pod creation time stamps\n+    LinkedHashMap<String, DateTime> pods = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(introDomainNamespace, adminServerPodName);\n+    pods.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      pods.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(introDomainNamespace, managedServerPodNamePrefix + i));\n+    }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"max_cluster_size\", Integer.toString(3));\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // patch the domain to increase the replicas of the cluster and add introspectVersion field\n+    String patchStr =\n+          \"[\"\n+            + \"{\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/clusters/0/replicas\\\", \\\"value\\\": 3},\"\n+            + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+\n+    logger.info(\"Updating replicas in cluster {0} using patch string: {1}\", clusterName, patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee9cf4a4328ea5433f48b8130ce5adf1964a58"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MTk2Mw==", "bodyText": "Yes I agree when I was manually testing it I missed the introspector lifecycle and noticed that within 30 seconds it finished running.\nThe withStandardRetryPolicy has a poll delay of 2 seconds so hopefully it shouldn't miss it. But lets see if fails intermittently.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r436041963", "createdAt": "2020-06-05T16:49:04Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,854 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to introspectVersion attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the introspectVersion runs the introspector\")\n+@IntegrationTest\n+public class ItIntrospectVersion implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String introDomainNamespace = null;\n+\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static HelmParams nginxHelmParams = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    introDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, introDomainNamespace);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+\n+  /**\n+   * Test domain status gets updated when introspectVersion attribute is added under domain.spec.\n+   * Test Creates a domain in persistent volume using WLST.\n+   * Updates the cluster configuration; cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and the cluster maximum replica is updated\n+   * under domain status.\n+   * Verifies that the new pod comes up and sample application deployment works.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int managedServerPort = 8001;\n+\n+    int replicaCount = 2;\n+\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // get the pod creation time stamps\n+    LinkedHashMap<String, DateTime> pods = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(introDomainNamespace, adminServerPodName);\n+    pods.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      pods.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(introDomainNamespace, managedServerPodNamePrefix + i));\n+    }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"max_cluster_size\", Integer.toString(3));\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // patch the domain to increase the replicas of the cluster and add introspectVersion field\n+    String patchStr =\n+          \"[\"\n+            + \"{\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/clusters/0/replicas\\\", \\\"value\\\": 3},\"\n+            + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+\n+    logger.info(\"Updating replicas in cluster {0} using patch string: {1}\", clusterName, patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyODkzMA=="}, "originalCommit": {"oid": "4bee9cf4a4328ea5433f48b8130ce5adf1964a58"}, "originalPosition": 394}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjAxMTEyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjoyNDoyMVrOGf1HsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0OToyMlrOGf15cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyOTM2MA==", "bodyText": "no capital 'S'", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r436029360", "createdAt": "2020-06-05T16:24:21Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,854 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to introspectVersion attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the introspectVersion runs the introspector\")\n+@IntegrationTest\n+public class ItIntrospectVersion implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String introDomainNamespace = null;\n+\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static HelmParams nginxHelmParams = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    introDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, introDomainNamespace);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+\n+  /**\n+   * Test domain status gets updated when introspectVersion attribute is added under domain.spec.\n+   * Test Creates a domain in persistent volume using WLST.\n+   * Updates the cluster configuration; cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and the cluster maximum replica is updated\n+   * under domain status.\n+   * Verifies that the new pod comes up and sample application deployment works.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int managedServerPort = 8001;\n+\n+    int replicaCount = 2;\n+\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // get the pod creation time stamps\n+    LinkedHashMap<String, DateTime> pods = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(introDomainNamespace, adminServerPodName);\n+    pods.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      pods.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(introDomainNamespace, managedServerPodNamePrefix + i));\n+    }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"max_cluster_size\", Integer.toString(3));\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // patch the domain to increase the replicas of the cluster and add introspectVersion field\n+    String patchStr =\n+          \"[\"\n+            + \"{\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/clusters/0/replicas\\\", \\\"value\\\": 3},\"\n+            + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+\n+    logger.info(\"Updating replicas in cluster {0} using patch string: {1}\", clusterName, patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, introDomainNamespace);\n+\n+    //verify the maximum cluster size is updated to expected value\n+    withStandardRetryPolicy.conditionEvaluationListener(new ConditionEvaluationListener() {\n+        @Override\n+        public void conditionEvaluated(EvaluatedCondition condition) {\n+          logger.info(\"Waiting for Domain.status.clusters.{0}.maximumReplicas to be {1}\",\n+              clusterName, 3);\n+        }\n+      })\n+        .until((Callable<Boolean>) () -> {\n+          Domain res = getDomainCustomResource(domainUid, introDomainNamespace);\n+          return (res.getStatus().getClusters().get(0).getMaximumReplicas() == 3);\n+        }\n+        );\n+\n+    // verify the 3rd server pod comes up\n+    checkPodReady(managedServerPodNamePrefix + 3, domainUid, introDomainNamespace);\n+    checkServiceExists(managedServerPodNamePrefix + 3, introDomainNamespace);\n+\n+    // verify existing managed server pods are not affected\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify existing managed server services are not affected\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // verify existing pods are not restarted\n+    podStateNotChanged(adminServerPodName, domainUid, introDomainNamespace, adminPodCreationTime);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podStateNotChanged(managedServerPodNamePrefix + i,\n+          domainUid, introDomainNamespace, pods.get(i));\n+    }\n+\n+    //create ingress controller\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, introDomainNamespace);\n+    createIngressForDomainAndVerify(domainUid, introDomainNamespace, clusterNameMsPortMap);\n+\n+    // deploy application and verify all servers functions normally\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    logger.info(\"Deploying webapp to domain {0}\", archivePath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + adminServerName, archivePath,\n+        introDomainNamespace);\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //access application from admin server\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + \"/testwebapp/index.jsp\";\n+    assertEquals(200,\n+        assertDoesNotThrow(() -> OracleHttpClient.get(url, true),\n+            \"Accessing sample application on admin server failed\")\n+            .statusCode(), \"Status code not equals to 200\");\n+\n+    //access application in managed servers through NGINX load balancer\n+    logger.info(\"Accessing the sample app through NGINX load balancer\");\n+    String curlRequest = String.format(\"curl --silent --show-error --noproxy '*' \"\n+        + \"-H 'host: %s' http://%s:%s/testwebapp/index.jsp\",\n+        domainUid + \".\" + clusterName + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n+    List<String> managedServers = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      managedServers.add(domainUid + \"-\" + managedServerNameBase + i);\n+    }\n+    assertThat(callWebAppAndCheckForServerNameInResponse(curlRequest, managedServers, 20))\n+        .as(\"Verify NGINX can access the test web app from all managed servers in the domain\")\n+        .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n+        .isTrue();\n+\n+  }\n+\n+  /**\n+   * Test server pods are rolling restarted and updated when domain is patched\n+   * with introSpectVersion when non dynamic changes are made.\n+   * Updates the admin server listen port using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and pods are restated in a rolling fashion.\n+   * Verifies the new admin port of the admin server in services.\n+   * Verifies accessing sample application in admin server works.\n+   */\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion rolling server pods when admin server port is changed\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bee9cf4a4328ea5433f48b8130ce5adf1964a58"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MjA5OA==", "bodyText": "Fixed it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1706#discussion_r436042098", "createdAt": "2020-06-05T16:49:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIntrospectVersion.java", "diffHunk": "@@ -0,0 +1,854 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionEvaluationListener;\n+import org.awaitility.core.ConditionFactory;\n+import org.awaitility.core.EvaluatedCondition;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServicePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.WLSTUtils.executeWLSTScript;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests related to introspectVersion attribute.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the introspectVersion runs the introspector\")\n+@IntegrationTest\n+public class ItIntrospectVersion implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String introDomainNamespace = null;\n+\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static HelmParams nginxHelmParams = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for Introspect Version WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    introDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, introDomainNamespace);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+\n+  /**\n+   * Test domain status gets updated when introspectVersion attribute is added under domain.spec.\n+   * Test Creates a domain in persistent volume using WLST.\n+   * Updates the cluster configuration; cluster size using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and the cluster maximum replica is updated\n+   * under domain status.\n+   * Verifies that the new pod comes up and sample application deployment works.\n+   */\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion starting a introspector and updating domain status\")\n+  public void testDomainIntrospectVersionNotRolling() {\n+\n+    final String domainUid = \"mydomain\";\n+    final String clusterName = \"mycluster\";\n+\n+    final String adminServerName = \"admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+    final String managedServerNameBase = \"ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int managedServerPort = 8001;\n+\n+    int replicaCount = 2;\n+\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(introDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, introDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, introDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+        File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+        p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, introDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(introDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(introDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, introDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, introDomainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, introDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // get the pod creation time stamps\n+    LinkedHashMap<String, DateTime> pods = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(introDomainNamespace, adminServerPodName);\n+    pods.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      pods.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(introDomainNamespace, managedServerPodNamePrefix + i));\n+    }\n+\n+    logger.info(\"change the cluster size and verify the introspector runs and updates the domain status\");\n+    // create a temporary WebLogic WLST property file\n+    File wlstPropertiesFile = assertDoesNotThrow(() -> File.createTempFile(\"wlst\", \"properties\"),\n+        \"Creating WLST properties file failed\");\n+    Properties p1 = new Properties();\n+    p1.setProperty(\"admin_host\", K8S_NODEPORT_HOST);\n+    p1.setProperty(\"admin_port\", Integer.toString(t3ChannelPort));\n+    p1.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p1.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p1.setProperty(\"cluster_name\", clusterName);\n+    p1.setProperty(\"max_cluster_size\", Integer.toString(3));\n+    p1.setProperty(\"test_name\", \"change_server_count\");\n+    assertDoesNotThrow(() -> p1.store(new FileOutputStream(wlstPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write the WLST properties to file\");\n+\n+    // change the server count of the cluster by running online WLST\n+    Path configScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"introspect_version_script.py\");\n+    executeWLSTScript(configScript, wlstPropertiesFile.toPath(), introDomainNamespace);\n+\n+    // patch the domain to increase the replicas of the cluster and add introspectVersion field\n+    String patchStr =\n+          \"[\"\n+            + \"{\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/clusters/0/replicas\\\", \\\"value\\\": 3},\"\n+            + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"2\\\"}\"\n+        + \"]\";\n+\n+    logger.info(\"Updating replicas in cluster {0} using patch string: {1}\", clusterName, patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, introDomainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, introDomainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, introDomainNamespace);\n+\n+    //verify the maximum cluster size is updated to expected value\n+    withStandardRetryPolicy.conditionEvaluationListener(new ConditionEvaluationListener() {\n+        @Override\n+        public void conditionEvaluated(EvaluatedCondition condition) {\n+          logger.info(\"Waiting for Domain.status.clusters.{0}.maximumReplicas to be {1}\",\n+              clusterName, 3);\n+        }\n+      })\n+        .until((Callable<Boolean>) () -> {\n+          Domain res = getDomainCustomResource(domainUid, introDomainNamespace);\n+          return (res.getStatus().getClusters().get(0).getMaximumReplicas() == 3);\n+        }\n+        );\n+\n+    // verify the 3rd server pod comes up\n+    checkPodReady(managedServerPodNamePrefix + 3, domainUid, introDomainNamespace);\n+    checkServiceExists(managedServerPodNamePrefix + 3, introDomainNamespace);\n+\n+    // verify existing managed server pods are not affected\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, introDomainNamespace);\n+    }\n+\n+    // verify existing managed server services are not affected\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, introDomainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, introDomainNamespace);\n+    }\n+\n+    // verify existing pods are not restarted\n+    podStateNotChanged(adminServerPodName, domainUid, introDomainNamespace, adminPodCreationTime);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podStateNotChanged(managedServerPodNamePrefix + i,\n+          domainUid, introDomainNamespace, pods.get(i));\n+    }\n+\n+    //create ingress controller\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, introDomainNamespace);\n+    createIngressForDomainAndVerify(domainUid, introDomainNamespace, clusterNameMsPortMap);\n+\n+    // deploy application and verify all servers functions normally\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    logger.info(\"Deploying webapp to domain {0}\", archivePath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + adminServerName, archivePath,\n+        introDomainNamespace);\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(introDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //access application from admin server\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + \"/testwebapp/index.jsp\";\n+    assertEquals(200,\n+        assertDoesNotThrow(() -> OracleHttpClient.get(url, true),\n+            \"Accessing sample application on admin server failed\")\n+            .statusCode(), \"Status code not equals to 200\");\n+\n+    //access application in managed servers through NGINX load balancer\n+    logger.info(\"Accessing the sample app through NGINX load balancer\");\n+    String curlRequest = String.format(\"curl --silent --show-error --noproxy '*' \"\n+        + \"-H 'host: %s' http://%s:%s/testwebapp/index.jsp\",\n+        domainUid + \".\" + clusterName + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n+    List<String> managedServers = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      managedServers.add(domainUid + \"-\" + managedServerNameBase + i);\n+    }\n+    assertThat(callWebAppAndCheckForServerNameInResponse(curlRequest, managedServers, 20))\n+        .as(\"Verify NGINX can access the test web app from all managed servers in the domain\")\n+        .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n+        .isTrue();\n+\n+  }\n+\n+  /**\n+   * Test server pods are rolling restarted and updated when domain is patched\n+   * with introSpectVersion when non dynamic changes are made.\n+   * Updates the admin server listen port using online WLST.\n+   * Patches the domain custom resource with introSpectVersion.\n+   * Verifies the introspector runs and pods are restated in a rolling fashion.\n+   * Verifies the new admin port of the admin server in services.\n+   * Verifies accessing sample application in admin server works.\n+   */\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Test introSpectVersion rolling server pods when admin server port is changed\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyOTM2MA=="}, "originalCommit": {"oid": "4bee9cf4a4328ea5433f48b8130ce5adf1964a58"}, "originalPosition": 495}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4304, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}