{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMTg2MjA1", "number": 2020, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToyNzowNlrOEz7faQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToyNzowNlrOEz7faQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODg3NTI5OnYy", "diffSide": "RIGHT", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToyNzowNlrOHrdF1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMzo0MzoxOVrOHrjEUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA==", "bodyText": "Would this approach affect the guaranteed 'lexi numeric' order in which we start or shutdown servers?  Or which servers are reported in status?   (For example, when we're shutting down a cluster's servers one-at-a-time, the goal is to shutdown only the 'highest' server first, then the second highest, and so on.)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515327444", "createdAt": "2020-10-30T19:27:06Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MDI4MA==", "bodyText": "The approach considers this. The pending list is in the original order. We have unit test cases covering this too.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515350280", "createdAt": "2020-10-30T20:05:56Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MjYyNQ==", "bodyText": "But the final list does not maintain the original order. For example, if server3 is always and replicas count is 2, server1 and server3 will be started, and server3 will be started before server1.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515352625", "createdAt": "2020-10-30T20:11:21Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1Mjg5Nw==", "bodyText": "In the sample example, if cluster later scales down, server1 will be taken down, which is the correct.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515352897", "createdAt": "2020-10-30T20:12:04Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTI5MQ==", "bodyText": "The only behavior difference is the startup order among servers that need to be started up in the same round of make right check; servers with ALWAYS policy will be started before the servers with If-needed policy.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515355291", "createdAt": "2020-10-30T20:17:51Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4NTA1MQ==", "bodyText": "We want the overall startup and shutdown order to be very intuitive, predictable, and the exact reverse of each-other.\nQuestion 1: I think it'd be better if server1 always first in a cluster, then server2, and so on, if they aren't configured to start concurrently -- regardless of whether any of the servers are marked 'always'.  So, based on your analysis of the cluster use case ^^^ where server3 (marked always) starts before server1 (marked if_needed), it sounds like this pull may need to be refined?\nQuestion 2:  As for shutdown, if replica count is 3, and server1 & 3 are 'if needed' while server2 is always, then reducing replica count to 1 (or 0) should always shutdown server3 first and then shutdown server1 second.  (Side note: when setting the entire cluster to NEVER the entire cluster is expected to shutdown concurrently, so no worries there.)  Based on your analysis, it sounds like this will be honored?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515385051", "createdAt": "2020-10-30T21:11:48Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5MDk0Mg==", "bodyText": "I understand why you started the ALWAYS servers first, but I agree that it's more important that servers be started (and stopped) in a predictable and consistent order. We've had a few customers ask about startup ordering, so I could see us doing something like that in a future release. I think that means we need to keep the order very, very simple now so that customers would understand what they are configuring later.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515390942", "createdAt": "2020-10-30T21:28:47Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwNjE4Ng==", "bodyText": "\"Yes\" to both questions. Good catch on sequential startup order. I agree we need to resort the final list.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515406186", "createdAt": "2020-10-30T22:16:48Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNTM2MA==", "bodyText": "Fixed.\nKicked off a new Jenkins job (passed) https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/2893/.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2020#discussion_r515425360", "createdAt": "2020-10-30T23:43:19Z", "author": {"login": "doxiao"}, "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServersUpStep.java", "diffHunk": "@@ -118,23 +118,30 @@ public NextAction apply(Packet packet) {\n   private void addServersToFactory(@Nonnull ServersUpStepFactory factory, @Nonnull WlsDomainConfig wlsDomainConfig) {\n     Set<String> clusteredServers = new HashSet<>();\n \n+    List<ServerConfig> pendingServers = new ArrayList<>();\n     wlsDomainConfig.getClusterConfigs().values()\n-        .forEach(wlsClusterConfig -> addClusteredServersToFactory(factory, clusteredServers, wlsClusterConfig));\n+        .forEach(wlsClusterConfig -> addClusteredServersToFactory(\n+            factory, clusteredServers, wlsClusterConfig, pendingServers));\n \n     wlsDomainConfig.getServerConfigs().values().stream()\n         .filter(wlsServerConfig -> !clusteredServers.contains(wlsServerConfig.getName()))\n-        .forEach(wlsServerConfig -> factory.addServerIfNeeded(wlsServerConfig, null));\n+        .forEach(wlsServerConfig -> factory.addServerIfAlways(wlsServerConfig, null, pendingServers));\n+\n+    for (ServerConfig serverConfig : pendingServers) {\n+      factory.addServerIfNeeded(serverConfig.wlsServerConfig, serverConfig.wlsClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNzQ0NA=="}, "originalCommit": {"oid": "b7251b97731807540d9b6e9495e0b34d3b5c8d11"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3881, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}