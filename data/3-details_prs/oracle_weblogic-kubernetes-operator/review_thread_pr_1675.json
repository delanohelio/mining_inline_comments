{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTgyMTcz", "number": 1675, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODowMjo1NVrOD_yalw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMTozNjoyMFrOEAVLtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjEyODg3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODowMjo1NVrOGaqGIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODoxNzoyN1rOGbXeMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNTg1Nw==", "bodyText": "This port needs to match with the t3channel port of the domain you are creating. Otherwise it won't work.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430605857", "createdAt": "2020-05-26T18:02:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1MzU4OQ==", "bodyText": "The test runs fine. I checked ItDomainOnPV.java. It also set the nodePort(0) in Domain object (see line 257).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430753589", "createdAt": "2020-05-26T23:01:33Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNTg1Nw=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NTMxNg==", "bodyText": "By setting nodePort(0) here, the operator will pick a free nodePort available for admin T3Channel and default channel.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430785316", "createdAt": "2020-05-27T00:50:25Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNTg1Nw=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTEzNg==", "bodyText": "I changed the nodePort in ItDomainOnPV.java , its in PR #1678\nJust for the T3Channel the port has to match with what is used by the server inside the pod.\nPlease see the above PR.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430841136", "createdAt": "2020-05-27T03:46:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNTg1Nw=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0OTI5Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431349297", "createdAt": "2020-05-27T18:17:27Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNTg1Nw=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjEzOTQ0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODowNTo1OFrOGaqM2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODoxNzo1M1rOGbXfMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNzU3OQ==", "bodyText": "The same port needs to be used while creating the domain", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430607579", "createdAt": "2020-05-26T18:05:58Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwODQyOQ==", "bodyText": "Just FYI...\nthe port range has to be between 30,000 to 32,767", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430608429", "createdAt": "2020-05-26T18:07:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNzU3OQ=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NTY5OA==", "bodyText": "I ran the test and the result showed that the admin_t3_channel_port here is a cluster IP. We can hard code the port number here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430785698", "createdAt": "2020-05-27T00:51:55Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNzU3OQ=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0OTU1NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431349554", "createdAt": "2020-05-27T18:17:53Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwNzU3OQ=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 495}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjE0NTg4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODowNzo1NVrOGaqRBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToyODoyOVrOGa2K5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwODY0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Scale domain1 and verify there was no impact on domain2.\n          \n          \n            \n               * Scale domain1 and verify there is no impact on domain2.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430608647", "createdAt": "2020-05-26T18:07:55Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgwMzY4NQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430803685", "createdAt": "2020-05-27T01:28:29Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwODY0Nw=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 505}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjE1ODQwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxMToyN1rOGaqY5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToyODozN1rOGa2LXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMDY2Mg==", "bodyText": "this has to be done after domain1 was shutdown as well.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430610662", "createdAt": "2020-05-26T18:11:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 571}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgwMzgwNA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430803804", "createdAt": "2020-05-27T01:28:37Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMDY2Mg=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 571}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjE2MTI1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxMjoyMlrOGaqazA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToyODo0NlrOGa2Lyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMTE0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Verify domain2 server pods were no changed.\n          \n          \n            \n               * Verify domain2 server pods were not changed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430611148", "createdAt": "2020-05-26T18:12:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 575}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgwMzkxNA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430803914", "createdAt": "2020-05-27T01:28:46Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMTE0OA=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 575}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjE3NjI1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxNjo0OVrOGaqkag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToyODo1NFrOGa2MPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMzYxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Get domain1 an domain2 server pods original creation timestamps.\n          \n          \n            \n               * Get domain1 and domain2 server pods original creation timestamps.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430613610", "createdAt": "2020-05-26T18:16:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.\n+   */\n+  private void verifyDomain2NotChanged() {\n+    String domain2AdminServerPodName = domainAdminServerPodNames.get(1);\n+\n+    logger.info(\"Checking that domain2 admin server pod state was not changed\");\n+    assertThat(podStateNotChanged(domain2AdminServerPodName, domain2Uid, domain2Namespace,\n+        domainAdminPodOriginalTimestamps.get(1)))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .isTrue();\n+\n+    logger.info(\"Checking that domain2 managed server pods states were not changed\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      assertThat(podStateNotChanged(managedServerPodName, domain2Uid, domain2Namespace,\n+          domain2ManagedServerPodOriginalTimestampList.get(i - 1)))\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Get domain1 an domain2 server pods original creation timestamps.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgwNDAzMQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430804031", "createdAt": "2020-05-27T01:28:54Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.\n+   */\n+  private void verifyDomain2NotChanged() {\n+    String domain2AdminServerPodName = domainAdminServerPodNames.get(1);\n+\n+    logger.info(\"Checking that domain2 admin server pod state was not changed\");\n+    assertThat(podStateNotChanged(domain2AdminServerPodName, domain2Uid, domain2Namespace,\n+        domainAdminPodOriginalTimestamps.get(1)))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .isTrue();\n+\n+    logger.info(\"Checking that domain2 managed server pods states were not changed\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      assertThat(podStateNotChanged(managedServerPodName, domain2Uid, domain2Namespace,\n+          domain2ManagedServerPodOriginalTimestampList.get(i - 1)))\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Get domain1 an domain2 server pods original creation timestamps.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMzYxMA=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 603}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjE4MTY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxODoxODoyNVrOGaqn2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToyOTowNFrOGa2M0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxNDQ5MA==", "bodyText": "You don't need this check since podReady does this too.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430614490", "createdAt": "2020-05-26T18:18:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.\n+   */\n+  private void verifyDomain2NotChanged() {\n+    String domain2AdminServerPodName = domainAdminServerPodNames.get(1);\n+\n+    logger.info(\"Checking that domain2 admin server pod state was not changed\");\n+    assertThat(podStateNotChanged(domain2AdminServerPodName, domain2Uid, domain2Namespace,\n+        domainAdminPodOriginalTimestamps.get(1)))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .isTrue();\n+\n+    logger.info(\"Checking that domain2 managed server pods states were not changed\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      assertThat(podStateNotChanged(managedServerPodName, domain2Uid, domain2Namespace,\n+          domain2ManagedServerPodOriginalTimestampList.get(i - 1)))\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Get domain1 an domain2 server pods original creation timestamps.\n+   */\n+  private void getBothDomainsPodsOriginalCreationTimestamp() {\n+    // get the domain1 pods original creation timestamp\n+    logger.info(\"Getting admin server pod original creation timestamps for both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      domainAdminServerPodNames.add(domainUids.get(i) + \"-\" + ADMIN_SERVER_NAME_BASE);\n+      domainAdminPodOriginalTimestamps.add(\n+          getPodOriginalCreationTimestamp(domainAdminServerPodNames.get(i), domainNamespaces.get(i)));\n+    }\n+\n+    // get the managed server pods original creation timestamps\n+    logger.info(\"Getting managed server pods original creation timestamps for both domains\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      domain1ManagedServerPodOriginalTimestampList.add(\n+          getPodOriginalCreationTimestamp(managedServerPodName, domain1Namespace));\n+\n+      managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      domain2ManagedServerPodOriginalTimestampList.add(\n+          getPodOriginalCreationTimestamp(managedServerPodName, domain2Namespace));\n+    }\n+  }\n+\n+  /**\n+   * Shutdown both domains and verify all the server pods were shutdown.\n+   */\n+  private void shutdownBothDomainsAndVerify() {\n+\n+    // shutdown both domains\n+    logger.info(\"Shutting down both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      shutdown(domainUids.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // verify all the pods were shutdown\n+    logger.info(\"Verifying all server pods were shutdown for both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      // check admin server pod was shutdown\n+      checkPodDoesNotExist(domainUids.get(i) + \"-\" + ADMIN_SERVER_NAME_BASE,\n+          domainUids.get(i), domainNamespaces.get(i));\n+\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUids.get(i) + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodDoesNotExist(managedServerPodName, domainUids.get(i), domainNamespaces.get(i));\n+      }\n+    }\n+\n+    // check the scaled up managed servers in domain1 were shutdown\n+    logger.info(\"Verifying the scaled up managed servers in domain1 were shutdown\");\n+    for (int i = replicaCount + 1; i <= replicasAfterScale; i++) {\n+      String managedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(managedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Get pod original creation timestamp.\n+   * @param podName pod name to get the original creation timestamp\n+   * @param namespace the namespace in which the pod exists\n+   * @return the pod original creation timestamp\n+   */\n+  private String getPodOriginalCreationTimestamp(String podName, String namespace) {\n+    return assertDoesNotThrow(() -> getPodCreationTimestamp(namespace, \"\", podName),\n+        String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+            podName, namespace));\n+  }\n+\n+  /**\n+   * Check pod exist, ready and service exists in the specified namespace.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the label the pod is decorated with\n+   * @param namespace the namespace in which the pod exists\n+   */\n+  private void checkPodExistsReadyAndServiceExists(String podName, String domainUid, String namespace) {\n+    logger.info(\"Checking that pod {0} exists in namespace {1}\", podName, namespace);\n+    checkPodExists(podName, domainUid, namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgwNDE3OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r430804178", "createdAt": "2020-05-27T01:29:04Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restart;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdown;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+  private final int replicaCount = 2;\n+\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   * @throws IOException when creating PV path fails\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() throws IOException {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      image = kindRepoImage;\n+    } else {\n+      // create pull secrets for WebLogic image\n+      for (int i = 0; i < numberOfDomains; i++) {\n+        createOCRRepoSecret(domainNamespaces.get(i));\n+      }\n+      isUseSecret = true;\n+    }\n+\n+    // create two domains on PV using WLST\n+    createTwoDomainsOnPVUsingWlstAndVerify();\n+\n+    // get the domain1 and domain2 pods original creation timestamps\n+    getBothDomainsPodsOriginalCreationTimestamp();\n+\n+    // scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2\n+    replicasAfterScale = 3;\n+    scaleDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // restart domain1 and verify no impact on domain2\n+    restartDomain1AndVerifyNoImpactOnDomain2();\n+\n+    // shutdown both domains and verify the pods were shutdown\n+    shutdownBothDomainsAndVerify();\n+  }\n+\n+  /**\n+   * Create two domains on PV using WLST.\n+   * @throws IOException when creating PV path fails\n+   */\n+  private void createTwoDomainsOnPVUsingWlstAndVerify() throws IOException {\n+\n+    String wlSecretName = \"weblogic-credentials\";\n+\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      String domainUid = domainUids.get(i);\n+      String domainNamespace = domainNamespaces.get(i);\n+      String pvName = domainUid + \"-pv\";\n+      String pvcName = domainUid + \"-pvc\";\n+\n+      // create WebLogic credentials secret\n+      createSecretWithUsernamePassword(wlSecretName, domainNamespace, adminUser, adminPassword);\n+\n+      // create persistent volume and persistent volume claims\n+      Path pvHostPath =\n+          createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), domainUid + \"-persistentVolume\"));\n+\n+      logger.info(\"Creating PV directory {0}\", pvHostPath);\n+      deleteDirectory(pvHostPath.toFile());\n+      createDirectories(pvHostPath);\n+\n+      V1PersistentVolume v1pv = new V1PersistentVolume()\n+          .spec(new V1PersistentVolumeSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeMode(\"Filesystem\")\n+              .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+              .persistentVolumeReclaimPolicy(\"Recycle\")\n+              .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+              .hostPath(new V1HostPathVolumeSource()\n+                  .path(pvHostPath.toString())))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+          .spec(new V1PersistentVolumeClaimSpec()\n+              .addAccessModesItem(\"ReadWriteMany\")\n+              .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+              .volumeName(pvName)\n+              .resources(new V1ResourceRequirements()\n+                  .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+          .metadata(new V1ObjectMetaBuilder()\n+              .withName(pvcName)\n+              .withNamespace(domainNamespace)\n+              .build()\n+              .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+              .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+      String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+      createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+      // run create a domain on PV job using WLST\n+      runCreateDomainOnPVJobUsingWlst(pvName, pvcName, domainUid, domainNamespace);\n+\n+      // create the domain custom resource configuration object\n+      logger.info(\"Creating domain custom resource\");\n+      Domain domain = new Domain()\n+          .apiVersion(DOMAIN_API_VERSION)\n+          .kind(\"Domain\")\n+          .metadata(new V1ObjectMeta()\n+              .name(domainUid)\n+              .namespace(domainNamespace))\n+          .spec(new DomainSpec()\n+              .domainUid(domainUid)\n+              .domainHome(\"/shared/domains/\" + domainUid)\n+              .domainHomeSourceType(\"PersistentVolume\")\n+              .image(image)\n+              .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                  new V1LocalObjectReference()\n+                      .name(OCR_SECRET_NAME))\n+                  : null)\n+              .webLogicCredentialsSecret(new V1SecretReference()\n+                  .name(wlSecretName)\n+                  .namespace(domainNamespace))\n+              .includeServerOutInPodLog(true)\n+              .logHomeEnabled(Boolean.TRUE)\n+              .logHome(\"/shared/logs/\" + domainUid)\n+              .dataHome(\"\")\n+              .serverStartPolicy(\"IF_NEEDED\")\n+              .serverPod(new ServerPod()\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"JAVA_OPTIONS\")\n+                      .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                  .addEnvItem(new V1EnvVar()\n+                      .name(\"USER_MEM_ARGS\")\n+                      .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                  .addVolumesItem(new V1Volume()\n+                      .name(pvName)\n+                      .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                          .claimName(pvcName)))\n+                  .addVolumeMountsItem(new V1VolumeMount()\n+                      .mountPath(\"/shared\")\n+                      .name(pvName)))\n+              .adminServer(new AdminServer()\n+                  .serverStartState(\"RUNNING\")\n+                  .adminService(new AdminService()\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"default\")\n+                          .nodePort(0))\n+                      .addChannelsItem(new Channel()\n+                          .channelName(\"T3Channel\")\n+                          .nodePort(0))))\n+              .addClustersItem(new Cluster()\n+                  .clusterName(clusterName)\n+                  .replicas(replicaCount)\n+                  .serverStartState(\"RUNNING\")));\n+\n+      logger.info(\"Creating domain custom resource {0} in namespace {1}\", domainUid, domainNamespace);\n+      createDomainAndVerify(domain, domainNamespace);\n+\n+      String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+      // check admin server pod is ready and service exists in domain namespace\n+      checkPodExistsReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+      // check for managed server pods existence\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodExistsReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+\n+      logger.info(\"Getting admin service node port\");\n+      int serviceNodePort =\n+              getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+\n+      logger.info(\"Validating WebLogic admin server access by login to console\");\n+      assertTrue(assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, adminUser, adminPassword),\n+          \"Access to admin server node port failed\"), \"Console login validation failed\");\n+    }\n+  }\n+\n+  /**\n+   * Run a job to create a WebLogic domain on a persistent volume by doing the following.\n+   * Copies the WLST domain script to a temp location.\n+   * Creates a domain properties in the temp location.\n+   * Creates a configmap containing domain scripts and property files.\n+   * Runs a job to create domain on persistent volume.\n+   *\n+   * @param pvName persistence volume on which the WebLogic domain home will be hosted\n+   * @param pvcName persistence volume claim for the WebLogic domain\n+   * @param domainUid the Uid of the domain to create\n+   * @param domainNamespace the namespace in which the domain will be created\n+   * @throws IOException when reading/writing domain scripts fails\n+   */\n+  private void runCreateDomainOnPVJobUsingWlst(String pvName,\n+                                               String pvcName,\n+                                               String domainUid,\n+                                               String domainNamespace) throws IOException {\n+\n+    logger.info(\"Creating a staging location for domain creation scripts\");\n+    Path pvTemp = get(RESULTS_ROOT, this.getClass().getSimpleName(), \"domainCreateTempPV\");\n+    deleteDirectory(pvTemp.toFile());\n+    createDirectories(pvTemp);\n+\n+    logger.info(\"Copying the domain creation WLST script to staging location\");\n+    Path srcWlstScript = get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+    Path targetWlstScript = get(pvTemp.toString(), \"create-domain.py\");\n+    copy(srcWlstScript, targetWlstScript, StandardCopyOption.REPLACE_EXISTING);\n+\n+    logger.info(\"Creating WebLogic domain properties file\");\n+    Path domainPropertiesFile = get(pvTemp.toString(), \"domain.properties\");\n+    assertDoesNotThrow(() -> createDomainProperties(domainPropertiesFile, domainUid),\n+        \"Creating domain properties file failed\");\n+\n+    logger.info(\"Adding files to a ConfigMap for domain creation job\");\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(targetWlstScript);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a ConfigMap to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, domainNamespace),\n+        \"Create ConfigMap for domain creation failed\");\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job\")\n+                .namespace(domainNamespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\")\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(new V1Container()\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))) // mounted under /shared inside pod\n+                        .addCommandItem(\"/bin/sh\") //call wlst.sh script with py and properties file\n+                        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+                        .addArgsItem(\"/u01/weblogic/create-domain.py\")\n+                        .addArgsItem(\"-skipWLSModuleScanning\")\n+                        .addArgsItem(\"-loadProperties\")\n+                        .addArgsItem(\"/u01/weblogic/domain.properties\")))\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptConfigMapName))))  //ConfigMap containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Running a job {0} to create a domain on PV for domain {1} in namespace {2}\",\n+        jobBody.getMetadata().getName(), domainUid, domainNamespace);\n+    runCreateDomainJob(jobBody, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a properties file for WebLogic domain configuration.\n+   * @param wlstPropertiesFile path of the properties file\n+   * @param domainUid the WebLogic domain for which the properties file is created\n+   * @throws FileNotFoundException when properties file path not found\n+   * @throws IOException when writing properties fails\n+   */\n+  private void createDomainProperties(Path wlstPropertiesFile,\n+                                      String domainUid) throws FileNotFoundException, IOException {\n+    // create a list of properties for the WebLogic domain configuration\n+    Properties p = new Properties();\n+\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", adminUser);\n+    p.setProperty(\"admin_password\", adminPassword);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", \"\" + getNextFreePort(32001, 32101));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+\n+    p.store(new FileOutputStream(wlstPropertiesFile.toFile()), \"WLST properties file\");\n+  }\n+\n+  /**\n+   * Scale domain1 and verify there was no impact on domain2.\n+   */\n+  private void scaleDomain1AndVerifyNoImpactOnDomain2() {\n+\n+    // scale domain1\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+        clusterName, domain1Uid, domain1Namespace, replicasAfterScale);\n+    scaleAndVerifyCluster(clusterName, domain1Uid, domain1Namespace,\n+        domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE, replicaCount, replicasAfterScale,\n+        null, null);\n+\n+    // add the third managed server pod original creation timestamp to the list\n+    domain1ManagedServerPodOriginalTimestampList.add(\n+        getPodOriginalCreationTimestamp(\n+            domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + replicasAfterScale,\n+            domain1Namespace));\n+\n+    // verify scaling domain1 has no impact on domain2\n+    logger.info(\"Checking that domain2 was not changed after domain1 was scaled up\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Restart domain1 and verify there was no impact on domain2.\n+   */\n+  private void restartDomain1AndVerifyNoImpactOnDomain2() {\n+    String domain1AdminServerPodName = domainAdminServerPodNames.get(0);\n+\n+    // shutdown domain1\n+    logger.info(\"Shutting down domain1\");\n+    assertTrue(shutdown(domain1Uid, domain1Namespace),\n+        String.format(\"shutdown domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify all the server pods in domain1 were shutdown\n+    logger.info(\"Checking that admin server pod in domain1 was shutdown\");\n+    checkPodDoesNotExist(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+\n+    logger.info(\"Checking managed server pods in domain1 were shutdown\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+    // restart domain1\n+    logger.info(\"Restarting domain1\");\n+    assertTrue(restart(domain1Uid, domain1Namespace),\n+        String.format(\"restart domain %s in namespace %s failed\", domain1Uid, domain1Namespace));\n+\n+    // verify domain1 is restarted\n+    // check domain1 admin server pod exists and ready, also check admin service exists in the domain1 namespace\n+    logger.info(\"Checking admin server pod in domain1 was restarted\");\n+    checkPodExistsReadyAndServiceExists(domain1AdminServerPodName, domain1Uid, domain1Namespace);\n+    checkPodRestarted(domain1Uid, domain1Namespace, domain1AdminServerPodName,\n+        domainAdminPodOriginalTimestamps.get(0));\n+\n+    // check managed server pods in domain1\n+    logger.info(\"Checking managed server pods in domain1 were restarted\");\n+    for (int i = 1; i <= replicasAfterScale; i++) {\n+      String domain1ManagedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodExistsReadyAndServiceExists(domain1ManagedServerPodName, domain1Uid, domain1Namespace);\n+      checkPodRestarted(domain1Uid, domain1Namespace, domain1ManagedServerPodName,\n+          domain1ManagedServerPodOriginalTimestampList.get(i - 1));\n+    }\n+\n+    // verify domain 2 was not changed after domain1 was restarted\n+    logger.info(\"Verifying that domain2 was not changed after domain1 was restarted\");\n+    verifyDomain2NotChanged();\n+  }\n+\n+  /**\n+   * Verify domain2 server pods were no changed.\n+   */\n+  private void verifyDomain2NotChanged() {\n+    String domain2AdminServerPodName = domainAdminServerPodNames.get(1);\n+\n+    logger.info(\"Checking that domain2 admin server pod state was not changed\");\n+    assertThat(podStateNotChanged(domain2AdminServerPodName, domain2Uid, domain2Namespace,\n+        domainAdminPodOriginalTimestamps.get(1)))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+            domain2AdminServerPodName, domain2Namespace)\n+        .isTrue();\n+\n+    logger.info(\"Checking that domain2 managed server pods states were not changed\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      assertThat(podStateNotChanged(managedServerPodName, domain2Uid, domain2Namespace,\n+          domain2ManagedServerPodOriginalTimestampList.get(i - 1)))\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n+              managedServerPodName, domain2Namespace)\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Get domain1 an domain2 server pods original creation timestamps.\n+   */\n+  private void getBothDomainsPodsOriginalCreationTimestamp() {\n+    // get the domain1 pods original creation timestamp\n+    logger.info(\"Getting admin server pod original creation timestamps for both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      domainAdminServerPodNames.add(domainUids.get(i) + \"-\" + ADMIN_SERVER_NAME_BASE);\n+      domainAdminPodOriginalTimestamps.add(\n+          getPodOriginalCreationTimestamp(domainAdminServerPodNames.get(i), domainNamespaces.get(i)));\n+    }\n+\n+    // get the managed server pods original creation timestamps\n+    logger.info(\"Getting managed server pods original creation timestamps for both domains\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      domain1ManagedServerPodOriginalTimestampList.add(\n+          getPodOriginalCreationTimestamp(managedServerPodName, domain1Namespace));\n+\n+      managedServerPodName = domain2Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      domain2ManagedServerPodOriginalTimestampList.add(\n+          getPodOriginalCreationTimestamp(managedServerPodName, domain2Namespace));\n+    }\n+  }\n+\n+  /**\n+   * Shutdown both domains and verify all the server pods were shutdown.\n+   */\n+  private void shutdownBothDomainsAndVerify() {\n+\n+    // shutdown both domains\n+    logger.info(\"Shutting down both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      shutdown(domainUids.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // verify all the pods were shutdown\n+    logger.info(\"Verifying all server pods were shutdown for both domains\");\n+    for (int i = 0; i < numberOfDomains; i++) {\n+      // check admin server pod was shutdown\n+      checkPodDoesNotExist(domainUids.get(i) + \"-\" + ADMIN_SERVER_NAME_BASE,\n+          domainUids.get(i), domainNamespaces.get(i));\n+\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName = domainUids.get(i) + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+        checkPodDoesNotExist(managedServerPodName, domainUids.get(i), domainNamespaces.get(i));\n+      }\n+    }\n+\n+    // check the scaled up managed servers in domain1 were shutdown\n+    logger.info(\"Verifying the scaled up managed servers in domain1 were shutdown\");\n+    for (int i = replicaCount + 1; i <= replicasAfterScale; i++) {\n+      String managedServerPodName = domain1Uid + \"-\" + MANAGED_SERVER_NAME_BASE + i;\n+      checkPodDoesNotExist(managedServerPodName, domain1Uid, domain1Namespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Get pod original creation timestamp.\n+   * @param podName pod name to get the original creation timestamp\n+   * @param namespace the namespace in which the pod exists\n+   * @return the pod original creation timestamp\n+   */\n+  private String getPodOriginalCreationTimestamp(String podName, String namespace) {\n+    return assertDoesNotThrow(() -> getPodCreationTimestamp(namespace, \"\", podName),\n+        String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+            podName, namespace));\n+  }\n+\n+  /**\n+   * Check pod exist, ready and service exists in the specified namespace.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the label the pod is decorated with\n+   * @param namespace the namespace in which the pod exists\n+   */\n+  private void checkPodExistsReadyAndServiceExists(String podName, String domainUid, String namespace) {\n+    logger.info(\"Checking that pod {0} exists in namespace {1}\", podName, namespace);\n+    checkPodExists(podName, domainUid, namespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxNDQ5MA=="}, "originalCommit": {"oid": "a42c0d74675032473ad9135a5b2316c4853191b7"}, "originalPosition": 681}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQxNzcyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjowOToyMFrOGbe5-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyMzo1MlrOGbgh8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTA5Ng==", "bodyText": "modify the method name to shutdownDomain()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431471096", "createdAt": "2020-05-27T22:09:20Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTAwMg==", "bodyText": "having shutdown() is fine in implementation class..In action class, we need the full method name shutdownDomain() as that's the method being called in test classes.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431479002", "createdAt": "2020-05-27T22:29:32Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTA5Ng=="}, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NzcxNQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431497715", "createdAt": "2020-05-27T23:23:52Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTA5Ng=="}, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQxOTI0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoxMDowMFrOGbe68w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzoyNDowMVrOGbgiIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTM0Nw==", "bodyText": "modify the method name to restartDomain()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431471347", "createdAt": "2020-05-27T22:10:00Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {\n-    return true;\n+    // change the /spec/serverStartPolicy to NEVER to shut down all servers in the domain\n+    // create patch string to shut down the domain\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"add\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/serverStartPolicy\\\", \")\n+        .append(\"\\\"value\\\": \\\"NEVER\\\"\")\n+        .append(\"}]\");\n+\n+    logger.info(\"Shutting down domain {0} in namespace {1} using patch string: {2}\",\n+        domainUid, namespace, patchStr.toString());\n+\n+    V1Patch patch = new V1Patch(new String(patchStr));\n+\n+    return patchDomainCustomResource(domainUid, namespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n   }\n \n+  /**\n+   * Restart a domain in the specified namespace.\n+   *\n+   * @param domainUid the domain to restart\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain resource succeeded, false otherwise\n+   */\n   public static boolean restart(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTEyMw==", "bodyText": "same as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431479123", "createdAt": "2020-05-27T22:29:47Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {\n-    return true;\n+    // change the /spec/serverStartPolicy to NEVER to shut down all servers in the domain\n+    // create patch string to shut down the domain\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"add\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/serverStartPolicy\\\", \")\n+        .append(\"\\\"value\\\": \\\"NEVER\\\"\")\n+        .append(\"}]\");\n+\n+    logger.info(\"Shutting down domain {0} in namespace {1} using patch string: {2}\",\n+        domainUid, namespace, patchStr.toString());\n+\n+    V1Patch patch = new V1Patch(new String(patchStr));\n+\n+    return patchDomainCustomResource(domainUid, namespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n   }\n \n+  /**\n+   * Restart a domain in the specified namespace.\n+   *\n+   * @param domainUid the domain to restart\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain resource succeeded, false otherwise\n+   */\n   public static boolean restart(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTM0Nw=="}, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5Nzc2Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431497763", "createdAt": "2020-05-27T23:24:01Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -37,12 +37,52 @@ public static DomainList listDomainCustomResources(String namespace) {\n     return Kubernetes.listDomains(namespace);\n   }\n \n+  /**\n+   * Shut down a domain in the specified namespace.\n+   * @param domainUid the domain to shut down\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain custom resource succeeded, false otherwise\n+   */\n   public static boolean shutdown(String domainUid, String namespace) {\n-    return true;\n+    // change the /spec/serverStartPolicy to NEVER to shut down all servers in the domain\n+    // create patch string to shut down the domain\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"add\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/serverStartPolicy\\\", \")\n+        .append(\"\\\"value\\\": \\\"NEVER\\\"\")\n+        .append(\"}]\");\n+\n+    logger.info(\"Shutting down domain {0} in namespace {1} using patch string: {2}\",\n+        domainUid, namespace, patchStr.toString());\n+\n+    V1Patch patch = new V1Patch(new String(patchStr));\n+\n+    return patchDomainCustomResource(domainUid, namespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH);\n   }\n \n+  /**\n+   * Restart a domain in the specified namespace.\n+   *\n+   * @param domainUid the domain to restart\n+   * @param namespace the namespace in which the domain exists\n+   * @return true if patching domain resource succeeded, false otherwise\n+   */\n   public static boolean restart(String domainUid, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTM0Nw=="}, "originalCommit": {"oid": "48707a87228c550515d96865986e111bf89fe98d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Nzc2ODE2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMTowMToxNVrOGbiOmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMzo1MDo0MVrOGbkt7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTUzMQ==", "bodyText": "Since you moved it to utils, the name should be generic. Something like createConfigMapFromFiles(...)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431525531", "createdAt": "2020-05-28T01:01:15Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -753,6 +803,111 @@ public static void scaleAndVerifyCluster(String clusterName,\n     }\n   }\n \n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   *\n+   * @param v1pv V1PersistentVolume object to create the persistent volume\n+   * @param v1pvc V1PersistentVolumeClaim object to create the persistent volume claim\n+   * @param labelSelector String containing the labels the PV is decorated with\n+   * @param namespace the namespace in which the persistence volume claim to be created\n+   */\n+  public static void createPVPVCAndVerify(V1PersistentVolume v1pv,\n+                                          V1PersistentVolumeClaim v1pvc,\n+                                          String labelSelector,\n+                                          String namespace) {\n+\n+    assertNotNull(v1pv, \"v1pv is null\");\n+    assertNotNull(v1pvc, \"v1pvc is null\");\n+\n+    String pvName = v1pv.getMetadata().getName();\n+    String pvcName = v1pvc.getMetadata().getName();\n+\n+    logger.info(\"Creating persistent volume {0}\", pvName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed with ApiException \"),\n+        \"PersistentVolume creation failed\");\n+\n+    logger.info(\"Creating persistent volume claim {0}\", pvcName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed with ApiException\"),\n+        \"PersistentVolumeClaim creation failed\");\n+\n+    // check the persistent volume and persistent volume claim exist\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume {0} exists \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                pvName,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvExists(pvName, labelSelector),\n+            String.format(\"pvExists failed with ApiException when checking pv %s\", pvName)));\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume claim {0} exists in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                pvcName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvcExists(pvcName, namespace),\n+            String.format(\"pvcExists failed with ApiException when checking pvc %s in namespace %s\",\n+                pvcName, namespace)));\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain scripts.\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to be added in ConfigMap, including domain creation python script and properties files\n+   * @param namespace the namespace in which the ConfigMap to be created\n+   * @throws IOException when reading files fails\n+   */\n+  public static void createConfigMapForDomainCreation(String configMapName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2NjMxNg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431566316", "createdAt": "2020-05-28T03:50:41Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -753,6 +803,111 @@ public static void scaleAndVerifyCluster(String clusterName,\n     }\n   }\n \n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   *\n+   * @param v1pv V1PersistentVolume object to create the persistent volume\n+   * @param v1pvc V1PersistentVolumeClaim object to create the persistent volume claim\n+   * @param labelSelector String containing the labels the PV is decorated with\n+   * @param namespace the namespace in which the persistence volume claim to be created\n+   */\n+  public static void createPVPVCAndVerify(V1PersistentVolume v1pv,\n+                                          V1PersistentVolumeClaim v1pvc,\n+                                          String labelSelector,\n+                                          String namespace) {\n+\n+    assertNotNull(v1pv, \"v1pv is null\");\n+    assertNotNull(v1pvc, \"v1pvc is null\");\n+\n+    String pvName = v1pv.getMetadata().getName();\n+    String pvcName = v1pvc.getMetadata().getName();\n+\n+    logger.info(\"Creating persistent volume {0}\", pvName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed with ApiException \"),\n+        \"PersistentVolume creation failed\");\n+\n+    logger.info(\"Creating persistent volume claim {0}\", pvcName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed with ApiException\"),\n+        \"PersistentVolumeClaim creation failed\");\n+\n+    // check the persistent volume and persistent volume claim exist\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume {0} exists \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                pvName,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvExists(pvName, labelSelector),\n+            String.format(\"pvExists failed with ApiException when checking pv %s\", pvName)));\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume claim {0} exists in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                pvcName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvcExists(pvcName, namespace),\n+            String.format(\"pvcExists failed with ApiException when checking pvc %s in namespace %s\",\n+                pvcName, namespace)));\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain scripts.\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to be added in ConfigMap, including domain creation python script and properties files\n+   * @param namespace the namespace in which the ConfigMap to be created\n+   * @throws IOException when reading files fails\n+   */\n+  public static void createConfigMapForDomainCreation(String configMapName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTUzMQ=="}, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Nzc3MTk0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMTowMzo0N1rOGbiRCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMzo1MDo0OVrOGbkuEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNjE1NA==", "bodyText": "The name should be changed for this too, because this is simple create job and wait for it to complete. could be used for any purpose.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431526154", "createdAt": "2020-05-28T01:03:47Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -753,6 +803,111 @@ public static void scaleAndVerifyCluster(String clusterName,\n     }\n   }\n \n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   *\n+   * @param v1pv V1PersistentVolume object to create the persistent volume\n+   * @param v1pvc V1PersistentVolumeClaim object to create the persistent volume claim\n+   * @param labelSelector String containing the labels the PV is decorated with\n+   * @param namespace the namespace in which the persistence volume claim to be created\n+   */\n+  public static void createPVPVCAndVerify(V1PersistentVolume v1pv,\n+                                          V1PersistentVolumeClaim v1pvc,\n+                                          String labelSelector,\n+                                          String namespace) {\n+\n+    assertNotNull(v1pv, \"v1pv is null\");\n+    assertNotNull(v1pvc, \"v1pvc is null\");\n+\n+    String pvName = v1pv.getMetadata().getName();\n+    String pvcName = v1pvc.getMetadata().getName();\n+\n+    logger.info(\"Creating persistent volume {0}\", pvName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed with ApiException \"),\n+        \"PersistentVolume creation failed\");\n+\n+    logger.info(\"Creating persistent volume claim {0}\", pvcName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed with ApiException\"),\n+        \"PersistentVolumeClaim creation failed\");\n+\n+    // check the persistent volume and persistent volume claim exist\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume {0} exists \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                pvName,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvExists(pvName, labelSelector),\n+            String.format(\"pvExists failed with ApiException when checking pv %s\", pvName)));\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume claim {0} exists in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                pvcName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvcExists(pvcName, namespace),\n+            String.format(\"pvcExists failed with ApiException when checking pvc %s in namespace %s\",\n+                pvcName, namespace)));\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain scripts.\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to be added in ConfigMap, including domain creation python script and properties files\n+   * @param namespace the namespace in which the ConfigMap to be created\n+   * @throws IOException when reading files fails\n+   */\n+  public static void createConfigMapForDomainCreation(String configMapName,\n+                                                      List<Path> files,\n+                                                      String namespace) throws IOException {\n+\n+    // create a ConfigMap of the domain\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), readString(file));\n+    }\n+\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(new V1ObjectMeta()\n+            .name(configMapName)\n+            .namespace(namespace));\n+\n+    assertTrue(assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed with ApiException for ConfigMap %s with files %s in namespace %s\",\n+            configMapName, files, namespace)),\n+        String.format(\"createConfigMap failed while creating ConfigMap %s in namespace %s\", configMapName, namespace));\n+  }\n+\n+  /**\n+   * Run a job to create a domain in the specified namespace.\n+   *\n+   * @param jobBody V1Job object to create a domain in the specified namespace\n+   * @param namespace the namespace in which the job will be run\n+   */\n+  public static void runCreateDomainJob(V1Job jobBody, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2NjM1Mg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431566352", "createdAt": "2020-05-28T03:50:49Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -753,6 +803,111 @@ public static void scaleAndVerifyCluster(String clusterName,\n     }\n   }\n \n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   *\n+   * @param v1pv V1PersistentVolume object to create the persistent volume\n+   * @param v1pvc V1PersistentVolumeClaim object to create the persistent volume claim\n+   * @param labelSelector String containing the labels the PV is decorated with\n+   * @param namespace the namespace in which the persistence volume claim to be created\n+   */\n+  public static void createPVPVCAndVerify(V1PersistentVolume v1pv,\n+                                          V1PersistentVolumeClaim v1pvc,\n+                                          String labelSelector,\n+                                          String namespace) {\n+\n+    assertNotNull(v1pv, \"v1pv is null\");\n+    assertNotNull(v1pvc, \"v1pvc is null\");\n+\n+    String pvName = v1pv.getMetadata().getName();\n+    String pvcName = v1pvc.getMetadata().getName();\n+\n+    logger.info(\"Creating persistent volume {0}\", pvName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed with ApiException \"),\n+        \"PersistentVolume creation failed\");\n+\n+    logger.info(\"Creating persistent volume claim {0}\", pvcName);\n+    assertTrue(assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed with ApiException\"),\n+        \"PersistentVolumeClaim creation failed\");\n+\n+    // check the persistent volume and persistent volume claim exist\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume {0} exists \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                pvName,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvExists(pvName, labelSelector),\n+            String.format(\"pvExists failed with ApiException when checking pv %s\", pvName)));\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for persistent volume claim {0} exists in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                pvcName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> pvcExists(pvcName, namespace),\n+            String.format(\"pvcExists failed with ApiException when checking pvc %s in namespace %s\",\n+                pvcName, namespace)));\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain scripts.\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to be added in ConfigMap, including domain creation python script and properties files\n+   * @param namespace the namespace in which the ConfigMap to be created\n+   * @throws IOException when reading files fails\n+   */\n+  public static void createConfigMapForDomainCreation(String configMapName,\n+                                                      List<Path> files,\n+                                                      String namespace) throws IOException {\n+\n+    // create a ConfigMap of the domain\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      data.put(file.getFileName().toString(), readString(file));\n+    }\n+\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(new V1ObjectMeta()\n+            .name(configMapName)\n+            .namespace(namespace));\n+\n+    assertTrue(assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed with ApiException for ConfigMap %s with files %s in namespace %s\",\n+            configMapName, files, namespace)),\n+        String.format(\"createConfigMap failed while creating ConfigMap %s in namespace %s\", configMapName, namespace));\n+  }\n+\n+  /**\n+   * Run a job to create a domain in the specified namespace.\n+   *\n+   * @param jobBody V1Job object to create a domain in the specified namespace\n+   * @param namespace the namespace in which the job will be run\n+   */\n+  public static void runCreateDomainJob(V1Job jobBody, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNjE1NA=="}, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzgyNTE4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMTozNjoyMFrOGbixKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMzo1MTowMlrOGbkuQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzNDM3Nw==", "bodyText": "I have moved the pull from It class to ImageBuilders, here we simply need to check if its running Kind cluster, if true set the image to kindRepoImage. Please see PR https://github.com/oracle/weblogic-kubernetes-operator/pull/1678/files", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431534377", "createdAt": "2020-05-28T01:36:20Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restartDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+\n+  private int t3ChannelPort = 0;\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2NjQwMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1675#discussion_r431566400", "createdAt": "2020-05-28T03:51:02Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorTwoDomains.java", "diffHunk": "@@ -0,0 +1,682 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.restartDomain;\n+import static oracle.weblogic.kubernetes.actions.TestActions.shutdownDomain;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodRestarted;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runCreateDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Test operator manages multiple domains.\n+ */\n+@DisplayName(\"Verify operator manages multiple domains\")\n+@IntegrationTest\n+public class ItOperatorTwoDomains implements LoggedTest {\n+\n+  private static final int numberOfDomains = 2;\n+  private static final int numberOfOperators = 2;\n+\n+  private static String domain1Uid = null;\n+  private static String domain2Uid = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static List<String> opNamespaces = new ArrayList<>();\n+  private static List<String> domainNamespaces = new ArrayList<>();\n+  private static List<String> domainUids = new ArrayList<>();\n+\n+  // domain constants\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+\n+  private int t3ChannelPort = 0;\n+  private String image = null;\n+  private boolean isUseSecret = false;\n+  private int replicasAfterScale;\n+  private List<String> domainAdminServerPodNames = new ArrayList<>();\n+  private List<String> domainAdminPodOriginalTimestamps = new ArrayList<>();\n+  private List<String> domain1ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+  private List<String> domain2ManagedServerPodOriginalTimestampList = new ArrayList<>();\n+\n+  /**\n+   * Get namespaces, install operator and initiate domain UID list.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(4) List<String> namespaces) {\n+\n+    // get unique operator namespaces\n+    logger.info(\"Get unique namespaces for operator1 and operator2\");\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // get unique domain namespaces\n+    logger.info(\"Get unique namespaces for WebLogic domain1 and domain2\");\n+    for (int i = numberOfOperators; i < numberOfOperators + numberOfDomains; i++) {\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      domainNamespaces.add(namespaces.get(i));\n+    }\n+\n+    // install and verify operator\n+    for (int i = 0; i < numberOfOperators; i++) {\n+      installAndVerifyOperator(opNamespaces.get(i), domainNamespaces.get(i));\n+    }\n+\n+    // initiate domainUid list for two domains\n+    for (int i = 1; i <= numberOfDomains; i++) {\n+      domainUids.add(\"domain\" + i);\n+    }\n+\n+    domain1Uid = domainUids.get(0);\n+    domain2Uid = domainUids.get(1);\n+    domain1Namespace = domainNamespaces.get(0);\n+    domain2Namespace = domainNamespaces.get(1);\n+\n+  }\n+\n+  /**\n+   * Test covers the following use cases.\n+   * create two domains on PV using WLST\n+   * domain1 managed by operator1\n+   * domain2 managed by operator2\n+   * scale cluster in domain1 from 2 to 3 servers and verify no impact on domain2, domain2 continues to run\n+   * restart domain1 and verify no impact on domain2, domain2 continues to run\n+   * shutdown the domains using serverStartPolicy\n+   */\n+  @Test\n+  @DisplayName(\"Create domain on PV using WLST script\")\n+  public void testTwoDomainsManagedByTwoOperators() {\n+\n+    image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+\n+    if (KIND_REPO != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUzNDM3Nw=="}, "originalCommit": {"oid": "d93af2da01dfa7f4f47ead3f5a4c2fbb5e9f3ec9"}, "originalPosition": 186}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4243, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}