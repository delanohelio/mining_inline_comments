{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNzc5NTk4", "number": 1975, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMzo1NFrOEuGQiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0ODoyOVrOEuK5WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzcyNDkxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMzo1NFrOHiSUKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyNTo1MFrOHiWvRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzcwNQ==", "bodyText": "make this method as private or provide javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505713705", "createdAt": "2020-10-15T17:23:54Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NjE4Mg==", "bodyText": "modified the scope to private", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786182", "createdAt": "2020-10-15T19:25:50Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzcwNQ=="}, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzcyNzg5OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyNDo1NFrOHiSWRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyNjo0N1rOHiWxFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNDI0NQ==", "bodyText": "Do you want to use copyFileFromPod(...) instead of using kubectl cp?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505714245", "createdAt": "2020-10-15T17:24:54Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NjY0Nw==", "bodyText": "assertDoesNotThrow(() -> copyFileFromPod(domainNamespace,\nadminServerPodName, \"weblogic-server\",\n\"/u01/oracle/wlserver/server/lib/wlthint3client.jar\",\nPaths.get(RESULTS_ROOT, \"wlthint3client.jar\")));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786647", "createdAt": "2020-10-15T19:26:47Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNDI0NQ=="}, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2Nzc2ODMxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzozNTo1MlrOHiSwUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyNzoxNVrOHiWyBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDkxMg==", "bodyText": "Add some comments as to what these private methods does.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505720912", "createdAt": "2020-10-15T17:35:52Z", "author": {"login": "sankarpn"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");\n+    copyCmd.append(domainNamespace + \"/\" + adminServerPodName);\n+    copyCmd.append(\":/u01/oracle/wlserver/server/lib/wlthint3client.jar \");\n+    copyCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    logger.info(\"kubectl copy command {0}\", copyCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(copyCmd), true));\n+    logger.info(\"kubectl copy returned {0}\", result.toString());\n+\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  private static void createCertKeyFiles(String cn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4Njg4Nw==", "bodyText": "modified the scope to private and added description", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786887", "createdAt": "2020-10-15T19:27:15Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");\n+    copyCmd.append(domainNamespace + \"/\" + adminServerPodName);\n+    copyCmd.append(\":/u01/oracle/wlserver/server/lib/wlthint3client.jar \");\n+    copyCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    logger.info(\"kubectl copy command {0}\", copyCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(copyCmd), true));\n+    logger.info(\"kubectl copy returned {0}\", result.toString());\n+\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  private static void createCertKeyFiles(String cn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDkxMg=="}, "originalCommit": {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODMyMTg4OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoxMDoxN1rOHiYKrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowMzozMVrOHjOO7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw==", "bodyText": "add comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505809583", "createdAt": "2020-10-15T20:10:17Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyNzg4MQ==", "bodyText": "The method definition createCertKeyFiles() has the description\n// Create display SSL certificate and key using openssl with SAN extension", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505927881", "createdAt": "2020-10-15T23:54:39Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDQ0NA==", "bodyText": "The method definition createCertKeyFiles() has the comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505930444", "createdAt": "2020-10-16T00:03:51Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTQwNQ==", "bodyText": "Added comments inside the test method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695405", "createdAt": "2020-10-16T20:03:31Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM4NzQxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyODo0NlrOHiYxfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowMzo1N1rOHjOPnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTUxOQ==", "bodyText": "add at least single line comments for each segment of code in the test method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505819519", "createdAt": "2020-10-15T20:28:46Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTU4Mw==", "bodyText": "Added comments as javadoc to the test method.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695583", "createdAt": "2020-10-16T20:03:57Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTUxOQ=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM4ODYwOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyOTowM1rOHiYySw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowNDoxOVrOHjOQTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTcyMw==", "bodyText": "comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505819723", "createdAt": "2020-10-15T20:29:03Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTc1Nw==", "bodyText": "Added comments as javadoc to the test method.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695757", "createdAt": "2020-10-16T20:04:19Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTcyMw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM5MDk2OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyOToyNVrOHiYzxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowNDo0MFrOHjOQ3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDEwMA==", "bodyText": "comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505820100", "createdAt": "2020-10-15T20:29:25Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTkwMQ==", "bodyText": "Added comments inside the test method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695901", "createdAt": "2020-10-16T20:04:40Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDEwMA=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM5MjkzOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyOTo1MVrOHiY1Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMDowMjowOFrOHifg_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDQ1NQ==", "bodyText": "comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505820455", "createdAt": "2020-10-15T20:29:51Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTk4MA==", "bodyText": "// Generate java command to execute client with classpath", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505929980", "createdAt": "2020-10-16T00:02:08Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDQ1NQ=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM5ODM5OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMDo1OVrOHiY4sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMzo1ODozOVrOHifdRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTM2Mw==", "bodyText": "add comments on what the client does", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505821363", "createdAt": "2020-10-15T20:30:59Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTAzMQ==", "bodyText": "See the comments in buildClient() method defintion", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505929031", "createdAt": "2020-10-15T23:58:39Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTM2Mw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQwMDQ2OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMToyMlrOHiY6GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMToyMlrOHiY6GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTcyMQ==", "bodyText": "add comments in this test too", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505821721", "createdAt": "2020-10-15T20:31:22Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQwNjk3OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMjo0NVrOHiY-jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMjo0NVrOHiY-jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMjg2MA==", "bodyText": "comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505822860", "createdAt": "2020-10-15T20:32:45Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQwODE2OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMzowMFrOHiY_Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMzowMFrOHiY_Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzAzNA==", "bodyText": "comments", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505823034", "createdAt": "2020-10-15T20:33:00Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQ1MzUxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0MjozMlrOHiZdPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowNjo0NlrOHjOULw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ==", "bodyText": "log the error that it fails with", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505830719", "createdAt": "2020-10-15T20:42:32Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzODA2Mw==", "bodyText": "Modified the logic to put stderr and stdout from ExecResult class", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505938063", "createdAt": "2020-10-16T00:33:29Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5Njc1MQ==", "bodyText": "Modified logic to use actions.impl.primitive.Command to execute bash command.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506696751", "createdAt": "2020-10-16T20:06:46Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQ1ODgxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0Mzo0MFrOHiZg1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowNjo1N1rOHjOUdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA==", "bodyText": "you don't have to check the result?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505831638", "createdAt": "2020-10-15T20:43:40Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"openssl x509 -in \" + tlsCertFile + \" -noout -text \";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecResult result = ExecCommand.exec(command2, true);\n+      logger.info(\"openssl list command  returned {0}\", result.toString());\n+    });\n+  }\n+\n+  // Import the certificate into a JKS TrustStore to be used while running \n+  // external JMS client to send message to WebLogic.\n+  private void createJksStore() {\n+    assertDoesNotThrow(() -> {\n+      jksTrustFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-trust.jks\");\n+      String command = \"keytool -import -file \" + tlsCertFile \n+             + \" --keystore \" + jksTrustFile \n+             + \" -storetype jks -storepass password -noprompt \";\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecCommand.exec(command, true);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"keytool -list -keystore \" + jksTrustFile + \" -storepass password -noprompt\";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecCommand.exec(command2, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 434}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMjcyOA==", "bodyText": "Modified the logic to check the ResultSet's exitcode", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505932728", "createdAt": "2020-10-16T00:12:21Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"openssl x509 -in \" + tlsCertFile + \" -noout -text \";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecResult result = ExecCommand.exec(command2, true);\n+      logger.info(\"openssl list command  returned {0}\", result.toString());\n+    });\n+  }\n+\n+  // Import the certificate into a JKS TrustStore to be used while running \n+  // external JMS client to send message to WebLogic.\n+  private void createJksStore() {\n+    assertDoesNotThrow(() -> {\n+      jksTrustFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-trust.jks\");\n+      String command = \"keytool -import -file \" + tlsCertFile \n+             + \" --keystore \" + jksTrustFile \n+             + \" -storetype jks -storepass password -noprompt \";\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecCommand.exec(command, true);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"keytool -list -keystore \" + jksTrustFile + \" -storepass password -noprompt\";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecCommand.exec(command2, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 434}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NjgyMQ==", "bodyText": "Modified logic to use actions.impl.primitive.Command to execute bash command.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506696821", "createdAt": "2020-10-16T20:06:57Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"openssl x509 -in \" + tlsCertFile + \" -noout -text \";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecResult result = ExecCommand.exec(command2, true);\n+      logger.info(\"openssl list command  returned {0}\", result.toString());\n+    });\n+  }\n+\n+  // Import the certificate into a JKS TrustStore to be used while running \n+  // external JMS client to send message to WebLogic.\n+  private void createJksStore() {\n+    assertDoesNotThrow(() -> {\n+      jksTrustFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-trust.jks\");\n+      String command = \"keytool -import -file \" + tlsCertFile \n+             + \" --keystore \" + jksTrustFile \n+             + \" -storetype jks -storepass password -noprompt \";\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecCommand.exec(command, true);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"keytool -list -keystore \" + jksTrustFile + \" -storepass password -noprompt\";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecCommand.exec(command2, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 434}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQ3OTg5OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0NzoyNlrOHiZuWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMDoyODo1N1rOHif8Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTA5Ng==", "bodyText": "add javadoc with purpose of this class", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505835096", "createdAt": "2020-10-15T20:47:26Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import javax.jms.Destination;\r\n+import javax.jms.ConnectionFactory;\r\n+import javax.jms.Connection;\r\n+import javax.jms.Session;\r\n+import javax.jms.Message;\r\n+import javax.jms.DeliveryMode;\r\n+import javax.jms.TextMessage;\r\n+import javax.jms.MessageProducer;\r\n+import javax.jms.MessageConsumer;\r\n+import javax.jms.JMSException;\r\n+\r\n+import javax.jms.JMSContext;\r\n+import javax.jms.JMSConsumer;\r\n+import javax.jms.JMSProducer;\r\n+import javax.jms.JMSRuntimeException;\r\n+\r\n+public class JmsTestClient {\r\n+\r\n+  public  String username =\"weblogic\";\r\n+  public  String password =\"welcome1\";\r\n+\r\n+  public  String clusterurl =\"t3://localhost:7001\";\r\n+  public  String testQueue =\"jms/DistributedQueue\";\r\n+  public  String testcf =\"jms.ClusterConnectionFactory\";\r\n+\r\n+  public JmsTestClient(String[] args)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNjkzOQ==", "bodyText": "/**\n\nThis JMS client that sends 300 messages to a Uniform Distributed Queue\nusing load balancer http(s) url which maps to custom channel on cluster\nmember server on WebLogic cluster.\nIt also verifies that the messages are load balanced across 2 member.\nThe test returns success(0) if it finds 150 messages on each member\nelse returns failure (-1)\nUsage java JmsTestClient http(s)://host:port\n*/", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505936939", "createdAt": "2020-10-16T00:28:57Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import javax.jms.Destination;\r\n+import javax.jms.ConnectionFactory;\r\n+import javax.jms.Connection;\r\n+import javax.jms.Session;\r\n+import javax.jms.Message;\r\n+import javax.jms.DeliveryMode;\r\n+import javax.jms.TextMessage;\r\n+import javax.jms.MessageProducer;\r\n+import javax.jms.MessageConsumer;\r\n+import javax.jms.JMSException;\r\n+\r\n+import javax.jms.JMSContext;\r\n+import javax.jms.JMSConsumer;\r\n+import javax.jms.JMSProducer;\r\n+import javax.jms.JMSRuntimeException;\r\n+\r\n+public class JmsTestClient {\r\n+\r\n+  public  String username =\"weblogic\";\r\n+  public  String password =\"welcome1\";\r\n+\r\n+  public  String clusterurl =\"t3://localhost:7001\";\r\n+  public  String testQueue =\"jms/DistributedQueue\";\r\n+  public  String testcf =\"jms.ClusterConnectionFactory\";\r\n+\r\n+  public JmsTestClient(String[] args)\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTA5Ng=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQ4MjQ0OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/resources/wdt-models/tunneling.model.template.yaml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0Nzo1N1rOHiZwJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMDoyMDo1NVrOHif0UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTU1Nw==", "bodyText": "fix year", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505835557", "createdAt": "2020-10-15T20:47:57Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/resources/wdt-models/tunneling.model.template.yaml", "diffHunk": "@@ -0,0 +1,55 @@\n+# Copyright (c) 2018, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNDkyOQ==", "bodyText": "Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505934929", "createdAt": "2020-10-16T00:20:55Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/resources/wdt-models/tunneling.model.template.yaml", "diffHunk": "@@ -0,0 +1,55 @@\n+# Copyright (c) 2018, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTU1Nw=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQ4NDcyOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0ODoyOVrOHiZxzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwMDoyMTo0NVrOHif1HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTk4MA==", "bodyText": "missing copyright", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505835980", "createdAt": "2020-10-15T20:48:29Z", "author": {"login": "vanajamukkara"}, "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNTEzMg==", "bodyText": "// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505935132", "createdAt": "2020-10-16T00:21:45Z", "author": {"login": "anpanigr"}, "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTk4MA=="}, "originalCommit": {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4045, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}