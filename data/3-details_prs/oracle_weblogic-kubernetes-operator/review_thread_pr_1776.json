{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMDcxMDIy", "number": 1776, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1NDowOFrOES5uOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzo0MjoyOFrOEUywEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjU1NTQ0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1NDowOFrOG4VwIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1NDowOFrOG4VwIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyOTgyNg==", "bodyText": "The service check should be done before pod ready check.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r461729826", "createdAt": "2020-07-28T16:54:08Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -751,6 +750,22 @@ public static void checkServiceExists(String serviceName, String namespace) {\n                 serviceName, namespace)));\n   }\n \n+  /**\n+   * Check pod is ready and service exists in the specified namespace.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the label the pod is decorated with\n+   * @param namespace the namespace in which the pod exists\n+   */\n+  public static void checkPodReadyAndServiceExists(String podName, String domainUid, String namespace) {\n+    LoggingFacade logger = getLogger();\n+    logger.info(\"Waiting for pod {0} to be ready in namespace {1}\", podName, namespace);\n+    checkPodReady(podName, domainUid, namespace);\n+\n+    logger.info(\"Check service {0} exists in namespace {1}\", podName, namespace);\n+    checkServiceExists(podName, namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d3372dd5be21bcc298157e596e8befb0f1f1a71"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTUwNjE4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODoxNjowOFrOG7D4nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjozOToyN1rOG7ok1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MjgxMw==", "bodyText": "Does the service check should be done?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464582813", "createdAt": "2020-08-03T18:16:08Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, externalRestHttpsPort,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    Domain miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test liveness probe of pod\")\n+  @MethodSource(\"domainProvider\")\n+  public void testLivenessProbe(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    String serverName;\n+    if (numClusters > 1) {\n+      serverName = domainUid + \"-\" + clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    } else {\n+      serverName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    }\n+\n+    // create file to kill server process\n+    File killServerScript = assertDoesNotThrow(() -> createScriptToKillServer(),\n+        \"Failed to create script to kill server\");\n+    logger.info(\"File/script created to kill server {0}\", killServerScript);\n+\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // copy script to pod\n+    String destLocation = \"/u01/killserver.sh\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace, serverName, \"weblogic-server\",\n+        killServerScript.toPath(), Paths.get(destLocation)),\n+        String.format(\"Failed to copy file %s to pod %s in namespace %s\",\n+            killServerScript, serverName, domainNamespace));\n+    logger.info(\"File copied to Pod {0} in namespace {1}\", serverName, domainNamespace);\n+\n+    // get the restart count of the container in pod before liveness probe restarts\n+    final int beforeRestartCount =\n+        assertDoesNotThrow(() -> getContainerRestartCount(domainNamespace, null, serverName, null),\n+            String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+                serverName, domainNamespace));\n+    logger.info(\"Restart count before liveness probe {0}\", beforeRestartCount);\n+\n+    // change file permissions\n+    ExecResult execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+        true, \"/bin/sh\", \"-c\", \"chmod +x \" + destLocation),\n+        String.format(\"Failed to change permissions for file %s in pod %s\", destLocation, serverName));\n+    assertTrue(execResult.exitValue() == 0,\n+        String.format(\"Failed to change file %s permissions, stderr %s stdout %s\", destLocation,\n+            execResult.stderr(), execResult.stdout()));\n+    logger.info(\"File permissions changed inside pod\");\n+\n+    /* First, kill the managed server process in the container three times to cause the node manager to\n+     * mark the server 'failed not restartable'. This in turn is detected by the liveness probe, which\n+     * initiates a container restart.\n+     */\n+    for (int i = 0; i < 3; i++) {\n+      execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+          true, \"/bin/sh\", \"-c\", destLocation + \" \" + serverName),\n+          String.format(\"Failed to execute script %s in pod %s namespace %s\", destLocation,\n+              serverName, domainNamespace));\n+      logger.info(\"Command executed to kill server inside pod, exit value {0}, stdout {1}, stderr {2}\",\n+          execResult.exitValue(), execResult.stdout(), execResult.stderr());\n+\n+      try {\n+        Thread.sleep(2 * 1000);\n+      } catch (InterruptedException ie) {\n+        // ignore\n+      }\n+    }\n+\n+    // check pod is ready\n+    checkPodReady(serverName, domainUid, domainNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4Mzk1OQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r465183959", "createdAt": "2020-08-04T16:39:27Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, externalRestHttpsPort,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    Domain miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test liveness probe of pod\")\n+  @MethodSource(\"domainProvider\")\n+  public void testLivenessProbe(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    String serverName;\n+    if (numClusters > 1) {\n+      serverName = domainUid + \"-\" + clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    } else {\n+      serverName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    }\n+\n+    // create file to kill server process\n+    File killServerScript = assertDoesNotThrow(() -> createScriptToKillServer(),\n+        \"Failed to create script to kill server\");\n+    logger.info(\"File/script created to kill server {0}\", killServerScript);\n+\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // copy script to pod\n+    String destLocation = \"/u01/killserver.sh\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace, serverName, \"weblogic-server\",\n+        killServerScript.toPath(), Paths.get(destLocation)),\n+        String.format(\"Failed to copy file %s to pod %s in namespace %s\",\n+            killServerScript, serverName, domainNamespace));\n+    logger.info(\"File copied to Pod {0} in namespace {1}\", serverName, domainNamespace);\n+\n+    // get the restart count of the container in pod before liveness probe restarts\n+    final int beforeRestartCount =\n+        assertDoesNotThrow(() -> getContainerRestartCount(domainNamespace, null, serverName, null),\n+            String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+                serverName, domainNamespace));\n+    logger.info(\"Restart count before liveness probe {0}\", beforeRestartCount);\n+\n+    // change file permissions\n+    ExecResult execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+        true, \"/bin/sh\", \"-c\", \"chmod +x \" + destLocation),\n+        String.format(\"Failed to change permissions for file %s in pod %s\", destLocation, serverName));\n+    assertTrue(execResult.exitValue() == 0,\n+        String.format(\"Failed to change file %s permissions, stderr %s stdout %s\", destLocation,\n+            execResult.stderr(), execResult.stdout()));\n+    logger.info(\"File permissions changed inside pod\");\n+\n+    /* First, kill the managed server process in the container three times to cause the node manager to\n+     * mark the server 'failed not restartable'. This in turn is detected by the liveness probe, which\n+     * initiates a container restart.\n+     */\n+    for (int i = 0; i < 3; i++) {\n+      execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+          true, \"/bin/sh\", \"-c\", destLocation + \" \" + serverName),\n+          String.format(\"Failed to execute script %s in pod %s namespace %s\", destLocation,\n+              serverName, domainNamespace));\n+      logger.info(\"Command executed to kill server inside pod, exit value {0}, stdout {1}, stderr {2}\",\n+          execResult.exitValue(), execResult.stdout(), execResult.stderr());\n+\n+      try {\n+        Thread.sleep(2 * 1000);\n+      } catch (InterruptedException ie) {\n+        // ignore\n+      }\n+    }\n+\n+    // check pod is ready\n+    checkPodReady(serverName, domainUid, domainNamespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MjgxMw=="}, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 425}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg2MTI0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNTowMlrOG7HRqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjozOTozNlrOG7olJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODM3OA==", "bodyText": "You can use 0 for external rest port as well. I did the same in upgrade tests - https://github.com/oracle/weblogic-kubernetes-operator/blob/operator-upgrade-tests/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItOperatorUpgrade.java", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464638378", "createdAt": "2020-08-03T20:15:02Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjU3OQ==", "bodyText": "you can make this change in your next PR if you want.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464642579", "createdAt": "2020-08-03T20:24:12Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODM3OA=="}, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NDAzOA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r465184038", "createdAt": "2020-08-04T16:39:36Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODM3OA=="}, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg2Nzc0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxNzoxMlrOG7HVmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjozOTo0M1rOG7olfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTM4NA==", "bodyText": "can you test this for only one type of domain, no need to test with all three models, just adds up run time.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464639384", "createdAt": "2020-08-03T20:17:12Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, externalRestHttpsPort,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    Domain miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test liveness probe of pod\")\n+  @MethodSource(\"domainProvider\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NDEyNg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r465184126", "createdAt": "2020-08-04T16:39:43Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1284 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    // get a free port for external REST HTTPS port\n+    externalRestHttpsPort = getNextFreePort(31001, 31201);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, externalRestHttpsPort,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    Domain miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test liveness probe of pod\")\n+  @MethodSource(\"domainProvider\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTM4NA=="}, "originalCommit": {"oid": "be608db189e9581622546e5b4934bf23c4af5156"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjM3NTgyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzozODoyNFrOG7MEbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjozOTo0OVrOG7olvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNjkxMA==", "bodyText": "do we need so many debug flags here?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464716910", "createdAt": "2020-08-03T23:38:24Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1285 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+  private static Domain miiDomain = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, 0,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @Test\n+  @DisplayName(\"Test liveness probe of pod\")\n+  public void testLivenessProbe() {\n+    Domain domain = miiDomain;\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    String serverName;\n+    if (numClusters > 1) {\n+      serverName = domainUid + \"-\" + clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    } else {\n+      serverName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    }\n+\n+    // create file to kill server process\n+    File killServerScript = assertDoesNotThrow(() -> createScriptToKillServer(),\n+        \"Failed to create script to kill server\");\n+    logger.info(\"File/script created to kill server {0}\", killServerScript);\n+\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // copy script to pod\n+    String destLocation = \"/u01/killserver.sh\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace, serverName, \"weblogic-server\",\n+        killServerScript.toPath(), Paths.get(destLocation)),\n+        String.format(\"Failed to copy file %s to pod %s in namespace %s\",\n+            killServerScript, serverName, domainNamespace));\n+    logger.info(\"File copied to Pod {0} in namespace {1}\", serverName, domainNamespace);\n+\n+    // get the restart count of the container in pod before liveness probe restarts\n+    final int beforeRestartCount =\n+        assertDoesNotThrow(() -> getContainerRestartCount(domainNamespace, null, serverName, null),\n+            String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+                serverName, domainNamespace));\n+    logger.info(\"Restart count before liveness probe {0}\", beforeRestartCount);\n+\n+    // change file permissions\n+    ExecResult execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+        true, \"/bin/sh\", \"-c\", \"chmod +x \" + destLocation),\n+        String.format(\"Failed to change permissions for file %s in pod %s\", destLocation, serverName));\n+    assertTrue(execResult.exitValue() == 0,\n+        String.format(\"Failed to change file %s permissions, stderr %s stdout %s\", destLocation,\n+            execResult.stderr(), execResult.stdout()));\n+    logger.info(\"File permissions changed inside pod\");\n+\n+    /* First, kill the managed server process in the container three times to cause the node manager to\n+     * mark the server 'failed not restartable'. This in turn is detected by the liveness probe, which\n+     * initiates a container restart.\n+     */\n+    for (int i = 0; i < 3; i++) {\n+      execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+          true, \"/bin/sh\", \"-c\", destLocation + \" \" + serverName),\n+          String.format(\"Failed to execute script %s in pod %s namespace %s\", destLocation,\n+              serverName, domainNamespace));\n+      logger.info(\"Command executed to kill server inside pod, exit value {0}, stdout {1}, stderr {2}\",\n+          execResult.exitValue(), execResult.stdout(), execResult.stderr());\n+\n+      try {\n+        Thread.sleep(2 * 1000);\n+      } catch (InterruptedException ie) {\n+        // ignore\n+      }\n+    }\n+\n+    // check pod is ready\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // get the restart count of the container in pod after liveness probe restarts\n+    int afterRestartCount = assertDoesNotThrow(() ->\n+            getContainerRestartCount(domainNamespace, null, serverName, null),\n+        String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+            serverName, domainNamespace));\n+    assertTrue(afterRestartCount - beforeRestartCount == 1,\n+        String.format(\"Liveness probe did not start the container in pod %s in namespace %s\",\n+            serverName, domainNamespace));\n+\n+    //access application in managed servers through NGINX load balancer\n+    logger.info(\"Accessing the sample app through NGINX load balancer\");\n+    String curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+    List<String> managedServers = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServers, 20))\n+        .as(\"Verify NGINX can access the test web app from all managed servers in the domain\")\n+        .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n+        .isTrue();\n+  }\n+\n+  /**\n+   * Generate a steam of Domain objects used in parameterized tests.\n+   * @return stream of oracle.weblogic.domain.Domain objects\n+   */\n+  private static Stream<Domain> domainProvider() {\n+    return domains.stream();\n+  }\n+\n+  /**\n+   * Verify scale each cluster of the domain by patching domain resource.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get the domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    for (int i = 1; i <= numClusters; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+\n+      int numberOfServers;\n+      // scale cluster-1 to 1 server and cluster-2 to 3 servers\n+      if (i == 1) {\n+        numberOfServers = 1;\n+      } else {\n+        numberOfServers = 3;\n+      }\n+\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+          clusterName, domainUid, domainNamespace, numberOfServers);\n+      curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+      List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+      scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+          replicaCount, numberOfServers, curlCmd, managedServersBeforeScale);\n+\n+      // then scale cluster back to 2 servers\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+          clusterName, domainUid, domainNamespace, numberOfServers, replicaCount);\n+      managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, numberOfServers);\n+      scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+          numberOfServers, replicaCount, curlCmd, managedServersBeforeScale);\n+    }\n+  }\n+\n+  /**\n+   * Verify scale each cluster of the domain by calling REST API.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+    String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+    int numberOfServers = 3;\n+\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount, numberOfServers);\n+    curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+    List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount, numberOfServers, true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+        false, \"\", \"\", 0, \"\", \"\", curlCmd, managedServersBeforeScale);\n+\n+    // then scale cluster back to 2 servers\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, numberOfServers, replicaCount);\n+    managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, numberOfServers);\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        numberOfServers, replicaCount, true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+        false, \"\", \"\", 0, \"\", \"\", curlCmd, managedServersBeforeScale);\n+  }\n+\n+  /**\n+   * Verify scale each cluster in the domain using WLDF policy.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String domainHome = domain.getSpec().getDomainHome();\n+    int numClusters = domain.getSpec().getClusters().size();\n+    String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+\n+    curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+\n+    // scale up the cluster by 1 server\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount, replicaCount + 1);\n+    List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    String curlCmdForWLDFScript =\n+        generateCurlCmd(domainUid, domainNamespace, clusterName, WLDF_OPENSESSION_APP_CONTEXT_ROOT);\n+\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount, replicaCount + 1, false, 0, opNamespace, opServiceAccount,\n+        true, domainHome, \"scaleUp\", 1,\n+        WLDF_OPENSESSION_APP, curlCmdForWLDFScript, curlCmd, managedServersBeforeScale);\n+\n+    // scale down the cluster by 1 server\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount + 1, replicaCount);\n+    managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount + 1);\n+\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount + 1, replicaCount, false, 0, opNamespace, opServiceAccount,\n+        true, domainHome, \"scaleDown\", 1,\n+        WLDF_OPENSESSION_APP, curlCmdForWLDFScript, curlCmd, managedServersBeforeScale);\n+  }\n+\n+  /**\n+   * Uninstall NGINX release.\n+   * Delete cluster role and cluster role binding used for WLDF.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+\n+    for (Domain domain : domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // delete cluster role binding created for WLDF policy\n+      if (assertDoesNotThrow(\n+          () -> clusterRoleBindingExists(domainNamespace + \"-\" + WLDF_CLUSTER_ROLE_BINDING_NAME))) {\n+        assertTrue(deleteClusterRoleBinding(domainNamespace + \"-\" + WLDF_CLUSTER_ROLE_BINDING_NAME));\n+      }\n+    }\n+\n+    // delete cluster role created for WLDF policy\n+    if (assertDoesNotThrow(() -> clusterRoleExists(WLDF_CLUSTER_ROLE_NAME))) {\n+      assertThat(assertDoesNotThrow(() -> deleteClusterRole(WLDF_CLUSTER_ROLE_NAME),\n+          \"deleteClusterRole failed with ApiException\"))\n+          .as(\"Test delete cluster role returns true\")\n+          .withFailMessage(\"deleteClusterRole() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create model in image domain with multiple clusters.\n+   *\n+   * @param domainNamespace namespace in which the domain will be created\n+   * @return oracle.weblogic.domain.Domain objects\n+   */\n+  private static Domain createMiiDomainWithMultiClusters(String domainNamespace) {\n+\n+    final String domainUid = \"miidomain\";\n+    final String miiImageName = \"mii-image\";\n+    final String wdtModelFileForMiiDomain = \"model-multiclusterdomain-sampleapp-wls.yaml\";\n+\n+    // admin/managed server name here should match with WDT model yaml file\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    // create image with model files\n+    logger.info(\"Creating image with model file {0} and verify\", wdtModelFileForMiiDomain);\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+    String miiImage =\n+        createMiiImageAndVerify(miiImageName, Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFileForMiiDomain),\n+            appSrcDirList, WLS_BASE_IMAGE_NAME, WLS_BASE_IMAGE_TAG, WLS_DOMAIN_TYPE, false);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // construct the cluster list used for domain custom resource\n+    List<Cluster> clusterList = new ArrayList<>();\n+    for (int i = NUMBER_OF_CLUSTERS_MIIDOMAIN; i >= 1; i--) {\n+      clusterList.add(new Cluster()\n+          .clusterName(CLUSTER_NAME_PREFIX + i)\n+          .replicas(replicaCount)\n+          .serverStartState(\"RUNNING\"));\n+    }\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/u01/domains/\" + domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusterList)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod is ready and service exists in domain namespace\n+    logger.info(\"Checking that admin server pod {0} is ready and service exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS_MIIDOMAIN; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+\n+        // check managed server pod is ready and service exists in the namespace\n+        logger.info(\"Checking that managed server pod {0} is ready and service exists in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+    }\n+\n+    return domain;\n+  }\n+\n+  /**\n+   * Create a domain in PV using WDT.\n+   *\n+   * @param domainNamespace namespace in which the domain will be created\n+   * @return oracle.weblogic.domain.Domain objects\n+   */\n+  private static Domain createDomainInPvUsingWdt(String domainNamespace) {\n+    final String domainUid = \"domaininpv\" + \"-\" + domainNamespace.substring(3);\n+    final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+    String managedServerPodNamePrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+    int t3ChannelPort = getNextFreePort(31111, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    Path pvHostPath =\n+        get(PV_ROOT, ItParameterizedDomain.class.getSimpleName(), pvcName);\n+\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+    createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = assertDoesNotThrow(() -> createTempFile(\"domaininpv\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+\n+    Properties p = new Properties();\n+    p.setProperty(\"adminUsername\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"adminPassword\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    assertDoesNotThrow(() ->\n+            p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain in persistent volume using WDT\n+    runCreateDomainInPVJobUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, domainNamespace);\n+\n+    // create the domain custom resource\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/u01/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(wlsBaseImage)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/u01/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/u01/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify admin server pod is ready and service exists\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server pods are ready and services exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready and service existing in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // build application sample-app and opensessionapp\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+\n+    for (String appName : appSrcDirList) {\n+      assertTrue(buildAppArchive(defaultAppParams()\n+              .srcDirList(Collections.singletonList(appName))\n+              .appName(appName)),\n+          String.format(\"Failed to create app archive for %s\", appName));\n+\n+      //deploy application\n+      Path archivePath = get(ARCHIVE_DIR, \"wlsdeploy\", \"applications\", appName + \".ear\");\n+      logger.info(\"Deploying webapp {0} to domain {1}\", archivePath, domainUid);\n+      deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3ChannelPort),\n+          ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + ADMIN_SERVER_NAME_BASE, archivePath,\n+          domainNamespace);\n+    }\n+\n+    return domain;\n+  }\n+\n+  /**\n+   * Generate the curl command to access the sample app from the ingress controller.\n+   *\n+   * @param domainUid uid of the domain\n+   * @param domainNamespace the namespace in which the domain exists\n+   * @param clusterName WebLogic cluster name which is the backend of the ingress\n+   * @param appContextRoot the context root of the application\n+   * @return curl command string\n+   */\n+  private static String generateCurlCmd(String domainUid, String domainNamespace, String clusterName,\n+                                        String appContextRoot) {\n+\n+    return String.format(\"curl -v --show-error --noproxy '*' -H 'host: %s' http://%s:%s/%s/index.jsp\",\n+        domainUid + \".\" + domainNamespace + \".\" + clusterName + \".test\",\n+        K8S_NODEPORT_HOST, nodeportshttp, appContextRoot);\n+  }\n+\n+  /**\n+   * Generate a server list which contains all managed servers in the cluster before scale.\n+   *\n+   * @param numClusters         number of clusters in the domain\n+   * @param clusterName         the name of the WebLogic cluster\n+   * @param replicasBeforeScale the replicas of WebLogic cluster before scale\n+   * @return list of managed servers in the cluster before scale\n+   */\n+  private static List<String> listManagedServersBeforeScale(int numClusters, String clusterName,\n+                                                            int replicasBeforeScale) {\n+\n+    List<String> managedServerNames = new ArrayList<>();\n+    for (int i = 1; i <= replicasBeforeScale; i++) {\n+      if (numClusters <= 1) {\n+        managedServerNames.add(MANAGED_SERVER_NAME_BASE + i);\n+      } else {\n+        managedServerNames.add(clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + i);\n+      }\n+    }\n+\n+    return managedServerNames;\n+  }\n+\n+  /**\n+   * Create a WebLogic domain in a persistent volume by doing the following.\n+   * Create a configmap containing WDT model file, property file and shell script to download and run WDT.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param domainCreationScriptFile path of the shell script to download and run WDT\n+   * @param modelFile path of the WDT model file\n+   * @param domainPropertiesFile property file holding properties referenced in WDT model file\n+   * @param domainUid unique id of the WebLogic domain\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private static void runCreateDomainInPVJobUsingWdt(Path domainCreationScriptFile,\n+                                                     Path modelFile,\n+                                                     Path domainPropertiesFile,\n+                                                     String domainUid,\n+                                                     String pvName,\n+                                                     String pvcName,\n+                                                     String namespace) {\n+    logger.info(\"Preparing to run create domain job using WDT\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(domainCreationScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+    domainScriptFiles.add(modelFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainCreationScriptFile.getFileName())\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VERSION\")\n+            .value(WDT_VERSION))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_MODEL_FILE\")\n+            .value(\"/u01/weblogic/\" + modelFile.getFileName()))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VAR_FILE\")\n+            .value(\"/u01/weblogic/\" + domainPropertiesFile.getFileName()))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_DIR\")\n+            .value(\"/u01/shared/wdt\"))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"DOMAIN_HOME_DIR\")\n+            .value(\"/u01/shared/domains/\" + domainUid));\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to add in ConfigMap\n+   * @param namespace name of the namespace in which to create ConfigMap\n+   * @throws IOException when reading the domain script files fail\n+   */\n+  private static void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws IOException {\n+    logger.info(\"Creating ConfigMap {0}\", configMapName);\n+\n+    Path domainScriptsDir = createDirectories(\n+        get(TestConstants.LOGS_DIR, ItParameterizedDomain.class.getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in ConfigMap\", file);\n+      data.put(file.getFileName().toString(), readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create ConfigMap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM ConfigMap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private static void createDomainJob(String pvName,\n+                                      String pvcName,\n+                                      String domainScriptCM,\n+                                      String namespace,\n+                                      V1Container jobContainer) {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .addInitContainersItem(new V1Container()\n+                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n+                        .image(wlsBaseImage)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /u01/shared\")\n+                        .addVolumeMountsItem(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/u01/shared\"))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L)))\n+                    .addContainersItem(jobContainer  // container containing WLST or WDT details\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(wlsBaseImage)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .addPortsItem(new V1ContainerPort()\n+                            .containerPort(7001))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/u01/shared\")))) // mounted under /u01/shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    String jobName = createJobAndWaitUntilComplete(jobBody, namespace);\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n+        \"Getting the job failed\");\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = assertDoesNotThrow(() -> listPods(\n+            namespace, \"job-name=\" + jobName).getItems(),\n+            \"Listing pods failed\");\n+        if (!pods.isEmpty()) {\n+          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n+              \"Failed to get pod log\");\n+          logger.severe(podLog);\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain in image using WDT.\n+   *\n+   * @param domainNamespace namespace in which the domain to be created\n+   * @return oracle.weblogic.domain.Domain object\n+   */\n+  private static Domain createAndVerifyDomainInImageUsingWdt(String domainNamespace) {\n+\n+    String domainUid = \"domaininimage\";\n+    String wdtModelFileForDomainInImage = \"wdt-singlecluster-multiapps-usingprop-wls.yaml\";\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create image with model files\n+    logger.info(\"Creating image with model file and verify\");\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+\n+    String domainInImageWithWDTImage = createImageAndVerify(\"domaininimage-wdtimage\",\n+        Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFileForDomainInImage), appSrcDirList,\n+        Collections.singletonList(MODEL_DIR + \"/\" + WDT_BASIC_MODEL_PROPERTIES_FILE),\n+        WLS_BASE_IMAGE_NAME, WLS_BASE_IMAGE_TAG, WLS_DOMAIN_TYPE, false,\n+        domainUid, false);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domainInImageWithWDTImage);\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create the domain custom resource\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(WDT_IMAGE_DOMAINHOME_BASE_DIR + \"/\" + domainUid)\n+            .domainHomeSourceType(\"Image\")\n+            .image(domainInImageWithWDTImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a955847adc5af54bff4e6d5b796e1a988767297"}, "originalPosition": 1199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NDE4OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r465184188", "createdAt": "2020-08-04T16:39:49Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItParameterizedDomain.java", "diffHunk": "@@ -0,0 +1,1285 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Stream;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.io.File.createTempFile;\n+import static java.nio.file.Files.copy;\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Files.readString;\n+import static java.nio.file.Paths.get;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_APP_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_MODEL_PROPERTIES_FILE;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_IMAGE_DOMAINHOME_BASE_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_BINDING_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLDF_CLUSTER_ROLE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRole;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteClusterRoleBinding;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getContainerRestartCount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.copyFileToPod;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleBindingExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.clusterRoleExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createJobAndWaitUntilComplete;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOCRRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndWaitTillReady;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Verify scaling up and down the clusters in the domain with different domain types.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@DisplayName(\"Verify scaling the clusters in the domain with different domain types and \"\n+    + \"the sample application can be accessed via NGINX ingress controller\")\n+@IntegrationTest\n+class ItParameterizedDomain {\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS_MIIDOMAIN = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final String clusterName = \"cluster-1\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int ADMIN_SERVER_PORT = 7001;\n+  private static final int replicaCount = 2;\n+  private static final String SAMPLE_APP_CONTEXT_ROOT = \"sample-war\";\n+  private static final String WLDF_OPENSESSION_APP = \"opensessionapp\";\n+  private static final String WLDF_OPENSESSION_APP_CONTEXT_ROOT = \"opensession\";\n+  private static final String wlSecretName = \"weblogic-credentials\";\n+\n+  private static String wlsBaseImage = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static String opNamespace = null;\n+  private static String opServiceAccount = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static int externalRestHttpsPort = 0;\n+  private static boolean isUseSecret = true;\n+  private static List<Domain> domains = new ArrayList<>();\n+  private static LoggingFacade logger = null;\n+  private static Domain miiDomain = null;\n+\n+  private String curlCmd = null;\n+\n+  /**\n+   * Install operator and NGINX.\n+   * Create three different type of domains: model in image, domain in PV and domain in image.\n+   * Create ingress for each domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(5) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(1);\n+\n+    // get unique namespaces for three different type of domains\n+    logger.info(\"Getting unique namespaces for three different type of domains\");\n+    assertNotNull(namespaces.get(2));\n+    String miiDomainNamespace = namespaces.get(2);\n+    assertNotNull(namespaces.get(3));\n+    String domainInPVNamespace = namespaces.get(3);\n+    assertNotNull(namespaces.get(4));\n+    String domainInImageNamespace = namespaces.get(4);\n+\n+    // set the service account name for the operator\n+    opServiceAccount = opNamespace + \"-sa\";\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + wlsBaseImage.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      wlsBaseImage = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+\n+    // install and verify operator with REST API\n+    installAndVerifyOperator(opNamespace, opServiceAccount, true, 0,\n+        miiDomainNamespace, domainInPVNamespace, domainInImageNamespace);\n+\n+    externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, 0, 0);\n+    String nginxServiceName = nginxHelmParams.getReleaseName() + \"-nginx-ingress-controller\";\n+    logger.info(\"NGINX service name: {0}\", nginxServiceName);\n+    nodeportshttp = getServiceNodePort(nginxNamespace, nginxServiceName, \"http\");\n+    logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n+\n+    // create model in image domain with multiple clusters\n+    miiDomain = createMiiDomainWithMultiClusters(miiDomainNamespace);\n+    // create domain in image\n+    Domain domainInImage = createAndVerifyDomainInImageUsingWdt(domainInImageNamespace);\n+    // create domain in pv\n+    Domain domainInPV = createDomainInPvUsingWdt(domainInPVNamespace);\n+\n+    domains.add(miiDomain);\n+    domains.add(domainInImage);\n+    domains.add(domainInPV);\n+\n+    // create ingress for each domain\n+    for (Domain domain: domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainUid = domain.getSpec().getDomainUid();\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // create ingress using host based routing\n+      Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+      int numClusters = domain.getSpec().getClusters().size();\n+      for (int i = 1; i <= numClusters; i++) {\n+        clusterNameMsPortMap.put(CLUSTER_NAME_PREFIX + i, MANAGED_SERVER_PORT);\n+      }\n+      logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+      createIngressForDomainAndVerify(domainUid, domainNamespace, nodeportshttp, clusterNameMsPortMap, true,\n+          true, ADMIN_SERVER_PORT);\n+    }\n+  }\n+\n+  /**\n+   * Scale the cluster by patching domain resource for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster by patching domain resource with three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain by patching domain resource\n+    logger.info(\"testScaleClustersByPatchingDomainResource with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersByPatchingDomainResource(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using REST API for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using REST API for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain using REST API\n+    logger.info(\"testScaleClustersWithRestApi with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithRestApi(domain);\n+  }\n+\n+  /**\n+   * Scale cluster using WLDF policy for three different type of domains.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"scale cluster using WLDF policy for three different type of domains\")\n+  @MethodSource(\"domainProvider\")\n+  public void testParamsScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // Verify scale cluster of the domain with WLDF policy\n+    logger.info(\"testScaleClustersWithWLDF with domain {0}\", domain.getMetadata().getName());\n+    testScaleClustersWithWLDF(domain);\n+  }\n+\n+  /**\n+   * Verify admin console login using admin node port.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using admin node port\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingAdminNodePort(Domain domain) {\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(\n+        domainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() ->\n+        adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Verify admin console login using ingress controller.\n+   *\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  @ParameterizedTest\n+  @DisplayName(\"Test admin console login using ingress controller\")\n+  @MethodSource(\"domainProvider\")\n+  public void testAdminConsoleLoginUsingIngressController(Domain domain) {\n+    logger.info(\"Validating WebLogic admin server access using ingress controller\");\n+\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+\n+    String curlCmd = \"curl --silent --show-error --noproxy '*' -H 'host: \"\n+        + domainUid + \".\" + domainNamespace + \".adminserver.test\"\n+        + \"' http://\" + K8S_NODEPORT_HOST + \":\" + nodeportshttp\n+        + \"/console/login/LoginForm.jsp --write-out %{http_code} -o /dev/null\";\n+\n+    logger.info(\"Executing curl command {0}\", curlCmd);\n+    assertTrue(callWebAppAndWaitTillReady(curlCmd, 60));\n+    logger.info(\"WebLogic console on domain1 is accessible\");\n+  }\n+\n+  /**\n+   * Verify liveness probe by killing managed server process 3 times to kick pod container auto-restart.\n+   */\n+  @Test\n+  @DisplayName(\"Test liveness probe of pod\")\n+  public void testLivenessProbe() {\n+    Domain domain = miiDomain;\n+    assertDomainNotNull(domain);\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    String serverName;\n+    if (numClusters > 1) {\n+      serverName = domainUid + \"-\" + clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    } else {\n+      serverName = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE + \"1\";\n+    }\n+\n+    // create file to kill server process\n+    File killServerScript = assertDoesNotThrow(() -> createScriptToKillServer(),\n+        \"Failed to create script to kill server\");\n+    logger.info(\"File/script created to kill server {0}\", killServerScript);\n+\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // copy script to pod\n+    String destLocation = \"/u01/killserver.sh\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace, serverName, \"weblogic-server\",\n+        killServerScript.toPath(), Paths.get(destLocation)),\n+        String.format(\"Failed to copy file %s to pod %s in namespace %s\",\n+            killServerScript, serverName, domainNamespace));\n+    logger.info(\"File copied to Pod {0} in namespace {1}\", serverName, domainNamespace);\n+\n+    // get the restart count of the container in pod before liveness probe restarts\n+    final int beforeRestartCount =\n+        assertDoesNotThrow(() -> getContainerRestartCount(domainNamespace, null, serverName, null),\n+            String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+                serverName, domainNamespace));\n+    logger.info(\"Restart count before liveness probe {0}\", beforeRestartCount);\n+\n+    // change file permissions\n+    ExecResult execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+        true, \"/bin/sh\", \"-c\", \"chmod +x \" + destLocation),\n+        String.format(\"Failed to change permissions for file %s in pod %s\", destLocation, serverName));\n+    assertTrue(execResult.exitValue() == 0,\n+        String.format(\"Failed to change file %s permissions, stderr %s stdout %s\", destLocation,\n+            execResult.stderr(), execResult.stdout()));\n+    logger.info(\"File permissions changed inside pod\");\n+\n+    /* First, kill the managed server process in the container three times to cause the node manager to\n+     * mark the server 'failed not restartable'. This in turn is detected by the liveness probe, which\n+     * initiates a container restart.\n+     */\n+    for (int i = 0; i < 3; i++) {\n+      execResult = assertDoesNotThrow(() -> execCommand(domainNamespace, serverName, null,\n+          true, \"/bin/sh\", \"-c\", destLocation + \" \" + serverName),\n+          String.format(\"Failed to execute script %s in pod %s namespace %s\", destLocation,\n+              serverName, domainNamespace));\n+      logger.info(\"Command executed to kill server inside pod, exit value {0}, stdout {1}, stderr {2}\",\n+          execResult.exitValue(), execResult.stdout(), execResult.stderr());\n+\n+      try {\n+        Thread.sleep(2 * 1000);\n+      } catch (InterruptedException ie) {\n+        // ignore\n+      }\n+    }\n+\n+    // check pod is ready\n+    checkPodReady(serverName, domainUid, domainNamespace);\n+\n+    // get the restart count of the container in pod after liveness probe restarts\n+    int afterRestartCount = assertDoesNotThrow(() ->\n+            getContainerRestartCount(domainNamespace, null, serverName, null),\n+        String.format(\"Failed to get the restart count of the container from pod {0} in namespace {1}\",\n+            serverName, domainNamespace));\n+    assertTrue(afterRestartCount - beforeRestartCount == 1,\n+        String.format(\"Liveness probe did not start the container in pod %s in namespace %s\",\n+            serverName, domainNamespace));\n+\n+    //access application in managed servers through NGINX load balancer\n+    logger.info(\"Accessing the sample app through NGINX load balancer\");\n+    String curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+    List<String> managedServers = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServers, 20))\n+        .as(\"Verify NGINX can access the test web app from all managed servers in the domain\")\n+        .withFailMessage(\"NGINX can not access the test web app from one or more of the managed servers\")\n+        .isTrue();\n+  }\n+\n+  /**\n+   * Generate a steam of Domain objects used in parameterized tests.\n+   * @return stream of oracle.weblogic.domain.Domain objects\n+   */\n+  private static Stream<Domain> domainProvider() {\n+    return domains.stream();\n+  }\n+\n+  /**\n+   * Verify scale each cluster of the domain by patching domain resource.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersByPatchingDomainResource(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get the domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+\n+    for (int i = 1; i <= numClusters; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+\n+      int numberOfServers;\n+      // scale cluster-1 to 1 server and cluster-2 to 3 servers\n+      if (i == 1) {\n+        numberOfServers = 1;\n+      } else {\n+        numberOfServers = 3;\n+      }\n+\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+          clusterName, domainUid, domainNamespace, numberOfServers);\n+      curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+      List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+      scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+          replicaCount, numberOfServers, curlCmd, managedServersBeforeScale);\n+\n+      // then scale cluster back to 2 servers\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+          clusterName, domainUid, domainNamespace, numberOfServers, replicaCount);\n+      managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, numberOfServers);\n+      scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+          numberOfServers, replicaCount, curlCmd, managedServersBeforeScale);\n+    }\n+  }\n+\n+  /**\n+   * Verify scale each cluster of the domain by calling REST API.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersWithRestApi(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    int numClusters = domain.getSpec().getClusters().size();\n+    String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+    int numberOfServers = 3;\n+\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount, numberOfServers);\n+    curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+    List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount, numberOfServers, true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+        false, \"\", \"\", 0, \"\", \"\", curlCmd, managedServersBeforeScale);\n+\n+    // then scale cluster back to 2 servers\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, numberOfServers, replicaCount);\n+    managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, numberOfServers);\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        numberOfServers, replicaCount, true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+        false, \"\", \"\", 0, \"\", \"\", curlCmd, managedServersBeforeScale);\n+  }\n+\n+  /**\n+   * Verify scale each cluster in the domain using WLDF policy.\n+   * @param domain oracle.weblogic.domain.Domain object\n+   */\n+  private void testScaleClustersWithWLDF(Domain domain) {\n+    assertDomainNotNull(domain);\n+\n+    // get domain properties\n+    String domainUid = domain.getSpec().getDomainUid();\n+    String domainNamespace = domain.getMetadata().getNamespace();\n+    String domainHome = domain.getSpec().getDomainHome();\n+    int numClusters = domain.getSpec().getClusters().size();\n+    String managedServerPodNamePrefix = generateMsPodNamePrefix(numClusters, domainUid, clusterName);\n+\n+    curlCmd = generateCurlCmd(domainUid, domainNamespace, clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+\n+    // scale up the cluster by 1 server\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount, replicaCount + 1);\n+    List<String> managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount);\n+    String curlCmdForWLDFScript =\n+        generateCurlCmd(domainUid, domainNamespace, clusterName, WLDF_OPENSESSION_APP_CONTEXT_ROOT);\n+\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount, replicaCount + 1, false, 0, opNamespace, opServiceAccount,\n+        true, domainHome, \"scaleUp\", 1,\n+        WLDF_OPENSESSION_APP, curlCmdForWLDFScript, curlCmd, managedServersBeforeScale);\n+\n+    // scale down the cluster by 1 server\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+        clusterName, domainUid, domainNamespace, replicaCount + 1, replicaCount);\n+    managedServersBeforeScale = listManagedServersBeforeScale(numClusters, clusterName, replicaCount + 1);\n+\n+    scaleAndVerifyCluster(clusterName, domainUid, domainNamespace, managedServerPodNamePrefix,\n+        replicaCount + 1, replicaCount, false, 0, opNamespace, opServiceAccount,\n+        true, domainHome, \"scaleDown\", 1,\n+        WLDF_OPENSESSION_APP, curlCmdForWLDFScript, curlCmd, managedServersBeforeScale);\n+  }\n+\n+  /**\n+   * Uninstall NGINX release.\n+   * Delete cluster role and cluster role binding used for WLDF.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+\n+    for (Domain domain : domains) {\n+      assertDomainNotNull(domain);\n+\n+      String domainNamespace = domain.getMetadata().getNamespace();\n+\n+      // delete cluster role binding created for WLDF policy\n+      if (assertDoesNotThrow(\n+          () -> clusterRoleBindingExists(domainNamespace + \"-\" + WLDF_CLUSTER_ROLE_BINDING_NAME))) {\n+        assertTrue(deleteClusterRoleBinding(domainNamespace + \"-\" + WLDF_CLUSTER_ROLE_BINDING_NAME));\n+      }\n+    }\n+\n+    // delete cluster role created for WLDF policy\n+    if (assertDoesNotThrow(() -> clusterRoleExists(WLDF_CLUSTER_ROLE_NAME))) {\n+      assertThat(assertDoesNotThrow(() -> deleteClusterRole(WLDF_CLUSTER_ROLE_NAME),\n+          \"deleteClusterRole failed with ApiException\"))\n+          .as(\"Test delete cluster role returns true\")\n+          .withFailMessage(\"deleteClusterRole() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create model in image domain with multiple clusters.\n+   *\n+   * @param domainNamespace namespace in which the domain will be created\n+   * @return oracle.weblogic.domain.Domain objects\n+   */\n+  private static Domain createMiiDomainWithMultiClusters(String domainNamespace) {\n+\n+    final String domainUid = \"miidomain\";\n+    final String miiImageName = \"mii-image\";\n+    final String wdtModelFileForMiiDomain = \"model-multiclusterdomain-sampleapp-wls.yaml\";\n+\n+    // admin/managed server name here should match with WDT model yaml file\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+\n+    // create image with model files\n+    logger.info(\"Creating image with model file {0} and verify\", wdtModelFileForMiiDomain);\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+    String miiImage =\n+        createMiiImageAndVerify(miiImageName, Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFileForMiiDomain),\n+            appSrcDirList, WLS_BASE_IMAGE_NAME, WLS_BASE_IMAGE_TAG, WLS_DOMAIN_TYPE, false);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+\n+    // construct the cluster list used for domain custom resource\n+    List<Cluster> clusterList = new ArrayList<>();\n+    for (int i = NUMBER_OF_CLUSTERS_MIIDOMAIN; i >= 1; i--) {\n+      clusterList.add(new Cluster()\n+          .clusterName(CLUSTER_NAME_PREFIX + i)\n+          .replicas(replicaCount)\n+          .serverStartState(\"RUNNING\"));\n+    }\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/u01/domains/\" + domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusterList)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    // create model in image domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // check that admin server pod is ready and service exists in domain namespace\n+    logger.info(\"Checking that admin server pod {0} is ready and service exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS_MIIDOMAIN; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + \"-\" + MANAGED_SERVER_NAME_BASE + j;\n+\n+        // check managed server pod is ready and service exists in the namespace\n+        logger.info(\"Checking that managed server pod {0} is ready and service exists in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+      }\n+    }\n+\n+    return domain;\n+  }\n+\n+  /**\n+   * Create a domain in PV using WDT.\n+   *\n+   * @param domainNamespace namespace in which the domain will be created\n+   * @return oracle.weblogic.domain.Domain objects\n+   */\n+  private static Domain createDomainInPvUsingWdt(String domainNamespace) {\n+    final String domainUid = \"domaininpv\" + \"-\" + domainNamespace.substring(3);\n+    final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+    String managedServerPodNamePrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+    int t3ChannelPort = getNextFreePort(31111, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    Path pvHostPath =\n+        get(PV_ROOT, ItParameterizedDomain.class.getSimpleName(), pvcName);\n+\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    String labelSelector = String.format(\"weblogic.domainUid in (%s)\", domainUid);\n+    createPVPVCAndVerify(v1pv, v1pvc, labelSelector, domainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = assertDoesNotThrow(() -> createTempFile(\"domaininpv\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+\n+    Properties p = new Properties();\n+    p.setProperty(\"adminUsername\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"adminPassword\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", ADMIN_SERVER_NAME_BASE);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", MANAGED_SERVER_NAME_BASE);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    assertDoesNotThrow(() ->\n+            p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain in persistent volume using WDT\n+    runCreateDomainInPVJobUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, domainNamespace);\n+\n+    // create the domain custom resource\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/u01/shared/domains/\" + domainUid)\n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(wlsBaseImage)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/u01/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/u01/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify admin server pod is ready and service exists\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server pods are ready and services exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready and service existing in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // build application sample-app and opensessionapp\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+\n+    for (String appName : appSrcDirList) {\n+      assertTrue(buildAppArchive(defaultAppParams()\n+              .srcDirList(Collections.singletonList(appName))\n+              .appName(appName)),\n+          String.format(\"Failed to create app archive for %s\", appName));\n+\n+      //deploy application\n+      Path archivePath = get(ARCHIVE_DIR, \"wlsdeploy\", \"applications\", appName + \".ear\");\n+      logger.info(\"Deploying webapp {0} to domain {1}\", archivePath, domainUid);\n+      deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3ChannelPort),\n+          ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, clusterName + \",\" + ADMIN_SERVER_NAME_BASE, archivePath,\n+          domainNamespace);\n+    }\n+\n+    return domain;\n+  }\n+\n+  /**\n+   * Generate the curl command to access the sample app from the ingress controller.\n+   *\n+   * @param domainUid uid of the domain\n+   * @param domainNamespace the namespace in which the domain exists\n+   * @param clusterName WebLogic cluster name which is the backend of the ingress\n+   * @param appContextRoot the context root of the application\n+   * @return curl command string\n+   */\n+  private static String generateCurlCmd(String domainUid, String domainNamespace, String clusterName,\n+                                        String appContextRoot) {\n+\n+    return String.format(\"curl -v --show-error --noproxy '*' -H 'host: %s' http://%s:%s/%s/index.jsp\",\n+        domainUid + \".\" + domainNamespace + \".\" + clusterName + \".test\",\n+        K8S_NODEPORT_HOST, nodeportshttp, appContextRoot);\n+  }\n+\n+  /**\n+   * Generate a server list which contains all managed servers in the cluster before scale.\n+   *\n+   * @param numClusters         number of clusters in the domain\n+   * @param clusterName         the name of the WebLogic cluster\n+   * @param replicasBeforeScale the replicas of WebLogic cluster before scale\n+   * @return list of managed servers in the cluster before scale\n+   */\n+  private static List<String> listManagedServersBeforeScale(int numClusters, String clusterName,\n+                                                            int replicasBeforeScale) {\n+\n+    List<String> managedServerNames = new ArrayList<>();\n+    for (int i = 1; i <= replicasBeforeScale; i++) {\n+      if (numClusters <= 1) {\n+        managedServerNames.add(MANAGED_SERVER_NAME_BASE + i);\n+      } else {\n+        managedServerNames.add(clusterName + \"-\" + MANAGED_SERVER_NAME_BASE + i);\n+      }\n+    }\n+\n+    return managedServerNames;\n+  }\n+\n+  /**\n+   * Create a WebLogic domain in a persistent volume by doing the following.\n+   * Create a configmap containing WDT model file, property file and shell script to download and run WDT.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param domainCreationScriptFile path of the shell script to download and run WDT\n+   * @param modelFile path of the WDT model file\n+   * @param domainPropertiesFile property file holding properties referenced in WDT model file\n+   * @param domainUid unique id of the WebLogic domain\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private static void runCreateDomainInPVJobUsingWdt(Path domainCreationScriptFile,\n+                                                     Path modelFile,\n+                                                     Path domainPropertiesFile,\n+                                                     String domainUid,\n+                                                     String pvName,\n+                                                     String pvcName,\n+                                                     String namespace) {\n+    logger.info(\"Preparing to run create domain job using WDT\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(domainCreationScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+    domainScriptFiles.add(modelFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainCreationScriptFile.getFileName())\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VERSION\")\n+            .value(WDT_VERSION))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_MODEL_FILE\")\n+            .value(\"/u01/weblogic/\" + modelFile.getFileName()))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VAR_FILE\")\n+            .value(\"/u01/weblogic/\" + domainPropertiesFile.getFileName()))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_DIR\")\n+            .value(\"/u01/shared/wdt\"))\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"DOMAIN_HOME_DIR\")\n+            .value(\"/u01/shared/domains/\" + domainUid));\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+  }\n+\n+  /**\n+   * Create ConfigMap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the ConfigMap to create\n+   * @param files files to add in ConfigMap\n+   * @param namespace name of the namespace in which to create ConfigMap\n+   * @throws IOException when reading the domain script files fail\n+   */\n+  private static void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws IOException {\n+    logger.info(\"Creating ConfigMap {0}\", configMapName);\n+\n+    Path domainScriptsDir = createDirectories(\n+        get(TestConstants.LOGS_DIR, ItParameterizedDomain.class.getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in ConfigMap\", file);\n+      data.put(file.getFileName().toString(), readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create ConfigMap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM ConfigMap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   */\n+  private static void createDomainJob(String pvName,\n+                                      String pvcName,\n+                                      String domainScriptCM,\n+                                      String namespace,\n+                                      V1Container jobContainer) {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .addInitContainersItem(new V1Container()\n+                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n+                        .image(wlsBaseImage)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /u01/shared\")\n+                        .addVolumeMountsItem(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/u01/shared\"))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L)))\n+                    .addContainersItem(jobContainer  // container containing WLST or WDT details\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(wlsBaseImage)\n+                        .imagePullPolicy(\"IfNotPresent\")\n+                        .addPortsItem(new V1ContainerPort()\n+                            .containerPort(7001))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/u01/shared\")))) // mounted under /u01/shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    String jobName = createJobAndWaitUntilComplete(jobBody, namespace);\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = assertDoesNotThrow(() -> getJob(jobName, namespace),\n+        \"Getting the job failed\");\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = assertDoesNotThrow(() -> listPods(\n+            namespace, \"job-name=\" + jobName).getItems(),\n+            \"Listing pods failed\");\n+        if (!pods.isEmpty()) {\n+          String podLog = assertDoesNotThrow(() -> getPodLog(pods.get(0).getMetadata().getName(), namespace),\n+              \"Failed to get pod log\");\n+          logger.severe(podLog);\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain in image using WDT.\n+   *\n+   * @param domainNamespace namespace in which the domain to be created\n+   * @return oracle.weblogic.domain.Domain object\n+   */\n+  private static Domain createAndVerifyDomainInImageUsingWdt(String domainNamespace) {\n+\n+    String domainUid = \"domaininimage\";\n+    String wdtModelFileForDomainInImage = \"wdt-singlecluster-multiapps-usingprop-wls.yaml\";\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create image with model files\n+    logger.info(\"Creating image with model file and verify\");\n+    List<String> appSrcDirList = new ArrayList<>();\n+    appSrcDirList.add(MII_BASIC_APP_NAME);\n+    appSrcDirList.add(WLDF_OPENSESSION_APP);\n+\n+    String domainInImageWithWDTImage = createImageAndVerify(\"domaininimage-wdtimage\",\n+        Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFileForDomainInImage), appSrcDirList,\n+        Collections.singletonList(MODEL_DIR + \"/\" + WDT_BASIC_MODEL_PROPERTIES_FILE),\n+        WLS_BASE_IMAGE_NAME, WLS_BASE_IMAGE_TAG, WLS_DOMAIN_TYPE, false,\n+        domainUid, false);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domainInImageWithWDTImage);\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create the domain custom resource\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(WDT_IMAGE_DOMAINHOME_BASE_DIR + \"/\" + domainUid)\n+            .domainHomeSourceType(\"Image\")\n+            .image(domainInImageWithWDTImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctionMapper=true \"\n+                        + \"-Dweblogic.StdoutDebugEnabled=true -Dweblogic.log.LogSeverity=Debug \"\n+                        + \"-Dweblogic.log.LoggerSeverity=Debug -Dweblogic.debug.DebugDiagnosticsUtils=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionFunctions=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticsExpressionPoller=true \"\n+                        + \"-Dweblogic.debug.DebugDiagnosticWatch=true\"))\n+                .addEnvItem(new V1EnvVar()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNjkxMA=="}, "originalCommit": {"oid": "3a955847adc5af54bff4e6d5b796e1a988767297"}, "originalPosition": 1199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjM4NDgwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzo0MjoyOFrOG7MJcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjozOTo1N1rOG7omFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxODE5Mw==", "bodyText": "would it work on multinoded cluster? why switch from Always?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r464718193", "createdAt": "2020-08-03T23:42:28Z", "author": {"login": "marinakog"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -2211,7 +2238,7 @@ public static void createDomainJob(String image, boolean isUseSecret, String pvN\n                     .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n                         .name(\"create-weblogic-domain-onpv-container\")\n                         .image(image)\n-                        .imagePullPolicy(\"Always\")\n+                        .imagePullPolicy(\"IfNotPresent\")\n                         .ports(Arrays.asList(new V1ContainerPort()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a955847adc5af54bff4e6d5b796e1a988767297"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NDI3OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1776#discussion_r465184278", "createdAt": "2020-08-04T16:39:57Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -2211,7 +2238,7 @@ public static void createDomainJob(String image, boolean isUseSecret, String pvN\n                     .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n                         .name(\"create-weblogic-domain-onpv-container\")\n                         .image(image)\n-                        .imagePullPolicy(\"Always\")\n+                        .imagePullPolicy(\"IfNotPresent\")\n                         .ports(Arrays.asList(new V1ContainerPort()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxODE5Mw=="}, "originalCommit": {"oid": "3a955847adc5af54bff4e6d5b796e1a988767297"}, "originalPosition": 169}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4427, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}