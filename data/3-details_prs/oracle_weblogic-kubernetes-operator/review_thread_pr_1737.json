{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0ODM5Mjg2", "number": 1737, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxMzoxN1rOEFtuPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1Mzo1MlrOEGaX_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDI3NDUzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxMzoxN1rOGkEh6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNDo1OVrOGlSLZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3NjEzNw==", "bodyText": "Change the method name to reflect the JRF domain  e.g. testJrfDomainInPvusingWlst()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476137", "createdAt": "2020-06-15T22:13:17Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + JRF_BASE_IMAGE_TAG : JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG);\n+    logger.info(\"For ItJrfDomainInPV using DB image: {0}, FMW image {1}\", dbImage, fmwImage);\n+\n+  }\n+\n+  /**\n+   * Create a JRF domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   */\n+  @Test\n+  @DisplayName(\"Create JRF domain in PV using WLST script\")\n+  public void testDomainInPvUsingWlst() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODMyNg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748326", "createdAt": "2020-06-17T18:34:59Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + JRF_BASE_IMAGE_TAG : JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG);\n+    logger.info(\"For ItJrfDomainInPV using DB image: {0}, FMW image {1}\", dbImage, fmwImage);\n+\n+  }\n+\n+  /**\n+   * Create a JRF domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   */\n+  @Test\n+  @DisplayName(\"Create JRF domain in PV using WLST script\")\n+  public void testDomainInPvUsingWlst() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3NjEzNw=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDI3OTA3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxNDo1MVrOGkEkdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNToxNlrOGlSMKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3Njc4OQ==", "bodyText": "Remove TODO comment, if resolved", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476789", "createdAt": "2020-06-15T22:14:51Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODUyMg==", "bodyText": "fixed already", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748522", "createdAt": "2020-06-17T18:35:16Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3Njc4OQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDI4ODM4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxODo0MVrOGkEqDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNToyNFrOGlSMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODIyMg==", "bodyText": "Should be 2020,  instead of 2019, 2020,", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440478222", "createdAt": "2020-06-15T22:18:41Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODYwMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748600", "createdAt": "2020-06-17T18:35:24Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODIyMg=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDI4OTU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxOToxM1rOGkEqyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNTozMlrOGlSMyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODQxMQ==", "bodyText": "Remove commented code", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440478411", "createdAt": "2020-06-15T22:19:13Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"\n+ exit -1\n+else\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString}\n+fi\n+\n+# SOA needs extra component(s) SOAINFRA ESS (optional)\n+# SOA needs variables param(s) SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\n+\n+case $rcuType in\n+ fmw)\n+   extComponents=\"\"\n+   extVariables=\"\"\n+   echo \"Creating RCU Schema for FMW Domain ...\"\n+   ;;\n+ soa|soaosb|osb)\n+   extComponents=\"-component SOAINFRA\"\n+   extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+   echo \"Creating RCU Schema for SOA Domain [$rcuType] ...\"\n+   ;;\n+ soaess|soaessosb)\n+    extComponents=\"-component SOAINFRA -component ESS\"\n+    extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+    echo \"Creating RCU Schema for SOA Domain w/ESS [$rcuType] ...\"\n+  ;;\n+  * )\n+    echo \"[ERROR] Unknown RCU Schema Type [$rcuType]\"\n+    echo \"Supported values: fmw(default),soa,osb,soaosb,soaess,soaessosb\"\n+    exit -1\n+  ;;\n+esac\n+\n+echo \"Extra RCU Schema Component Choosen[${extComponents}]\" \n+echo \"Extra RCU Schema Variable Choosen[${extVariables}]\" \n+\n+#Debug ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODY4MQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748681", "createdAt": "2020-06-17T18:35:32Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"\n+ exit -1\n+else\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString}\n+fi\n+\n+# SOA needs extra component(s) SOAINFRA ESS (optional)\n+# SOA needs variables param(s) SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\n+\n+case $rcuType in\n+ fmw)\n+   extComponents=\"\"\n+   extVariables=\"\"\n+   echo \"Creating RCU Schema for FMW Domain ...\"\n+   ;;\n+ soa|soaosb|osb)\n+   extComponents=\"-component SOAINFRA\"\n+   extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+   echo \"Creating RCU Schema for SOA Domain [$rcuType] ...\"\n+   ;;\n+ soaess|soaessosb)\n+    extComponents=\"-component SOAINFRA -component ESS\"\n+    extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+    echo \"Creating RCU Schema for SOA Domain w/ESS [$rcuType] ...\"\n+  ;;\n+  * )\n+    echo \"[ERROR] Unknown RCU Schema Type [$rcuType]\"\n+    echo \"Supported values: fmw(default),soa,osb,soaosb,soaess,soaessosb\"\n+    exit -1\n+  ;;\n+esac\n+\n+echo \"Extra RCU Schema Component Choosen[${extComponents}]\" \n+echo \"Extra RCU Schema Variable Choosen[${extVariables}]\" \n+\n+#Debug ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODQxMQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDI5MzU3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoyMTowMVrOGkEtTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNTo0MVrOGlSNPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3OTA1Mw==", "bodyText": "Remove extra space between words", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440479053", "createdAt": "2020-06-15T22:21:01Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODc5Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748797", "createdAt": "2020-06-17T18:35:41Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3OTA1Mw=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQzODY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMDoxN1rOGkGFkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NDoyMFrOGksy4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMTY1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Start DB service and create RCU schema\n          \n          \n            \n               * Start DB service and create RCU schema.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440501651", "createdAt": "2020-06-15T23:30:17Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTg0Mw==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441135843", "createdAt": "2020-06-16T20:54:20Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMTY1MQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ0MzcyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMjo0MFrOGkGIaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NDozMVrOGkszSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjM3Ng==", "bodyText": "use static imports for OCR_REGISTRY", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502376", "createdAt": "2020-06-15T23:32:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTk0NA==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441135944", "createdAt": "2020-06-16T20:54:31Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjM3Ng=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ0NDAxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMjo0OVrOGkGIjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NDo0MVrOGkszqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjQxNA==", "bodyText": "same", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502414", "createdAt": "2020-06-15T23:32:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjA0MQ==", "bodyText": "Fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441136041", "createdAt": "2020-06-16T20:54:41Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjQxNA=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ0NzEyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozNDoyN1rOGkGKZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NjoxNVrOGks3DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjg4Nw==", "bodyText": "does this work?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502887", "createdAt": "2020-06-15T23:34:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -130,6 +130,10 @@\n     try {\n       Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n       apiClient = Configuration.getDefaultApiClient();\n+      // disable connection and read timeout to force the internal HTTP client\n+      // to keep a long running connection with the server to fix SSL connection closed issue\n+      apiClient.setConnectTimeout(0);\n+      apiClient.setReadTimeout(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjkwOA==", "bodyText": "The result is positive but not consistent. Since now I ignore the SSLProtocolException I removed the above line.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441136908", "createdAt": "2020-06-16T20:56:15Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -130,6 +130,10 @@\n     try {\n       Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n       apiClient = Configuration.getDefaultApiClient();\n+      // disable connection and read timeout to force the internal HTTP client\n+      // to keep a long running connection with the server to fix SSL connection closed issue\n+      apiClient.setConnectTimeout(0);\n+      apiClient.setReadTimeout(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjg4Nw=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ0OTg1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozNTo0MFrOGkGL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNjo0NTo0OVrOGkkQZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzI4MQ==", "bodyText": "I believe this method is available in actions/impl/primitive/Kubernetes.java\nyou can use that instead of duplicating it here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440503281", "createdAt": "2020-06-15T23:35:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -674,4 +676,24 @@ public static V1PersistentVolumeClaimList listPersistentVolumeClaims(String name\n \n     return v1PersistentVolumeClaimList;\n   }\n+\n+  /**\n+   * Copy a file to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the file\n+   * @param destPath destination location of the file\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFileToPod(String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5NTk0MA==", "bodyText": "I only see copyDirectoryFromPod in in actions/impl/primitive/Kubernetes.java.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440995940", "createdAt": "2020-06-16T16:45:49Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -674,4 +676,24 @@ public static V1PersistentVolumeClaimList listPersistentVolumeClaims(String name\n \n     return v1PersistentVolumeClaimList;\n   }\n+\n+  /**\n+   * Copy a file to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the file\n+   * @param destPath destination location of the file\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFileToPod(String namespace,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzI4MQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ2MTc4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo0MToxN1rOGkGS7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NjoyOFrOGks3bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTA3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefixe\n          \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefix", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505071", "createdAt": "2020-06-15T23:41:17Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzAwNA==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137004", "createdAt": "2020-06-16T20:56:28Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTA3MQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ2NzEwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo0NDoxM1rOGkGWVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1Njo0M1rOGks3-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk0Mg==", "bodyText": "do we need this check? Anyway its going to pull images since the kind clusters are thrown away after every test run.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505942", "createdAt": "2020-06-15T23:44:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzE0Ng==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137146", "createdAt": "2020-06-16T20:56:43Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk0Mg=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ4MTEzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo1MjowMlrOGkGe8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1Njo1NVrOGks4dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODE0Nw==", "bodyText": "You need to do a kind check here. Please refer to ItDomainInPV.java", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508147", "createdAt": "2020-06-15T23:52:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzI2OA==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137268", "createdAt": "2020-06-16T20:56:55Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODE0Nw=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ4MzE1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo1MzowNlrOGkGgOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NzowM1rOGks4rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODQ3NA==", "bodyText": "You need to check if it exists before creating it and create only for non kind cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508474", "createdAt": "2020-06-15T23:53:06Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzMyNQ==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137325", "createdAt": "2020-06-16T20:57:03Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODQ3NA=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDQ4NzM0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzo1NToyMFrOGkGivw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNjo1MTo1N1rOGkke9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwOTExOQ==", "bodyText": "creating services comes before deployment?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440509119", "createdAt": "2020-06-15T23:55:20Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5OTY2OA==", "bodyText": "You are right. Creating a Service before its corresponding backend workloads (Deployments) is a best practice even though in this case it doesn't cause any issue. I'm going to change it.\nThanks for pointing out this, Sankar.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440999668", "createdAt": "2020-06-16T16:51:57Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwOTExOQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDUyMDgxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDoxMzo0MFrOGkG3Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NzoxNVrOGks5GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDQwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {\n          \n          \n            \n                return Kubernetes.getPodLog(podName,namespace,null).contains(matchStr));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514402", "createdAt": "2020-06-16T00:13:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();\n+  }\n+\n+  private static boolean checkPodLogContains(String matchStr, String podName, String namespace)\n+      throws ApiException {\n+    if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzQzMw==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137433", "createdAt": "2020-06-16T20:57:15Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();\n+  }\n+\n+  private static boolean checkPodLogContains(String matchStr, String podName, String namespace)\n+      throws ApiException {\n+    if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDQwMg=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDUyMjAzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDoxNDoyNVrOGkG4IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NzoyMlrOGks5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDU5Mg==", "bodyText": "do a null check", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514592", "createdAt": "2020-06-16T00:14:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzUwNQ==", "bodyText": "Fixed.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137505", "createdAt": "2020-06-16T20:57:22Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDU5Mg=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 416}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDYyODY5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/helper-files/pwd.txt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMToxNjoxOFrOGkH58Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODo1NjozMFrOGlTL3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMTQ0MQ==", "bodyText": "Can u generate the file based on SYSPASSWORD variable instaed of hard-codding the password in a file", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440531441", "createdAt": "2020-06-16T01:16:18Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/helper-files/pwd.txt", "diffHunk": "@@ -0,0 +1,2 @@\n+Oradoc_db1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NDgzMQ==", "bodyText": "Chatted with Pani. Right now the dbping util also printed out the SYSPASSWORD which Pani filed a bug long time back.\nFiled the JIRA https://jira.****/jira/browse/OWLS-82793 to track the issue. Will come back to fix this after JRF domain creation is done.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441764831", "createdAt": "2020-06-17T18:56:30Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/resources/helper-files/pwd.txt", "diffHunk": "@@ -0,0 +1,2 @@\n+Oradoc_db1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMTQ0MQ=="}, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTUwMzcxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTozMjozOVrOGlLcVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNDoxM1rOGlSJww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzk3NA==", "bodyText": "It comes to here when createService failed without throwing exception.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441637974", "createdAt": "2020-06-17T15:32:39Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NzkwNw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441747907", "createdAt": "2020-06-17T18:34:13Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzk3NA=="}, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTUwNTY3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTozMzowOVrOGlLdjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNDoyOVrOGlSKVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODI4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n          \n          \n            \n                    \"Create service failed for oracleDBService in namespace %s \", dbNamespace));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441638286", "createdAt": "2020-06-17T15:33:09Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODA1Mg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748052", "createdAt": "2020-06-17T18:34:29Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODI4Ng=="}, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTUxNDY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTozNToyMlrOGlLjHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNDozOFrOGlSKog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTcxMA==", "bodyText": "same as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441639710", "createdAt": "2020-06-17T15:35:22Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1))\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(\"IfNotPresent\")\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODEzMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748130", "createdAt": "2020-06-17T18:34:38Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1))\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(\"IfNotPresent\")\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTcxMA=="}, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTU5MDM5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1Mzo1MlrOGlMTTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozNDo0N1rOGlSK-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1MjA0Nw==", "bodyText": "If DB connection fails after all the retries, its helpful to see the actual error its failing for ...can you cat dbping.err here to print out the actual error", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441652047", "createdAt": "2020-06-17T15:53:52Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODIxOQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748219", "createdAt": "2020-06-17T18:34:47Z", "author": {"login": "maggiehe00"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1MjA0Nw=="}, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4344, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}