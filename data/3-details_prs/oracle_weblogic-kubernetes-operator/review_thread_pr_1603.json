{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Nzg2MDQ0", "number": 1603, "reviewThreads": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDoyODo0NFrOD3OQHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1Mzo0MFrOD3clfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjMxNzc1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDoyODo0NFrOGNW48g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzowNzowOVrOGOImDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA==", "bodyText": "This is still synchronous by namespace, correct?  It will be curious to see how long clean-up takes.  Perhaps because clean-up happens for each test suite as that suite finishes, maybe this is parallel enough.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r416659698", "createdAt": "2020-04-28T14:28:44Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NjIyNw==", "bodyText": "Yes this is synchronous. But the delete operation on the artifacts in all namespaces(from single test class) is already called (line # 74) hopefully further iteration of the namespace won't wait long.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r416766227", "createdAt": "2020-04-28T16:46:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzU1Nw==", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023557", "createdAt": "2020-04-29T01:45:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzcwMw==", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023703", "createdAt": "2020-04-29T01:46:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3Mzg1Nw==", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...\n\nThere is already a 30 second wait(Thread.sleep)  before this right ? The pollDelay is for the initial delay to start polling every pollInterval seconds which is 10 seconds.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417473857", "createdAt": "2020-04-29T17:06:48Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NDA2Mw==", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point\n\nI changed it to 10 minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417474063", "createdAt": "2020-04-29T17:07:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzMTY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozMTo1MlrOGNs54w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMDozMlrOGOLWDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDM4Nw==", "bodyText": "the -> a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020387", "createdAt": "2020-04-29T01:31:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -242,18 +260,61 @@ public static boolean createDeployment(String deploymentYaml) {\n   }\n \n   /**\n-   * List all deployments in a given namespace.\n-   * @param namespace Namespace in which to list the deployments\n-   * @return V1DeploymentList of deployments in the Kubernetes cluster\n+   * List deployments in the given namespace.\n+   *\n+   * @param namespace namespace in which to list the deployments\n+   * @return list of deployment objects as {@link V1DeploymentList}\n+   * @throws ApiException when listing fails\n    */\n-  public static V1DeploymentList listDeployments(String namespace) {\n-    KubernetesApiResponse<V1DeploymentList> list = deploymentClient.list(namespace);\n-    if (list.isSuccess()) {\n-      return list.getObject();\n-    } else {\n-      logger.warning(\"Failed to list deployments, status code {0}\", list.getHttpStatusCode());\n-      return null;\n+  public static V1DeploymentList listDeployments(String namespace) throws ApiException {\n+    V1DeploymentList deployments;\n+    try {\n+      AppsV1Api apiInstance = new AppsV1Api(apiClient);\n+      deployments = apiInstance.listNamespacedDeployment(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n     }\n+    return deployments;\n+  }\n+\n+  /**\n+   * Delete the deployment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTExOA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519118", "createdAt": "2020-04-29T18:20:32Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -242,18 +260,61 @@ public static boolean createDeployment(String deploymentYaml) {\n   }\n \n   /**\n-   * List all deployments in a given namespace.\n-   * @param namespace Namespace in which to list the deployments\n-   * @return V1DeploymentList of deployments in the Kubernetes cluster\n+   * List deployments in the given namespace.\n+   *\n+   * @param namespace namespace in which to list the deployments\n+   * @return list of deployment objects as {@link V1DeploymentList}\n+   * @throws ApiException when listing fails\n    */\n-  public static V1DeploymentList listDeployments(String namespace) {\n-    KubernetesApiResponse<V1DeploymentList> list = deploymentClient.list(namespace);\n-    if (list.isSuccess()) {\n-      return list.getObject();\n-    } else {\n-      logger.warning(\"Failed to list deployments, status code {0}\", list.getHttpStatusCode());\n-      return null;\n+  public static V1DeploymentList listDeployments(String namespace) throws ApiException {\n+    V1DeploymentList deployments;\n+    try {\n+      AppsV1Api apiInstance = new AppsV1Api(apiClient);\n+      deployments = apiInstance.listNamespacedDeployment(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n     }\n+    return deployments;\n+  }\n+\n+  /**\n+   * Delete the deployment.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDM4Nw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzMjgyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozMjozOVrOGNs6kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwMzozNTowNFrOGPBPNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg==", "bodyText": "do we need to instantiate a class, can we not implement this as a static method?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020562", "createdAt": "2020-04-29T01:32:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1OTE2Mg==", "bodyText": "This is from the kubernetes client-java API library, we are not implementing this.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417459162", "createdAt": "2020-04-29T16:44:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwMjEwMg==", "bodyText": "ok, that's a shame :(", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r418402102", "createdAt": "2020-05-01T03:35:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzNTMyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNDozMFrOGNs8FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDozMlrOGOH7Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA==", "bodyText": "does this work? does it actually wait for the delete to complete and then return this?\nalso - this needs to be wrapped in a thread and run with a timeout -- you can create a JIRA to add that later, if you want to do it in a separate PR.\nas written, this will fail if a finalizer prevents the ns deletion from completing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020948", "createdAt": "2020-04-29T01:34:30Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -485,9 +580,16 @@ public static boolean deleteNamespace(String name) {\n     KubernetesApiResponse<V1Namespace> response = namespaceClient.delete(name);\n \n     if (!response.isSuccess()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MzEzMQ==", "bodyText": "This is not synchronous . As seen from the log message in the method.\n\"Received after-deletion status of the requested object, will be deleting namespace in background!\"\nWe issue the delete request and wait for it be deleted in the calling method.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417463131", "createdAt": "2020-04-29T16:50:32Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -485,9 +580,16 @@ public static boolean deleteNamespace(String name) {\n     KubernetesApiResponse<V1Namespace> response = namespaceClient.delete(name);\n \n     if (!response.isSuccess()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzNTk5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNTowNlrOGNs8fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MjoyNlrOGOIAdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ==", "bodyText": "finalizer can also prevent this from working - also needs to be run in a thread with a timeout", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021055", "createdAt": "2020-04-29T01:35:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -565,7 +667,7 @@ private static JsonElement convertToJson(Object obj) {\n    */\n   public static boolean deleteDomainCustomResource(String domainUid, String namespace) {\n \n-    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid);\n+    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid, deleteOptions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDQzNw==", "bodyText": "Again, this is not synchronous. Will be deleting the domain the background.\nThe calling method waits for it to be deleted.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464437", "createdAt": "2020-04-29T16:52:26Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -565,7 +667,7 @@ private static JsonElement convertToJson(Object obj) {\n    */\n   public static boolean deleteDomainCustomResource(String domainUid, String namespace) {\n \n-    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid);\n+    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid, deleteOptions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzNjIwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNToxOVrOGNs8qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MzowOVrOGOICZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng==", "bodyText": "thread/timeout", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021096", "createdAt": "2020-04-29T01:35:19Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -989,7 +1091,7 @@ public static boolean createPvc(V1PersistentVolumeClaim persistentVolumeClaim) t\n    */\n   public static boolean deletePv(String name) {\n \n-    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name);\n+    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name, deleteOptions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDkzMg==", "bodyText": "please see my similar comment.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464932", "createdAt": "2020-04-29T16:53:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -989,7 +1091,7 @@ public static boolean createPvc(V1PersistentVolumeClaim persistentVolumeClaim) t\n    */\n   public static boolean deletePv(String name) {\n \n-    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name);\n+    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name, deleteOptions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzNjgzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNTo1NVrOGNs9Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMDo1NFrOGOLW2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTIwMw==", "bodyText": "include the ns in the message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021203", "createdAt": "2020-04-29T01:35:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTMyMg==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519322", "createdAt": "2020-04-29T18:20:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTIwMw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzNzIwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNjowM1rOGNs9Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMTowMVrOGOLXKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTI1MA==", "bodyText": "delete a job", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021250", "createdAt": "2020-04-29T01:36:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTQwMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519400", "createdAt": "2020-04-29T18:21:01Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTI1MA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzODE0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNjoyNlrOGNs9tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMTowN1rOGOLXcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTM2Ng==", "bodyText": "...deletion of job fails", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021366", "createdAt": "2020-04-29T01:36:26Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTQ3Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519473", "createdAt": "2020-04-29T18:21:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTM2Ng=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzODg1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNjo0OVrOGNs-GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMToyOVrOGOLYVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA==", "bodyText": "delete a replica set", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021464", "createdAt": "2020-04-29T01:36:49Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTU1Mg==", "bodyText": "curious as to where we need this - i don't think we use any rs's?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021552", "createdAt": "2020-04-29T01:37:11Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTcwMA==", "bodyText": "[speriyat@speriyat-1 weblogic-kubernetes-operator]$ k get rs --all-namespaces | grep opns\ntwooptwodomain-opns-1   weblogic-operator-69fd5c765    1         1         1       54m\ntwooptwodomain-opns-3   weblogic-operator-6dbccd7b95   1         1         1       51m", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519700", "createdAt": "2020-04-29T18:21:29Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDYzOTk1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozNzo0MVrOGNs-vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMjoyNlrOGOLapg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTYzMQ==", "bodyText": "delete a role", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021631", "createdAt": "2020-04-29T01:37:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDI5NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520294", "createdAt": "2020-04-29T18:22:26Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTYzMQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MDU2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozODowNlrOGNs_Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MzozMVrOGOIDWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg==", "bodyText": "role or rolebinding? javadoc and code don't match", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021722", "createdAt": "2020-04-29T01:38:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NTE3OA==", "bodyText": "fixed it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417465178", "createdAt": "2020-04-29T16:53:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 519}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MDk5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozODoyM1rOGNs_XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMzoxNVrOGOLcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTc4OQ==", "bodyText": "namespace is one word", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021789", "createdAt": "2020-04-29T01:38:23Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDc2OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520768", "createdAt": "2020-04-29T18:23:15Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTc4OQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 540}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MTY5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozODo0OVrOGNs_uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMzoyNFrOGOLc4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTg4MA==", "bodyText": "a role\nrole or clusterrole? javadoc and code don't match", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021880", "createdAt": "2020-04-29T01:38:49Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 571}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDg2Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520867", "createdAt": "2020-04-29T18:23:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTg4MA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 571}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MjEzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozODo1OFrOGNs_8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyMzozMVrOGOLdJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTkzNg==", "bodyText": "was successful", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021936", "createdAt": "2020-04-29T01:38:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 574}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDkzNA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520934", "createdAt": "2020-04-29T18:23:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTkzNg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 574}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MjUyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozOToxNlrOGNtANA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNDowNVrOGOLeeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjAwNA==", "bodyText": "cluster roles", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022004", "createdAt": "2020-04-29T01:39:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTI3NA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521274", "createdAt": "2020-04-29T18:24:05Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjAwNA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 597}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0Mjc3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozOTozMVrOGNtAZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNDoxMlrOGOLe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjA1Mw==", "bodyText": "was", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022053", "createdAt": "2020-04-29T01:39:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 629}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTM2MA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521360", "createdAt": "2020-04-29T18:24:12Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjA1Mw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 629}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0MzUzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozOTo1NlrOGNtAzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNDozNFrOGOLftQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjE1OA==", "bodyText": "listNamespacesRoles plural", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022158", "createdAt": "2020-04-29T01:39:56Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 658}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTU4OQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521589", "createdAt": "2020-04-29T18:24:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjE1OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 658}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0Mzg4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MDoxMVrOGNtBCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNDo0MVrOGOLf_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjIxOA==", "bodyText": "list ingresses in the given namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022218", "createdAt": "2020-04-29T01:40:11Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTY2MQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521661", "createdAt": "2020-04-29T18:24:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjIxOA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 681}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NDE3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MDoyN1rOGNtBPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNToyMVrOGOLhYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI2OQ==", "bodyText": "listNamespacedIngresses", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022269", "createdAt": "2020-04-29T01:40:27Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 687}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjAxNw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522017", "createdAt": "2020-04-29T18:25:21Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI2OQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 687}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NDMzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MDo0MFrOGNtBWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNTozM1rOGOLh0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI5OQ==", "bodyText": "get ingress in the ....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022299", "createdAt": "2020-04-29T01:40:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 711}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjEzMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522130", "createdAt": "2020-04-29T18:25:33Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI5OQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 711}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NDgwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MDo1N1rOGNtBmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNTo0MVrOGOLiFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjM2Mw==", "bodyText": "name of the ingress - no such thing as an \"ingress extension\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022363", "createdAt": "2020-04-29T01:40:57Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 714}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjE5Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522196", "createdAt": "2020-04-29T18:25:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjM2Mw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 714}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NTE3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MTowNlrOGNtBzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNjoxNFrOGOLjUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQxNQ==", "bodyText": "Ingress object", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022415", "createdAt": "2020-04-29T01:41:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 715}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjUxNQ==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522515", "createdAt": "2020-04-29T18:26:14Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQxNQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 715}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NTQzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MToxNVrOGNtB8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNjoyMlrOGOLjpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQ1MA==", "bodyText": "getNamespacedIngress", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022450", "createdAt": "2020-04-29T01:41:15Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null\n+   * @throws ApiException when get fails\n+   */\n+  public static ExtensionsV1beta1Ingress getIngressExtension(String namespace, String name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 718}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjU5Ng==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522596", "createdAt": "2020-04-29T18:26:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null\n+   * @throws ApiException when get fails\n+   */\n+  public static ExtensionsV1beta1Ingress getIngressExtension(String namespace, String name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQ1MA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 718}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0NzUwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MjowN1rOGNtC9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNjo0MlrOGOLkdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjcxMQ==", "bodyText": "this is just for a single test right -- so this comment is wrong", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022711", "createdAt": "2020-04-29T01:42:07Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjgwNA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522804", "createdAt": "2020-04-29T18:26:42Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjcxMQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0ODI1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MjozNVrOGNtDYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyNjo1OFrOGOLlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjgxNw==", "bodyText": "for up to three minutes\n3 min is not long enough -these things can take longer,  try 10", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022817", "createdAt": "2020-04-29T01:42:35Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjk0OA==", "bodyText": "changed to 10 minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522948", "createdAt": "2020-04-29T18:26:58Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjgxNw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0ODk0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0MzowOVrOGNtDzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1NjowOVrOGOIKow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw==", "bodyText": "there could be a domain in the operator namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022927", "createdAt": "2020-04-29T01:43:09Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzA0Mw==", "bodyText": "Removed the namespace check to figure out if it is operator or domain anmespace and trying to delete domain and operator in all namespaces.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417467043", "createdAt": "2020-04-29T16:56:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY0OTY3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0Mzo0MVrOGNtERQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzowMjoyNVrOGOIadg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ==", "bodyText": "there could be an operator in any of these namespaces -- i don't think you need this isOperatorNamespace business", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023045", "createdAt": "2020-04-29T01:43:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3MTA5NA==", "bodyText": "see my above comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417471094", "createdAt": "2020-04-29T17:02:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1MTQ1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0NDo0MVrOGNtFPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozMDozNVrOGOLtPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ==", "bodyText": "try { \n  Thread.sleep(30 *1000);\n} catch (InterruptedException e) { \n  //ignore \n}", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023295", "createdAt": "2020-04-29T01:44:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzQwNw==", "bodyText": "also, why? :)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023407", "createdAt": "2020-04-29T01:45:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTA1Mw==", "bodyText": "Otherwise I need to put this wait in the pollDelay which will make it wait for every namespace. Since the delete on the namespaces was already called a one time wait is good enough.\nConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n.and().with().pollInterval(10, SECONDS)\n.atMost(10, MINUTES).await();", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525053", "createdAt": "2020-04-29T18:30:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1NjA1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0NzoxNVrOGNtHrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozMDo1MVrOGOLtwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkxOQ==", "bodyText": "what artifacts?  rename this to something like nothingFoundInNamespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023919", "createdAt": "2020-04-29T01:47:15Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTE4Ng==", "bodyText": "renamed it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525186", "createdAt": "2020-04-29T18:30:51Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkxOQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1NjQ0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0Nzo0MVrOGNtH9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozMDo1OVrOGOLuEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzk4OQ==", "bodyText": "delete all domains in the given namespace, if any exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023989", "createdAt": "2020-04-29T01:47:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTI2Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525267", "createdAt": "2020-04-29T18:30:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzk4OQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1Njg0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0Nzo1OVrOGNtIMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozMTozNFrOGOLvfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA==", "bodyText": "uninstall the operator", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024048", "createdAt": "2020-04-29T01:47:59Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDE2MQ==", "bodyText": "feels the the release name should be a param, or you should call this uninstallWebLogicOperators (plural)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024161", "createdAt": "2020-04-29T01:48:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTUyNg==", "bodyText": "changed the method name", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525526", "createdAt": "2020-04-29T18:31:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTYyOQ==", "bodyText": "uninstall the operator\n\nfixed it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525629", "createdAt": "2020-04-29T18:31:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1ODA3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0ODo1NFrOGNtI5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToyMzozNlrOGOuXiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDIzMA==", "bodyText": "this assumes (possibly incorrectly) that there is only one and that you know what its name is", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024230", "createdAt": "2020-04-29T01:48:54Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MjkzNg==", "bodyText": "changed the method name to uninstallWebLogicOperator.  It will uninstall whatever the TestConstants.OPERATOR_RELEASE_NAME set.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r418092936", "createdAt": "2020-04-30T15:23:36Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDIzMA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY1OTUyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0OToyOFrOGNtJoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODowMjo0MFrOGOKt1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw==", "bodyText": "unreliable and possibly useless anyway\nwould give wrong results if the pod was not running", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024417", "createdAt": "2020-04-29T01:49:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwODgyMw==", "bodyText": "removed it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417508823", "createdAt": "2020-04-29T18:02:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MDE1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo0OTo1NFrOGNtJ9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozMjowMFrOGOLwiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDUwMA==", "bodyText": "noArtifactsFound or something like that -- see earlier comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024500", "createdAt": "2020-04-29T01:49:54Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTg5Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525897", "createdAt": "2020-04-29T18:32:00Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDUwMA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MDQ4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MDowNlrOGNtKIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNDoyMlrOGOL2JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU0NQ==", "bodyText": ".. if no artifacts exist in ..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024545", "createdAt": "2020-04-29T01:50:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzMzMw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527333", "createdAt": "2020-04-29T18:34:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU0NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MDgzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MDoxN1rOGNtKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNDozM1rOGOL2oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU5NQ==", "bodyText": "doesNotExist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024595", "createdAt": "2020-04-29T01:50:17Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzQ1Nw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527457", "createdAt": "2020-04-29T18:34:33Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU5NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MTE5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MDozOVrOGNtKiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNDo0OVrOGOL3Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDY0OA==", "bodyText": "probably should list which artifacts...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024648", "createdAt": "2020-04-29T01:50:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzYxNA==", "bodyText": "added list in the log message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527614", "createdAt": "2020-04-29T18:34:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDY0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MTY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MDo1OVrOGNtKzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNDo1NlrOGOL3eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDcxOQ==", "bodyText": "check if any domains exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024719", "createdAt": "2020-04-29T01:50:59Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzY3Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527673", "createdAt": "2020-04-29T18:34:56Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDcxOQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2MjYzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MToyMFrOGNtLRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNToxMlrOGOL4DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDgzOA==", "bodyText": "check if any replica sets exist (and so on through the rest of this method)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024838", "createdAt": "2020-04-29T01:51:20Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzgyMA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527820", "createdAt": "2020-04-29T18:35:12Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDgzOA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2NDMzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1MjowN1rOGNtMKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODowNTozMFrOGOK0Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA==", "bodyText": "this won't work - the fact that you are looking through the namespace means it must exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025064", "createdAt": "2020-04-29T01:52:07Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMDQ1OQ==", "bodyText": "The intention of the method is to check if all the artifacts in the namespace was deleted and namespace itself deleted.\nWhen this check is made , the delete on the namespace was already called. So it is working, to tell whether the namespace exists or not.\nSince you asked to rename this method to nothingFoundInNamespace I cannot have this check for namespace here.\nMoved the namespace and namespace delete to separate methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417510459", "createdAt": "2020-04-29T18:05:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2NDk0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1Mjo0MFrOGNtMlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODowOTozM1rOGOK84w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA==", "bodyText": "i'd be stunned if this never threw an exception or failed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025174", "createdAt": "2020-04-29T01:52:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjY3NQ==", "bodyText": "I am catching the exceptions in each delete operation. If I don't catch it inside this method then this method will end prematurely if there is uncaught exceptions and the delete will be only partial.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417512675", "createdAt": "2020-04-29T18:09:33Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 384}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2NTM1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1Mjo1NVrOGNtM0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNTo1OVrOGOL5wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTIzNA==", "bodyText": ".. in the given ..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025234", "createdAt": "2020-04-29T01:52:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODI1OA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417528258", "createdAt": "2020-04-29T18:35:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTIzNA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 387}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDY2NjIwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1Mzo0MFrOGNtNYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODozNjozNVrOGOL7RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTM3Ng==", "bodyText": "probably should do deployments before pvcs, config maps, secrets, rs's, otherwise those could fail", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025376", "createdAt": "2020-04-29T01:53:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        Kubernetes.deleteDomainCustomResource(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete domains\");\n+    }\n+\n+    // Delete replicasets\n+    try {\n+      for (var item : Kubernetes.listReplicaSets(namespace).getItems()) {\n+        Kubernetes.deleteReplicaSet(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete replica sets\");\n+    }\n+\n+    // Delete jobs\n+    try {\n+      for (var item : Kubernetes.listJobs(namespace).getItems()) {\n+        Kubernetes.deleteJob(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete jobs\");\n+    }\n+\n+    // Delete configmaps\n+    try {\n+      for (var item : Kubernetes.listConfigMaps(namespace).getItems()) {\n+        Kubernetes.deleteConfigMap(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete config maps\");\n+    }\n+\n+    // Delete secrets\n+    try {\n+      for (var item : Kubernetes.listSecrets(namespace).getItems()) {\n+        Kubernetes.deleteSecret(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete secrets\");\n+    }\n+\n+    // Delete pv\n+    try {\n+      for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(item)\n+            .map(pvc -> pvc.getMetadata())\n+            .map(metadata -> metadata.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+        for (var pv : Kubernetes.listPersistentVolumes(\n+            String.format(\"weblogic.domainUid = %s\", label)).getItems()) {\n+          Kubernetes.deletePv(pv.getMetadata().getName());\n+        }\n+      }\n+    } catch (ApiException ex) {\n+      logger.warning(ex.getResponseBody());\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete persistent volumes\");\n+    }\n+\n+    // Delete deployments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODY0NA==", "bodyText": "moved the deployments delete above  pvcs, config maps, secrets, rs's,", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417528644", "createdAt": "2020-04-29T18:36:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        Kubernetes.deleteDomainCustomResource(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete domains\");\n+    }\n+\n+    // Delete replicasets\n+    try {\n+      for (var item : Kubernetes.listReplicaSets(namespace).getItems()) {\n+        Kubernetes.deleteReplicaSet(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete replica sets\");\n+    }\n+\n+    // Delete jobs\n+    try {\n+      for (var item : Kubernetes.listJobs(namespace).getItems()) {\n+        Kubernetes.deleteJob(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete jobs\");\n+    }\n+\n+    // Delete configmaps\n+    try {\n+      for (var item : Kubernetes.listConfigMaps(namespace).getItems()) {\n+        Kubernetes.deleteConfigMap(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete config maps\");\n+    }\n+\n+    // Delete secrets\n+    try {\n+      for (var item : Kubernetes.listSecrets(namespace).getItems()) {\n+        Kubernetes.deleteSecret(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete secrets\");\n+    }\n+\n+    // Delete pv\n+    try {\n+      for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(item)\n+            .map(pvc -> pvc.getMetadata())\n+            .map(metadata -> metadata.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+        for (var pv : Kubernetes.listPersistentVolumes(\n+            String.format(\"weblogic.domainUid = %s\", label)).getItems()) {\n+          Kubernetes.deletePv(pv.getMetadata().getName());\n+        }\n+      }\n+    } catch (ApiException ex) {\n+      logger.warning(ex.getResponseBody());\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete persistent volumes\");\n+    }\n+\n+    // Delete deployments", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTM3Ng=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 456}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4485, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}