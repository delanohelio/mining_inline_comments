{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4MzYxMzQx", "number": 1651, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDoxMTowOFrOD841KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowODoyNFrOD-Sh_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTcyMjY0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDoxMTowOFrOGWGiXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxODoxNVrOGY9qXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw==", "bodyText": "I could be wrong, but I suspect there may be multiple issues with this assertion, some of it functional, some of it due to incompleteness.  All of the following should be double checked with Ryan, Lenny, and Anthony:\n\n\nSeems to assume a single cluster and no non-clustered servers. Consequently, this test seems to assume that only one server can go down a time.  This is incorrect when there are multiple clusters, unmanaged servers, a replica count change, or a deleted cluster.\n\n\nSeems to dynamically obtain a list of servers when checking if only one server is 'down'.  IMO, it'd be better to get the list of servers at the beginning of a test before any changes are made to initiate the roll (otherwise, it won't catch if two servers in the cluster 'disappear' at the same time).  This 'original list' should be then compared to what's expected by the domain resource in terms of replicas, restartVersions, and image in order to determine the expected behavior for the roll.\n\n\nNote that this may get a little tricky when 'replicas' changes at the same time as everything else.  When replicas increases, the number of 'not ready' can be higher than 1 since the replicas are allowed to start in parallel.   When replicas decreases I assume (but am not sure) the roll is expected to defer terminating the servers until after it's completed the roll of the previous servers, and then only terminate them one at a time.   Similar issues may be seen when a cluster is deleted (the roll doesn't apply in that case I assume) or a new cluster is added (multiple servers can start at once).\n\n\nSeems to use 'Terminating' as a criteria when checking if a single server is down. For any particular domain it should check the admin server is ready - if not, then the admin server should be the only cycling server.  Then it should check that all other servers are 'ready' except one for their particular cluster as compared to the list of pods obtained at the beginning of the test (except in the case of varying replicas).\n\n\nDoes not seem to verify that admin server always is 'ahead' of other servers (first to roll and reach target state, and only one that should be down until this occurs)?\n\n\nDoes not verify that rolls are expected to occur 'in order' within a given cluster.\n\n\nAt the conclusion of the test, does not check if all servers have (a) reached their target domain/cluster/server restartVersion and (b) reached their target image.  (This should be done in addition to checking for  'ready' state.)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r425828957", "createdAt": "2020-05-15T14:11:08Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTI4OQ==", "bodyText": "Removed getting pods dynamically and instead the pod names are passed to the assertion method as a list. The assertion method will simply go through the list and verify its restarted in the sequence it is added in the list, at the same time verifies no other pods are restarted at the same time. verifying the restart version after rolling should be done in the test IMO.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427611289", "createdAt": "2020-05-19T21:29:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4ODE5Mw==", "bodyText": "verifying the restart version after rolling should be done in the test IMO.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428788193", "createdAt": "2020-05-21T17:04:03Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4OTI4Mw==", "bodyText": "Why? A \"proper\" restart version and image are required for every single roll.  They're essential for correct behavior.  So why not centrally ensure they match the domain resource's values for every roll?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428789283", "createdAt": "2020-05-21T17:05:59Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTQzNA==", "bodyText": "The requirement is to assert pods replacement doesn't exceed maxUnavailable at a time. We can create another assertion to ensure the integrity of the restartVersion and image.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428815434", "createdAt": "2020-05-21T17:53:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTI3OA==", "bodyText": "the 'spirit' of the requirement IMO, is to check that roll is working as designed from a customer perspective, this includes restart-version and image", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428829278", "createdAt": "2020-05-21T18:18:15Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MTI5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjo1NjoxMlrOGWd4BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0MTozN1rOGYSDUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw==", "bodyText": "up to ten minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211333", "createdAt": "2020-05-17T02:56:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQyNg==", "bodyText": "but your logic below seems to wait longer than ten minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211426", "createdAt": "2020-05-17T02:58:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDQzNQ==", "bodyText": "changed javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114435", "createdAt": "2020-05-20T15:41:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDc2OA==", "bodyText": "but your logic below seems to wait longer than ten minutes\n\nremoved old wait code", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114768", "createdAt": "2020-05-20T15:41:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MTU0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjo1NzowM1rOGWd4JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0MTo1MFrOGYSD-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTM2NQ==", "bodyText": "method name seems wrong, something like verifyRollingRestartOccurred maybe?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211365", "createdAt": "2020-05-17T02:57:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDkzNg==", "bodyText": "changed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114936", "createdAt": "2020-05-20T15:41:50Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTM2NQ=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MjMzOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjo1OToyMlrOGWd4iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0NDoyMlrOGYSK6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ2NA==", "bodyText": "something seems wrong here - what it you call this too late?\nseems like this needs to be some kind of \"watcher\" than can be started before you initiate the roll, and collect a future/promise/whatever from it afterwards/later", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211464", "createdAt": "2020-05-17T02:59:22Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNjcxMw==", "bodyText": "now the assertion method takes the list of pods to check for rolling restart from test and there is a requirement for using this assertion , it should be called right after the patching was done.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428116713", "createdAt": "2020-05-20T15:44:22Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ2NA=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MjQwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjo1OTo0NlrOGWd4kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0NDo0MVrOGYSLxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ3Mw==", "bodyText": "how do you know you found all of the expected pods? again, there is a timing issue here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211473", "createdAt": "2020-05-17T02:59:46Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNjkzMg==", "bodyText": "see above comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428116932", "createdAt": "2020-05-20T15:44:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ3Mw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MjkxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDoxOFrOGWd4yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0NzozMVrOGYST_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTUyOQ==", "bodyText": "check that all of the pods are in termination status in a set of concurrent threads", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211529", "createdAt": "2020-05-17T03:00:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTAzOQ==", "bodyText": "checking the pod termination status is now sequential according to the order of pods in the list. Also while checking for termination status of a  given pod , the method will check no other pods are terminating along with it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119039", "createdAt": "2020-05-20T15:47:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTUyOQ=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MzA2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMDozOVrOGWd42w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0ODowN1rOGYSVkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw==", "bodyText": "again, not sure this is a good idea when you are running under maven/failsafe plugin", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211547", "createdAt": "2020-05-17T03:00:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU5NA==", "bodyText": "you could just use the kubernetes get pods api and set watch = true .....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211594", "createdAt": "2020-05-17T03:01:29Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTQ0Mw==", "bodyText": "no concurrent checking now, its sequential", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119443", "createdAt": "2020-05-20T15:48:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MzYxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMjowM1rOGWd5Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0OTowN1rOGYSYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYxMA==", "bodyText": "do you need to wait for them to be ready, or just running?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211610", "createdAt": "2020-05-17T03:02:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDE2Nw==", "bodyText": "The refactored code will check the termination status and then the ready status", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428120167", "createdAt": "2020-05-20T15:49:07Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYxMA=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDI3MzgyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMzowMjo0MVrOGWd5Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0OTo1NFrOGYSaVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYzNQ==", "bodyText": "this will wait another ten minutes right?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211635", "createdAt": "2020-05-17T03:02:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDY2Mw==", "bodyText": "now its a standard  wait time of 5 minutes/pod", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428120663", "createdAt": "2020-05-20T15:49:54Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYzNQ=="}, "originalCommit": {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjE4OTA4OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo1Mjo1MFrOGXpokw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMzoxMlrOGYS_gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw==", "bodyText": "You assume the pods will be terminated in a specific order. This needs to match how operator does the termination.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427452563", "createdAt": "2020-05-19T16:52:50Z", "author": {"login": "xiancao"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTIzOA==", "bodyText": "It is up to the test provide the list of pods in a order for rolling restart", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428121238", "createdAt": "2020-05-20T15:50:44Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw=="}, "originalCommit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDE3Ng==", "bodyText": "The operator does roll the servers in sorted order.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428130176", "createdAt": "2020-05-20T16:03:12Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw=="}, "originalCommit": {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk5NzIyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozNjozOVrOGXxqSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToxMDoxNlrOGXyvuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NDA3NQ==", "bodyText": "print the pod names that are terminating", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427584075", "createdAt": "2020-05-19T20:36:39Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),\n+              String.format(\"pod %s didn't terminate in namespace %s\", pod, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, pod),\n+              String.format(\"pod %s is not ready in namespace %s\", pod, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating from the list of pods.\n+   *\n+   * @param pods names of the pods in a list\n+   * @param podName name of pod to check for termination status\n+   * @param namespace name of the namespace in which the pod terminating status to be checked\n+   * @return true if given pod is the only pod terminating\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  public static Callable<Boolean> onlyGivenPodTerminating(ArrayList<String> pods, String podName, String namespace)\n+      throws Exception {\n+    return () -> {\n+      int terminatingPods = 0;\n+      boolean givenPodTerminating = false;\n+      for (var pod : pods) {\n+        if (Kubernetes.isPodTerminating(namespace, null, pod)) {\n+          terminatingPods++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTg0OA==", "bodyText": "Its printed inside the Kubernetes.isPodTerminating method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427601848", "createdAt": "2020-05-19T21:10:16Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),\n+              String.format(\"pod %s didn't terminate in namespace %s\", pod, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, pod),\n+              String.format(\"pod %s is not ready in namespace %s\", pod, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating from the list of pods.\n+   *\n+   * @param pods names of the pods in a list\n+   * @param podName name of pod to check for termination status\n+   * @param namespace name of the namespace in which the pod terminating status to be checked\n+   * @return true if given pod is the only pod terminating\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  public static Callable<Boolean> onlyGivenPodTerminating(ArrayList<String> pods, String podName, String namespace)\n+      throws Exception {\n+    return () -> {\n+      int terminatingPods = 0;\n+      boolean givenPodTerminating = false;\n+      for (var pod : pods) {\n+        if (Kubernetes.isPodTerminating(namespace, null, pod)) {\n+          terminatingPods++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NDA3NQ=="}, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzAxNDk2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0MTo1NlrOGXx1cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo1MTowMVrOGYSdag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ==", "bodyText": "get the pods list before patching domain", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427586931", "createdAt": "2020-05-19T20:41:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -372,6 +374,16 @@ public void testCreateMiiConfigMapDomain() {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n+    ArrayList<String> pods = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMjc2Ng==", "bodyText": "moved it before patching", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427602766", "createdAt": "2020-05-19T21:12:01Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -372,6 +374,16 @@ public void testCreateMiiConfigMapDomain() {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n+    ArrayList<String> pods = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ=="}, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTQ1MA==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428121450", "createdAt": "2020-05-20T15:51:01Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -372,6 +374,16 @@ public void testCreateMiiConfigMapDomain() {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n+    ArrayList<String> pods = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ=="}, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzAzOTU5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0OTowM1rOGXyEjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToxMjo1MVrOGXy05Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDc5Ng==", "bodyText": "Check only one pod is restarted at a time in the same order as in the pods list ...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427590796", "createdAt": "2020-05-19T20:49:03Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMzE3Mw==", "bodyText": "fixed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427603173", "createdAt": "2020-05-19T21:12:51Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDc5Ng=="}, "originalCommit": {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjMzMzc0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo0Nzo1MFrOGYSUyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTozMjo0MVrOGYekaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw==", "bodyText": "I have a use case where I want to verify there I want to see the rolling restart should shutdown 2 servers simultaneously where the maxUnavailable attribute is set to 2.  In this case what will be my pod list?  Say I have 1 admin and 3 managed servers ( ms1,ms2, and ms3 ) Here  I should see ms1 and ms2 can both go to terminating state simultaneously while ms3 will be re-stated after both ms1 and ms2 are up", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119243", "createdAt": "2020-05-20T15:47:50Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNTA3NQ==", "bodyText": "According to the JIRA only one server can restart at a time.\nhttps://jira.****/jira/browse/OWLS-81478\nIf 2 servers can go down at the same time then how can it be a rolling restart?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428125075", "createdAt": "2020-05-20T15:56:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTQ4MA==", "bodyText": "We have a field that controls how many servers can be down at the same time -- it's maxUnavailable. The default value is 1.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428129480", "createdAt": "2020-05-20T16:02:14Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTgwNw==", "bodyText": "This was added for customers with larger clusters who want to improve the time to roll the entire cluster.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428129807", "createdAt": "2020-05-20T16:02:43Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDAxMw==", "bodyText": "Yes, still, it is a rolling re-start as long as the cluster service is available. The maxUnavailable attribute is designed for this purpose. It can be any non-zero value less than the replica.  See the reference page\nhttps://github.com/oracle/weblogic-kubernetes-operator/blob/master/docs/domains/Domain.md", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428130013", "createdAt": "2020-05-20T16:02:59Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxOTg0OA==", "bodyText": "now checking the max number of pods that can restart concurrently to be not more than maxUnavailable.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428319848", "createdAt": "2020-05-20T21:32:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM4MDAxOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTo1ODo1N1rOGYSziA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTozMzo1MlrOGYemTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzExMg==", "bodyText": "Type of argument can just be List", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428127112", "createdAt": "2020-05-20T15:58:57Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -157,9 +160,20 @@\n    * @return true if the pod is terminating otherwise false\n    */\n   public static Callable<Boolean> podTerminating(String podName, String domainUid, String namespace) {\n-    return () -> Kubernetes.isPodTerminating(namespace, domainUid, podName);\n+    return Pod.podTerminating(namespace, domainUid, podName);\n   }\n \n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMDMzNA==", "bodyText": "Now the argument is a Map with podnames and its creation time stamps.\nThe test will create a LinkedHashMap and add all the pods with its creation time stamps.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428320334", "createdAt": "2020-05-20T21:33:52Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -157,9 +160,20 @@\n    * @return true if the pod is terminating otherwise false\n    */\n   public static Callable<Boolean> podTerminating(String podName, String domainUid, String namespace) {\n-    return () -> Kubernetes.isPodTerminating(namespace, domainUid, podName);\n+    return Pod.podTerminating(namespace, domainUid, podName);\n   }\n \n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzExMg=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM4OTQwOnYy", "diffSide": "LEFT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMToxMVrOGYS5zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTozNDozNFrOGYenZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODcxOA==", "bodyText": "As an alternative, you can check that the pod's metadata.deletionTimestamp is set. If this field has a value, then the pod has been marked for deletion. It will either then be in it's terminating phase or soon will be.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428128718", "createdAt": "2020-05-20T16:01:11Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -154,27 +153,30 @@ public static boolean isPodReady(String namespace, String domainUid, String podN\n   }\n \n   /**\n-   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * Check if a pod exists in a given namespace and is terminating.\n    * @param namespace in which to check for the pod\n    * @param domainUid the label the pod is decorated with\n    * @param podName name of the pod to check for\n-   * @return true if pod is in Terminating state otherwise false\n+   * @return true if pod is terminating otherwise false\n    * @throws ApiException when there is error in querying the cluster\n    */\n-  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMDYxNA==", "bodyText": "Yes, the new implementation uses pod deletion timestamp.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428320614", "createdAt": "2020-05-20T21:34:34Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -154,27 +153,30 @@ public static boolean isPodReady(String namespace, String domainUid, String podN\n   }\n \n   /**\n-   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * Check if a pod exists in a given namespace and is terminating.\n    * @param namespace in which to check for the pod\n    * @param domainUid the label the pod is decorated with\n    * @param podName name of the pod to check for\n-   * @return true if pod is in Terminating state otherwise false\n+   * @return true if pod is terminating otherwise false\n    * @throws ApiException when there is error in querying the cluster\n    */\n-  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODcxOA=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQxMDM5OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowNjoxNlrOGYTHhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTozNjowNlrOGYeqXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ==", "bodyText": "On this statement: \"This assertion method needs to be called right after the domain is patched to ensure it doesn't miss any of the pods restart.\"...  This seems likely to intermittently fail. I think it would be better to collect the current V1PodList in advance of starting the roll and using that as the input.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428132231", "createdAt": "2020-05-20T16:06:16Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzOTE1NQ==", "bodyText": "+1 to that", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428139155", "createdAt": "2020-05-20T16:16:42Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMTM3Mg==", "bodyText": "The test supplies the list of pods with its creation timestamps(created before the patching).", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428321372", "createdAt": "2020-05-20T21:36:06Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQxOTE3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowODoyNFrOGYTNBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzozNTowNFrOGYhYwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMzYzNg==", "bodyText": "Not sure if I've read this correctly, but even though WebLogic terminates and restarts slowly, I'd like the code to be defensive to the condition that you missed detecting the termination. It would be enough to find that the \"new\" Pod has a creation timestamp later than when the roll started.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428133636", "createdAt": "2020-05-20T16:08:24Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2NjAxNw==", "bodyText": "The new implementation will compare creation time stamps to determine the pods replacement status.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428366017", "createdAt": "2020-05-20T23:35:04Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMzYzNg=="}, "originalCommit": {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4563, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}