{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0ODM5Mjg2", "number": 1737, "title": "JUnit5 JRF tests infra: DB startup and RCU schema creation", "bodyText": "After addressing  Sanker's comments,  Single cluster 10 passed at:\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests-10/381/\nFull test suite passed with 1 other test failure:\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests-10/384/\nsingle kind cluster passed at:\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/416/\nFull test suite passed with 1 other test failure:\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/415/", "createdAt": "2020-06-15T22:01:10Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737", "merged": true, "mergeCommit": {"oid": "fa8802947db50ea15901787912256947b3c0bc52"}, "closed": true, "closedAt": "2020-06-19T18:42:16Z", "author": {"login": "maggiehe00"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpUzbTgH2gAyNDM0ODM5Mjg2Ojg0MzFmZTY2NzAxYjE2ZWY2OTkwODc3YTUwZGQwOGE3MzJkMzY0ODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcs3i4tAH2gAyNDM0ODM5Mjg2Ojg1NzE0ZmI2OWYzYmY2YTEyMTA2Y2UzZjJlZjU5ODU4ODRmM2ZlMGI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8431fe66701b16ef6990877a50dd08a732d36483", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8431fe66701b16ef6990877a50dd08a732d36483", "committedDate": "2020-06-08T18:31:15Z", "message": "first cut for junit5 JRF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dc8de3be05fb8e3f358dc5ac28dbba0302b93c7", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0dc8de3be05fb8e3f358dc5ac28dbba0302b93c7", "committedDate": "2020-06-10T21:01:48Z", "message": "first working version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dde26beb1135bebe0382d97807349dcdc85dabf", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3dde26beb1135bebe0382d97807349dcdc85dabf", "committedDate": "2020-06-11T14:14:54Z", "message": "add the missing files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac18848d688a50219d80d758a6429fc93056c696", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ac18848d688a50219d80d758a6429fc93056c696", "committedDate": "2020-06-11T21:09:22Z", "message": "fix SSL connection closed issue and Kind image pull issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8ad23e518f9460b24f32d6913b5ab571e27b879", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f8ad23e518f9460b24f32d6913b5ab571e27b879", "committedDate": "2020-06-12T02:14:27Z", "message": "increase retry time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66151869f9ecec705fb35a2fd4a9f15bec75ed7a", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/66151869f9ecec705fb35a2fd4a9f15bec75ed7a", "committedDate": "2020-06-12T16:02:22Z", "message": "ignore SSLProtocolException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1962c85a2e1b1a1ec6d5c6b6bb8e4b781e423bf", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d1962c85a2e1b1a1ec6d5c6b6bb8e4b781e423bf", "committedDate": "2020-06-12T18:02:25Z", "message": "minor change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d3cee06b6539bdef3ef6aea3aaa75227e4e741d", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2d3cee06b6539bdef3ef6aea3aaa75227e4e741d", "committedDate": "2020-06-12T20:59:56Z", "message": "merge to the latest devlop branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b938abd359aa3d42b62dc71f546b2ec3285fc07e", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b938abd359aa3d42b62dc71f546b2ec3285fc07e", "committedDate": "2020-06-15T20:53:41Z", "message": "cleanup the code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "553d1701be4ec7ef7870eaf9d823d7e8cfac065a", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/553d1701be4ec7ef7870eaf9d823d7e8cfac065a", "committedDate": "2020-06-15T21:42:44Z", "message": "minor cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "committedDate": "2020-06-15T21:47:39Z", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDU5OTE4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-431059918", "createdAt": "2020-06-15T23:30:17Z", "commit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMDoxN1rOGkGFkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMDoxN1rOGkGFkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMTY1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Start DB service and create RCU schema\n          \n          \n            \n               * Start DB service and create RCU schema.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440501651", "createdAt": "2020-06-15T23:30:17Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDYwNzgw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-431060780", "createdAt": "2020-06-15T23:32:40Z", "commit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMzozMjo0MFrOGkGIaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMDoxNDoyNVrOGkG4IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjM3Ng==", "bodyText": "use static imports for OCR_REGISTRY", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502376", "createdAt": "2020-06-15T23:32:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjQxNA==", "bodyText": "same", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502414", "createdAt": "2020-06-15T23:32:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjg4Nw==", "bodyText": "does this work?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502887", "createdAt": "2020-06-15T23:34:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -130,6 +130,10 @@\n     try {\n       Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n       apiClient = Configuration.getDefaultApiClient();\n+      // disable connection and read timeout to force the internal HTTP client\n+      // to keep a long running connection with the server to fix SSL connection closed issue\n+      apiClient.setConnectTimeout(0);\n+      apiClient.setReadTimeout(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzI4MQ==", "bodyText": "I believe this method is available in actions/impl/primitive/Kubernetes.java\nyou can use that instead of duplicating it here.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440503281", "createdAt": "2020-06-15T23:35:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -674,4 +676,24 @@ public static V1PersistentVolumeClaimList listPersistentVolumeClaims(String name\n \n     return v1PersistentVolumeClaimList;\n   }\n+\n+  /**\n+   * Copy a file to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the file\n+   * @param destPath destination location of the file\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFileToPod(String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTA3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefixe\n          \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefix", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505071", "createdAt": "2020-06-15T23:41:17Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk0Mg==", "bodyText": "do we need this check? Anyway its going to pull images since the kind clusters are thrown away after every test run.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505942", "createdAt": "2020-06-15T23:44:13Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODE0Nw==", "bodyText": "You need to do a kind check here. Please refer to ItDomainInPV.java", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508147", "createdAt": "2020-06-15T23:52:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODQ3NA==", "bodyText": "You need to check if it exists before creating it and create only for non kind cluster", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508474", "createdAt": "2020-06-15T23:53:06Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwOTExOQ==", "bodyText": "creating services comes before deployment?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440509119", "createdAt": "2020-06-15T23:55:20Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDQwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {\n          \n          \n            \n                return Kubernetes.getPodLog(podName,namespace,null).contains(matchStr));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514402", "createdAt": "2020-06-16T00:13:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();\n+  }\n+\n+  private static boolean checkPodLogContains(String matchStr, String podName, String namespace)\n+      throws ApiException {\n+    if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDU5Mg==", "bodyText": "do a null check", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514592", "createdAt": "2020-06-16T00:14:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 416}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bc96a8cfe106880530cf0607d3e435b110fd127", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3bc96a8cfe106880530cf0607d3e435b110fd127", "committedDate": "2020-06-16T20:51:29Z", "message": "address the review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "committedDate": "2020-06-17T15:22:00Z", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTI1MTkz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-432525193", "createdAt": "2020-06-17T15:32:39Z", "commit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTozMjozOVrOGlLcVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1Mzo1MlrOGlMTTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzk3NA==", "bodyText": "It comes to here when createService failed without throwing exception.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441637974", "createdAt": "2020-06-17T15:32:39Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODI4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n          \n          \n            \n                    \"Create service failed for oracleDBService in namespace %s \", dbNamespace));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441638286", "createdAt": "2020-06-17T15:33:09Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTcxMA==", "bodyText": "same as above", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441639710", "createdAt": "2020-06-17T15:35:22Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1))\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(\"IfNotPresent\")\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1MjA0Nw==", "bodyText": "If DB connection fails after all the retries, its helpful to see the actual error its failing for ...can you cat dbping.err here to print out the actual error", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441652047", "createdAt": "2020-06-17T15:53:52Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDI5NjUz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-431029653", "createdAt": "2020-06-15T22:13:17Z", "commit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMjoxMzoxN1rOGkEh6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMToxNjoxOFrOGkH58Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3NjEzNw==", "bodyText": "Change the method name to reflect the JRF domain  e.g. testJrfDomainInPvusingWlst()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476137", "createdAt": "2020-06-15T22:13:17Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + JRF_BASE_IMAGE_TAG : JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG);\n+    logger.info(\"For ItJrfDomainInPV using DB image: {0}, FMW image {1}\", dbImage, fmwImage);\n+\n+  }\n+\n+  /**\n+   * Create a JRF domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   */\n+  @Test\n+  @DisplayName(\"Create JRF domain in PV using WLST script\")\n+  public void testDomainInPvUsingWlst() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3Njc4OQ==", "bodyText": "Remove TODO comment, if resolved", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476789", "createdAt": "2020-06-15T22:14:51Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODIyMg==", "bodyText": "Should be 2020,  instead of 2019, 2020,", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440478222", "createdAt": "2020-06-15T22:18:41Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3ODQxMQ==", "bodyText": "Remove commented code", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440478411", "createdAt": "2020-06-15T22:19:13Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/bash-scripts/createRepository.sh", "diffHunk": "@@ -0,0 +1,72 @@\n+#!/bin/bash\n+# Copyright (c) 2019, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+. /u01/oracle/wlserver/server/bin/setWLSEnv.sh\n+\n+echo \"Check if the DB Service is ready to accept request \"\n+connectString=${1:-oracle-db.default.svc.cluster.local:1521/devpdb.k8s}\n+schemaPrefix=${2:-domain1}\n+rcuType=${3:-fmw}\n+sysPassword=${4:-Oradoc_db1}\n+\n+echo \"DB Connection String [$connectString], schemaPrefix [${schemaPrefix}] rcuType [${rcuType}]\"\n+\n+max=100\n+counter=0\n+while [ $counter -le ${max} ]\n+do\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString} > dbping.err 2>&1\n+ [[ $? == 0 ]] && break;\n+ ((counter++))\n+ echo \"[$counter/${max}] Retrying the DB Connection ...\"\n+ sleep 10\n+done\n+\n+if [ $counter -gt ${max} ]; then\n+ echo \"[ERROR] Oracle DB Service is not ready after [${max}] iterations ...\"\n+ exit -1\n+else\n+ java utils.dbping ORACLE_THIN \"sys as sysdba\" ${sysPassword} ${connectString}\n+fi\n+\n+# SOA needs extra component(s) SOAINFRA ESS (optional)\n+# SOA needs variables param(s) SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\n+\n+case $rcuType in\n+ fmw)\n+   extComponents=\"\"\n+   extVariables=\"\"\n+   echo \"Creating RCU Schema for FMW Domain ...\"\n+   ;;\n+ soa|soaosb|osb)\n+   extComponents=\"-component SOAINFRA\"\n+   extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+   echo \"Creating RCU Schema for SOA Domain [$rcuType] ...\"\n+   ;;\n+ soaess|soaessosb)\n+    extComponents=\"-component SOAINFRA -component ESS\"\n+    extVariables=\"-variables SOA_PROFILE_TYPE=SMALL,HEALTHCARE_INTEGRATION=NO\"\n+    echo \"Creating RCU Schema for SOA Domain w/ESS [$rcuType] ...\"\n+  ;;\n+  * )\n+    echo \"[ERROR] Unknown RCU Schema Type [$rcuType]\"\n+    echo \"Supported values: fmw(default),soa,osb,soaosb,soaess,soaessosb\"\n+    exit -1\n+  ;;\n+esac\n+\n+echo \"Extra RCU Schema Component Choosen[${extComponents}]\" \n+echo \"Extra RCU Schema Variable Choosen[${extVariables}]\" \n+\n+#Debug ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3OTA1Mw==", "bodyText": "Remove extra space between words", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440479053", "createdAt": "2020-06-15T22:21:01Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMTQ0MQ==", "bodyText": "Can u generate the file based on SYSPASSWORD variable instaed of hard-codding the password in a file", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440531441", "createdAt": "2020-06-16T01:16:18Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/resources/helper-files/pwd.txt", "diffHunk": "@@ -0,0 +1,2 @@\n+Oradoc_db1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33bdbc27bd7eef51be1932b67d7e30adcde450ee", "author": {"user": {"login": "maggiehe00", "name": "Maggie He"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/33bdbc27bd7eef51be1932b67d7e30adcde450ee", "committedDate": "2020-06-17T18:32:29Z", "message": "addressed more review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzM5MDk4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-432739098", "createdAt": "2020-06-17T20:12:48Z", "commit": {"oid": "33bdbc27bd7eef51be1932b67d7e30adcde450ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzcxMDU3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-432771057", "createdAt": "2020-06-17T20:57:56Z", "commit": {"oid": "33bdbc27bd7eef51be1932b67d7e30adcde450ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzYwNTA5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#pullrequestreview-433360509", "createdAt": "2020-06-18T14:47:20Z", "commit": {"oid": "33bdbc27bd7eef51be1932b67d7e30adcde450ee"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85714fb69f3bf6a12106ce3f2ef5985884f3fe0b", "author": {"user": {"login": "rjeberhard", "name": "Ryan Eberhard"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/85714fb69f3bf6a12106ce3f2ef5985884f3fe0b", "committedDate": "2020-06-19T18:41:38Z", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4539, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}