{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTAyNTUx", "number": 2027, "title": "Detect and shut down stuck server pods", "bodyText": "This code looks for stuck pods, which is detects by comparing the current time with any deleted time stamp, allowing for the specified grace period. If any pods managed by the operator is terminated, but are still present after the grace period, the operator will force-delete them and run a new make-right on their domain(s).\nNote: we need to do some code cleanup on the async calls. Adding new parameters to be checked by unit tests is increasingly difficult. It is time to introduce an object rather than passing in a list (see Clean Code, chapter 3, regarding function parameters).", "createdAt": "2020-11-04T02:58:18Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027", "merged": true, "mergeCommit": {"oid": "fe2df155ff0805f78ad214f2ffdbf1f6d967005d"}, "closed": true, "closedAt": "2020-11-04T18:40:35Z", "author": {"login": "russgold"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZDg1JgH2gAyNTE1MTAyNTUxOmM5ZjBjZmQ2MDhhODdmN2ZhOWQ4MDRiZjRjMGRhNWViMzc1NGViZDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZQkzGgFqTUyMzU0MzY4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c9f0cfd608a87f7fa9d804bf4c0da5eb3754ebd5", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c9f0cfd608a87f7fa9d804bf4c0da5eb3754ebd5", "committedDate": "2020-11-04T01:30:55Z", "message": "Detect and shut down stuck server pods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9c6b2c34734f351305eab2cf27558e6c2827a116", "committedDate": "2020-11-04T02:52:00Z", "message": "Send 0 grace period seconds to force delete"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMjkxNTE4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#pullrequestreview-523291518", "createdAt": "2020-11-04T11:54:28Z", "commit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo1NDoyOFrOHtU7jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMTo1NDoyOFrOHtU7jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5MDg5Mw==", "bodyText": "No issue... Reminder to myself to verify if 1 is the proper default for deletionGracePeriodSeconds if not set. I had thought that it defaulted to 30 seconds.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517290893", "createdAt": "2020-11-04T11:54:28Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMjk1OTcz", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#pullrequestreview-523295973", "createdAt": "2020-11-04T12:00:23Z", "commit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowMDoyM1rOHtVH4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowMDoyM1rOHtVH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5NDA1MA==", "bodyText": "I'd like to make sure that we've thought through and verified the concurrency here. While we don't want to depend on watches, it's very likely that the deletion of a pod will trigger our pod watcher. The pod watcher would start a make-right for the associated domain.\nThat seems right. This flow here (reading existing resources) will generate \"recheck\" make-right calls, which won't interrupt a make-right flow for the given domain that may have been started because of the watch event following the deletion.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517294050", "createdAt": "2020-11-04T12:00:23Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);\n+    }\n+\n+    private DateTime getDeletionTimeStamp(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionTimestamp).orElse(SystemClock.now());\n+    }\n+\n+    private void addStuckPodToPacket(Packet packet, V1Pod stuckPod) {\n+      getStuckPodList(packet).add(stuckPod);\n+    }\n+  }\n+\n+  class PodActionsStep extends Step {\n+\n+    private final String namespace;\n+\n+    public PodActionsStep(String namespace) {\n+      this.namespace = namespace;\n+    }\n+\n+    @Override\n+    public NextAction apply(Packet packet) {\n+      final List<V1Pod> stuckPodList = getStuckPodList(packet);\n+      if (stuckPodList.isEmpty()) {\n+        return doNext(packet);\n+      } else {\n+        Collection<StepAndPacket> startDetails = new ArrayList<>();\n+\n+        for (V1Pod pod : stuckPodList) {\n+          startDetails.add(new StepAndPacket(createForcedDeletePodStep(pod), packet.clone()));\n+        }\n+        return doForkJoin(readExistingNamespaces(), packet, startDetails);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzAwOTY5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#pullrequestreview-523300969", "createdAt": "2020-11-04T12:08:07Z", "commit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowODowN1rOHtVW5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjowODowN1rOHtVW5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5Nzg5NA==", "bodyText": "Does the DefaultResponseStep include typical retry behavior? We still have that issue where a delete will periodically fail because Kubernetes returns a V1Status rather than a V1Pod.\nThat's actually a little scary because this code might retry and accidentally interleave with make-right code triggered by the pod watcher that has already created a new pod.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517297894", "createdAt": "2020-11-04T12:08:07Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);\n+    }\n+\n+    private DateTime getExpectedDeleteTime(V1Pod pod) {\n+      return getDeletionTimeStamp(pod).plusSeconds((int) getDeletionGracePeriodSeconds(pod));\n+    }\n+\n+    private long getDeletionGracePeriodSeconds(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionGracePeriodSeconds).orElse(1L);\n+    }\n+\n+    private DateTime getDeletionTimeStamp(V1Pod pod) {\n+      return Optional.of(pod).map(V1Pod::getMetadata).map(V1ObjectMeta::getDeletionTimestamp).orElse(SystemClock.now());\n+    }\n+\n+    private void addStuckPodToPacket(Packet packet, V1Pod stuckPod) {\n+      getStuckPodList(packet).add(stuckPod);\n+    }\n+  }\n+\n+  class PodActionsStep extends Step {\n+\n+    private final String namespace;\n+\n+    public PodActionsStep(String namespace) {\n+      this.namespace = namespace;\n+    }\n+\n+    @Override\n+    public NextAction apply(Packet packet) {\n+      final List<V1Pod> stuckPodList = getStuckPodList(packet);\n+      if (stuckPodList.isEmpty()) {\n+        return doNext(packet);\n+      } else {\n+        Collection<StepAndPacket> startDetails = new ArrayList<>();\n+\n+        for (V1Pod pod : stuckPodList) {\n+          startDetails.add(new StepAndPacket(createForcedDeletePodStep(pod), packet.clone()));\n+        }\n+        return doForkJoin(readExistingNamespaces(), packet, startDetails);\n+      }\n+    }\n+\n+    @Nonnull\n+    private Step readExistingNamespaces() {\n+      return mainDelegate.getDomainNamespaces().readExistingResources(namespace, mainDelegate.getDomainProcessor());\n+    }\n+\n+    private Step createForcedDeletePodStep(V1Pod pod) {\n+      return new CallBuilder()\n+            .withGracePeriodSeconds(0)\n+            .deletePodAsync(getName(pod), getNamespace(pod), getDomainUid(pod), null, new DefaultResponseStep<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzU5Mjkw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#pullrequestreview-523359290", "createdAt": "2020-11-04T13:29:30Z", "commit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOHtYETw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOHtYETw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI4Nw==", "bodyText": "The stuck check potentially involves two different machine clocks that might be out of sync - the operator's and the pod's. I just did some brief research, and it looks like k8s doesn't require strict clock synchronization although it's considered desirable (in addition, WL clusters have fairly tight needs).\nShould there be an additional grace after a detecting a potentially stuck delete in order to give K8S time to 'naturally' honor its timeout and perhaps to help account for a 'small' amount of potential clock drift?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#discussion_r517342287", "createdAt": "2020-11-04T13:29:30Z", "author": {"login": "tbarnes-us"}, "path": "operator/src/main/java/oracle/kubernetes/operator/StuckPodProcessing.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.annotation.Nonnull;\n+\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.kubernetes.operator.calls.CallResponse;\n+import oracle.kubernetes.operator.helpers.CallBuilder;\n+import oracle.kubernetes.operator.helpers.PodHelper;\n+import oracle.kubernetes.operator.steps.DefaultResponseStep;\n+import oracle.kubernetes.operator.work.NextAction;\n+import oracle.kubernetes.operator.work.Packet;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.utils.SystemClock;\n+import org.joda.time.DateTime;\n+\n+public class StuckPodProcessing {\n+\n+\n+  private final MainDelegate mainDelegate;\n+\n+  public StuckPodProcessing(MainDelegate mainDelegate) {\n+    this.mainDelegate = mainDelegate;\n+  }\n+\n+  void checkStuckPods(String namespace) {\n+    Step step = new CallBuilder()\n+          .withLabelSelectors(LabelConstants.getCreatedbyOperatorSelector())\n+          .listPodAsync(namespace, new PodListProcessing(namespace, SystemClock.now()));\n+    mainDelegate.runSteps(step);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private List<V1Pod> getStuckPodList(Packet packet) {\n+    return (List<V1Pod>) packet.computeIfAbsent(\"STUCK_PODS\", k -> new ArrayList<>());\n+  }\n+\n+  class PodListProcessing extends DefaultResponseStep<V1PodList> {\n+\n+    private final DateTime now;\n+\n+    public PodListProcessing(String namespace, DateTime dateTime) {\n+      super(new PodActionsStep(namespace));\n+      now = dateTime;\n+    }\n+\n+    @Override\n+    public NextAction onSuccess(Packet packet, CallResponse<V1PodList> callResponse) {\n+      callResponse.getResult().getItems().stream()\n+            .filter(pod -> isStuck(pod, now))\n+            .forEach(pod -> addStuckPodToPacket(packet, pod));\n+      \n+      return doContinueListOrNext(callResponse, packet);\n+    }\n+\n+    private boolean isStuck(V1Pod pod, DateTime now)  {\n+      return getExpectedDeleteTime(pod).isBefore(now);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2c34734f351305eab2cf27558e6c2827a116"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c35e8f51d1b649161995340787c8973941e6dd75", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c35e8f51d1b649161995340787c8973941e6dd75", "committedDate": "2020-11-04T15:57:16Z", "message": "Log message after deleting stuck pod"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTQzNjg3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2027#pullrequestreview-523543687", "createdAt": "2020-11-04T16:44:01Z", "commit": {"oid": "c35e8f51d1b649161995340787c8973941e6dd75"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4075, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}