{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyODU4MjYx", "number": 1725, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDoyNzowMVrOEEtVlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDo1NTo0OFrOEEuFaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzcyNTY2OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDoyNzowMVrOGif5Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzoyNDoyOVrOGinS2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzI4Ng==", "bodyText": "Another possible reason is that the response contained unexpected content (did not contain ServerName/Bound).  It'd be helpful to accumulate an 'error' string that contains 'unexpected' responses (e.g. does not contain at least ServerName of one of the servers), and dump the String here on a failure.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438827286", "createdAt": "2020-06-11T14:27:01Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -88,6 +89,66 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n     return false;\n   }\n \n+  /**\n+   * Call the curl command and check the managed servers can see each other.\n+   *\n+   * @param curlCmd curl command to call the clusterview app\n+   * @param managedServerNames managed server names that should be see other\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the managed servers can see each other, false otherwise\n+   */\n+  public static boolean verifyClusterMemberCommunication(\n+      String curlCmd,\n+      List<String> managedServerNames,\n+      int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName\n+        -> managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling clusterview at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    ExecResult result = null;\n+    for (int i = 0; i < maxIterations; i++) {\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          TimeUnit.MILLISECONDS.sleep(100);\n+          result = ExecCommand.exec(curlCmd, true);\n+          String response = result.stdout().trim();\n+          for (var entry : managedServers.entrySet()) {\n+            if (response.contains(\"ServerName:\" + entry.getKey())) {\n+              boolean bound = true;\n+              for (String managedServerName : managedServerNames) {\n+                bound = bound && response.contains(\"Bound:\" + managedServerName);\n+              }\n+              if (bound) {\n+                managedServers.put(entry.getKey(), true);\n+              }\n+            }\n+          }\n+        } catch (IOException | InterruptedException e) {\n+          logger.info(e.toString());\n+          return false;\n+        }\n+      } else {\n+        return true;\n+      }\n+    }\n+    // after the max iterations, if hit here, one or more servers cannot see other\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The server {0} can see other cluster members\", key);\n+      } else {\n+        logger.info(\"The server {0} cannot see other cluster members\", key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0MzI2MQ==", "bodyText": "And yet another is that all managedServers didn't respond.   Or an 'extra' managed server responded.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438843261", "createdAt": "2020-06-11T14:49:47Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -88,6 +89,66 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n     return false;\n   }\n \n+  /**\n+   * Call the curl command and check the managed servers can see each other.\n+   *\n+   * @param curlCmd curl command to call the clusterview app\n+   * @param managedServerNames managed server names that should be see other\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the managed servers can see each other, false otherwise\n+   */\n+  public static boolean verifyClusterMemberCommunication(\n+      String curlCmd,\n+      List<String> managedServerNames,\n+      int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName\n+        -> managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling clusterview at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    ExecResult result = null;\n+    for (int i = 0; i < maxIterations; i++) {\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          TimeUnit.MILLISECONDS.sleep(100);\n+          result = ExecCommand.exec(curlCmd, true);\n+          String response = result.stdout().trim();\n+          for (var entry : managedServers.entrySet()) {\n+            if (response.contains(\"ServerName:\" + entry.getKey())) {\n+              boolean bound = true;\n+              for (String managedServerName : managedServerNames) {\n+                bound = bound && response.contains(\"Bound:\" + managedServerName);\n+              }\n+              if (bound) {\n+                managedServers.put(entry.getKey(), true);\n+              }\n+            }\n+          }\n+        } catch (IOException | InterruptedException e) {\n+          logger.info(e.toString());\n+          return false;\n+        }\n+      } else {\n+        return true;\n+      }\n+    }\n+    // after the max iterations, if hit here, one or more servers cannot see other\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The server {0} can see other cluster members\", key);\n+      } else {\n+        logger.info(\"The server {0} cannot see other cluster members\", key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzI4Ng=="}, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwMDM0Mw==", "bodyText": "Another possible reason is that the response contained unexpected content (did not contain ServerName/Bound). It'd be helpful to accumulate an 'error' string that contains 'unexpected' responses (e.g. does not contain at least ServerName of one of the servers), and dump the String here on a failure.\n\nIts already there, when http requests are made in a loop it will print this until all expected servers are bound.\n\n\n\n<title>ClusterViewServlet</title>\n\n\nServerName:ms-2\nAlive:3\nHealth:0\nMembers:ms-3,ms-1,ms-2\nUnable to resolve 'ms-3'. Resolved ''\nUnable to resolve 'ms-1'. Resolved ''\nBound:ms-2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438900343", "createdAt": "2020-06-11T16:02:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -88,6 +89,66 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n     return false;\n   }\n \n+  /**\n+   * Call the curl command and check the managed servers can see each other.\n+   *\n+   * @param curlCmd curl command to call the clusterview app\n+   * @param managedServerNames managed server names that should be see other\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the managed servers can see each other, false otherwise\n+   */\n+  public static boolean verifyClusterMemberCommunication(\n+      String curlCmd,\n+      List<String> managedServerNames,\n+      int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName\n+        -> managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling clusterview at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    ExecResult result = null;\n+    for (int i = 0; i < maxIterations; i++) {\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          TimeUnit.MILLISECONDS.sleep(100);\n+          result = ExecCommand.exec(curlCmd, true);\n+          String response = result.stdout().trim();\n+          for (var entry : managedServers.entrySet()) {\n+            if (response.contains(\"ServerName:\" + entry.getKey())) {\n+              boolean bound = true;\n+              for (String managedServerName : managedServerNames) {\n+                bound = bound && response.contains(\"Bound:\" + managedServerName);\n+              }\n+              if (bound) {\n+                managedServers.put(entry.getKey(), true);\n+              }\n+            }\n+          }\n+        } catch (IOException | InterruptedException e) {\n+          logger.info(e.toString());\n+          return false;\n+        }\n+      } else {\n+        return true;\n+      }\n+    }\n+    // after the max iterations, if hit here, one or more servers cannot see other\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The server {0} can see other cluster members\", key);\n+      } else {\n+        logger.info(\"The server {0} cannot see other cluster members\", key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzI4Ng=="}, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNTM4Mw==", "bodyText": "I don't see how it's already there? I see line 120 String response = result.stdout().trim(); but no corresponding print for the response if the response doesn't contain ServerName:.\nRegardless, the error message at line 145 itself is misleading if it hits the error cases I mentioned above (e.g. an error case that isn't due to 'unbound').", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438905383", "createdAt": "2020-06-11T16:10:56Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -88,6 +89,66 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n     return false;\n   }\n \n+  /**\n+   * Call the curl command and check the managed servers can see each other.\n+   *\n+   * @param curlCmd curl command to call the clusterview app\n+   * @param managedServerNames managed server names that should be see other\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the managed servers can see each other, false otherwise\n+   */\n+  public static boolean verifyClusterMemberCommunication(\n+      String curlCmd,\n+      List<String> managedServerNames,\n+      int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName\n+        -> managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling clusterview at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    ExecResult result = null;\n+    for (int i = 0; i < maxIterations; i++) {\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          TimeUnit.MILLISECONDS.sleep(100);\n+          result = ExecCommand.exec(curlCmd, true);\n+          String response = result.stdout().trim();\n+          for (var entry : managedServers.entrySet()) {\n+            if (response.contains(\"ServerName:\" + entry.getKey())) {\n+              boolean bound = true;\n+              for (String managedServerName : managedServerNames) {\n+                bound = bound && response.contains(\"Bound:\" + managedServerName);\n+              }\n+              if (bound) {\n+                managedServers.put(entry.getKey(), true);\n+              }\n+            }\n+          }\n+        } catch (IOException | InterruptedException e) {\n+          logger.info(e.toString());\n+          return false;\n+        }\n+      } else {\n+        return true;\n+      }\n+    }\n+    // after the max iterations, if hit here, one or more servers cannot see other\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The server {0} can see other cluster members\", key);\n+      } else {\n+        logger.info(\"The server {0} cannot see other cluster members\", key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzI4Ng=="}, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0ODU3MQ==", "bodyText": "The response from the server is always printed, that happens when the curl command is executed. line # 119\nSo it unnecessary to accumulate the unexpected response and print it again.\nI can change the error message in line # 145 to include the case for unbound.\nPlease see the https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/323/consoleFull\nsearch for Unable to resolve 'ms-1'. Resolved ''", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438948571", "createdAt": "2020-06-11T17:24:29Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -88,6 +89,66 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n     return false;\n   }\n \n+  /**\n+   * Call the curl command and check the managed servers can see each other.\n+   *\n+   * @param curlCmd curl command to call the clusterview app\n+   * @param managedServerNames managed server names that should be see other\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the managed servers can see each other, false otherwise\n+   */\n+  public static boolean verifyClusterMemberCommunication(\n+      String curlCmd,\n+      List<String> managedServerNames,\n+      int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName\n+        -> managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling clusterview at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    ExecResult result = null;\n+    for (int i = 0; i < maxIterations; i++) {\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          TimeUnit.MILLISECONDS.sleep(100);\n+          result = ExecCommand.exec(curlCmd, true);\n+          String response = result.stdout().trim();\n+          for (var entry : managedServers.entrySet()) {\n+            if (response.contains(\"ServerName:\" + entry.getKey())) {\n+              boolean bound = true;\n+              for (String managedServerName : managedServerNames) {\n+                bound = bound && response.contains(\"Bound:\" + managedServerName);\n+              }\n+              if (bound) {\n+                managedServers.put(entry.getKey(), true);\n+              }\n+            }\n+          }\n+        } catch (IOException | InterruptedException e) {\n+          logger.info(e.toString());\n+          return false;\n+        }\n+      } else {\n+        return true;\n+      }\n+    }\n+    // after the max iterations, if hit here, one or more servers cannot see other\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The server {0} can see other cluster members\", key);\n+      } else {\n+        logger.info(\"The server {0} cannot see other cluster members\", key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzI4Ng=="}, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzg0ODExOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ClusterViewServlet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDo1NTo0OFrOGihIbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjowMzo0N1rOGikZCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NzU5Ng==", "bodyText": "I'm not sure about this, but if you were to view this output in a browser, I suspect the newlines would be ignored and it'd all end up munged into one line. If so, you can put a <pre> after <body> and a </pre> before </body> to correct this.\nDitto for the JSPs.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438847596", "createdAt": "2020-06-11T14:55:48Z", "author": {"login": "tbarnes-us"}, "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ClusterViewServlet.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.applications.clusterview;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.management.MBeanServer;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NameNotFoundException;\n+import javax.naming.NamingException;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import weblogic.management.jmx.MBeanServerInvocationHandler;\n+import weblogic.management.mbeanservers.runtime.RuntimeServiceMBean;\n+import weblogic.management.runtime.ClusterRuntimeMBean;\n+import weblogic.management.runtime.ServerRuntimeMBean;\n+\n+/**\n+ * Servlet to print all MBeans names and attributes in the server runtime.\n+ */\n+public class ClusterViewServlet extends HttpServlet {\n+\n+  Context ctx = null;\n+  MBeanServer localMBeanServer;\n+  ServerRuntimeMBean serverRuntime;\n+\n+  @Override\n+  public void init(ServletConfig config) throws ServletException {\n+    try {\n+      ctx = new InitialContext();\n+      localMBeanServer = (MBeanServer) ctx.lookup(\"java:comp/env/jmx/runtime\");\n+      // get ServerRuntimeMBean\n+      ObjectName runtimeserviceObjectName = new ObjectName(RuntimeServiceMBean.OBJECT_NAME);\n+      RuntimeServiceMBean runtimeService = (RuntimeServiceMBean) MBeanServerInvocationHandler\n+          .newProxyInstance(localMBeanServer, runtimeserviceObjectName);\n+      serverRuntime = runtimeService.getServerRuntime();\n+      try {\n+        ctx.lookup(serverRuntime.getName());\n+      } catch (NameNotFoundException nnfe) {\n+        ctx.bind(serverRuntime.getName(), serverRuntime.getName());\n+      }\n+    } catch (NamingException | MalformedObjectNameException ex) {\n+      Logger.getLogger(ClusterViewServlet.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+  }\n+\n+  @Override\n+  public void destroy() {\n+    try {\n+      ctx.unbind(serverRuntime.getName());\n+      ctx.close();\n+    } catch (NamingException ex) {\n+      Logger.getLogger(ClusterViewServlet.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+  }\n+\n+  /**\n+   * Processes requests for both HTTP <code>GET</code> and <code>POST</code> methods.\n+   *\n+   * @param request servlet request\n+   * @param response servlet response\n+   * @throws ServletException if a servlet-specific error occurs\n+   * @throws IOException if an I/O error occurs\n+   */\n+  protected void processRequest(HttpServletRequest request, HttpServletResponse response)\n+      throws ServletException, IOException {\n+    response.setContentType(\"text/html;charset=UTF-8\");\n+    try (PrintWriter out = response.getWriter()) {\n+      out.println(\"<!DOCTYPE html>\");\n+      out.println(\"<html>\");\n+      out.println(\"<head>\");\n+      out.println(\"<title>ClusterViewServlet</title>\");\n+      out.println(\"</head>\");\n+      out.println(\"<body>\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwMTAwMA==", "bodyText": "Added pre tag", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1725#discussion_r438901000", "createdAt": "2020-06-11T16:03:47Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/resources/apps/clusterview/src/java/oracle/weblogic/kubernetes/applications/clusterview/ClusterViewServlet.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.applications.clusterview;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.management.MBeanServer;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NameNotFoundException;\n+import javax.naming.NamingException;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import weblogic.management.jmx.MBeanServerInvocationHandler;\n+import weblogic.management.mbeanservers.runtime.RuntimeServiceMBean;\n+import weblogic.management.runtime.ClusterRuntimeMBean;\n+import weblogic.management.runtime.ServerRuntimeMBean;\n+\n+/**\n+ * Servlet to print all MBeans names and attributes in the server runtime.\n+ */\n+public class ClusterViewServlet extends HttpServlet {\n+\n+  Context ctx = null;\n+  MBeanServer localMBeanServer;\n+  ServerRuntimeMBean serverRuntime;\n+\n+  @Override\n+  public void init(ServletConfig config) throws ServletException {\n+    try {\n+      ctx = new InitialContext();\n+      localMBeanServer = (MBeanServer) ctx.lookup(\"java:comp/env/jmx/runtime\");\n+      // get ServerRuntimeMBean\n+      ObjectName runtimeserviceObjectName = new ObjectName(RuntimeServiceMBean.OBJECT_NAME);\n+      RuntimeServiceMBean runtimeService = (RuntimeServiceMBean) MBeanServerInvocationHandler\n+          .newProxyInstance(localMBeanServer, runtimeserviceObjectName);\n+      serverRuntime = runtimeService.getServerRuntime();\n+      try {\n+        ctx.lookup(serverRuntime.getName());\n+      } catch (NameNotFoundException nnfe) {\n+        ctx.bind(serverRuntime.getName(), serverRuntime.getName());\n+      }\n+    } catch (NamingException | MalformedObjectNameException ex) {\n+      Logger.getLogger(ClusterViewServlet.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+  }\n+\n+  @Override\n+  public void destroy() {\n+    try {\n+      ctx.unbind(serverRuntime.getName());\n+      ctx.close();\n+    } catch (NamingException ex) {\n+      Logger.getLogger(ClusterViewServlet.class.getName()).log(Level.SEVERE, null, ex);\n+    }\n+  }\n+\n+  /**\n+   * Processes requests for both HTTP <code>GET</code> and <code>POST</code> methods.\n+   *\n+   * @param request servlet request\n+   * @param response servlet response\n+   * @throws ServletException if a servlet-specific error occurs\n+   * @throws IOException if an I/O error occurs\n+   */\n+  protected void processRequest(HttpServletRequest request, HttpServletResponse response)\n+      throws ServletException, IOException {\n+    response.setContentType(\"text/html;charset=UTF-8\");\n+    try (PrintWriter out = response.getWriter()) {\n+      out.println(\"<!DOCTYPE html>\");\n+      out.println(\"<html>\");\n+      out.println(\"<head>\");\n+      out.println(\"<title>ClusterViewServlet</title>\");\n+      out.println(\"</head>\");\n+      out.println(\"<body>\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NzU5Ng=="}, "originalCommit": {"oid": "6029169103bba1d1f178117a3f51fcf592403c27"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4323, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}