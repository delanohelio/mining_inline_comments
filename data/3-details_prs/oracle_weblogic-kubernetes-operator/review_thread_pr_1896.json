{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3Mzk1MTM4", "number": 1896, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMToyOTo1OVrOEfI-Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTo0MjoxOVrOEfJQyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDg4Mjk1OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMToyOTo1OVrOHLOKmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxMToyNFrOHL5I-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyODQ3Mg==", "bodyText": "Does it mean two dynamic clusters with two managed server each ?\nSpecify which domain model is being used.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r481528472", "createdAt": "2020-09-02T01:29:59Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMjU2OA==", "bodyText": "changed the wording, it is 1 domain, 1 cluster and 2 ms in it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482232568", "createdAt": "2020-09-02T17:11:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyODQ3Mg=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDkwMDkyOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTozNDozNVrOHLOWGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMzowNToxMlrOHMOhAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTQxNg==", "bodyText": "Can we make  REST call to Admin Server to get System Resource Runtime MBean to verify the Override, instead of using a web application to check the override ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r481531416", "createdAt": "2020-09-02T01:34:35Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for jms server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyJMSResourceOverride();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNjg4Ng==", "bodyText": "It will be too much in the test code. For JMS its ok, but in WLDF there are lot of overrides that needs to be verified so it is better to stick with the application.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482236886", "createdAt": "2020-09-02T17:16:23Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for jms server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyJMSResourceOverride();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTQxNg=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4Mjc4NA==", "bodyText": "OK. It is fine", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482582784", "createdAt": "2020-09-02T23:05:12Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for jms server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyJMSResourceOverride();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMTQxNg=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDkwODQ0OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTozNjozM1rOHLOazg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxMjowMFrOHL5LVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjYyMg==", "bodyText": "Modify Test name to \"testJmsWldfSystemResourceOverride\" to describe the usecase.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r481532622", "createdAt": "2020-09-02T01:36:33Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMzE3NQ==", "bodyText": "changed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482233175", "createdAt": "2020-09-02T17:12:00Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjYyMg=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDkyMjkwOnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTo0MDoxNFrOHLOkNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxNTowOVrOHL5XFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzNTAyOA==", "bodyText": "The description does not says, we need to bump up introspector version. If so please update the javadoc to detail the steps in the usecase", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r481535028", "createdAt": "2020-09-02T01:40:14Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNjE4MQ==", "bodyText": "improved the javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482236181", "createdAt": "2020-09-02T17:15:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzNTAyOA=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDkzMDY3OnYy", "diffSide": "RIGHT", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTo0MjoxOVrOHLOpXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxOTo1M1rOHL5h8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzNjM0OQ==", "bodyText": "Is this not a common test utility ?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r481536349", "createdAt": "2020-09-02T01:42:19Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for jms server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyJMSResourceOverride();\n+    verifyWLDFResourceOverride();\n+\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/sitconfig/SitconfigServlet\";\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      return (response.statusCode() == 200) && response.body().contains(\"ExpirationPolicy:Discard\");\n+    });\n+  }\n+\n+  private void verifyJMSResourceOverride() {\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String uri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/sitconfig/SitconfigServlet\";\n+\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(uri, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    assertTrue(response.body().contains(\"ExpirationPolicy:Discard\"), \"Didn't get ExpirationPolicy:Discard\");\n+    assertTrue(response.body().contains(\"RedeliveryLimit:20\"), \"Didn't get RedeliveryLimit:20\");\n+  }\n+\n+  private void verifyWLDFResourceOverride() {\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String uri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/sitconfig/SitconfigServlet\";\n+\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(uri, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    assertTrue(response.body().contains(\"MONITORS:PASSED\"), \"Didn't get MONITORS:PASSED\");\n+    assertTrue(response.body().contains(\"HARVESTORS:PASSED\"), \"Didn't get HARVESTORS:PASSED\");\n+    assertTrue(response.body().contains(\"HARVESTOR MATCHED:weblogic.management.runtime.JDBCServiceRuntimeMBean\"),\n+        \"Didn't get HARVESTOR MATCHED:weblogic.management.runtime.JDBCServiceRuntimeMBean\");\n+    assertTrue(response.body().contains(\"HARVESTOR MATCHED:weblogic.management.runtime.ServerRuntimeMBean\"),\n+        \"Didn't get HARVESTOR MATCHED:weblogic.management.runtime.ServerRuntimeMBean\");\n+  }\n+\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    createPV(pvName, domainUid, this.getClass().getSimpleName());\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(31518, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"sit-config-create-domain.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true \"\n+                        + \"-Dweblogic.debug.DebugSituationalConfigDumpXml=true \"\n+                        + \"-Dweblogic.kernel.debug=true \"\n+                        + \"-Dweblogic.debug.DebugMessaging=true \"\n+                        + \"-Dweblogic.debug.DebugConnection=true \"\n+                        + \"-Dweblogic.ResolveDNSName=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application sitconfig.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", sitconfigAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, sitconfigAppPath,\n+        domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(\n+            domainScriptConfigMapName, domainScriptFiles, namespace, this.getClass().getSimpleName()),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(image, isUseSecret, pvName, pvcName, domainScriptConfigMapName,\n+        namespace, jobCreationContainer);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzODk2MA==", "bodyText": "I am calling createDockerRegistrySecret in this method when secret doesn't exist. But createOCRRepoSecret itself is not a common utility.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1896#discussion_r482238960", "createdAt": "2020-09-02T17:19:53Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSystemResOverrides.java", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getNextIntrospectVersion;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.impl.Domain.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.listSecrets;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.BuildApplication.buildApplication;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapForDomainCreation;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainJob;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.DeployUtil.deployUsingWlst;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests related to Situational Configuration overrides for system resources.\n+ */\n+@DisplayName(\"Verify the JMS and WLDF system resources are overridden with values from override files\")\n+@IntegrationTest\n+public class ItSystemResOverrides {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  final String domainUid = \"mydomain\";\n+  final String clusterName = \"mycluster\";\n+  final String adminServerName = \"admin-server\";\n+  final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+  final String managedServerNameBase = \"ms-\";\n+  final int managedServerPort = 8001;\n+  int t3ChannelPort;\n+  final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+  final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+  final String wlSecretName = \"weblogic-credentials\";\n+  final String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+  int replicaCount = 2;\n+\n+  static Path sitconfigAppPath;\n+  String overridecm = \"configoverride-cm\";\n+  LinkedHashMap<String, DateTime> podTimestamps;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pulls WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   * Creates and starts WebLogic domain containing 2 instances in dynamic cluster.\n+   * Creates JMS and WLDF system resources.\n+   * Deploys sitconfig application to cluster and admin targets.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for domain namspace\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    } else {\n+      // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+    //create and start WebLogic domain\n+    createDomain();\n+\n+    // build the sitconfig application\n+    Path distDir = buildApplication(Paths.get(APP_DIR, \"sitconfig\"),\n+        null, null, \"dist\", domainNamespace);\n+    sitconfigAppPath = Paths.get(distDir.toString(), \"sitconfig.war\");\n+    assertTrue(sitconfigAppPath.toFile().exists(), \"Application archive is not available\");\n+\n+    //deploy application to view server configuration\n+    deployApplication(clusterName + \",\" + adminServerName);\n+\n+  }\n+\n+  /**\n+   * Test JMS and WLDF system resources configurations are overridden dynamically when domain resource\n+   * is updated with overridesConfigMap property. After the override verifies the system resources properties\n+   * are overridden as per the values set.\n+   */\n+  @Test\n+  @DisplayName(\"Test JMS and WLDF system resources override\")\n+  public void testSystemResourceOverride() {\n+\n+    //store the pod creation timestamps\n+    storePodCreationTimestamps();\n+\n+    List<Path> overrideFiles = new ArrayList<>();\n+    overrideFiles.add(\n+        Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/jms-ClusterJmsSystemResource.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/diagnostics-WLDF-MODULE-0.xml\"));\n+    overrideFiles.add(Paths.get(RESOURCE_DIR, \"configfiles/configoverridesset2/version.txt\"));\n+\n+    //create config override map\n+    createConfigMapFromFiles(overridecm, overrideFiles, domainNamespace);\n+\n+    String introspectVersion = assertDoesNotThrow(() -> getNextIntrospectVersion(domainUid, domainNamespace));\n+\n+    logger.info(\"patch the domain resource with overridesConfigMap and introspectVersion\");\n+    String patchStr\n+        = \"[\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/configuration/overridesConfigMap\\\", \\\"value\\\": \\\"\" + overridecm + \"\\\"},\"\n+        + \"{\\\"op\\\": \\\"add\\\", \\\"path\\\": \\\"/spec/introspectVersion\\\", \\\"value\\\": \\\"\" + introspectVersion + \"\\\"}\"\n+        + \"]\";\n+    logger.info(\"Updating domain configuration using patch string: {0}\", patchStr);\n+    V1Patch patch = new V1Patch(patchStr);\n+    assertTrue(patchDomainCustomResource(domainUid, domainNamespace, patch, V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch domain\");\n+\n+    verifyIntrospectorRuns();\n+    verifyPodsStateNotChanged();\n+\n+    //wait until config is updated upto 5 minutes\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for jms server configuration to be updated\"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(configUpdated());\n+\n+    verifyJMSResourceOverride();\n+    verifyWLDFResourceOverride();\n+\n+  }\n+\n+  private Callable<Boolean> configUpdated() {\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName\n+            + \"-external\",\n+            \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    //verify server attribute MaxMessageSize\n+    String appURI = \"/sitconfig/SitconfigServlet\";\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + serviceNodePort + appURI;\n+\n+    return (()\n+        -> {\n+      HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\n+      return (response.statusCode() == 200) && response.body().contains(\"ExpirationPolicy:Discard\");\n+    });\n+  }\n+\n+  private void verifyJMSResourceOverride() {\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String uri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/sitconfig/SitconfigServlet\";\n+\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(uri, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    assertTrue(response.body().contains(\"ExpirationPolicy:Discard\"), \"Didn't get ExpirationPolicy:Discard\");\n+    assertTrue(response.body().contains(\"RedeliveryLimit:20\"), \"Didn't get RedeliveryLimit:20\");\n+  }\n+\n+  private void verifyWLDFResourceOverride() {\n+    int port = getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"default\");\n+    String uri = \"http://\" + K8S_NODEPORT_HOST + \":\" + port + \"/sitconfig/SitconfigServlet\";\n+\n+    HttpResponse<String> response = assertDoesNotThrow(() -> OracleHttpClient.get(uri, true));\n+    assertEquals(200, response.statusCode(), \"Status code not equals to 200\");\n+    assertTrue(response.body().contains(\"MONITORS:PASSED\"), \"Didn't get MONITORS:PASSED\");\n+    assertTrue(response.body().contains(\"HARVESTORS:PASSED\"), \"Didn't get HARVESTORS:PASSED\");\n+    assertTrue(response.body().contains(\"HARVESTOR MATCHED:weblogic.management.runtime.JDBCServiceRuntimeMBean\"),\n+        \"Didn't get HARVESTOR MATCHED:weblogic.management.runtime.JDBCServiceRuntimeMBean\");\n+    assertTrue(response.body().contains(\"HARVESTOR MATCHED:weblogic.management.runtime.ServerRuntimeMBean\"),\n+        \"Didn't get HARVESTOR MATCHED:weblogic.management.runtime.ServerRuntimeMBean\");\n+  }\n+\n+\n+  //store pod creation timestamps for podstate check\n+  private void storePodCreationTimestamps() {\n+    // get the pod creation time stamps\n+    podTimestamps = new LinkedHashMap<>();\n+    // get the creation time of the admin server pod before patching\n+    DateTime adminPodCreationTime = getPodCreationTime(domainNamespace, adminServerPodName);\n+    podTimestamps.put(adminServerPodName, adminPodCreationTime);\n+    // get the creation time of the managed server pods before patching\n+    for (int i = 1; i <= replicaCount; i++) {\n+      podTimestamps.put(managedServerPodNamePrefix + i,\n+          getPodCreationTime(domainNamespace, managedServerPodNamePrefix + i));\n+    }\n+  }\n+\n+  //check if the pods are restarted by comparing the pod creationtimestamp.\n+  private void verifyPodsStateNotChanged() {\n+    logger.info(\"Verifying the WebLogic server pod states are not changed\");\n+    for (Map.Entry<String, DateTime> entry : podTimestamps.entrySet()) {\n+      String podName = (String) entry.getKey();\n+      DateTime creationTimestamp = (DateTime) entry.getValue();\n+      assertTrue(podStateNotChanged(podName, domainUid, domainNamespace,\n+          creationTimestamp), \"Pod is restarted\");\n+    }\n+  }\n+\n+  //verify the introspector pod is created and run\n+  private void verifyIntrospectorRuns() {\n+    //verify the introspector pod is created and runs\n+    logger.info(\"Verifying introspector pod is created, runs and deleted\");\n+    String introspectPodName = domainUid + \"-\" + \"introspect-domain-job\";\n+    checkPodExists(introspectPodName, domainUid, domainNamespace);\n+    checkPodDoesNotExist(introspectPodName, domainUid, domainNamespace);\n+  }\n+\n+  //create a standard WebLogic domain.\n+  private void createDomain() {\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    createPV(pvName, domainUid, this.getClass().getSimpleName());\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    t3ChannelPort = getNextFreePort(31518, 32767);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(()\n+        -> File.createTempFile(\"domain\", \".properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", Integer.toString(managedServerPort));\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"2\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(()\n+        -> p.store(new FileOutputStream(domainPropertiesFile), \"domain properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"sit-config-create-domain.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .configuration(new Configuration()\n+                .overrideDistributionStrategy(\"DYNAMIC\"))\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.debug.DebugSituationalConfig=true \"\n+                        + \"-Dweblogic.debug.DebugSituationalConfigDumpXml=true \"\n+                        + \"-Dweblogic.kernel.debug=true \"\n+                        + \"-Dweblogic.debug.DebugMessaging=true \"\n+                        + \"-Dweblogic.debug.DebugConnection=true \"\n+                        + \"-Dweblogic.ResolveDNSName=true\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  //deploy application sitconfig.war to domain\n+  private void deployApplication(String targets) {\n+    logger.info(\"Getting node port for T3 channel\");\n+    int t3channelNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(domainNamespace, adminServerPodName + \"-external\", \"t3channel\"),\n+        \"Getting admin server t3channel node port failed\");\n+    assertNotEquals(-1, t3ChannelPort, \"admin server t3channelport is not valid\");\n+\n+    //deploy application\n+    logger.info(\"Deploying webapp {0} to domain\", sitconfigAppPath);\n+    deployUsingWlst(K8S_NODEPORT_HOST, Integer.toString(t3channelNodePort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, targets, sitconfigAppPath,\n+        domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following. Create a configmap containing WLST script\n+   * and property file. Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(\n+            domainScriptConfigMapName, domainScriptFiles, namespace, this.getClass().getSimpleName()),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh\n+        // script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName());\n+    //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    createDomainJob(image, isUseSecret, pvName, pvcName, domainScriptConfigMapName,\n+        namespace, jobCreationContainer);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzNjM0OQ=="}, "originalCommit": {"oid": "15a100271e1c266d6179bb04054176eeb8f9163a"}, "originalPosition": 492}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3926, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}