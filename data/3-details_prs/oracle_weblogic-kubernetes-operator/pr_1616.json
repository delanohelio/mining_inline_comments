{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNjYwNjYz", "number": 1616, "title": "Mii app patching test", "bodyText": "Add test case #5 and #6, which patches an existing app or adds an additional app respectively,  including verifications of patching, app accessibility, and app continuous availability.\nUse Kubernetes client exec api to verify app availability.\nAdd timeout to the join call in Kubernetes API exec command action.\nCleanup, including removing ItWitValidation.java because its content has been moved into ItMiiDomain.java.", "createdAt": "2020-05-03T20:21:06Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616", "merged": true, "mergeCommit": {"oid": "898b967684a11e92ac64fbaf7300630dea17a53f"}, "closed": true, "closedAt": "2020-05-17T19:32:08Z", "author": {"login": "doxiao"}, "timelineItems": {"totalCount": 93, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYMo5qAH2gAyNDEyNjYwNjYzOjUxODI0ZDZhNmRkM2EwZTQzYTUzNDQ4ODU2MDZlNTk1NmI0NDg0M2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABciLU1OgH2gAyNDEyNjYwNjYzOmQzNzg1OGUyMDQ4ZTkzMzIzYmRkNDkwNGY2YWM2ZTI1ZWRhN2RkNzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "51824d6a6dd3a0e43a5344885606e5956b44843b", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/51824d6a6dd3a0e43a5344885606e5956b44843b", "committedDate": "2020-04-16T13:23:48Z", "message": "Initial changes to test application update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9dc18a32a815da9588a2f2f1705b47fabc96bcd", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c9dc18a32a815da9588a2f2f1705b47fabc96bcd", "committedDate": "2020-04-16T13:28:12Z", "message": "Add app assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af2e168a0f5b2a7fad2f6df328cc815cd8badcfe", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/af2e168a0f5b2a7fad2f6df328cc815cd8badcfe", "committedDate": "2020-04-17T15:13:41Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "351bc8a1172bc7be3d41eeb24eb3d34ed2691519", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/351bc8a1172bc7be3d41eeb24eb3d34ed2691519", "committedDate": "2020-04-17T17:57:04Z", "message": "Save the current change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b50a627b242a87880a04a6f414caf3f59218b89", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9b50a627b242a87880a04a6f414caf3f59218b89", "committedDate": "2020-04-20T00:08:47Z", "message": "Update ItMiiDomain test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c40df289fa37a0c16c336bbed026378fda407abb", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c40df289fa37a0c16c336bbed026378fda407abb", "committedDate": "2020-04-20T18:07:52Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36f7b34daabe18d019ae4029af489b5086d2f351", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/36f7b34daabe18d019ae4029af489b5086d2f351", "committedDate": "2020-04-21T13:26:10Z", "message": "More changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a1164effc5061aec4367b63e0bf4ea92f7e1453", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8a1164effc5061aec4367b63e0bf4ea92f7e1453", "committedDate": "2020-04-21T20:39:43Z", "message": "verify an app from a server pod"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "888b1f371bd46698390739ba6e6357b70b3002ff", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/888b1f371bd46698390739ba6e6357b70b3002ff", "committedDate": "2020-04-21T20:45:10Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/CommandParams.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75d6028c66cba27976c044efa25ef3a0c8faad1d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/75d6028c66cba27976c044efa25ef3a0c8faad1d", "committedDate": "2020-04-22T17:07:23Z", "message": "add code to patch the domain with a new image and verify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2b169f89526f38c2deaf40a426bf67e2bb198de", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b2b169f89526f38c2deaf40a426bf67e2bb198de", "committedDate": "2020-04-22T17:14:26Z", "message": "Revert unintended changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99fae4e407ba673db7d05d1c2afd2baf0fe2299", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c99fae4e407ba673db7d05d1c2afd2baf0fe2299", "committedDate": "2020-04-22T17:52:28Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItWitValidation.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e76239b16e4ffbf7dbbce9ab4cdd7b6fc0b5adf6", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e76239b16e4ffbf7dbbce9ab4cdd7b6fc0b5adf6", "committedDate": "2020-04-22T18:33:01Z", "message": "Fix merge issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd2745f0a5fbb7ccd60004f10d66d7592cd97152", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dd2745f0a5fbb7ccd60004f10d66d7592cd97152", "committedDate": "2020-04-22T19:53:36Z", "message": "more cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa28b4c77f3d8c9a5694a49dd877693fb5e5740d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fa28b4c77f3d8c9a5694a49dd877693fb5e5740d", "committedDate": "2020-04-22T20:38:59Z", "message": "Initial change for test number 6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32d0238959c9528f1f83a486594c12f9ef96113c", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32d0238959c9528f1f83a486594c12f9ef96113c", "committedDate": "2020-04-22T23:31:31Z", "message": "Fix ExecCommand to allow both redirect and saveResults enabled the same time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92ac716d86b1e08e42b052d9152c2f13d625a2a4", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/92ac716d86b1e08e42b052d9152c2f13d625a2a4", "committedDate": "2020-04-23T14:30:22Z", "message": "Initial change for adding another app"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3c9709577ac9da1d3a15dad2340c9e3493b65e7", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f3c9709577ac9da1d3a15dad2340c9e3493b65e7", "committedDate": "2020-04-23T17:57:59Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItWitValidation.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d41efedb81bf0d4cd2137cf846a266da65dbfa95", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d41efedb81bf0d4cd2137cf846a266da65dbfa95", "committedDate": "2020-04-23T21:12:40Z", "message": "More impl for the second test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "754bf4497d8fd23bc3b9771cb8aa0d0cef7ab3cf", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/754bf4497d8fd23bc3b9771cb8aa0d0cef7ab3cf", "committedDate": "2020-04-23T21:40:32Z", "message": "Add model file for the second app"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5532b3d39e36c8062d588ced8abc7d5795da0e1", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c5532b3d39e36c8062d588ced8abc7d5795da0e1", "committedDate": "2020-04-23T21:42:50Z", "message": "Minor cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be44a53d60cfe75b6ff342288af3c4e1ce399811", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/be44a53d60cfe75b6ff342288af3c4e1ce399811", "committedDate": "2020-04-24T01:30:23Z", "message": "Clean up comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0794ce024084b386c79c0548a480bc1b2ea5cc7e", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0794ce024084b386c79c0548a480bc1b2ea5cc7e", "committedDate": "2020-04-24T01:33:42Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f586f78d2bbae877c30eb8038216779af76294f", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6f586f78d2bbae877c30eb8038216779af76294f", "committedDate": "2020-04-24T01:46:52Z", "message": "Minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d0b7bd398fdd7bf26902a85745bc510b6103378", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d0b7bd398fdd7bf26902a85745bc510b6103378", "committedDate": "2020-04-24T02:08:48Z", "message": "Move delete images to the end of AfterAll"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e714627616e7b5a40c04aa9aefd3b553dc22a89", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e714627616e7b5a40c04aa9aefd3b553dc22a89", "committedDate": "2020-04-24T15:59:30Z", "message": "Update command to check response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cecb83fd842eb352317582c61a084fd64cd114a", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7cecb83fd842eb352317582c61a084fd64cd114a", "committedDate": "2020-04-24T17:32:01Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937c92372d9348213abd44909be4d72b1f2f223d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/937c92372d9348213abd44909be4d72b1f2f223d", "committedDate": "2020-04-24T18:06:42Z", "message": "Fix a merge error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bc4f4f82d81369273d5d5d59108d39c4396984d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5bc4f4f82d81369273d5d5d59108d39c4396984d", "committedDate": "2020-04-24T18:29:38Z", "message": "Fix exec command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3e17ca1bfcde308bae1a128edd5135af2aaa9f3", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d3e17ca1bfcde308bae1a128edd5135af2aaa9f3", "committedDate": "2020-04-24T18:59:22Z", "message": "Add code for remote repo stuff for the new tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45c965af628f3056b9858b1d392cce7fe58d1ff8", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/45c965af628f3056b9858b1d392cce7fe58d1ff8", "committedDate": "2020-04-24T19:01:44Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdc828239fa53cdb58e43ae2ce387319c37af5aa", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cdc828239fa53cdb58e43ae2ce387319c37af5aa", "committedDate": "2020-04-24T19:08:54Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c729d7d8d1999cc5fef03fba0a3f3e0d564736d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2c729d7d8d1999cc5fef03fba0a3f3e0d564736d", "committedDate": "2020-04-24T19:15:05Z", "message": "Fix image name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5c5d46c0553584003cf170380d4173db6cb7447", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e5c5d46c0553584003cf170380d4173db6cb7447", "committedDate": "2020-04-24T20:08:33Z", "message": "Add an app file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4094e4efc3e2b34370d2c937f6bf00fdd01dabb4", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4094e4efc3e2b34370d2c937f6bf00fdd01dabb4", "committedDate": "2020-04-24T20:34:57Z", "message": "Make sure the thread joins before we save the stdout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c243b49296820acca34af5192841491c0ac30802", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c243b49296820acca34af5192841491c0ac30802", "committedDate": "2020-04-24T20:47:19Z", "message": "Remove ItWitValidation class becuase the test in it has been copied to ItMiiDomain class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2b97eb4dbeafbb4a14a737302c9b9efab4e5a5", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e2b97eb4dbeafbb4a14a737302c9b9efab4e5a5", "committedDate": "2020-04-24T21:25:09Z", "message": "Revert \"Remove ItWitValidation class becuase the test in it has been copied to ItMiiDomain class\"\n\nThis reverts commit c243b49296820acca34af5192841491c0ac30802."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0591fbf66b92ce9dc993214815878aedadf4732c", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0591fbf66b92ce9dc993214815878aedadf4732c", "committedDate": "2020-04-25T02:43:11Z", "message": "Debugging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8f50c7bca30d768a00eaf0473714504de12baf3", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e8f50c7bca30d768a00eaf0473714504de12baf3", "committedDate": "2020-04-25T03:10:34Z", "message": "Fix pushed image name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "713a3bb6b43b97481990a100e073095a9e5a4a88", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/713a3bb6b43b97481990a100e073095a9e5a4a88", "committedDate": "2020-04-25T14:28:00Z", "message": "Turn off debugging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c6c391aac1b0baace56f358d44295b25c07f17d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5c6c391aac1b0baace56f358d44295b25c07f17d", "committedDate": "2020-04-25T20:51:39Z", "message": "Testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "818af8094c15a8e85bd5a170ca078d3fc21dafad", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/818af8094c15a8e85bd5a170ca078d3fc21dafad", "committedDate": "2020-04-27T15:56:25Z", "message": "Change single check of expected condition to quick retry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2fb039a8730392531560b536b9880eaaf5c71b3", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2fb039a8730392531560b536b9880eaaf5c71b3", "committedDate": "2020-04-27T18:56:50Z", "message": "Check app on all managed servers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b9f6aa2b92e156fea3d3787071e2253d83e9963", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9b9f6aa2b92e156fea3d3787071e2253d83e9963", "committedDate": "2020-04-27T21:11:34Z", "message": "Check each pod to verify if the image has been patched"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a9b2e4585474ab19a8e9d75104fcc6c453c562d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9a9b2e4585474ab19a8e9d75104fcc6c453c562d", "committedDate": "2020-04-27T21:12:43Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b3af6f97ce4eddf8ceb4b039b6b40013641599b", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1b3af6f97ce4eddf8ceb4b039b6b40013641599b", "committedDate": "2020-04-27T22:20:44Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/ExecCommand.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ca8fc5246cbcb851b6809c751d4ca343d12883f", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5ca8fc5246cbcb851b6809c751d4ca343d12883f", "committedDate": "2020-04-28T02:00:36Z", "message": "Fine tuning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c68d8ea12418fcff6bb73e67a2bb4f994da9c035", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c68d8ea12418fcff6bb73e67a2bb4f994da9c035", "committedDate": "2020-04-28T15:25:06Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fde567ab1dec7596fb572438b788da77c03f722", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6fde567ab1dec7596fb572438b788da77c03f722", "committedDate": "2020-04-28T17:59:49Z", "message": "More cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e15b34b65cc85710bba70d3fefc221f8332ebcdb", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e15b34b65cc85710bba70d3fefc221f8332ebcdb", "committedDate": "2020-04-28T18:54:53Z", "message": "Continue work in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a267c36e2d09af33d923af4515d60f83516b46", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b8a267c36e2d09af33d923af4515d60f83516b46", "committedDate": "2020-04-30T21:17:14Z", "message": "Add app continuous availability check and enable it with a system property"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "497ad2759d14b73a6d20d02a8e4ac1a4ad5a819e", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/497ad2759d14b73a6d20d02a8e4ac1a4ad5a819e", "committedDate": "2020-04-30T21:33:21Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32cab300710b9395956599c77913dc16dd09aeb7", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32cab300710b9395956599c77913dc16dd09aeb7", "committedDate": "2020-05-01T14:56:25Z", "message": "More javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1461b964db954c6ac3587d347a1c87aafb2fbcbe", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1461b964db954c6ac3587d347a1c87aafb2fbcbe", "committedDate": "2020-05-01T18:25:04Z", "message": "Merge branch 'develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9570c024c5659630e84f9ce6e869df5f5c27d86f", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9570c024c5659630e84f9ce6e869df5f5c27d86f", "committedDate": "2020-05-01T19:51:59Z", "message": "javadoc and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87451a8c0fb4cad7b2d02260402fa3c90d63abff", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/87451a8c0fb4cad7b2d02260402fa3c90d63abff", "committedDate": "2020-05-01T20:51:45Z", "message": "Adjust timeout values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41f6edeeab8d98af50141205f891f4701dcd9c6e", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/41f6edeeab8d98af50141205f891f4701dcd9c6e", "committedDate": "2020-05-01T21:21:20Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31cc7fd29c031fdd1a87d4b46b00a5e043b3969a", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/31cc7fd29c031fdd1a87d4b46b00a5e043b3969a", "committedDate": "2020-05-01T21:44:23Z", "message": "Fine tuning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5206a8905a457d4a46b284b7e4d78bff37bb3670", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5206a8905a457d4a46b284b7e4d78bff37bb3670", "committedDate": "2020-05-02T03:29:01Z", "message": "Minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab8ecdfb3362fbd2a507f24da924cd6a3acfe172", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ab8ecdfb3362fbd2a507f24da924cd6a3acfe172", "committedDate": "2020-05-02T07:16:06Z", "message": "Use kubectl exec command for checking app continuous availability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "191ea28a650f06521ec87580354839569f556bd0", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/191ea28a650f06521ec87580354839569f556bd0", "committedDate": "2020-05-02T07:34:34Z", "message": "clean up javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15f52a885515e5dd87b5ae2dd078305cf071875", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d15f52a885515e5dd87b5ae2dd078305cf071875", "committedDate": "2020-05-03T14:30:44Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91718268821b8ff6526d906096e25bbec183499e", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/91718268821b8ff6526d906096e25bbec183499e", "committedDate": "2020-05-04T20:20:48Z", "message": "Minor update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89a9123951329addafd819650ad3cd20c511f0fd", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/89a9123951329addafd819650ad3cd20c511f0fd", "committedDate": "2020-05-05T20:05:28Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb8af2660c72e38eb737d7b335c30d5bbcbac1b1", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bb8af2660c72e38eb737d7b335c30d5bbcbac1b1", "committedDate": "2020-05-05T20:34:40Z", "message": "Minor update of log messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f1c30255fa251e2db6646acc4c8af541102ca1f2", "committedDate": "2020-05-05T21:12:46Z", "message": "More cleanup of log messages and comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTExNjg1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-406111685", "createdAt": "2020-05-05T19:59:27Z", "commit": {"oid": "91718268821b8ff6526d906096e25bbec183499e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxOTo1OToyN1rOGQ5YAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMTo0NDo1MFrOGRBf2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA==", "bodyText": "i'm not completely sure about this -- do we not trust WebLogic to start the app on all the managed servers? could we not just hit the WebLogic Server REST API to check the application status?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420370434", "createdAt": "2020-05-05T19:59:27Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -324,7 +342,19 @@ public void testCreateMiiDomain() {\n           managedServerPrefix + i, domainNamespace);\n       checkServiceCreated(managedServerPrefix + i, domainNamespace);\n     }\n-\n+    \n+    // check and wait for the app to be accessible in all server pods\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91718268821b8ff6526d906096e25bbec183499e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzgyOQ==", "bodyText": "don't use the term \"continuous availability\" unless that is what you really mean - hint: it is not", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420483829", "createdAt": "2020-05-06T00:24:53Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a9123951329addafd819650ad3cd20c511f0fd"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDExOA==", "bodyText": "i am not sure how i feel about running a background thread in a test, especially one that is going to be run my maven...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484118", "createdAt": "2020-05-06T00:25:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89a9123951329addafd819650ad3cd20c511f0fd"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDYzOA==", "bodyText": "Check that the new app ...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484638", "createdAt": "2020-05-06T00:28:12Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc1MQ==", "bodyText": "application", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484751", "createdAt": "2020-05-06T00:28:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppNotRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+   \n+    logger.info(\"Create a new image that contains the additional app\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc3Mw==", "bodyText": "application", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484773", "createdAt": "2020-05-06T00:28:38Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDYzOA=="}, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc5Mw==", "bodyText": "application", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484793", "createdAt": "2020-05-06T00:28:44Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTAxNA==", "bodyText": "i didn't see you check that anything was restarted", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485014", "createdAt": "2020-05-06T00:29:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppNotRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+   \n+    logger.info(\"Create a new image that contains the additional app\");\n+    miiImageAddSecondApp = updateImageWithSampleApp3(\n+        String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-add-second-app\"),\n+        Arrays.asList(appDir1, appDir2),\n+        Collections.singletonList(appDir3),\n+        \"model2-wls.yaml\");\n+    \n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageIfNeeded(miiImageAddSecondApp);\n+   \n+    // patch the domain resource with the new image and verify that the domain resource is patched, \n+    // and all server pods are patched as well.\n+    logger.info(\"Patch the domain with the new image, and verify the result\"); \n+    patchAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        miiImageAddSecondApp);\n+    \n+    logger.info(\"Check and wait for the new app to become ready\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+ \n+    logger.info(\"Check and wait for the original app V2 to become ready\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"The cluster has been rolling restarted, and the two applications are both running correctly\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTM1Ng==", "bodyText": "this feels like the wrong way to assure what you want to happen, especially as the test could fail before you get to here", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485356", "createdAt": "2020-05-06T00:30:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTQ5Mg==", "bodyText": "include some details, at least the repo name", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485492", "createdAt": "2020-05-06T00:31:07Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);\n+    } catch (IOException | RuntimeException e) {    \n+      logger.severe(\"Failed to cleanup the download directory \" + DOWNLOAD_DIR + \" ready\", e);    \n+    }\n   }\n \n-  private String createImageAndVerify() {\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTYwOQ==", "bodyText": "how do you know it is ocir? \"registry\" would be a more accurate choice", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485609", "createdAt": "2020-05-06T00:31:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);\n+    } catch (IOException | RuntimeException e) {    \n+      logger.severe(\"Failed to cleanup the download directory \" + DOWNLOAD_DIR + \" ready\", e);    \n+    }\n   }\n \n-  private String createImageAndVerify() {\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", image);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTkxOA==", "bodyText": "this seems to be repeated - make it a static or a const or something?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485918", "createdAt": "2020-05-06T00:32:43Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjA2MA==", "bodyText": "there was no logging at all in this method", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486060", "createdAt": "2020-05-06T00:33:20Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjE2NA==", "bodyText": "seems like a lot of duplicate code here - refactor", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486164", "createdAt": "2020-05-06T00:33:44Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjIxMw==", "bodyText": "spelling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486213", "createdAt": "2020-05-06T00:33:56Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 502}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjQxMA==", "bodyText": "you are really using the resource's metadata.name right? not domainUid -- even though they might happen to be the same", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486410", "createdAt": "2020-05-06T00:34:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjUwMQ==", "bodyText": "which domain resource?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486501", "createdAt": "2020-05-06T00:34:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(\n+      String domainUid,\n+      String namespace,\n+      String image\n+  ) {\n+    String patch = \n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/image\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            image);\n+    logger.info(\"About to patch the domain resource with:\\n\" + patch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjU2Nw==", "bodyText": "spelling?\nwhich domain resource? which image?\nmake the log messages more informative", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486567", "createdAt": "2020-05-06T00:35:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(\n+      String domainUid,\n+      String namespace,\n+      String image\n+  ) {\n+    String patch = \n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/image\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            image);\n+    logger.info(\"About to patch the domain resource with:\\n\" + patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainUid,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch the domain resource with a  a different image.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjY4MQ==", "bodyText": "no logging?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486681", "createdAt": "2020-05-06T00:35:38Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -693,6 +1063,38 @@ private void checkPodCreated(String podName, String domainUid, String domNamespa\n \n   }\n \n+  private void patchAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String image\n+  ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Njg5MQ==", "bodyText": "should be checking the return values, or catching exceptions, or something here...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486891", "createdAt": "2020-05-06T00:36:35Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -693,6 +1063,38 @@ private void checkPodCreated(String podName, String domainUid, String domNamespa\n \n   }\n \n+  private void patchAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String image\n+  ) {\n+    // modify the domain resource to use the new image\n+    patchDomainResourceIamge(domainUid, namespace, image);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzA4NQ==", "bodyText": "duplicate code - refactor", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487085", "createdAt": "2020-05-06T00:37:23Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 635}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzE0OA==", "bodyText": "duplication", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487148", "createdAt": "2020-05-06T00:37:37Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 662}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzMwNA==", "bodyText": "initialize?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487304", "createdAt": "2020-05-06T00:38:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 741}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzQzNA==", "bodyText": "surely you're not pinging it  - fix this doc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487434", "createdAt": "2020-05-06T00:38:47Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 743}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzU0Ng==", "bodyText": "it's - possessive", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487546", "createdAt": "2020-05-06T00:39:04Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzQzNA=="}, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 743}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzYwMw==", "bodyText": "application", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487603", "createdAt": "2020-05-06T00:39:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 744}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzY5Nw==", "bodyText": "fix the problem then - don't work around it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487697", "createdAt": "2020-05-06T00:39:34Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 745}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Nzk0OQ==", "bodyText": "do while hides important information - use while instead, it is much clearer", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487949", "createdAt": "2020-05-06T00:40:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 748}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODA2OA==", "bodyText": "same", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488068", "createdAt": "2020-05-06T00:41:11Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 793}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODE3NA==", "bodyText": "running or ready? they are two different things", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488174", "createdAt": "2020-05-06T00:41:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");\n+        return false;\n       }\n-    } else {\n-      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);\n     }\n+    return true;\n   }\n \n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(namespace, podName, null, true, READ_STATE_COMMAND));\n+    if (execResult.exitValue() == 0) {\n+      logger.info(\"execResult: \" + execResult);\n+      assertEquals(\"RUNNING\", execResult.stdout(),\n+          \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 808}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODMxMg==", "bodyText": "what is \"ready command\"?  do you mean readiness probe?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488312", "createdAt": "2020-05-06T00:41:56Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");\n+        return false;\n       }\n-    } else {\n-      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);\n     }\n+    return true;\n   }\n \n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(namespace, podName, null, true, READ_STATE_COMMAND));\n+    if (execResult.exitValue() == 0) {\n+      logger.info(\"execResult: \" + execResult);\n+      assertEquals(\"RUNNING\", execResult.stdout(),\n+          \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+    } else {\n+      fail(\"Ready command failed with exit status code: \" + execResult.exitValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 810}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODQxNQ==", "bodyText": "what pod? do you mean the namespace to create the utility pod in?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488415", "createdAt": "2020-05-06T00:42:25Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -540,7 +540,8 @@ public static JsonObject createDockerConfigJson(String username, String password\n   /**\n    * Execute a command in a container.\n    *\n-   * @param pod The pod where the command is to be run\n+   * @param namespace The Kubernertes namespace that the pod is in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODUxNA==", "bodyText": "this implies the pod already exists, is that what you intended?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488514", "createdAt": "2020-05-06T00:42:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -540,7 +540,8 @@ public static JsonObject createDockerConfigJson(String username, String password\n   /**\n    * Execute a command in a container.\n    *\n-   * @param pod The pod where the command is to be run\n+   * @param namespace The Kubernertes namespace that the pod is in\n+   * @param podName The name of the pod where the command is to be run", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODU4OA==", "bodyText": "magic value (null)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488588", "createdAt": "2020-05-06T00:43:13Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -550,9 +551,19 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws ApiException if Kubernetes client API call fails\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n-  public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n-      throws IOException, ApiException, InterruptedException {\n+  public static ExecResult execCommand(\n+      String namespace,\n+      String podName,\n+      String containerName,\n+      boolean redirectToStdout,\n+      String... command\n+  ) throws IOException, ApiException, InterruptedException {\n+    final V1Pod pod = oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n+        .getPod(namespace, null, podName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODcyMQ==", "bodyText": "space before and after colon", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488721", "createdAt": "2020-05-06T00:43:45Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -52,22 +55,29 @@ private AppBuilder params(AppParams params) {\n   public boolean build() {\n     // prepare the archive directory and copy over the app src\n     try {\n-      cleanupDirectory(ARCHIVE_DIR);\n+      cleanupDirectory(ARCHIVE_SRC_DIR);\n       checkDirectory(ARCHIVE_SRC_DIR);\n-      copyFolder(\n-          APP_DIR + \"/\" + params.srcDir(), \n-          ARCHIVE_SRC_DIR);\n-    } catch (IOException ioe) {    \n-      logger.warning(\"Failed to get the directory \" + ARCHIVE_DIR + \" ready\");\n+      for (String item: params.srcDirList()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODgzNw==", "bodyText": "i don't think you can catch a runtime exception?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488837", "createdAt": "2020-05-06T00:44:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -52,22 +55,29 @@ private AppBuilder params(AppParams params) {\n   public boolean build() {\n     // prepare the archive directory and copy over the app src\n     try {\n-      cleanupDirectory(ARCHIVE_DIR);\n+      cleanupDirectory(ARCHIVE_SRC_DIR);\n       checkDirectory(ARCHIVE_SRC_DIR);\n-      copyFolder(\n-          APP_DIR + \"/\" + params.srcDir(), \n-          ARCHIVE_SRC_DIR);\n-    } catch (IOException ioe) {    \n-      logger.warning(\"Failed to get the directory \" + ARCHIVE_DIR + \" ready\");\n+      for (String item: params.srcDirList()) {\n+        copyFolder(\n+            APP_DIR + \"/\" + item, \n+            ARCHIVE_SRC_DIR);\n+      }\n+    } catch (IOException | RuntimeException e) {    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODk4NA==", "bodyText": "are -> is", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488984", "createdAt": "2020-05-06T00:44:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppParams.java", "diffHunk": "@@ -3,30 +3,46 @@\n \n package oracle.weblogic.kubernetes.actions.impl;\n \n+import java.util.List;\n+\n /**\n  * Contains the parameters for creating an application archive.\n  */\n \n public class AppParams {\n \n-  // Location of the source code. \n-  // This is the name of the directory under resources/apps for an application\n-  private String srcDir;\n+  // A list of directories under resources/apps that are part of the application.\n+  // Note: the order of the directory names are significant. Files are copied into", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTAyOQ==", "bodyText": "what if it is a war?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489029", "createdAt": "2020-05-06T00:44:46Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppParams.java", "diffHunk": "@@ -3,30 +3,46 @@\n \n package oracle.weblogic.kubernetes.actions.impl;\n \n+import java.util.List;\n+\n /**\n  * Contains the parameters for creating an application archive.\n  */\n \n public class AppParams {\n \n-  // Location of the source code. \n-  // This is the name of the directory under resources/apps for an application\n-  private String srcDir;\n+  // A list of directories under resources/apps that are part of the application.\n+  // Note: the order of the directory names are significant. Files are copied into\n+  // the staging directory in this order. \n+  private List<String> srcDirList;\n+  \n+  // The name of the final ear file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTE2Ng==", "bodyText": "spelling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489166", "createdAt": "2020-05-06T00:45:17Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java", "diffHunk": "@@ -66,4 +69,38 @@ public boolean execute() {\n       return false;\n     }\n   }\n+  \n+  /**\n+   * Execute a command and verify the response.\n+   *\n+   * @params expectedResponse the expected response to verify", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTMwNw==", "bodyText": "this seems a bit weak", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489307", "createdAt": "2020-05-06T00:45:53Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java", "diffHunk": "@@ -66,4 +69,38 @@ public boolean execute() {\n       return false;\n     }\n   }\n+  \n+  /**\n+   * Execute a command and verify the response.\n+   *\n+   * @params expectedResponse the expected response to verify\n+   * @return true if the execution succeeded and response contains the expected value\n+   */\n+  public boolean executeAndVerify(String expectedResponse) {\n+    if (params.verbose()) {\n+      logger.info(\"Executing command {0}\", params.command());\n+    }\n+    try {\n+      ExecResult result = ExecCommand.exec(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTUxOA==", "bodyText": "this sounds like a problem", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489518", "createdAt": "2020-05-06T00:46:44Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1915,7 +1915,9 @@ public static ExecResult exec(V1Pod pod, String containerName, boolean redirectT\n \n       // wait for reading thread to finish any last remaining output\n       if (out != null) {\n-        out.join();\n+        // need to time out here, otherwise the command can take almost one minute to return.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDE5OQ==", "bodyText": "i am not understand why we want to check inside the pod, rather than from outside... maybe i am  missing something", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420490199", "createdAt": "2020-05-06T00:49:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -186,6 +223,68 @@ public static boolean dockerImageExists(String imageName, String imageTag) {\n     return WitAssertion.doesImageExist(imageName, imageTag);\n   }\n \n+  /**\n+   * Check if an application is accessible inside a WebLogic server pod using", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMjM2MQ==", "bodyText": "is supposed to use -> is expected to be using", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420502361", "createdAt": "2020-05-06T01:39:44Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -77,6 +77,35 @@ public static boolean doesCrdExist() throws ApiException {\n     };\n   }\n \n+  /**\n+   * Check if the domain resource has been patched with a new image.\n+   *\n+   * @param domainUID identifier of the domain resource\n+   * @param namespace Kubernetes namespace in which the domain exists\n+   * @param image name of the image that the pod is supposed to use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMjk0OQ==", "bodyText": "we should probably make the container an optional param, pods can have more than one container, and probably will in some tests, e.g. when we have a fluentd sidecar.  if the pod has only one container, it is obvious which one to use.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420502949", "createdAt": "2020-05-06T01:42:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzE0MQ==", "bodyText": "spelling", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503141", "createdAt": "2020-05-06T01:43:21Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(\n+      String namespace,\n+      String domainUid,\n+      String podName,\n+      String image\n+  ) throws ApiException {\n+    boolean podPatched = false;\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null && pod.getSpec() != null) {\n+      List<V1Container> containers = pod.getSpec().getContainers();\n+      for (V1Container container : containers) {\n+        // look for the weblogic server container", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzI1NA==", "bodyText": "do we need a null check on containers?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503254", "createdAt": "2020-05-06T01:43:48Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(\n+      String namespace,\n+      String domainUid,\n+      String podName,\n+      String image\n+  ) throws ApiException {\n+    boolean podPatched = false;\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null && pod.getSpec() != null) {\n+      List<V1Container> containers = pod.getSpec().getContainers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzM3Mg==", "bodyText": "space after colon, not before", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503372", "createdAt": "2020-05-06T01:44:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -198,10 +234,11 @@ public static V1Pod getPod(String namespace, String labelSelector, String podNam\n         );\n     for (V1Pod item : v1PodList.getItems()) {\n       if (item.getMetadata().getName().startsWith(podName.trim())) {\n-        logger.info(\"Pod Name: \" + item.getMetadata().getName());\n-        logger.info(\"Pod Namespace: \" + item.getMetadata().getNamespace());\n-        logger.info(\"Pod UID: \" + item.getMetadata().getUid());\n-        logger.info(\"Pod Status: \" + item.getStatus().getPhase());\n+        logger.fine(String.format(\"Pod Name :%s, Pod Namespace :%s, Pod UID :%s, Pod Status :%s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzQ1OQ==", "bodyText": "directory", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503459", "createdAt": "2020-05-06T01:44:37Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -31,7 +35,7 @@ public static void checkDirectory(String dir) {\n     File file = new File(dir);\n     if (!(file.exists() && file.isDirectory())) {\n       file.mkdirs();\n-      logger.info(\"Made a new dir \" + dir);\n+      logger.fine(\"Made a new dir {0}.\", dir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzUxNA==", "bodyText": "to where?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503514", "createdAt": "2020-05-06T01:44:50Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -98,6 +102,7 @@ public static void copyFolder(String srcDir, String destDir) throws IOException\n         try {\n           copy(source, destPath.resolve(srcPath.relativize(source)));\n         } catch (IOException e) {\n+          logger.severe(String.format(\"Failed to copy file %s\", source), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d735a7e0e268ec0ecfabf6c4e6e0a889e50b8757", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d735a7e0e268ec0ecfabf6c4e6e0a889e50b8757", "committedDate": "2020-05-06T18:17:39Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "072aa1f16708bf5c6b7b8cf7d980b5cfce9c7760", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/072aa1f16708bf5c6b7b8cf7d980b5cfce9c7760", "committedDate": "2020-05-06T19:21:56Z", "message": "Address one more comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3003cd59b6cd0a216ea31f5ddf8775368dbd2be6", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3003cd59b6cd0a216ea31f5ddf8775368dbd2be6", "committedDate": "2020-05-06T20:41:24Z", "message": "Minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d67a4a9473bde201f727a873158bbea6a3ddda6b", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d67a4a9473bde201f727a873158bbea6a3ddda6b", "committedDate": "2020-05-06T22:03:48Z", "message": "More logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "745f8831775d3549bc842e5599bf5a9829106026", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/745f8831775d3549bc842e5599bf5a9829106026", "committedDate": "2020-05-08T16:46:37Z", "message": "Minor comment update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5c3a0d0c4df62015eaeca7df87106a9c18a051d", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b5c3a0d0c4df62015eaeca7df87106a9c18a051d", "committedDate": "2020-05-08T17:57:00Z", "message": "Make log messages more informative"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDU2OTQw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-408456940", "createdAt": "2020-05-08T19:03:52Z", "commit": {"oid": "b5c3a0d0c4df62015eaeca7df87106a9c18a051d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxOTowMzo1M1rOGSwPyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxOTowMzo1M1rOGSwPyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxODAyNw==", "bodyText": "I think we want to clean up the directory once before all tests run. This can be moved to ImageBuilders.beforeAll()?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r422318027", "createdAt": "2020-05-08T19:03:53Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -136,7 +155,20 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // create standard, reusable retry/backoff policy\n     withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n         .and().with().pollInterval(10, SECONDS)\n-        .atMost(5, MINUTES).await();\n+        .atMost(6, MINUTES).await();\n+\n+    // create a reusable quick retry policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(4, SECONDS)\n+        .atMost(10, SECONDS).await();\n+\n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c3a0d0c4df62015eaeca7df87106a9c18a051d"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea8c9552404cb16479feabe225717430958e2f0a", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ea8c9552404cb16479feabe225717430958e2f0a", "committedDate": "2020-05-08T21:18:14Z", "message": "Address a new review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8bded1674fb806172e05fea998111132570e6d5", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a8bded1674fb806172e05fea998111132570e6d5", "committedDate": "2020-05-08T21:49:30Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e3f2412b84b59e609631183d56e7add5b966bef", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0e3f2412b84b59e609631183d56e7add5b966bef", "committedDate": "2020-05-08T22:01:51Z", "message": "Fix a minor merge error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NDk1MjI1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-409495225", "createdAt": "2020-05-11T20:13:19Z", "commit": {"oid": "0e3f2412b84b59e609631183d56e7add5b966bef"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDoxMzoyMFrOGTrqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMDozMjoxMVrOGTsSOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5MTUxNA==", "bodyText": "action methods in TestActions.java should be calling other impl methods, no actual implementation should be here I think ..This may be moved to Kubernetes.java prim?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r423291514", "createdAt": "2020-05-11T20:13:20Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -588,9 +589,21 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws ApiException if Kubernetes client API call fails\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n-  public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n-      throws IOException, ApiException, InterruptedException {\n+  public static ExecResult execCommand(\n+      String namespace,\n+      String podName,\n+      String containerName,\n+      boolean redirectToStdout,\n+      String... command\n+  ) throws IOException, ApiException, InterruptedException {\n+    // get the pod given the namespace and name of the pod\n+    // no label selector is needed (thus null below)\n+    final V1Pod pod = oracle.weblogic.kubernetes.assertions.impl.Kubernetes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e3f2412b84b59e609631183d56e7add5b966bef"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMTY4OQ==", "bodyText": "name the model file name with a descriptive name, for example I renamed model1-wls.yaml to model-basicdomain-singlecluster-sampleapp-wls.yaml in my PR.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r423301689", "createdAt": "2020-05-11T20:32:11Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/resources/wdt-models/model2-wls.yaml", "diffHunk": "@@ -0,0 +1,38 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e3f2412b84b59e609631183d56e7add5b966bef"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a146531f22e0d9b6d8f92f7d40c04a262d810d6", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8a146531f22e0d9b6d8f92f7d40c04a262d810d6", "committedDate": "2020-05-11T23:57:38Z", "message": "Address more review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24f2579dd20243a773b3b44107772629f34a5de9", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/24f2579dd20243a773b3b44107772629f34a5de9", "committedDate": "2020-05-12T00:07:42Z", "message": "Update javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34d51a17b29308277775f55c8b625e111fbe813f", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/34d51a17b29308277775f55c8b625e111fbe813f", "committedDate": "2020-05-12T15:40:03Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c352f594a296e8685d9ac8aff883e216ec096101", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c352f594a296e8685d9ac8aff883e216ec096101", "committedDate": "2020-05-12T15:51:15Z", "message": "Fix merge issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6b2d51d4107d0e54366635b411646fdcd9e04d64", "committedDate": "2020-05-12T18:55:49Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/extensions/ImageBuilders.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDAxNzYw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-410401760", "createdAt": "2020-05-12T20:35:46Z", "commit": {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDozNTo0NlrOGUX9xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDozNTo0NlrOGUX9xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzM0OQ==", "bodyText": "This is what is breaking your test. You need to add REPO_NAME all of the time.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424017349", "createdAt": "2020-05-12T20:35:46Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -494,6 +738,189 @@ void tearDown() {\n     assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace1),\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n+\n+    // delete the domain images created in the test class\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n+  }\n+\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to a registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login to registry {0}\", REPO_REGISTRY);\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry {1}\", image, REPO_REGISTRY);\n+      assertTrue(dockerPush(image), String.format(\"docker push failed for image %s\", image));\n+    }\n+  }\n+\n+  private String createUniqueImageTag() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    return dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+  }\n+\n+  private String createImageName(String baseImageName) {\n+    // Add repository name in image name for Jenkins runs\n+    return REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? baseImageName : REPO_NAME + baseImageName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64"}, "originalPosition": 410}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDAyNDk4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-410402498", "createdAt": "2020-05-12T20:36:54Z", "commit": {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDozNjo1NFrOGUYAEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDozNjo1NFrOGUYAEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzkzNg==", "bodyText": "This is broken too.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424017936", "createdAt": "2020-05-12T20:36:54Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -494,6 +738,189 @@ void tearDown() {\n     assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace1),\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n+\n+    // delete the domain images created in the test class\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n+  }\n+\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to a registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64"}, "originalPosition": 392}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4da2f19a4e6235f141dd77f3268f2a1d5c5f50", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3b4da2f19a4e6235f141dd77f3268f2a1d5c5f50", "committedDate": "2020-05-12T21:08:54Z", "message": "Update the push image code to check REPO_NAME"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "294decc6e04c463406ddafbdb92ea0f3561ef917", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/294decc6e04c463406ddafbdb92ea0f3561ef917", "committedDate": "2020-05-12T21:51:36Z", "message": "remove double adding REMO_NAME"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70fbeb1b8ef8598db5aa0d36ed05c651864c24b5", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/70fbeb1b8ef8598db5aa0d36ed05c651864c24b5", "committedDate": "2020-05-12T22:02:41Z", "message": "Change baseImageName to image Name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMTE1MDI4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-411115028", "createdAt": "2020-05-13T16:49:46Z", "commit": {"oid": "70fbeb1b8ef8598db5aa0d36ed05c651864c24b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo0OTo0NlrOGU6p2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo0OTo0NlrOGU6p2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NTY4OQ==", "bodyText": "I think the new tests in this PR should be added in a new or other existing It class where the domain creation/existence is a prerequisite, then you don't need to order the tests. Here it is assumed that the domain is up and running by ordering the tests where it should have been verified in beforeEach method. This is a late comment in this PR. If everyone agrees, changes can be made in another PR.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424585689", "createdAt": "2020-05-13T16:49:46Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -473,12 +525,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70fbeb1b8ef8598db5aa0d36ed05c651864c24b5"}, "originalPosition": 178}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "034a9b740bcb9cca6fab6ede2ecb1f609c225d1a", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/034a9b740bcb9cca6fab6ede2ecb1f609c225d1a", "committedDate": "2020-05-14T15:51:24Z", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/TestConstants.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNjI0OTk0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-412624994", "createdAt": "2020-05-15T12:59:01Z", "commit": {"oid": "034a9b740bcb9cca6fab6ede2ecb1f609c225d1a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTIwNTk2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#pullrequestreview-413120596", "createdAt": "2020-05-17T01:45:48Z", "commit": {"oid": "034a9b740bcb9cca6fab6ede2ecb1f609c225d1a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d37858e2048e93323bdd4904f6ac6e25eda7dd78", "author": {"user": {"login": "doxiao", "name": "Dongbo Xiao"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d37858e2048e93323bdd4904f6ac6e25eda7dd78", "committedDate": "2020-05-17T13:31:13Z", "message": "Fix a typo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4738, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}