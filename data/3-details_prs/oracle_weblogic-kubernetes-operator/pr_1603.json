{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Nzg2MDQ0", "number": 1603, "title": "Cleanup artifacts in Kubernetes cluster", "bodyText": "Deletes all the artifacts in the namespaces left behind by the tests.\nFirst it deletes the WebLogic domain if exists, then uninstalls the operator\nFinally deletes everything else in the namespace. Waits for up to 3 minutes for the cleanup to be complete.", "createdAt": "2020-04-27T22:43:41Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603", "merged": true, "mergeCommit": {"oid": "07f468b107b898ebee221f01a10a2fccd409e29e"}, "closed": true, "closedAt": "2020-05-01T19:39:50Z", "author": {"login": "sankarpn"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcb3DX3AH2gAyNDA5Nzg2MDQ0Ojc5NzMyNmNhMGQzYTVlMmU1NGRkZjgwOWE5ODdmZjQ0NzFhNWVlMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdEG2HgH2gAyNDA5Nzg2MDQ0OjZkZTEwYTI1NTIwNzkxNTZhMDgxOWFjOGI5YzA3ZGNkMzgyZWQzMDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "797326ca0d3a5e2e54ddf809a987ff4471a5ee12", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/797326ca0d3a5e2e54ddf809a987ff4471a5ee12", "committedDate": "2020-04-27T22:30:30Z", "message": "Adding cleanup methods to cleanup all the Kubernetyes artifacts left\nbehind by the test class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47eab4498b7adc51c85e47bd445a266a1cd5dcb8", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/47eab4498b7adc51c85e47bd445a266a1cd5dcb8", "committedDate": "2020-04-27T22:35:49Z", "message": "Leave the cluster artifacts untouched"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7626b31eef19bfc1c295474977873486b0e740dc", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7626b31eef19bfc1c295474977873486b0e740dc", "committedDate": "2020-04-27T23:28:42Z", "message": "correct the typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79e3de9f45c17067beacf341227d814a500cc51", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a79e3de9f45c17067beacf341227d814a500cc51", "committedDate": "2020-04-28T05:35:54Z", "message": "cleanup javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a80b6289f74705c05595bd3a1e513a45393b8205", "committedDate": "2020-04-28T05:41:11Z", "message": "add logs for pods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxODkzMTEy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-401893112", "createdAt": "2020-04-28T14:28:44Z", "commit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDoyODo0NFrOGNW48g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDoyODo0NFrOGNW48g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA==", "bodyText": "This is still synchronous by namespace, correct?  It will be curious to see how long clean-up takes.  Perhaps because clean-up happens for each test suite as that suite finishes, maybe this is parallel enough.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r416659698", "createdAt": "2020-04-28T14:28:44Z", "author": {"login": "rjeberhard"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxODkzNTMw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-401893530", "createdAt": "2020-04-28T14:29:07Z", "commit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjM1MzI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-402235329", "createdAt": "2020-04-28T21:45:13Z", "commit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzE4MTQ0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-402318144", "createdAt": "2020-04-29T01:31:52Z", "commit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTozMTo1MlrOGNs54w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMTo1Mzo0MFrOGNtNYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDM4Nw==", "bodyText": "the -> a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020387", "createdAt": "2020-04-29T01:31:52Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -242,18 +260,61 @@ public static boolean createDeployment(String deploymentYaml) {\n   }\n \n   /**\n-   * List all deployments in a given namespace.\n-   * @param namespace Namespace in which to list the deployments\n-   * @return V1DeploymentList of deployments in the Kubernetes cluster\n+   * List deployments in the given namespace.\n+   *\n+   * @param namespace namespace in which to list the deployments\n+   * @return list of deployment objects as {@link V1DeploymentList}\n+   * @throws ApiException when listing fails\n    */\n-  public static V1DeploymentList listDeployments(String namespace) {\n-    KubernetesApiResponse<V1DeploymentList> list = deploymentClient.list(namespace);\n-    if (list.isSuccess()) {\n-      return list.getObject();\n-    } else {\n-      logger.warning(\"Failed to list deployments, status code {0}\", list.getHttpStatusCode());\n-      return null;\n+  public static V1DeploymentList listDeployments(String namespace) throws ApiException {\n+    V1DeploymentList deployments;\n+    try {\n+      AppsV1Api apiInstance = new AppsV1Api(apiClient);\n+      deployments = apiInstance.listNamespacedDeployment(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n     }\n+    return deployments;\n+  }\n+\n+  /**\n+   * Delete the deployment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg==", "bodyText": "do we need to instantiate a class, can we not implement this as a static method?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020562", "createdAt": "2020-04-29T01:32:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA==", "bodyText": "does this work? does it actually wait for the delete to complete and then return this?\nalso - this needs to be wrapped in a thread and run with a timeout -- you can create a JIRA to add that later, if you want to do it in a separate PR.\nas written, this will fail if a finalizer prevents the ns deletion from completing", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020948", "createdAt": "2020-04-29T01:34:30Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -485,9 +580,16 @@ public static boolean deleteNamespace(String name) {\n     KubernetesApiResponse<V1Namespace> response = namespaceClient.delete(name);\n \n     if (!response.isSuccess()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ==", "bodyText": "finalizer can also prevent this from working - also needs to be run in a thread with a timeout", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021055", "createdAt": "2020-04-29T01:35:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -565,7 +667,7 @@ private static JsonElement convertToJson(Object obj) {\n    */\n   public static boolean deleteDomainCustomResource(String domainUid, String namespace) {\n \n-    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid);\n+    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid, deleteOptions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng==", "bodyText": "thread/timeout", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021096", "createdAt": "2020-04-29T01:35:19Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -989,7 +1091,7 @@ public static boolean createPvc(V1PersistentVolumeClaim persistentVolumeClaim) t\n    */\n   public static boolean deletePv(String name) {\n \n-    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name);\n+    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name, deleteOptions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTIwMw==", "bodyText": "include the ns in the message", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021203", "createdAt": "2020-04-29T01:35:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTI1MA==", "bodyText": "delete a job", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021250", "createdAt": "2020-04-29T01:36:03Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTM2Ng==", "bodyText": "...deletion of job fails", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021366", "createdAt": "2020-04-29T01:36:26Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA==", "bodyText": "delete a replica set", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021464", "createdAt": "2020-04-29T01:36:49Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTU1Mg==", "bodyText": "curious as to where we need this - i don't think we use any rs's?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021552", "createdAt": "2020-04-29T01:37:11Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTYzMQ==", "bodyText": "delete a role", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021631", "createdAt": "2020-04-29T01:37:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg==", "bodyText": "role or rolebinding? javadoc and code don't match", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021722", "createdAt": "2020-04-29T01:38:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTc4OQ==", "bodyText": "namespace is one word", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021789", "createdAt": "2020-04-29T01:38:23Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTg4MA==", "bodyText": "a role\nrole or clusterrole? javadoc and code don't match", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021880", "createdAt": "2020-04-29T01:38:49Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 571}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTkzNg==", "bodyText": "was successful", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021936", "createdAt": "2020-04-29T01:38:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 574}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjAwNA==", "bodyText": "cluster roles", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022004", "createdAt": "2020-04-29T01:39:16Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjA1Mw==", "bodyText": "was", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022053", "createdAt": "2020-04-29T01:39:31Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 629}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjE1OA==", "bodyText": "listNamespacesRoles plural", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022158", "createdAt": "2020-04-29T01:39:56Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 658}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjIxOA==", "bodyText": "list ingresses in the given namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022218", "createdAt": "2020-04-29T01:40:11Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 681}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI2OQ==", "bodyText": "listNamespacedIngresses", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022269", "createdAt": "2020-04-29T01:40:27Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 687}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI5OQ==", "bodyText": "get ingress in the ....", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022299", "createdAt": "2020-04-29T01:40:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 711}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjM2Mw==", "bodyText": "name of the ingress - no such thing as an \"ingress extension\"", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022363", "createdAt": "2020-04-29T01:40:57Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 714}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQxNQ==", "bodyText": "Ingress object", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022415", "createdAt": "2020-04-29T01:41:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 715}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQ1MA==", "bodyText": "getNamespacedIngress", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022450", "createdAt": "2020-04-29T01:41:15Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null\n+   * @throws ApiException when get fails\n+   */\n+  public static ExtensionsV1beta1Ingress getIngressExtension(String namespace, String name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 718}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjcxMQ==", "bodyText": "this is just for a single test right -- so this comment is wrong", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022711", "createdAt": "2020-04-29T01:42:07Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjgxNw==", "bodyText": "for up to three minutes\n3 min is not long enough -these things can take longer,  try 10", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022817", "createdAt": "2020-04-29T01:42:35Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw==", "bodyText": "there could be a domain in the operator namespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022927", "createdAt": "2020-04-29T01:43:09Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ==", "bodyText": "there could be an operator in any of these namespaces -- i don't think you need this isOperatorNamespace business", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023045", "createdAt": "2020-04-29T01:43:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ==", "bodyText": "try { \n  Thread.sleep(30 *1000);\n} catch (InterruptedException e) { \n  //ignore \n}", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023295", "createdAt": "2020-04-29T01:44:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzQwNw==", "bodyText": "also, why? :)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023407", "createdAt": "2020-04-29T01:45:18Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzU1Nw==", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023557", "createdAt": "2020-04-29T01:45:58Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzcwMw==", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023703", "createdAt": "2020-04-29T01:46:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkxOQ==", "bodyText": "what artifacts?  rename this to something like nothingFoundInNamespace", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023919", "createdAt": "2020-04-29T01:47:15Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzk4OQ==", "bodyText": "delete all domains in the given namespace, if any exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023989", "createdAt": "2020-04-29T01:47:41Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA==", "bodyText": "uninstall the operator", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024048", "createdAt": "2020-04-29T01:47:59Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDE2MQ==", "bodyText": "feels the the release name should be a param, or you should call this uninstallWebLogicOperators (plural)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024161", "createdAt": "2020-04-29T01:48:32Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDIzMA==", "bodyText": "this assumes (possibly incorrectly) that there is only one and that you know what its name is", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024230", "createdAt": "2020-04-29T01:48:54Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw==", "bodyText": "unreliable and possibly useless anyway\nwould give wrong results if the pod was not running", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024417", "createdAt": "2020-04-29T01:49:28Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDUwMA==", "bodyText": "noArtifactsFound or something like that -- see earlier comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024500", "createdAt": "2020-04-29T01:49:54Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU0NQ==", "bodyText": ".. if no artifacts exist in ..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024545", "createdAt": "2020-04-29T01:50:06Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU5NQ==", "bodyText": "doesNotExist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024595", "createdAt": "2020-04-29T01:50:17Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDY0OA==", "bodyText": "probably should list which artifacts...", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024648", "createdAt": "2020-04-29T01:50:39Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDcxOQ==", "bodyText": "check if any domains exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024719", "createdAt": "2020-04-29T01:50:59Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDgzOA==", "bodyText": "check if any replica sets exist (and so on through the rest of this method)", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024838", "createdAt": "2020-04-29T01:51:20Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA==", "bodyText": "this won't work - the fact that you are looking through the namespace means it must exist", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025064", "createdAt": "2020-04-29T01:52:07Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA==", "bodyText": "i'd be stunned if this never threw an exception or failed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025174", "createdAt": "2020-04-29T01:52:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTIzNA==", "bodyText": ".. in the given ..", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025234", "createdAt": "2020-04-29T01:52:55Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTM3Ng==", "bodyText": "probably should do deployments before pvcs, config maps, secrets, rs's, otherwise those could fail", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025376", "createdAt": "2020-04-29T01:53:40Z", "author": {"login": "markxnelson"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        Kubernetes.deleteDomainCustomResource(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete domains\");\n+    }\n+\n+    // Delete replicasets\n+    try {\n+      for (var item : Kubernetes.listReplicaSets(namespace).getItems()) {\n+        Kubernetes.deleteReplicaSet(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete replica sets\");\n+    }\n+\n+    // Delete jobs\n+    try {\n+      for (var item : Kubernetes.listJobs(namespace).getItems()) {\n+        Kubernetes.deleteJob(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete jobs\");\n+    }\n+\n+    // Delete configmaps\n+    try {\n+      for (var item : Kubernetes.listConfigMaps(namespace).getItems()) {\n+        Kubernetes.deleteConfigMap(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete config maps\");\n+    }\n+\n+    // Delete secrets\n+    try {\n+      for (var item : Kubernetes.listSecrets(namespace).getItems()) {\n+        Kubernetes.deleteSecret(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete secrets\");\n+    }\n+\n+    // Delete pv\n+    try {\n+      for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(item)\n+            .map(pvc -> pvc.getMetadata())\n+            .map(metadata -> metadata.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+        for (var pv : Kubernetes.listPersistentVolumes(\n+            String.format(\"weblogic.domainUid = %s\", label)).getItems()) {\n+          Kubernetes.deletePv(pv.getMetadata().getName());\n+        }\n+      }\n+    } catch (ApiException ex) {\n+      logger.warning(ex.getResponseBody());\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete persistent volumes\");\n+    }\n+\n+    // Delete deployments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 456}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37365e01f726fc9578ef5368e18f26b56ab61f66", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/37365e01f726fc9578ef5368e18f26b56ab61f66", "committedDate": "2020-04-29T15:24:50Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into itmiiests-cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ef1a862ba9a5d96074b16f022657cab7c76492", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/87ef1a862ba9a5d96074b16f022657cab7c76492", "committedDate": "2020-04-29T16:39:30Z", "message": "Addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "716e5e6b37794ee915c94675e217a26d351af8b2", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/716e5e6b37794ee915c94675e217a26d351af8b2", "committedDate": "2020-04-29T18:10:41Z", "message": "Refactor the methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODQ5ODAy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-402849802", "createdAt": "2020-04-29T16:44:37Z", "commit": {"oid": "87ef1a862ba9a5d96074b16f022657cab7c76492"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo0NDozN1rOGOHr2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODowOTozM1rOGOK84w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1OTE2Mg==", "bodyText": "This is from the kubernetes client-java API library, we are not implementing this.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417459162", "createdAt": "2020-04-29T16:44:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MzEzMQ==", "bodyText": "This is not synchronous . As seen from the log message in the method.\n\"Received after-deletion status of the requested object, will be deleting namespace in background!\"\nWe issue the delete request and wait for it be deleted in the calling method.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417463131", "createdAt": "2020-04-29T16:50:32Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -485,9 +580,16 @@ public static boolean deleteNamespace(String name) {\n     KubernetesApiResponse<V1Namespace> response = namespaceClient.delete(name);\n \n     if (!response.isSuccess()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDQzNw==", "bodyText": "Again, this is not synchronous. Will be deleting the domain the background.\nThe calling method waits for it to be deleted.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464437", "createdAt": "2020-04-29T16:52:26Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -565,7 +667,7 @@ private static JsonElement convertToJson(Object obj) {\n    */\n   public static boolean deleteDomainCustomResource(String domainUid, String namespace) {\n \n-    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid);\n+    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid, deleteOptions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDkzMg==", "bodyText": "please see my similar comment.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464932", "createdAt": "2020-04-29T16:53:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -989,7 +1091,7 @@ public static boolean createPvc(V1PersistentVolumeClaim persistentVolumeClaim) t\n    */\n   public static boolean deletePv(String name) {\n \n-    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name);\n+    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name, deleteOptions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NTE3OA==", "bodyText": "fixed it", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417465178", "createdAt": "2020-04-29T16:53:31Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzA0Mw==", "bodyText": "Removed the namespace check to figure out if it is operator or domain anmespace and trying to delete domain and operator in all namespaces.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417467043", "createdAt": "2020-04-29T16:56:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3MTA5NA==", "bodyText": "see my above comment", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417471094", "createdAt": "2020-04-29T17:02:25Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3Mzg1Nw==", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...\n\nThere is already a 30 second wait(Thread.sleep)  before this right ? The pollDelay is for the initial delay to start polling every pollInterval seconds which is 10 seconds.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417473857", "createdAt": "2020-04-29T17:06:48Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NDA2Mw==", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point\n\nI changed it to 10 minutes", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417474063", "createdAt": "2020-04-29T17:07:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwODgyMw==", "bodyText": "removed it.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417508823", "createdAt": "2020-04-29T18:02:40Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMDQ1OQ==", "bodyText": "The intention of the method is to check if all the artifacts in the namespace was deleted and namespace itself deleted.\nWhen this check is made , the delete on the namespace was already called. So it is working, to tell whether the namespace exists or not.\nSince you asked to rename this method to nothingFoundInNamespace I cannot have this check for namespace here.\nMoved the namespace and namespace delete to separate methods.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417510459", "createdAt": "2020-04-29T18:05:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjY3NQ==", "bodyText": "I am catching the exceptions in each delete operation. If I don't catch it inside this method then this method will end prematurely if there is uncaught exceptions and the delete will be only partial.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417512675", "createdAt": "2020-04-29T18:09:33Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA=="}, "originalCommit": {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205"}, "originalPosition": 384}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a23da218815c4087bb8f0d0def887e387c6fe007", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a23da218815c4087bb8f0d0def887e387c6fe007", "committedDate": "2020-04-29T18:45:21Z", "message": "javadoc fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8da0ef56096af5bba413768b2bb264ed5d3b8394", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8da0ef56096af5bba413768b2bb264ed5d3b8394", "committedDate": "2020-04-30T15:26:21Z", "message": "Fix javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MDA2NDI2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#pullrequestreview-404006426", "createdAt": "2020-05-01T03:38:20Z", "commit": {"oid": "8da0ef56096af5bba413768b2bb264ed5d3b8394"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6de10a2552079156a0819ac8b9c07dcd382ed304", "author": {"user": {"login": "sankarpn", "name": "Sankar Periyathambi Neelakandan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6de10a2552079156a0819ac8b9c07dcd382ed304", "committedDate": "2020-05-01T16:16:59Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into itmiiests-cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4714, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}