{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzc4MTM5", "number": 1953, "title": "Unit test and fix detection of stranded namespaces", "bodyText": "Reworked the namespace list logic to eliminate the ActionStep and move the post-processing to after all of the domain namespaces have been identified. Simplified the domain selection logic to move it into the enum, and varied the namespaces selected by the three relevant tests to ensure that they were using different rules.\nNote that this starts a refactoring which will end the superfluous passing of several intermediate values from method to method; however, it cannot proceed until a dependency between the NamespaceListAfterStep and some variables inside Main has been fixed - and that will require some additional unit testing to ensure coverage. I hope to work that in the future, but it was not needed for this bug fix.\nI am running the change on Jenkins at https://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-kind-new/2155/", "createdAt": "2020-09-25T21:24:22Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953", "merged": true, "mergeCommit": {"oid": "d461ebc4ff82f60322af0191fb304d0a57f6aeba"}, "closed": true, "closedAt": "2020-09-29T16:22:47Z", "author": {"login": "russgold"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMciZFAH2gAyNDkzMzc4MTM5OmQ1YzUyM2RkMjAwNDBiYjAyNTIzNjlhYjE1MmY1MDBjYTZlZmY1YTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNqsTJgFqTQ5ODY2NjUyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d5c523dd20040bb0252369ab152f500ca6eff5a6", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d5c523dd20040bb0252369ab152f500ca6eff5a6", "committedDate": "2020-09-25T21:19:14Z", "message": "Unit test and fix detection of stranded namespaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "325f284608a60b662a74508a0437ea28ab8bb871", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/325f284608a60b662a74508a0437ea28ab8bb871", "committedDate": "2020-09-27T01:36:06Z", "message": "Some code simplification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "committedDate": "2020-09-27T02:00:15Z", "message": "put some code back where it started from"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTQyODQ0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#pullrequestreview-497542844", "createdAt": "2020-09-28T14:01:17Z", "commit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDowMToxN1rOHY_JwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNDowMToxN1rOHY_JwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA==", "bodyText": "This is substantially less efficient than the old code as the number of namespaces increases. Why the change? Here's what was done before:\n            namespacesToStartNow = namespacesToStartNow.stream().filter(\n                    Pattern.compile(regexp).asPredicate()).collect(Collectors.toSet());\n\nThe new version compiles the regular expression for every namespace tested.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r495962560", "createdAt": "2020-09-28T14:01:17Z", "author": {"login": "rjeberhard"}, "path": "operator/src/main/java/oracle/kubernetes/operator/Main.java", "diffHunk": "@@ -447,94 +421,237 @@ ServiceWatcher getServiceWatcher(String namespace) {\n     return serviceWatchers.get(namespace);\n   }\n \n-  enum DomainNamespaceSelectionStrategy {\n-    List {\n-      @Override\n-      public Collection<String> getDomainNamespaces() {\n-        return NamespaceHelper.parseNamespaceList(getNamespaceList());\n+  /**\n+   * Returns true if the operator is configured to use a single dedicated namespace for both itself any any domains.\n+   */\n+  public static boolean isDedicated() {\n+    return Namespaces.SelectionStrategy.Dedicated.equals(Namespaces.getSelectionStrategy());\n+  }\n+\n+  public static class Namespaces {\n+    public static final String SELECTION_STRATEGY_KEY = \"domainNamespaceSelectionStrategy\";\n+    /** The key in a Packet of the collection of existing namespaces that are designated as domain namespaces. */\n+    static final String ALL_DOMAIN_NAMESPACES = \"ALL_DOMAIN_NAMESPACES\";\n+\n+    SelectionStrategy selectionStrategy = getSelectionStrategy();\n+    private Collection<String> configuredDomainNamespaces = selectionStrategy.getConfiguredDomainNamespaces();\n+    boolean isFullRecheck;\n+\n+    public Namespaces(boolean isFullRecheck) {\n+      this.isFullRecheck = isFullRecheck;\n+    }\n+\n+    public enum SelectionStrategy {\n+      List {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return getConfiguredDomainNamespaces().contains(namespaceName);\n+        }\n+\n+        @Override\n+        public Collection<String> getConfiguredDomainNamespaces() {\n+          return NamespaceHelper.parseNamespaceList(getNamespaceList());\n+        }\n+\n+        private String getNamespaceList() {\n+          return Optional.ofNullable(HelmAccess.getHelmSpecifiedNamespaceList()).orElse(getInternalNamespaceList());\n+        }\n+\n+        private String getInternalNamespaceList() {\n+          return Optional.ofNullable(getConfiguredNamespaceList()).orElse(getOperatorNamespace());\n+        }\n+\n+        private String getConfiguredNamespaceList() {\n+          return Optional.ofNullable(tuningAndConfig().get(\"domainNamespaces\"))\n+                .orElse(tuningAndConfig().get(\"targetNamespaces\"));\n+        }\n+      },\n+      LabelSelector {\n+        @Override\n+        public String[] getLabelSelectors() {\n+          return new String[] {tuningAndConfig().get(\"domainNamespaceLabelSelector\")};\n+        }\n+\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return true;  // filtering is done by Kubernetes list call\n+        }\n+      },\n+      RegExp {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          try {\n+            return Pattern.compile(getRegExp()).matcher(namespaceName).find();\n+          } catch (PatternSyntaxException e) {\n+            LOGGER.severe(MessageKeys.EXCEPTION, e);\n+            return false;\n+          }\n+        }\n+\n+        private String getRegExp() {\n+          return tuningAndConfig().get(\"domainNamespaceRegExp\");\n+        }\n+      },\n+      Dedicated {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return namespaceName.equals(getOperatorNamespace());\n+        }\n+\n+        @Override\n+        public Collection<String> getConfiguredDomainNamespaces() {\n+          return Collections.singleton(getOperatorNamespace());\n+        }\n+      };\n+\n+      static final String[] NO_SELECTORS = new String[0];\n+\n+      public abstract boolean isSelected(@Nonnull String namespaceName);\n+\n+      public String[] getLabelSelectors() {\n+        return NO_SELECTORS;\n       }\n \n-      private String getNamespaceList() {\n-        return Optional.ofNullable(HelmAccess.getHelmSpecifiedNamespaceList()).orElse(getInternalNamespaceList());\n+      public Collection<String> getConfiguredDomainNamespaces() {\n+        return null;\n       }\n+    }\n \n-      private String getInternalNamespaceList() {\n-        return Optional.ofNullable(getConfiguredNamespaceList()).orElse(getOperatorNamespace());\n+    static @Nonnull Collection<String> getAllDomainNamespaces(Packet packet) {\n+      return Optional.ofNullable(getFoundDomainNamespaces(packet)).orElse(Collections.emptyList());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static Collection<String> getFoundDomainNamespaces(Packet packet) {\n+      if (!packet.containsKey(ALL_DOMAIN_NAMESPACES)) {\n+        packet.put(ALL_DOMAIN_NAMESPACES, new HashSet<>());\n       }\n+      return (Collection<String>) packet.get(ALL_DOMAIN_NAMESPACES);\n+    }\n \n-      private String getConfiguredNamespaceList() {\n-        return Optional.ofNullable(tuningAndConfig().get(\"domainNamespaces\"))\n-              .orElse(tuningAndConfig().get(\"targetNamespaces\"));\n+    /**\n+     * Gets the configured domain namespace selection strategy.\n+     * @return Selection strategy\n+     */\n+    public static SelectionStrategy getSelectionStrategy() {\n+      SelectionStrategy strategy =\n+          Optional.ofNullable(tuningAndConfig().get(SELECTION_STRATEGY_KEY))\n+                .map(SelectionStrategy::valueOf)\n+                .orElse(SelectionStrategy.List);\n+\n+      if (SelectionStrategy.List.equals(strategy) && isDeprecatedDedicated()) {\n+        return SelectionStrategy.Dedicated;\n       }\n-    },\n-    LabelSelector {\n-      @Override\n-      public boolean isRequireList() {\n-        return true;\n+      return strategy;\n+    }\n+\n+    // Returns true if the deprecated way to specify the dedicated namespace strategy is being used.\n+    // This value will only be used if the 'list' namespace strategy is specified or defaulted.\n+    private static boolean isDeprecatedDedicated() {\n+      return \"true\".equalsIgnoreCase(Optional.ofNullable(tuningAndConfig().get(\"dedicated\")).orElse(\"false\"));\n+    }\n+\n+    @Nonnull Collection<String> getConfiguredDomainNamespaces() {\n+      return Optional.ofNullable(configuredDomainNamespaces).orElse(Collections.emptyList());\n+    }\n+\n+\n+    /**\n+     * Reads the existing namespaces from Kubernetes and performs appropriate processing on those\n+     * identified as domain namespaces.\n+      */\n+    Step readExistingNamespaces() {\n+      return new CallBuilder()\n+            .withLabelSelectors(selectionStrategy.getLabelSelectors())\n+            .listNamespaceAsync(new NamespaceListStep());\n+    }\n+\n+    private class NamespaceListStep extends DefaultResponseStep<V1NamespaceList> {\n+\n+      NamespaceListStep() {\n+        super(new NamespaceListAfterStep());\n       }\n \n+      // If unable to list the namespaces, we may still be able to start them if we are using\n+      // a strategy that specifies them explicitly.\n       @Override\n-      public String getLabelSelector() {\n-        return tuningAndConfig().get(\"domainNamespaceLabelSelector\");\n+      protected NextAction onFailureNoRetry(Packet packet, CallResponse<V1NamespaceList> callResponse) {\n+        return getConfiguredDomainNamespaces() != null && isNotAuthorizedOrForbidden(callResponse)\n+                ? doNext(startNamespaces(Namespaces.this, getConfiguredDomainNamespaces()), packet) :\n+                super.onFailureNoRetry(packet, callResponse);\n       }\n-    },\n-    RegExp {\n-      @Override\n-      public boolean isRequireList() {\n-        return true;\n+\n+      private Collection<String> getConfiguredDomainNamespaces() {\n+        return selectionStrategy.getConfiguredDomainNamespaces();\n       }\n \n       @Override\n-      public String getRegExp() {\n-        return tuningAndConfig().get(\"domainNamespaceRegExp\");\n+      public NextAction onSuccess(Packet packet, CallResponse<V1NamespaceList> callResponse) {\n+        final String intialResourceVersion = getResourceVersion(callResponse.getResult());\n+        final Set<String> namespacesToStartNow = getNamespacesToStart(getNames(callResponse.getResult()));\n+        getFoundDomainNamespaces(packet).addAll(namespacesToStartNow);\n+\n+        return doContinueListOrNext(callResponse, packet, createNextSteps(intialResourceVersion, namespacesToStartNow));\n       }\n-    },\n-    Dedicated {\n-      @Override\n-      public Collection<String> getDomainNamespaces() {\n-        return Collections.singleton(getOperatorNamespace());\n+\n+      private Step createNextSteps(String intialResourceVersion, Set<String> namespacesToStartNow) {\n+        List<Step> nextSteps = new ArrayList<>();\n+        if (!namespacesToStartNow.isEmpty()) {\n+          nextSteps.add(startNamespaces(Namespaces.this, namespacesToStartNow));\n+          if (getConfiguredDomainNamespaces() == null) {\n+            nextSteps.add(new InitializeNamespacesSecurityStep(namespacesToStartNow, null));\n+          }\n+        }\n+        nextSteps.add(new CreateNamespaceWatcherStep(selectionStrategy, intialResourceVersion));\n+        nextSteps.add(getNext());\n+        return Step.chain(nextSteps.toArray(new Step[0]));\n       }\n-    };\n \n-    public boolean isRequireList() {\n-      return false;\n-    }\n+      private Set<String> getNamespacesToStart(List<String> namespaceNames) {\n+        return namespaceNames.stream().filter(selectionStrategy::isSelected).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e"}, "originalPosition": 336}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODcyMjc0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#pullrequestreview-497872274", "createdAt": "2020-09-28T20:30:20Z", "commit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDozMDoyMFrOHZOfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDozMDoyMFrOHZOfog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMzkyMg==", "bodyText": "what is the difference between this test and the whenNamespacesListedInOneChunk...()?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496213922", "createdAt": "2020-09-28T20:30:20Z", "author": {"login": "alai8"}, "path": "operator/src/test/java/oracle/kubernetes/operator/MainTest.java", "diffHunk": "@@ -196,6 +206,62 @@ private V1ObjectMeta createMetadata(DateTime creationTimestamp) {\n         .resourceVersion(\"1\");\n   }\n \n+  @Test\n+  public void whenConfiguredDomainNamespaceMissing_logWarning() {\n+    loggerControl.withLogLevel(Level.WARNING).collectLogMessages(logRecords, MessageKeys.NAMESPACE_IS_MISSING);\n+\n+    defineSelectionStrategy(Main.Namespaces.SelectionStrategy.List);\n+    String namespaceString = \"NS1,NS\" + LAST_NAMESPACE_NUM;\n+    HelmAccessStub.defineVariable(HelmAccess.OPERATOR_DOMAIN_NAMESPACES, namespaceString);\n+    createNamespaces(LAST_NAMESPACE_NUM - 1);\n+\n+    testSupport.runSteps(new Main.Namespaces(false).readExistingNamespaces());\n+\n+    assertThat(logRecords, containsWarning(MessageKeys.NAMESPACE_IS_MISSING));\n+  }\n+\n+  @Test\n+  public void whenNamespacesListedInOneChunk_dontDeclarePresentNamespacesAsMissing() {\n+    loggerControl.withLogLevel(Level.WARNING).collectLogMessages(logRecords, MessageKeys.NAMESPACE_IS_MISSING);\n+\n+    defineSelectionStrategy(Main.Namespaces.SelectionStrategy.List);\n+    String namespaceString = \"NS1,NS\" + LAST_NAMESPACE_NUM;\n+    HelmAccessStub.defineVariable(HelmAccess.OPERATOR_DOMAIN_NAMESPACES, namespaceString);\n+    createNamespaces(LAST_NAMESPACE_NUM);\n+\n+    testSupport.runSteps(new Main.Namespaces(false).readExistingNamespaces());\n+  }\n+\n+  // todo add unit tests for namespace shutdown. Must manipulate the namespaceStopping map. Can that be abstracted?\n+\n+  private void defineSelectionStrategy(SelectionStrategy selectionStrategy) {\n+    TuningParameters.getInstance().put(Main.Namespaces.SELECTION_STRATEGY_KEY, selectionStrategy.toString());\n+  }\n+\n+  @Test\n+  public void whenNamespacesListedInMultipleChunks_dontDeclarePresentNamespacesAsMissing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e"}, "originalPosition": 188}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODcyMzM1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#pullrequestreview-497872335", "createdAt": "2020-09-28T20:30:25Z", "commit": {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b71528c628116b14953cdf8cc73efd284986f28", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b71528c628116b14953cdf8cc73efd284986f28", "committedDate": "2020-09-29T09:53:49Z", "message": "Correct method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e459d4983887bee380ace50844dae2e3ccb4a739", "author": {"user": {"login": "russgold", "name": "Russell Gold"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e459d4983887bee380ace50844dae2e3ccb4a739", "committedDate": "2020-09-29T13:22:34Z", "message": "Cache compiled pattern, use explicit constant for call limit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjY2NTIx", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#pullrequestreview-498666521", "createdAt": "2020-09-29T16:22:39Z", "commit": {"oid": "e459d4983887bee380ace50844dae2e3ccb4a739"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4192, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}