{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MzM3ODc2", "number": 1704, "title": "Added infra support for monitoring exporter", "bodyText": "Added actions for Prometheus, Grafana\nAdded creation for WebHook, Coordinator\nAdded end to end  test to build Mii domain with MonExp app and check metrics\n\nJenkins run:\nhttps://build.weblogick8s.org:8443/job/weblogic-kubernetes-operator-model-in-image-tests-10/255", "createdAt": "2020-06-03T17:04:14Z", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704", "merged": true, "mergeCommit": {"oid": "cb8f6b37f1676efd6d7e1b646b73feb0b4c1e3a5"}, "closed": true, "closedAt": "2020-06-11T16:30:24Z", "author": {"login": "marinakog"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclcaj5AH2gAyNDI3MzM3ODc2OjRjMGYwZTM1ODMwY2M2NGUxYTQ5NzIxODViMGMwOWViYTIxMzM2MjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpsEGsgH2gAyNDI3MzM3ODc2OmE3ZTQ3ZTNjODVhODEzNDE5NjNlN2M2ZjRiMDI0NjA5ZjVlMWIxZjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4c0f0e35830cc64e1a4972185b0c09eba2133622", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4c0f0e35830cc64e1a4972185b0c09eba2133622", "committedDate": "2020-05-27T17:07:38Z", "message": "added prom support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a6d44b33048c9e8093ddfd5be6dc3e04d7fbdc3", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3a6d44b33048c9e8093ddfd5be6dc3e04d7fbdc3", "committedDate": "2020-05-27T17:13:03Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9733f9718e65f6587ff570e5dcab17022aefd94f", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9733f9718e65f6587ff570e5dcab17022aefd94f", "committedDate": "2020-06-01T02:02:05Z", "message": "added support for coord, webhook"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83bce0092691778587c4c8f720b919d9b93f405b", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/83bce0092691778587c4c8f720b919d9b93f405b", "committedDate": "2020-06-01T02:28:06Z", "message": "merge with develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d21ca470d7aca52f0c1d8216f0e80c107c7b79f", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8d21ca470d7aca52f0c1d8216f0e80c107c7b79f", "committedDate": "2020-06-01T02:36:11Z", "message": "fixed typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3619c1d635d83424b5ce0900baf62bd7411b7b57", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3619c1d635d83424b5ce0900baf62bd7411b7b57", "committedDate": "2020-06-01T15:39:18Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b663d70caf24fedd788eba4c475f1f5089dfe80", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b663d70caf24fedd788eba4c475f1f5089dfe80", "committedDate": "2020-06-02T17:38:28Z", "message": "added support to deploy archived file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec54129757cfa6aadb61140cc278f7621eebab8e", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ec54129757cfa6aadb61140cc278f7621eebab8e", "committedDate": "2020-06-02T17:38:40Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "953e86eefe00968e4cee5d52561f12e679324d71", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/953e86eefe00968e4cee5d52561f12e679324d71", "committedDate": "2020-06-02T18:11:34Z", "message": "fixed monexp app check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f54e67f3dd40ef1940572b6e81ca203e7ef275a2", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f54e67f3dd40ef1940572b6e81ca203e7ef275a2", "committedDate": "2020-06-02T22:43:03Z", "message": "fixed style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "274e36bb2af2eec639a0f90523faa9a5ad00c99b", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/274e36bb2af2eec639a0f90523faa9a5ad00c99b", "committedDate": "2020-06-02T22:45:26Z", "message": "fixed style1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd2a7e3b627d8221cb39635fac9cfde87f45ef1c", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fd2a7e3b627d8221cb39635fac9cfde87f45ef1c", "committedDate": "2020-06-03T02:11:01Z", "message": "fixed push image"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15f2f56078fe2583236ac6d90b23b9915e9e1060", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/15f2f56078fe2583236ac6d90b23b9915e9e1060", "committedDate": "2020-06-03T15:10:37Z", "message": "fixed style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "336fcf99713b9352a9cae4a7fcbccfcdf2087d17", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/336fcf99713b9352a9cae4a7fcbccfcdf2087d17", "committedDate": "2020-06-03T15:10:46Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3d918be49df6f22c650ab52cc21f79be9b2fbe0", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a3d918be49df6f22c650ab52cc21f79be9b2fbe0", "committedDate": "2020-06-03T16:10:04Z", "message": "fixed deployment delete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8308ec0ed935b1bf89f3477a6b30ca29c7b2332a", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8308ec0ed935b1bf89f3477a6b30ca29c7b2332a", "committedDate": "2020-06-03T17:10:08Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8828d6bc3e02d9e4e8b2c382a17db5fe842e7cb", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f8828d6bc3e02d9e4e8b2c382a17db5fe842e7cb", "committedDate": "2020-06-03T17:13:25Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "committedDate": "2020-06-03T17:22:22Z", "message": "cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODMwNDU3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-423830457", "createdAt": "2020-06-03T18:41:59Z", "commit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MTo1OVrOGeou_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo1MjowMlrOGepEhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3Nzg1NQ==", "bodyText": "an unnecessary line break", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434777855", "createdAt": "2020-06-03T18:41:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM0Mg==", "bodyText": "add a import for java.nio.file.Files and java.nio.file.Paths", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434779342", "createdAt": "2020-06-03T18:44:45Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDE3MA==", "bodyText": "same as above comment.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780170", "createdAt": "2020-06-03T18:46:12Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,\n+          appName + \".\"\n+              + fileExtension),\n+          java.nio.file.StandardCopyOption.REPLACE_EXISTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDkyMA==", "bodyText": "remove unused imports", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780920", "createdAt": "2020-06-03T18:47:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjU1Mg==", "bodyText": "Missing javadoc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782552", "createdAt": "2020-06-03T18:50:35Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjgyNA==", "bodyText": "is this needed?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782824", "createdAt": "2020-06-03T18:51:03Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MzM2NA==", "bodyText": "Does this need any update?", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434783364", "createdAt": "2020-06-03T18:52:02Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NTQ1OTE3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-424545917", "createdAt": "2020-06-04T15:05:27Z", "commit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNToyN1rOGfKe6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNjowOVrOGfKg1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDc5NQ==", "bodyText": "This is stale. The PR has been merged.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435330795", "createdAt": "2020-06-04T15:05:27Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMTI4NQ==", "bodyText": "shutdown the domain before deleting CRD", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435331285", "createdAt": "2020-06-04T15:06:09Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 332}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjIyODQw", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-424622840", "createdAt": "2020-06-04T16:25:35Z", "commit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoyNTozNVrOGfOAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjo0MTo1OFrOGfOo9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg==", "bodyText": "This can be moved to a utils class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435388522", "createdAt": "2020-06-04T16:25:35Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5MDI4OA==", "bodyText": "pod name starts with podName", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435390288", "createdAt": "2020-06-04T16:28:17Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**\n+   * A utility method to sed files.\n+   *\n+   * @throws IOException when copying files from source location to staging area fails\n+   */\n+  private static void replaceStringInFile(String filePath, String oldValue, String newValue)\n+      throws IOException {\n+    Path src = Paths.get(filePath);\n+    logger.info(\"Copying {0}\", src.toString());\n+    Charset charset = StandardCharsets.UTF_8;\n+    String content = new String(Files.readAllBytes(src), charset);\n+    content = content.replaceAll(oldValue, newValue);\n+    logger.info(\"to {0}\", src.toString());\n+    Files.write(src, content.getBytes(charset));\n+  }\n+\n+  /**\n+   * Create, install  Webhook or Coordinator and wait up to five minutes until the pod is ready.\n+   *\n+   * @param dockerFileDir directory where dockerfile is located\n+   * @param baseImageName base image name\n+   * @param namespace namespace\n+   * @return status of installation\n+   */\n+  public static boolean installAndVerifyPodFromCustomImage(String dockerFileDir,\n+                                                String baseImageName,\n+                                                String namespace,\n+                                                String labelSelector,\n+                                                String secretName) throws ApiException {\n+    //build webhook image\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (!REPO_NAME.isEmpty()) {\n+      imagePullPolicy = \"Always\";\n+    }\n+    String image = createPushImage(dockerFileDir,baseImageName, namespace, secretName);\n+    logger.info(\"Installing {0} in namespace {1}\", baseImageName, namespace);\n+    if (baseImageName.equalsIgnoreCase((\"webhook\"))) {\n+      createWebHook(image, imagePullPolicy, namespace, REPO_SECRET_NAME);\n+    } else if (baseImageName.contains(\"coordinator\")) {\n+      createCoordinator(image, imagePullPolicy, namespace, \"coordsecret\");\n+    } else {\n+      throw new ApiException(\"Custom image creation for \" + baseImageName + \"is not supported\");\n+    }\n+    // wait for the pod to be ready\n+    logger.info(\"Wait for the {0} pod is ready in namespace {1}\", baseImageName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be running in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                baseImageName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, labelSelector, baseImageName),\n+            baseImageName + \" podIsReady failed with ApiException\"));\n+    return true;\n+  }\n+\n+  /**\n+   * Create Webhook deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace webhook namespace\n+   * @param secretName webhook image secret name\n+   */\n+  private static void createWebHook(String image,\n+                                    String imagePullPolicy,\n+                                    String namespace,\n+                                    String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"webhook\");\n+\n+    webhookDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"webhook\")))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for webhook in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(webhookDepl),\n+        String.format(\"Create deployment failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+\n+    webhookService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8080)\n+                    .protocol(\"TCP\")))\n+            .selector(labels));\n+\n+    logger.info(\"Create service for webhook in namespace {0}\",\n+        namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(webhookService),\n+        String.format(\"Create service failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+    // wait for the webhook pod to be ready\n+    logger.info(\"Wait for the webhook pod is ready in namespace {0}\", namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for webhook to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, \"app=webhook\", \"webhook\"),\n+            \"webhook podIsReady failed with ApiException\"));\n+  }\n+\n+  /**\n+   * Uninstall provided deployment and service.\n+   */\n+  private static void uninstallDeploymentService(V1Deployment deployment, V1Service service) {\n+    String namespace = null;\n+    String serviceName = null;\n+    String deploymentName = null;\n+    try {\n+      if (service != null) {\n+        serviceName = service.getMetadata().getName();\n+        namespace = service.getMetadata().getNamespace();\n+        Kubernetes.deleteService(serviceName, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete service {0} in namespace {1} \",\n+          serviceName, namespace);\n+    }\n+    try {\n+      if (deployment != null) {\n+        deploymentName = deployment.getMetadata().getName();\n+        namespace = deployment.getMetadata().getNamespace();\n+        Kubernetes.deleteDeployment(namespace, deploymentName);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete deployment {0} in namespace {1}\",\n+          deploymentName, namespace);\n+    }\n+    if (namespace != null) {\n+      deleteNamespace(namespace);\n+    }\n+  }\n+\n+  /**\n+   * Create Coordinator deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace coordinator namespace\n+   * @param secretName coordinator secret name\n+   */\n+  private static void createCoordinator(String image,\n+                                        String imagePullPolicy,\n+                                        String namespace,\n+                                        String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"coordinator\");\n+    coordinatorDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+            .type(\"Recreate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"coordinator\")\n+                    .ports(Arrays.asList(\n+                        new V1ContainerPort()\n+                        .containerPort(8999)))))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for coordinator in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(coordinatorDepl),\n+        String.format(\"Create deployment failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for coordinator in namespace %s \",\n+        namespace));\n+\n+    coordinatorService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8999)\n+                    .targetPort(new IntOrString(8999))))\n+            .type(\"NodePort\")\n+            .selector(labels));\n+\n+    logger.info(\"Create service for coordinator in namespace {0}\",\n+        namespace);\n+    boolean success = assertDoesNotThrow(() -> Kubernetes.createService(coordinatorService),\n+        String.format(\"Create service failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(success, \"Coordinator service creation failed\");\n+  }\n+\n+  /**\n+   * Checks if the pod is running in a given namespace.\n+   * The method assumes the pod name to starts with podName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 654}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzU5NQ==", "bodyText": "TestActions class should not contain the implementation, it should call impl class.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435397595", "createdAt": "2020-06-04T16:39:56Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODgwMQ==", "bodyText": "isPrometheusReady()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398801", "createdAt": "2020-06-04T16:41:47Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODkwMg==", "bodyText": "isGrafanaReady()", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398902", "createdAt": "2020-06-04T16:41:58Z", "author": {"login": "vanajamukkara"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {\n+\n+    return Prometheus.isReady(namespace);\n+  }\n+\n+  /**\n+   * Check if Grafana is running.\n+   *\n+   * @param namespace in which is grafana is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> grafanaIsReady(String namespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzMwNjk4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-424730698", "createdAt": "2020-06-04T18:41:00Z", "commit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MTowMFrOGfTJ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODo0MTowMFrOGfTJ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mjg5NA==", "bodyText": "Can we make the method createPvAndPvc() as action method in TestAction class.  I see similar local methods in ItDomainInPV class", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435472894", "createdAt": "2020-06-04T18:41:00Z", "author": {"login": "anpanigr"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6"}, "originalPosition": 260}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af1b8a8538a46bca0eae23e250fc85439b71e0d6", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/af1b8a8538a46bca0eae23e250fc85439b71e0d6", "committedDate": "2020-06-04T23:18:31Z", "message": "addressed comments from review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a2a8c241214d86f1ff46ba85e3b4a146272a595", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9a2a8c241214d86f1ff46ba85e3b4a146272a595", "committedDate": "2020-06-04T23:18:39Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5633729bddf3c70f1ed36f67cd176dbbf3a2f82e", "committedDate": "2020-06-05T00:01:54Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c154d759b9e59d3c5589e99da7d3673ddb6b7aa4", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c154d759b9e59d3c5589e99da7d3673ddb6b7aa4", "committedDate": "2020-06-05T06:29:39Z", "message": "fixed logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NDUyODY5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-425452869", "createdAt": "2020-06-05T16:33:24Z", "commit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjozMzoyNFrOGf1Z8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjozMzoyNFrOGf1Z8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA==", "bodyText": "can you replace the above 2 methods with this? You can use this method in Grafana,Prometheus\n/**\n*\n\nChecks if a pod is ready in a given namespace.\n\n@param namespace in which to check if the pod is ready\n@param labels map of labels as key value pairs\n@param podName name of the pod to check for\n@return true if the pod is in the ready condition, false otherwise\n@throws ApiException if Kubernetes client API call fails\n*/\npublic static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\nboolean status = false;\nString labelSelector = null;\n\nif (labels != null && !labels.isEmpty()) {\n  labelSelector = labels.entrySet()\n      .stream()\n      .map(e -> e.getKey() + \"=\" + e.getValue())\n      .collect(Collectors.joining(\",\"));\n}\n\nV1Pod pod = getPod(namespace, labelSelector, podName);\nif (pod != null) {\n\n  // get the podCondition with the 'Ready' type field\n  V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n      .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n      .findAny()\n      .orElse(null);\n\n  if (v1PodReadyCondition != null) {\n    status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n    if (status) {\n      logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n    }\n  }\n} else {\n  logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n}\nreturn status;\n\n}", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436034034", "createdAt": "2020-06-05T16:33:24Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05b7044280e0dca89df35a1e7ebd4d7b4da1f3e2", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/05b7044280e0dca89df35a1e7ebd4d7b4da1f3e2", "committedDate": "2020-06-05T19:48:41Z", "message": "modified isPodReady"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb12375980da4a7c2fd2639ebcb4bd78d2e8ac58", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eb12375980da4a7c2fd2639ebcb4bd78d2e8ac58", "committedDate": "2020-06-05T19:50:51Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf6004aba59b0987486d4f5cb8bc0edea3e4820d", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cf6004aba59b0987486d4f5cb8bc0edea3e4820d", "committedDate": "2020-06-08T15:31:13Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "committedDate": "2020-06-08T15:34:59Z", "message": "moved replaceString to testutils"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mzg3Njk0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-426387694", "createdAt": "2020-06-08T16:00:59Z", "commit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjowMDo1OVrOGglSgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoxMTo0NlrOGglvYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODU2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * install helm chart.\n          \n          \n            \n               * Install Prometheus.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818560", "createdAt": "2020-06-08T16:00:59Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODkwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Uninstall a helm release.\n          \n          \n            \n               * Uninstall a Prometheus release.", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818906", "createdAt": "2020-06-08T16:01:30Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.\n+   * @param params the helm parameters like namespace, release name, repo url or chart dir,\n+   *               chart name and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(PrometheusParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall a helm release.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMDM4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @throws ApiException when delete fails\n          \n          \n            \n               * @throws ApiException when create fails", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436820387", "createdAt": "2020-06-08T16:03:37Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -283,9 +283,34 @@ private static void initializeGenericKubernetesApiClients() {\n   }\n \n   // ------------------------  deployments -----------------------------------\n-  public static boolean createDeployment(String deploymentYaml) {\n-    // do something with the command!!!\n-    return true;\n+\n+  /**\n+   * Create a deployment.\n+   *\n+   * @param deployment V1Deployment object containing deployment configuration data\n+   * @return true if creation was successful\n+   * @throws ApiException when delete fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTE3Nw==", "bodyText": "we don't need this message logged, it will be too much verbose messages when this gets called repeatedly", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821177", "createdAt": "2020-06-08T16:04:49Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -448,6 +473,7 @@ public static boolean deletePod(String name, String namespace) {\n   public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n     V1PodList pods = listPods(namespace, labelSelector);\n     for (var pod : pods.getItems()) {\n+      logger.info(\"Check for pod {0}\", pod.getMetadata().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTc2Ng==", "bodyText": "remove empty line", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821766", "createdAt": "2020-06-08T16:05:41Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> isPrometheusReady(String namespace) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyNTk1Mw==", "bodyText": "Please replace the StringBuilder with this.\nlabelSelector = labels.entrySet() .stream() .map(e -> e.getKey() + \"=\" + e.getValue()) .collect(Collectors.joining(\",\"));", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436825953", "createdAt": "2020-06-08T16:11:46Z", "author": {"login": "sankarpn"}, "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -122,29 +123,33 @@ public static boolean isPodRunning(String namespace, String domainUid, String po\n   }\n \n   /**\n-   * Checks if a pod is ready in a given namespace.\n-   *\n-   * @param namespace in which to check if the pod is ready\n-   * @param domainUid the label the pod is decorated with\n-   * @param podName name of the pod to check for\n-   * @return true if the pod is in the ready condition, false otherwise\n-   * @throws ApiException if Kubernetes client API call fails\n+\n+   Checks if a pod is ready in a given namespace.\n+   @param namespace in which to check if the pod is ready\n+   @param labels map of labels as key value pairs\n+   @param podName name of the pod to check for\n+   @return true if the pod is in the ready condition, false otherwise\n+   @throws ApiException if Kubernetes client API call fails\n    */\n-  public static boolean isPodReady(String namespace, String domainUid, String podName) throws ApiException {\n+  public static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\n     boolean status = false;\n     String labelSelector = null;\n-    if (domainUid != null) {\n-      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    if (labels != null && !labels.isEmpty()) {\n+      StringBuilder str = new StringBuilder();\n+      for (Map.Entry<String, String> entry : labels.entrySet()) {\n+        str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n+      }\n+      //concat last ','\n+      labelSelector = str.toString().substring(0, str.toString().length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa", "committedDate": "2020-06-08T17:38:39Z", "message": "fixed comments, changed map processing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTc1MjI5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-426575229", "createdAt": "2020-06-08T19:59:14Z", "commit": {"oid": "3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTc3ODQy", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-426577842", "createdAt": "2020-06-08T20:03:01Z", "commit": {"oid": "3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjAyNjky", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#pullrequestreview-426602692", "createdAt": "2020-06-08T20:38:22Z", "commit": {"oid": "3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42801409d9da53d46169e82743d2dc9a6acf0abc", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/42801409d9da53d46169e82743d2dc9a6acf0abc", "committedDate": "2020-06-09T15:16:02Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "128ce9fd695305f280a85dc93002ad908c5e0b30", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/128ce9fd695305f280a85dc93002ad908c5e0b30", "committedDate": "2020-06-09T15:48:11Z", "message": "deleted unused vars, split methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1871c2db1014d65e8f410d3087a41cb1bb650c89", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1871c2db1014d65e8f410d3087a41cb1bb650c89", "committedDate": "2020-06-09T17:22:44Z", "message": "replaced with descriptive var name, fixed processing of multiple webapps files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c43e2ac0d51de5091fc767e606b3ea388a4f254", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6c43e2ac0d51de5091fc767e606b3ea388a4f254", "committedDate": "2020-06-09T17:42:56Z", "message": "style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a15a27cbbd0a157aeb79fd9efe20015ef86d22b9", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a15a27cbbd0a157aeb79fd9efe20015ef86d22b9", "committedDate": "2020-06-09T21:14:18Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7e47e3c85a81341963e7c6f4b024609f5e1b1f0", "author": {"user": {"login": "marinakog", "name": "Marina Kogan"}}, "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a7e47e3c85a81341963e7c6f4b024609f5e1b1f0", "committedDate": "2020-06-09T21:37:17Z", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4485, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}