{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMTc4Nzk3", "number": 1171, "title": "SOLR-13892: Add 'top-level' docValues Join implementation", "bodyText": "Description\nSome join usecases are better served (performance wise) by using top-level docValues structures, because they avoid some wasteful seeking and iteration that the per-segment alternatives do.\nSolution\nThis PR introduces a \"TopLevelJoinQuery\" which can be run on join's where the fields in question have docValues enabled.  This scales much better with the number of \"from\" query matches than existing alternatives.  Since it's implemented as a Two-Phase Iterator it scales less well by the number of overall matches.  See SOLR-13892 for more in-depth performance discussion.\nTests\nBeefed up tests in TestJoin to prove correctness.  Wrote a performance test driver TestJoinQueryPerformance that allows reproduction of the perf results.  (Though this will not be committed in the final version)\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ant precommit and the appropriate test suite.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-01-15T14:56:55Z", "url": "https://github.com/apache/lucene-solr/pull/1171", "merged": true, "mergeCommit": {"oid": "719b38c8d8c22a50a3738b852bffb5904cc8fcfa"}, "closed": true, "closedAt": "2020-01-31T16:21:02Z", "author": {"login": "gerlowskija"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6mrrLAH2gAyMzYzMTc4Nzk3OjQ1ZjE5MTA4Y2ZmOWVmZjZhMzk4NjhmZTczYjU3OWQxNGFhMWEyZGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_uqZbAH2gAyMzYzMTc4Nzk3OjRhODM4MTZlNTExODlmMDk2M2NmNDI0N2E0ZmNmYTYyMjRmNjE5NTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "45f19108cff9eff6a39868fe73b579d14aa1a2dc", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/45f19108cff9eff6a39868fe73b579d14aa1a2dc", "committedDate": "2020-01-15T14:46:38Z", "message": "SOLR-13892: Add \"join\" postfilter implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8251066c8ff37590cbd2908ce8f04ddcb508ac36", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/8251066c8ff37590cbd2908ce8f04ddcb508ac36", "committedDate": "2020-01-15T14:46:50Z", "message": "SOLR-13892: Add TPI implementation for benchmarking\n\nIn some benchmarking it looks like the TPI implementation has the same\nperf benefits as the postfilter implementation, which was mostly\nexpected. The current implementation is very rough (lots of duplication\nand debug logging), but I'm sharing it to give context to performance\nresults I'm posting at the same time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcc0b3f20c6e724efbfef82703304b74d2a34986", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/bcc0b3f20c6e724efbfef82703304b74d2a34986", "committedDate": "2020-01-15T15:09:36Z", "message": "SOLR-13892: Remove postfilter join impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7067a607bd932b5e1638442d23119fa479967f4", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/d7067a607bd932b5e1638442d23119fa479967f4", "committedDate": "2020-01-17T12:12:04Z", "message": "SOLR-13892: Add 'method' localParam to JoinQParser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989b0a5bce5fb70402a98012a7c2ab2a5f436703", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/989b0a5bce5fb70402a98012a7c2ab2a5f436703", "committedDate": "2020-01-17T19:39:42Z", "message": "Extract TopLevelJoinQuery and helpers to its own class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b7fc26ab57ea1cda478fd0bcc6f1544573ae1d", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/35b7fc26ab57ea1cda478fd0bcc6f1544573ae1d", "committedDate": "2020-01-21T12:42:25Z", "message": "SOLR-13892: Remove single-/multi-value duplication\n\nMuch of the the code for TopLevelJoinQuery was previously duplicated:\nonce to handle single-value fields (SortedDocValues objects) and once to\nhandle multi-value fields (SortedSetDocValues objects).  Most of the\ncode was actually the same, but since the DV objects didn't share any\nparent classes, it was impossible to take advantage of the fact that\nthey have mostly the same public methods and write helper methods etc\nthat operate on both object types.\n\nThis commit creates a wrapper object around these two types that allows\ncode to be written to handle either one.  This cut out a lot of\nthe duplication."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7bfc991472ff1f54e9056f1e236f6ffe23c10f5", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/e7bfc991472ff1f54e9056f1e236f6ffe23c10f5", "committedDate": "2020-01-22T17:15:10Z", "message": "SOLR-13892: Update tests following postfilter removal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffd4d793bb6a3351c50affdb25e28df445b52de8", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/ffd4d793bb6a3351c50affdb25e28df445b52de8", "committedDate": "2020-01-22T17:39:20Z", "message": "SOLR-13892: Replace DocValuesWrapper with existing lucene class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3233fe03fbffaccff982022e98be09ec14308a90", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/3233fe03fbffaccff982022e98be09ec14308a90", "committedDate": "2020-01-22T17:44:30Z", "message": "SOLR-13892: Remove SingletonSortedSetDocValues visibility change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97488093e36684dfe0797037469d1c40f83c3147", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/97488093e36684dfe0797037469d1c40f83c3147", "committedDate": "2020-01-23T14:46:50Z", "message": "SOLR-13892: Add JoinQParser 'method' docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c232d8d042b6fc86bba3b5be2672f2941cb8fb6f", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/c232d8d042b6fc86bba3b5be2672f2941cb8fb6f", "committedDate": "2020-01-23T14:50:06Z", "message": "SOLR-13892: Rename method val for Score impl\n\nEarlier in this PR I'd named it 'indexWithScore', but it actually uses\ndocValues or uninverted structures."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/ac33c8efb5146a94347d7e340d199dfbf8548834", "committedDate": "2020-01-23T14:54:42Z", "message": "SOLR-13892: Remove unwanted docs whitespace change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73c13faf86144cf39c5ccb1e60fedad917e6b429", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/73c13faf86144cf39c5ccb1e60fedad917e6b429", "committedDate": "2020-01-23T14:59:34Z", "message": "SOLR-13892: Fix precommit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTExODQz", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-347511843", "createdAt": "2020-01-23T18:24:12Z", "commit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODoyNDoxMlrOFhIKvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxOTo0ODoxOFrOFhKkxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4MTE0OQ==", "bodyText": "Use QueryParsing.V  thus also signals this isn't special", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370281149", "createdAt": "2020-01-23T18:24:12Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -59,67 +60,124 @@\n import org.apache.solr.search.join.ScoreJoinQParserPlugin;\n import org.apache.solr.util.RTimer;\n import org.apache.solr.util.RefCounted;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class JoinQParserPlugin extends QParserPlugin {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public static final String NAME = \"join\";\n+  /** Choose the internal algorithm */\n+  private static final String METHOD = \"method\";\n+\n+  private static class JoinParams {\n+    final String fromField;\n+    final String fromCore;\n+    final Query fromQuery;\n+    final long fromCoreOpenTime;\n+    final String toField;\n+\n+    public JoinParams(String fromField, String fromCore, Query fromQuery, long fromCoreOpenTime, String toField) {\n+      this.fromField = fromField;\n+      this.fromCore = fromCore;\n+      this.fromQuery = fromQuery;\n+      this.fromCoreOpenTime = fromCoreOpenTime;\n+      this.toField = toField;\n+    }\n+  }\n+\n+  private enum Method {\n+    index {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new JoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    },\n+    dvWithScore {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        return new ScoreJoinQParserPlugin().createParser(qparser.qstr, qparser.localParams, qparser.params, qparser.req).parse();\n+      }\n+    },\n+    topLevelDV {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new TopLevelJoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    };\n+\n+    abstract Query makeFilter(QParser qparser) throws SyntaxError;\n+\n+    JoinParams parseJoin(QParser qparser) throws SyntaxError {\n+      final String fromField = qparser.getParam(\"from\");\n+      final String fromIndex = qparser.getParam(\"fromIndex\");\n+      final String toField = qparser.getParam(\"to\");\n+      final String v = qparser.localParams.get(\"v\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4MjU5Mg==", "bodyText": "Can you use try-with-resources style for SolrCore and otherReq?  You might need to create a static method that gets the core and throws if non-null so that you are able to have a one-liner fetch of the core in the \"try\".  I generally like to use try-with-resources when possible as it's easier to reason to guarantee things get closed, and it's sometimes less code.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370282592", "createdAt": "2020-01-23T18:27:27Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -59,67 +60,124 @@\n import org.apache.solr.search.join.ScoreJoinQParserPlugin;\n import org.apache.solr.util.RTimer;\n import org.apache.solr.util.RefCounted;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class JoinQParserPlugin extends QParserPlugin {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public static final String NAME = \"join\";\n+  /** Choose the internal algorithm */\n+  private static final String METHOD = \"method\";\n+\n+  private static class JoinParams {\n+    final String fromField;\n+    final String fromCore;\n+    final Query fromQuery;\n+    final long fromCoreOpenTime;\n+    final String toField;\n+\n+    public JoinParams(String fromField, String fromCore, Query fromQuery, long fromCoreOpenTime, String toField) {\n+      this.fromField = fromField;\n+      this.fromCore = fromCore;\n+      this.fromQuery = fromQuery;\n+      this.fromCoreOpenTime = fromCoreOpenTime;\n+      this.toField = toField;\n+    }\n+  }\n+\n+  private enum Method {\n+    index {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new JoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    },\n+    dvWithScore {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        return new ScoreJoinQParserPlugin().createParser(qparser.qstr, qparser.localParams, qparser.params, qparser.req).parse();\n+      }\n+    },\n+    topLevelDV {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new TopLevelJoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    };\n+\n+    abstract Query makeFilter(QParser qparser) throws SyntaxError;\n+\n+    JoinParams parseJoin(QParser qparser) throws SyntaxError {\n+      final String fromField = qparser.getParam(\"from\");\n+      final String fromIndex = qparser.getParam(\"fromIndex\");\n+      final String toField = qparser.getParam(\"to\");\n+      final String v = qparser.localParams.get(\"v\");\n+      final String coreName;\n+\n+      Query fromQuery;\n+      long fromCoreOpenTime = 0;\n+\n+      if (fromIndex != null && !fromIndex.equals(qparser.req.getCore().getCoreDescriptor().getName()) ) {\n+        CoreContainer container = qparser.req.getCore().getCoreContainer();\n+\n+        // if in SolrCloud mode, fromIndex should be the name of a single-sharded collection\n+        coreName = ScoreJoinQParserPlugin.getCoreName(fromIndex, container);\n+\n+        final SolrCore fromCore = container.getCore(coreName);\n+        if (fromCore == null) {\n+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+              \"Cross-core join: no such core \" + coreName);\n+        }\n+\n+        RefCounted<SolrIndexSearcher> fromHolder = null;\n+        LocalSolrQueryRequest otherReq = new LocalSolrQueryRequest(fromCore, qparser.params);\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNDAwNw==", "bodyText": "Perhaps these two lines, setting is filter on the QParser and calling getQuery should be pulled out of the block as it is (or should be) in common with the positive side of the if-else?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370304007", "createdAt": "2020-01-23T19:13:06Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -59,67 +60,124 @@\n import org.apache.solr.search.join.ScoreJoinQParserPlugin;\n import org.apache.solr.util.RTimer;\n import org.apache.solr.util.RefCounted;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class JoinQParserPlugin extends QParserPlugin {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public static final String NAME = \"join\";\n+  /** Choose the internal algorithm */\n+  private static final String METHOD = \"method\";\n+\n+  private static class JoinParams {\n+    final String fromField;\n+    final String fromCore;\n+    final Query fromQuery;\n+    final long fromCoreOpenTime;\n+    final String toField;\n+\n+    public JoinParams(String fromField, String fromCore, Query fromQuery, long fromCoreOpenTime, String toField) {\n+      this.fromField = fromField;\n+      this.fromCore = fromCore;\n+      this.fromQuery = fromQuery;\n+      this.fromCoreOpenTime = fromCoreOpenTime;\n+      this.toField = toField;\n+    }\n+  }\n+\n+  private enum Method {\n+    index {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new JoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    },\n+    dvWithScore {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        return new ScoreJoinQParserPlugin().createParser(qparser.qstr, qparser.localParams, qparser.params, qparser.req).parse();\n+      }\n+    },\n+    topLevelDV {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new TopLevelJoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    };\n+\n+    abstract Query makeFilter(QParser qparser) throws SyntaxError;\n+\n+    JoinParams parseJoin(QParser qparser) throws SyntaxError {\n+      final String fromField = qparser.getParam(\"from\");\n+      final String fromIndex = qparser.getParam(\"fromIndex\");\n+      final String toField = qparser.getParam(\"to\");\n+      final String v = qparser.localParams.get(\"v\");\n+      final String coreName;\n+\n+      Query fromQuery;\n+      long fromCoreOpenTime = 0;\n+\n+      if (fromIndex != null && !fromIndex.equals(qparser.req.getCore().getCoreDescriptor().getName()) ) {\n+        CoreContainer container = qparser.req.getCore().getCoreContainer();\n+\n+        // if in SolrCloud mode, fromIndex should be the name of a single-sharded collection\n+        coreName = ScoreJoinQParserPlugin.getCoreName(fromIndex, container);\n+\n+        final SolrCore fromCore = container.getCore(coreName);\n+        if (fromCore == null) {\n+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+              \"Cross-core join: no such core \" + coreName);\n+        }\n+\n+        RefCounted<SolrIndexSearcher> fromHolder = null;\n+        LocalSolrQueryRequest otherReq = new LocalSolrQueryRequest(fromCore, qparser.params);\n+        try {\n+          QParser parser = QParser.getParser(v, otherReq);\n+          fromQuery = parser.getQuery();\n+          fromHolder = fromCore.getRegisteredSearcher();\n+          if (fromHolder != null) fromCoreOpenTime = fromHolder.get().getOpenNanoTime();\n+        } finally {\n+          otherReq.close();\n+          fromCore.close();\n+          if (fromHolder != null) fromHolder.decref();\n+        }\n+      } else {\n+        coreName = null;\n+        QParser fromQueryParser = qparser.subQuery(v, null);\n+        fromQueryParser.setIsFilter(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNDkwMA==", "bodyText": "Not used?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370304900", "createdAt": "2020-01-23T19:14:55Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -139,11 +197,16 @@ public static Query createJoinQuery(Query subQuery, String fromField, String toF\n \n \n class JoinQuery extends Query {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNDk3Ng==", "bodyText": "Not used?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370304976", "createdAt": "2020-01-23T19:15:06Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -139,11 +197,16 @@ public static Query createJoinQuery(Query subQuery, String fromField, String toF\n \n \n class JoinQuery extends Query {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   String fromField;\n   String toField;\n   String fromIndex; // TODO: name is missleading here compared to JoinQParserPlugin usage - here it must be a core name\n   Query q;\n   long fromCoreOpenTime;\n+  private boolean cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNzM2NQ==", "bodyText": "Couldn't you rename the method and it's variables to remove \"From\" and it would be just as valid?  Okay I see why not; this is an instance method that refers to 'fromField' but if that's the only distinction then maybe it should be a static method and take that argument?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370307365", "createdAt": "2020-01-23T19:20:03Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TopLevelJoinQuery.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.schema.IndexSchema;\n+import org.apache.solr.schema.SchemaField;\n+import org.apache.solr.search.join.MultiValueTermOrdinalCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TopLevelJoinQuery extends JoinQuery {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public TopLevelJoinQuery(String fromField, String toField, String coreName, Query subQuery) {\n+    super(fromField, toField, coreName, subQuery);\n+  }\n+\n+  @Override\n+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+    if (! (searcher instanceof SolrIndexSearcher)) {\n+      log.debug(\"Falling back to JoinQueryWeight because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n+      return super.createWeight(searcher, scoreMode, boost);\n+    }\n+\n+    final SolrIndexSearcher solrSearcher = (SolrIndexSearcher) searcher;\n+    final JoinQueryWeight weight = new JoinQueryWeight(solrSearcher, ScoreMode.COMPLETE_NO_SCORES, 1.0f);\n+    final SolrIndexSearcher fromSearcher = weight.fromSearcher;\n+    final SolrIndexSearcher toSearcher = weight.toSearcher;\n+\n+    try {\n+      final SortedSetDocValues topLevelFromDocValues = validateAndFetchDocValues(fromSearcher, fromField, \"from\");\n+      final SortedSetDocValues topLevelToDocValues = validateAndFetchDocValues(toSearcher, toField, \"to\");\n+      if (topLevelFromDocValues.getValueCount() == 0 || topLevelToDocValues.getValueCount() == 0) {\n+        return createNoMatchesWeight(boost);\n+      }\n+\n+      final LongBitSet fromOrdBitSet = findOrdinalsMatchingFromQuery(fromSearcher, topLevelFromDocValues);\n+      final LongBitSet toOrdBitSet = new LongBitSet(topLevelToDocValues.getValueCount());\n+      final BitsetBounds toBitsetBounds = convertFromOrdinalsIntoToField(fromOrdBitSet, topLevelFromDocValues, toOrdBitSet, topLevelToDocValues);\n+\n+      final boolean toMultivalued = toSearcher.getSchema().getFieldOrNull(toField).multiValued();\n+      return new ConstantScoreWeight(this, boost) {\n+        public Scorer scorer(LeafReaderContext context) throws IOException {\n+          if (toBitsetBounds.lower == BitsetBounds.NO_MATCHES) {\n+            return null;\n+          }\n+\n+          final DocIdSetIterator toApproximation = (toMultivalued) ? context.reader().getSortedSetDocValues(toField) :\n+              context.reader().getSortedDocValues(toField);\n+          if (toApproximation == null) {\n+            return null;\n+          }\n+\n+          final int docBase = context.docBase;\n+          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(toApproximation) {\n+            public boolean matches() throws IOException {\n+              final boolean hasDoc = topLevelToDocValues.advanceExact(docBase + approximation.docID());\n+              if (hasDoc) {\n+                for (long ord = topLevelToDocValues.nextOrd(); ord != -1L; ord = topLevelToDocValues.nextOrd()) {\n+                  if (toOrdBitSet.get(ord)) {\n+                    return true;\n+                  }\n+                }\n+              }\n+              return false;\n+            }\n+\n+            public float matchCost() {\n+              return 10.0F;\n+            }\n+          });\n+\n+        }\n+\n+        public boolean isCacheable(LeafReaderContext ctx) {\n+          return false;\n+        }\n+      };\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private Weight createNoMatchesWeight(float boost) {\n+    return new ConstantScoreWeight(this, boost) {\n+      @Override\n+      public Scorer scorer(LeafReaderContext context) throws IOException {\n+        return null;\n+      }\n+\n+      @Override\n+      public boolean isCacheable(LeafReaderContext ctx) {\n+        return false;\n+      }\n+    };\n+  }\n+\n+  private SortedSetDocValues validateAndFetchDocValues(SolrIndexSearcher solrSearcher, String fieldName, String querySide) throws IOException {\n+    final IndexSchema schema = solrSearcher.getSchema();\n+    final SchemaField field = schema.getFieldOrNull(fieldName);\n+    if (field == null) {\n+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, querySide + \" field '\" + fieldName + \"' does not exist\");\n+    }\n+\n+    if (!field.hasDocValues()) {\n+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+          \"'top-level' join queries require both 'from' and 'to' fields to have docValues, but \" + querySide +\n+              \" field [\" + fieldName +  \"] does not.\");\n+    }\n+\n+    final LeafReader leafReader = solrSearcher.getSlowAtomicReader();\n+    if (field.multiValued()) {\n+      return DocValues.getSortedSet(leafReader, fieldName);\n+    }\n+    return DocValues.singleton(DocValues.getSorted(leafReader, fieldName));\n+  }\n+\n+  private LongBitSet findOrdinalsMatchingFromQuery(SolrIndexSearcher fromSearcher, SortedSetDocValues fromDocValues) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwOTg3NQ==", "bodyText": "Why extend DelegatingCollector?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370309875", "createdAt": "2020-01-23T19:25:23Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/join/MultiValueTermOrdinalCollector.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Populates a bitset of (top-level) ordinals based on field values in a multi-valued field.\n+ */\n+public class MultiValueTermOrdinalCollector extends DelegatingCollector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMTcyNg==", "bodyText": "What's this for?  Looks old/legacy before needsScores became scoreMode yet you just wrote this code.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370311726", "createdAt": "2020-01-23T19:29:08Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/join/MultiValueTermOrdinalCollector.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Populates a bitset of (top-level) ordinals based on field values in a multi-valued field.\n+ */\n+public class MultiValueTermOrdinalCollector extends DelegatingCollector {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private int docBase;\n+  private SortedSetDocValues topLevelDocValues;\n+  private final String fieldName;\n+  private final LongBitSet topLevelDocValuesBitSet;\n+\n+  public MultiValueTermOrdinalCollector(String fieldName, SortedSetDocValues topLevelDocValues, LongBitSet topLevelDocValuesBitSet) {\n+    this.fieldName = fieldName;\n+    this.topLevelDocValues = topLevelDocValues;\n+    this.topLevelDocValuesBitSet = topLevelDocValuesBitSet;\n+  }\n+\n+  public ScoreMode scoreMode() {\n+    return ScoreMode.COMPLETE_NO_SCORES;\n+  }\n+\n+  public boolean needsScores(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMTk0Mw==", "bodyText": "Nothing to log", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370311943", "createdAt": "2020-01-23T19:29:35Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/join/MultiValueTermOrdinalCollector.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Populates a bitset of (top-level) ordinals based on field values in a multi-valued field.\n+ */\n+public class MultiValueTermOrdinalCollector extends DelegatingCollector {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMzE0OQ==", "bodyText": "document this is the outgoing data structure expressing the results.  Could be a trivial comment", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370313149", "createdAt": "2020-01-23T19:32:13Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/join/MultiValueTermOrdinalCollector.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Populates a bitset of (top-level) ordinals based on field values in a multi-valued field.\n+ */\n+public class MultiValueTermOrdinalCollector extends DelegatingCollector {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private int docBase;\n+  private SortedSetDocValues topLevelDocValues;\n+  private final String fieldName;\n+  private final LongBitSet topLevelDocValuesBitSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxODE0OQ==", "bodyText": "This class seems unused; no?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370318149", "createdAt": "2020-01-23T19:43:03Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/join/TopLevelDVTermsCollector.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.LeafCollector;\n+import org.apache.lucene.search.Scorable;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+\n+/**\n+ * Collects all documents with a field value matching a set value in an ordinal bitset.\n+ *\n+ * Implementation is similar to {@link org.apache.lucene.search.join.TermsCollector}, but uses top-level ordinals\n+ * explicitly and has wider visibility.\n+ */\n+public class TopLevelDVTermsCollector extends DelegatingCollector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxOTM3OA==", "bodyText": "Maybe instead of \"inverted index\" (which might confuse people) simply say terms index structure?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370319378", "createdAt": "2020-01-23T19:45:38Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses inverted index structures to process the request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxOTYwMA==", "bodyText": "\"this a\" -> \"this is a\"", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370319600", "createdAt": "2020-01-23T19:46:08Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses inverted index structures to process the request.\n+Performance scales linearly with the number of values matched in the \"from\" field.\n+Consider this method when the \"from\" query matches few documents, when the \"to\" side returns a large number of documents, or when sporadic post-commit slowdowns cannot be tolerated (this a disadvantage of other methods that `index` avoids).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxOTkyMA==", "bodyText": "\"uninverted values\" -> \"the field cache\"\nI believe \"uninvert\" is more of an internal word whereas publicly we say \"field cache\"?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370319920", "createdAt": "2020-01-23T19:46:47Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses inverted index structures to process the request.\n+Performance scales linearly with the number of values matched in the \"from\" field.\n+Consider this method when the \"from\" query matches few documents, when the \"to\" side returns a large number of documents, or when sporadic post-commit slowdowns cannot be tolerated (this a disadvantage of other methods that `index` avoids).\n \n-.Score parameter and single value numerics\n++\n+`dvWithScore` returns an optional \"score\" statistic alongside result documents.\n+Uses docValues structures if available, but falls back to uninverted values when necessary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyMDU4MA==", "bodyText": "\"Uninversion\" -> or maybe \"First access to the field cache\" ?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370320580", "createdAt": "2020-01-23T19:48:18Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses inverted index structures to process the request.\n+Performance scales linearly with the number of values matched in the \"from\" field.\n+Consider this method when the \"from\" query matches few documents, when the \"to\" side returns a large number of documents, or when sporadic post-commit slowdowns cannot be tolerated (this a disadvantage of other methods that `index` avoids).\n \n-.Score parameter and single value numerics\n++\n+`dvWithScore` returns an optional \"score\" statistic alongside result documents.\n+Uses docValues structures if available, but falls back to uninverted values when necessary.\n+Uninversion slows down the initial requests following a commit and takes up additional space on the JVM heap, so docValues are recommended in most situations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODQxNzg0", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-347841784", "createdAt": "2020-01-24T09:47:00Z", "commit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTo0NzowMFrOFhYaDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTo1MDo0MFrOFhYgNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0NzIxMg==", "bodyText": "How long does it take to run? Souldn't it be @slow?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370547212", "createdAt": "2020-01-24T09:47:00Z", "author": {"login": "mkhludnev"}, "path": "solr/core/src/test/org/apache/solr/search/TestJoinQueryPerformance.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.HttpSolrClient;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+\n+public class TestJoinQueryPerformance extends SolrTestCaseJ4 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0Nzc2MQ==", "bodyText": "Printing to stdout is prosecuted.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370547761", "createdAt": "2020-01-24T09:48:21Z", "author": {"login": "mkhludnev"}, "path": "solr/core/src/test/org/apache/solr/search/TestJoinQueryPerformance.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.HttpSolrClient;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+\n+public class TestJoinQueryPerformance extends SolrTestCaseJ4 {\n+  // Dictionary used to load String data\n+  private static final String DICT_PATH = \"/usr/share/dict/words\";\n+  private static final int NUM_DICT_TERMS = 235886;\n+  private static final String[] LOADED_DICTIONARY = new String[NUM_DICT_TERMS];\n+\n+  // Performance run parameters: Indexing\n+  private static final String FROM_COLLECTION_NAME = \"user_acls\";\n+  private static final int NUM_FROM_DOCS = 5050; // 1 + 2 + 3 + 4 + ...  + 100\n+  private static final String TO_COLLECTION_NAME = \"products\";\n+  private static final int NUM_TO_DOCS = 500000;\n+  private static final int PERMISSION_CARDINALITY = 50000; // 50K unique groups/roles/whatever\n+  private static int BATCH_SIZE = 500;\n+  private static int NUM_COMMITS = 500;\n+  private static final int VAL_MAX = 1000;\n+  private static final int USER_MAX = 100;\n+\n+  private static String COLLECTION_NAME= \"foo\";\n+\n+  /*\n+   * As I start out here, I think I'll want a few different axes.\n+   *  - \"from\" collection matches (with \"to\" matches held constant)\n+   *  - \"to\" collection matches (with \"from\" matches held constant)\n+   *\n+   * So I think I should index a finite number of docs\n+   */\n+\n+  @BeforeClass\n+  public static void setUpCluster() throws Exception {\n+    loadDictionary();\n+    //loadCollectionData(DType.USER);\n+    //loadCollectionData(DType.DATA);\n+  }\n+\n+  private static void loadDictionary() throws Exception {\n+    try (BufferedReader reader = new BufferedReader(new FileReader(DICT_PATH))) {\n+      for (int i = 0; i < NUM_DICT_TERMS; i++) {\n+        LOADED_DICTIONARY[i] = reader.readLine();\n+      }\n+    }\n+  }\n+\n+  public enum DType {\n+    USER(NUM_FROM_DOCS, FROM_COLLECTION_NAME) {\n+      // id - unique string\n+      // userid_s - username (user# from 1-100)...each user appears in # entries\n+      // permissions_ss - set of 300 string permissions (cardinality 50K)\n+      @Override\n+      SolrInputDocument buildDoc() {\n+        if (userRecordCounts[currentUser - 1] == currentUser) {\n+          currentUser++;\n+        } else {\n+          userRecordCounts[currentUser -1]++;\n+        }\n+\n+        final SolrInputDocument newDoc = new SolrInputDocument(\"id\", UUID.randomUUID().toString());\n+        final String userString = \"user\" + currentUser;\n+        final String[] permissions = getAFewDictionaryWords(300, PERMISSION_CARDINALITY);\n+\n+        newDoc.addField(\"userid_s\", userString);\n+        newDoc.addField(\"permissions_ss\", permissions);\n+\n+        return newDoc;\n+      }\n+    },\n+    DATA(NUM_TO_DOCS, TO_COLLECTION_NAME) {\n+      // id - unique string\n+      // val_i - random int between 1-1000\n+      // cost_d - random cost between 1-1000\n+      // body_txt - random text string between 100 - 10000 words\n+      // acl_ss - set of 100-3000 string permissions (cardinality 50K)\n+      @Override\n+      SolrInputDocument buildDoc() {\n+        final SolrInputDocument newDoc = new SolrInputDocument(\"id\", UUID.randomUUID().toString());\n+        final int val = random().nextInt(1000) + 1;\n+        final double cost = random().nextDouble() * 1000d;\n+        final String body = String.join(\" \", getAFewDictionaryWords(random().nextInt(9900) + 100));\n+        final String[] acls = getAFewDictionaryWords(random().nextInt(2900) + 100, PERMISSION_CARDINALITY);\n+\n+        newDoc.addField(\"val_i\", val);\n+        newDoc.addField(\"cost_d\", cost);\n+        newDoc.addField(\"body_txt\", body);\n+        newDoc.addField(\"acl_ss\", acls);\n+\n+        return newDoc;\n+      }\n+    };\n+\n+    private int numDocs;\n+    private String collName;\n+    private static int[] userRecordCounts = new int[100];\n+    private static int currentUser = 1;\n+\n+    private DType(int numDocs, String collectionName) {\n+      this.numDocs = numDocs;\n+      this.collName = collectionName;\n+    }\n+\n+    abstract SolrInputDocument buildDoc();\n+  }\n+\n+  private static void loadCollectionData(DType type) throws Exception {\n+    int numDocs = type.numDocs;\n+    String collectionName = type.collName;\n+    int numLoaded = 0;\n+    try (HttpSolrClient client = new HttpSolrClient.Builder(\"http://localhost:8983/solr\").build()) {\n+      final int numBatches = numDocs / BATCH_SIZE + 1;\n+      final int commitEveryBatches = NUM_COMMITS > 0 ? numBatches / NUM_COMMITS : Integer.MAX_VALUE;\n+      int batchCount = 0;\n+      while (numLoaded < numDocs) {\n+        final int sizeOfBatch = numLoaded + BATCH_SIZE > numDocs ? numDocs - numLoaded : BATCH_SIZE;\n+        final Collection<SolrInputDocument> batch = buildBatch(type, sizeOfBatch);\n+        client.add(collectionName, batch);\n+        batchCount++;\n+        numLoaded+=sizeOfBatch;\n+\n+        if (batchCount == commitEveryBatches) {\n+          client.commit(collectionName);\n+          batchCount = 0;\n+        }\n+      }\n+      client.commit(collectionName);\n+    }\n+\n+  }\n+\n+  private static Collection<SolrInputDocument> buildBatch(DType type, int sizeOfBatch) {\n+    final List<SolrInputDocument> batch = Lists.newArrayList();\n+    for (int i = 0; i < sizeOfBatch; i++) {\n+      batch.add(type.buildDoc());\n+    }\n+    return batch;\n+  }\n+\n+  private static String[] getAFewDictionaryWords(int numWords) {\n+    return getAFewDictionaryWords(numWords, NUM_DICT_TERMS);\n+  }\n+\n+  private static String[] getAFewDictionaryWords(int numWords, int onlyFirstN) {\n+    final String[] words = new String[numWords];\n+    for (int i = 0; i < numWords; i++) {\n+      words[i] = LOADED_DICTIONARY[random().nextInt(onlyFirstN)];\n+    }\n+\n+    return words;\n+  }\n+\n+\n+  @Test\n+  public void testJoinPerformanceAsMainQueryHitsIncrease() throws Exception {\n+    final String joinQueryBase = \"{!join fromIndex=\" + FROM_COLLECTION_NAME + \" from=permissions_ss to=acl_ss cache=false\";\n+    final String fromQuery = \"userid_s:user25\"; // The higher the user number, the more permissions he has attached to his name (1-100)\n+    final String standardJoin = joinQueryBase + \"}\" + fromQuery;\n+    final String noScoreJoin = joinQueryBase + \" score=none}\" + fromQuery;\n+    final String tpiJoin = joinQueryBase + \" toplevel=true}\" + fromQuery;\n+\n+    try (HttpSolrClient client = new HttpSolrClient.Builder(\"http://localhost:8983/solr\").build()) {\n+      for ( int i = 0; i < VAL_MAX; i+=20) {\n+        final String mainQuery = \"val_i:[1 TO \" + (i+1) + \"]\";\n+        final QueryResponse standardJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", standardJoin), SolrRequest.METHOD.POST);\n+        final QueryResponse tpiJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", tpiJoin), SolrRequest.METHOD.POST);\n+        final QueryResponse noScoreJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", noScoreJoin), SolrRequest.METHOD.POST);\n+        final long numFound = tpiJoinRsp.getResults().getNumFound();\n+\n+        System.out.println(i + \",\" + numFound + \",\" + standardJoinRsp.getQTime() + \",\" + noScoreJoinRsp.getQTime() + \",\" + tpiJoinRsp.getQTime());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testJoinPerformanceAsFromQueryHitsIncrease() throws Exception {\n+    final String mainQuery = \"val_i:[1 TO 250]\"; // Half the docs match the query (250K)\n+\n+    final String joinQueryBase = \"{!join fromIndex=\" + FROM_COLLECTION_NAME + \" from=permissions_ss to=acl_ss cache=false\";\n+\n+\n+    try (HttpSolrClient client = new HttpSolrClient.Builder(\"http://localhost:8983/solr\").build()) {\n+      for ( int i = 1; i <= USER_MAX; i++) {\n+        final String fromQuery = \"userid_s:user\" + i;\n+        final String standardJoin = joinQueryBase + \"}\" + fromQuery;\n+        final String noScoreJoin = joinQueryBase + \" score=none}\" + fromQuery;\n+        final String tpiJoin = joinQueryBase + \" toplevel=true}\" + fromQuery;\n+\n+        final QueryResponse standardJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", standardJoin), SolrRequest.METHOD.POST);\n+        final QueryResponse tpiJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", tpiJoin), SolrRequest.METHOD.POST);\n+        final QueryResponse noScoreJoinRsp = client.query(TO_COLLECTION_NAME, new SolrQuery(\"q\", mainQuery, \"fq\", noScoreJoin), SolrRequest.METHOD.POST);\n+        final long numFound = tpiJoinRsp.getResults().getNumFound();\n+\n+        System.out.println(i + \",\" + numFound + \",\" + standardJoinRsp.getQTime() + \",\" + noScoreJoinRsp.getQTime() + \",\" + tpiJoinRsp.getQTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0ODc5MA==", "bodyText": "Shouldn't it load at least anything?", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r370548790", "createdAt": "2020-01-24T09:50:40Z", "author": {"login": "mkhludnev"}, "path": "solr/core/src/test/org/apache/solr/search/TestJoinQueryPerformance.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.HttpSolrClient;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+\n+public class TestJoinQueryPerformance extends SolrTestCaseJ4 {\n+  // Dictionary used to load String data\n+  private static final String DICT_PATH = \"/usr/share/dict/words\";\n+  private static final int NUM_DICT_TERMS = 235886;\n+  private static final String[] LOADED_DICTIONARY = new String[NUM_DICT_TERMS];\n+\n+  // Performance run parameters: Indexing\n+  private static final String FROM_COLLECTION_NAME = \"user_acls\";\n+  private static final int NUM_FROM_DOCS = 5050; // 1 + 2 + 3 + 4 + ...  + 100\n+  private static final String TO_COLLECTION_NAME = \"products\";\n+  private static final int NUM_TO_DOCS = 500000;\n+  private static final int PERMISSION_CARDINALITY = 50000; // 50K unique groups/roles/whatever\n+  private static int BATCH_SIZE = 500;\n+  private static int NUM_COMMITS = 500;\n+  private static final int VAL_MAX = 1000;\n+  private static final int USER_MAX = 100;\n+\n+  private static String COLLECTION_NAME= \"foo\";\n+\n+  /*\n+   * As I start out here, I think I'll want a few different axes.\n+   *  - \"from\" collection matches (with \"to\" matches held constant)\n+   *  - \"to\" collection matches (with \"from\" matches held constant)\n+   *\n+   * So I think I should index a finite number of docs\n+   */\n+\n+  @BeforeClass\n+  public static void setUpCluster() throws Exception {\n+    loadDictionary();\n+    //loadCollectionData(DType.USER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "955bfbe76a05e98ac1614d30fdacb14eb0421f41", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/955bfbe76a05e98ac1614d30fdacb14eb0421f41", "committedDate": "2020-01-27T15:18:50Z", "message": "SOLR-13892: Address review feedback, round 1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NzIzNTA0", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-348723504", "createdAt": "2020-01-27T14:56:11Z", "commit": {"oid": "73c13faf86144cf39c5ccb1e60fedad917e6b429"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo1NjoxMVrOFiFjUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxMToyNFrOFiGHqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Njg2Ng==", "bodyText": "Totally agree - should be using try-with-resources here.\nBut I'm reluctant to introduce changes here that aren't strictly necessary.  (Github shows this section as \"added\", but really it was just moved from elsewhere in the file.)\nMy opinion on this changes, but I've been burned too many times recently by adding a \"harmless\" refactor into a related commit, only for that to cause issues later that force a revert.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r371286866", "createdAt": "2020-01-27T14:56:11Z", "author": {"login": "gerlowskija"}, "path": "solr/core/src/java/org/apache/solr/search/JoinQParserPlugin.java", "diffHunk": "@@ -59,67 +60,124 @@\n import org.apache.solr.search.join.ScoreJoinQParserPlugin;\n import org.apache.solr.util.RTimer;\n import org.apache.solr.util.RefCounted;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class JoinQParserPlugin extends QParserPlugin {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public static final String NAME = \"join\";\n+  /** Choose the internal algorithm */\n+  private static final String METHOD = \"method\";\n+\n+  private static class JoinParams {\n+    final String fromField;\n+    final String fromCore;\n+    final Query fromQuery;\n+    final long fromCoreOpenTime;\n+    final String toField;\n+\n+    public JoinParams(String fromField, String fromCore, Query fromQuery, long fromCoreOpenTime, String toField) {\n+      this.fromField = fromField;\n+      this.fromCore = fromCore;\n+      this.fromQuery = fromQuery;\n+      this.fromCoreOpenTime = fromCoreOpenTime;\n+      this.toField = toField;\n+    }\n+  }\n+\n+  private enum Method {\n+    index {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new JoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    },\n+    dvWithScore {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        return new ScoreJoinQParserPlugin().createParser(qparser.qstr, qparser.localParams, qparser.params, qparser.req).parse();\n+      }\n+    },\n+    topLevelDV {\n+      @Override\n+      Query makeFilter(QParser qparser) throws SyntaxError {\n+        final JoinParams jParams = parseJoin(qparser);\n+        final JoinQuery q = new TopLevelJoinQuery(jParams.fromField, jParams.toField, jParams.fromCore, jParams.fromQuery);\n+        q.fromCoreOpenTime = jParams.fromCoreOpenTime;\n+        return q;\n+      }\n+    };\n+\n+    abstract Query makeFilter(QParser qparser) throws SyntaxError;\n+\n+    JoinParams parseJoin(QParser qparser) throws SyntaxError {\n+      final String fromField = qparser.getParam(\"from\");\n+      final String fromIndex = qparser.getParam(\"fromIndex\");\n+      final String toField = qparser.getParam(\"to\");\n+      final String v = qparser.localParams.get(\"v\");\n+      final String coreName;\n+\n+      Query fromQuery;\n+      long fromCoreOpenTime = 0;\n+\n+      if (fromIndex != null && !fromIndex.equals(qparser.req.getCore().getCoreDescriptor().getName()) ) {\n+        CoreContainer container = qparser.req.getCore().getCoreContainer();\n+\n+        // if in SolrCloud mode, fromIndex should be the name of a single-sharded collection\n+        coreName = ScoreJoinQParserPlugin.getCoreName(fromIndex, container);\n+\n+        final SolrCore fromCore = container.getCore(coreName);\n+        if (fromCore == null) {\n+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+              \"Cross-core join: no such core \" + coreName);\n+        }\n+\n+        RefCounted<SolrIndexSearcher> fromHolder = null;\n+        LocalSolrQueryRequest otherReq = new LocalSolrQueryRequest(fromCore, qparser.params);\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4MjU5Mg=="}, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5NjE3MQ==", "bodyText": "Because it saves me from reimplementing getLeafCollector() and some other methods.  If you're wondering why DelegatingCollector as opposed to SimpleCollector or other options, there's not a great answer - DelegatingCollector was needed in some earlier revision when things were postfilter based.  I've changed it to use SimpleCollector; hopefully that addresses your concern.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r371296171", "createdAt": "2020-01-27T15:11:24Z", "author": {"login": "gerlowskija"}, "path": "solr/core/src/java/org/apache/solr/search/join/MultiValueTermOrdinalCollector.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search.join;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.search.DelegatingCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Populates a bitset of (top-level) ordinals based on field values in a multi-valued field.\n+ */\n+public class MultiValueTermOrdinalCollector extends DelegatingCollector {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwOTg3NQ=="}, "originalCommit": {"oid": "ac33c8efb5146a94347d7e340d199dfbf8548834"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4ODQwNzM5", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-348840739", "createdAt": "2020-01-27T17:25:52Z", "commit": {"oid": "955bfbe76a05e98ac1614d30fdacb14eb0421f41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNzoyNTo1MlrOFiLCbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNzoyNTo1MlrOFiLCbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM3Njc0OA==", "bodyText": "Always add at least one sentence javadoc for a class", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r371376748", "createdAt": "2020-01-27T17:25:52Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TopLevelJoinQuery.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.Collector;\n+import org.apache.lucene.search.ConstantScoreScorer;\n+import org.apache.lucene.search.ConstantScoreWeight;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.LongBitSet;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.schema.IndexSchema;\n+import org.apache.solr.schema.SchemaField;\n+import org.apache.solr.search.join.MultiValueTermOrdinalCollector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TopLevelJoinQuery extends JoinQuery {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "955bfbe76a05e98ac1614d30fdacb14eb0421f41"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e1795f1e261345544bdde949400ce8a4dd4c51b", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/2e1795f1e261345544bdde949400ce8a4dd4c51b", "committedDate": "2020-01-28T03:10:05Z", "message": "SOLR-13892: Address review feedback, round 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a75475ffecfc4cbe05adf3f0fb7cbbcdcbe88f5", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/5a75475ffecfc4cbe05adf3f0fb7cbbcdcbe88f5", "committedDate": "2020-01-28T03:12:55Z", "message": "Merge branch 'master' into jira/solr-13892"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99c336b6ef3274ec8572813b79bdd0fdea25ca57", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/99c336b6ef3274ec8572813b79bdd0fdea25ca57", "committedDate": "2020-01-29T13:26:27Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjExNTEy", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-350611512", "createdAt": "2020-01-30T06:55:26Z", "commit": {"oid": "99c336b6ef3274ec8572813b79bdd0fdea25ca57"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNjo1NToyNlrOFjg7CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNjo1NzowOFrOFjg8vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4Mzg4MA==", "bodyText": "Here I would disagree. Old solr's join loops term enums. So, number of terms and posings in from  dominates over number of from side matches in the overall complexity. see the thread linked at SOLR-14230, and also something like this is explained in LW's blogpost.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r372783880", "createdAt": "2020-01-30T06:55:26Z", "author": {"login": "mkhludnev"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses the terms index structures to process the request.\n+Performance scales linearly with the number of values matched in the \"from\" field.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99c336b6ef3274ec8572813b79bdd0fdea25ca57"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4NDMxOQ==", "bodyText": "That what I always think, but giving the mail linked to SOLR-14230 there might be something broken in fallback. I'll clarify.", "url": "https://github.com/apache/lucene-solr/pull/1171#discussion_r372784319", "createdAt": "2020-01-30T06:57:08Z", "author": {"login": "mkhludnev"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -591,36 +591,95 @@ The hash range query parser uses a special cache to improve the speedup of the q\n \n == Join Query Parser\n \n-`JoinQParser` extends the `QParserPlugin`. It allows normalizing relationships between documents with a join operation. This is different from the concept of a join in a relational database because no information is being truly joined. An appropriate SQL analogy would be an \"inner query\".\n+The Join query parser allows users to run queries that normalize relationships between documents.\n+Solr runs a subquery of the user's choosing (the `v` param), identifies all the values that matching documents have in a field of interest (the `from` param), and then returns documents where those values are contained in a second field of interest (the `to` param).\n \n-Examples:\n-\n-Find all products containing the word \"ipod\", join them against manufacturer docs and return the list of manufacturers:\n+In practice, these semantics are much like \"inner queries\" in a SQL engine.\n+As an example, consider the Solr query below:\n \n [source,text]\n ----\n-{!join from=manu_id_s to=id}ipod\n+/solr/techproducts/select?q={!join from=manu_id_s to=id}title:ipod\n ----\n \n-Find all manufacturer docs named \"belkin\", join them against product docs, and filter the list to only products with a price less than $12:\n+This query, which returns a document for each manufacturer that makes a product with \"ipod\" in the title, is semantically identical to the SQL query below:\n \n [source,text]\n ----\n-q  = {!join from=id to=manu_id_s}compName_s:Belkin\n-fq = price:[* TO 12]\n+SELECT *\n+FROM techproducts\n+WHERE id IN (\n+    SELECT manu_id_s\n+    FROM techproducts\n+    WHERE title='ipod'\n+  )\n ----\n \n-The join operation is done on a term basis, so the \"from\" and \"to\" fields must use compatible field types. For example: joining between a `StrField` and a `IntPointField` will not work, likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+The join operation is done on a term basis, so the `from` and `to` fields must use compatible field types.\n+For example: joining between a `StrField` and a `IntPointField` will not work.\n+Likewise joining between a `StrField` and a `TextField` that uses `LowerCaseFilterFactory` will only work for values that are already lower cased in the string field.\n+\n+=== Parameters\n+\n+This query parser takes the following parameters:\n+\n+`from`::\n+The name of a field which contains values to look for in the \"to\" field.\n+Can be single or multi-valued, but must have a field type compatible with the field represented in the \"to\" field.\n+This parameter is required.\n+\n+`to`::\n+The name of a field whose value(s) will be checked against those found in the \"from\" field.\n+Can be single or multi-valued, but must have a field type compatible with the \"from\" field.\n+This parameter is required.\n+\n+`fromIndex`::\n+The name of the index to run the \"from\" query (`v` parameter) on and where \"from\" values are gathered.\n+Must be located on the same node as the core processing the request.\n+This parameter is optional; it defaults to the value of the processing core if not specified.\n+See <<Joining Across Collections,Joining Across Collections>> below for more information.\n+\n+`score`::\n+An optional parameter that instructs Solr to return information about the \"from\" query scores.\n+The value of this parameter controls what type of aggregation information is returned.\n+Options include `avg` (average), `max` (maximum), `min` (minimum), `total` (total), or `none`.\n++\n+If `method` is not specified but `score` is, then the `dvWithScore` method is used.\n+If `method` is specified and is not `dvWithScore`, then the `score` value is ignored.\n+See the `method` parameter documentation below for more details.\n \n-=== Join Parser Scoring\n \n-You can optionally use the `score` parameter to return scores of the subordinate query. The values to use for this parameter define the type of aggregation, which are `avg` (average), `max` (maximum), `min` (minimum) `total`, or `none`.\n+`method`::\n+An optional parameter used to determine which of several query implementations should be used by Solr.\n+Options are restricted to: `index`, `dvWithScore`, and `topLevelDV`.\n+If unspecified the default value is `index`, unless the `score` parameter is present which overrides it to `dvWithScore`.\n+Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.\n+Details and performance heuristics are given below.\n++\n+`index` the default `method` unless the `score` parameter is specified.\n+Uses the terms index structures to process the request.\n+Performance scales linearly with the number of values matched in the \"from\" field.\n+Consider this method when the \"from\" query matches few documents, when the \"to\" side returns a large number of documents, or when sporadic post-commit slowdowns cannot be tolerated (this is a disadvantage of other methods that `index` avoids).\n \n-.Score parameter and single value numerics\n++\n+`dvWithScore` returns an optional \"score\" statistic alongside result documents.\n+Uses docValues structures if available, but falls back to the field cache when necessary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99c336b6ef3274ec8572813b79bdd0fdea25ca57"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d615522c0075b39208801da0d13509961a2e787", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/1d615522c0075b39208801da0d13509961a2e787", "committedDate": "2020-01-30T18:18:11Z", "message": "Address review feedback, rd #3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDc3MDY3", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-351077067", "createdAt": "2020-01-30T19:18:27Z", "commit": {"oid": "1d615522c0075b39208801da0d13509961a2e787"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMzI5NDUy", "url": "https://github.com/apache/lucene-solr/pull/1171#pullrequestreview-351329452", "createdAt": "2020-01-31T07:27:17Z", "commit": {"oid": "1d615522c0075b39208801da0d13509961a2e787"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a83816e51189f0963cf4247a4fcfa6224f61951", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/4a83816e51189f0963cf4247a4fcfa6224f61951", "committedDate": "2020-01-31T12:54:06Z", "message": "SOLR-13892: CHANGES.txt entry"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2385, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}