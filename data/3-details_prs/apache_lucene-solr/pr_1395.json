{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NDE5MjY3", "number": 1395, "title": "SOLR-14365: CollapsingQParser - Avoiding always allocate int[] and float[] with size equals to number of unique values (WIP)", "bodyText": "", "createdAt": "2020-04-02T08:04:33Z", "url": "https://github.com/apache/lucene-solr/pull/1395", "merged": true, "mergeCommit": {"oid": "adbd714b37d794e9aa7615e61c431e42162c1d3c"}, "closed": true, "closedAt": "2020-04-10T08:24:11Z", "author": {"login": "CaoManhDat"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTnq1wAH2gAyMzk3NDE5MjY3OjBkODJhOWY1Y2RhYzY3YzlkZTkyYzk3OWUwMTZjMWM2YjFmOGRjZjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWMSvmgH2gAyMzk3NDE5MjY3OjBlMTQ4MDcxMDQyMDU2NTg3YmQ5MzQ3OTZiY2UzYzI3ZGE4MWY5MjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "committedDate": "2020-04-02T08:03:44Z", "message": "SOLR-14365: CollapsingQParser - Avoiding always allocate int[] and float[] with size equals to number of unique values (WIP)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjgyNDM5", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-386282439", "createdAt": "2020-04-02T10:06:46Z", "commit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowNjo0NlrOF_kRlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDoyMTo1OFrOF_kyAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5ODkzNA==", "bodyText": "Should be named \"capacity\" rather than \"size\".", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402198934", "createdAt": "2020-04-02T10:06:46Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMDA5Mg==", "bodyText": "keyValues.length is a capacity while size() semantics is more a size: the current number of entries in the map. We should return a counter instead.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402200092", "createdAt": "2020-04-02T10:08:48Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;\n+  private int[] keyValues;\n+  private int emptyValue;\n+\n+  public IntIntArrayBasedMap(int initialSize, int emptyValue) {\n+    this.size = initialSize;\n+    this.keyValues = new int[initialSize];\n+    this.emptyValue = emptyValue;\n+    if (emptyValue != 0) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+  }\n+\n+  @Override\n+  public void set(int key, int value) {\n+    if (key >= size) {\n+      keyValues = ArrayUtil.grow(keyValues);\n+      if (emptyValue != 0) {\n+        for (int i = size; i < keyValues.length; i++) {\n+          keyValues[i] = emptyValue;\n+        }\n+      }\n+      size = keyValues.length;\n+    }\n+    keyValues[key] = value;\n+  }\n+\n+  @Override\n+  public int get(int key) {\n+    if (key >= size) {\n+      return emptyValue;\n+    }\n+    return keyValues[key];\n+  }\n+\n+  @Override\n+  public void forEachValue(IntConsumer consumer) {\n+    for (int val: keyValues) {\n+      if (val != emptyValue) {\n+        consumer.accept(val);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void remove(int key) {\n+    if (key < size) keyValues[key] = emptyValue;\n+  }\n+\n+  @Override\n+  public int size() {\n+    return keyValues.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMTM5NA==", "bodyText": "Here keyValues is enlarged (based on its current capacity), but are we sure it is enlarged enough to hold \"key\"?", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402201394", "createdAt": "2020-04-02T10:11:05Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;\n+  private int[] keyValues;\n+  private int emptyValue;\n+\n+  public IntIntArrayBasedMap(int initialSize, int emptyValue) {\n+    this.size = initialSize;\n+    this.keyValues = new int[initialSize];\n+    this.emptyValue = emptyValue;\n+    if (emptyValue != 0) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+  }\n+\n+  @Override\n+  public void set(int key, int value) {\n+    if (key >= size) {\n+      keyValues = ArrayUtil.grow(keyValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ==", "bodyText": "I agree that we should use primitive map instead of array if we don't load enough arrays. The speed of the map put/get is sufficiently fast that I suppose it should not be visible in the overall perf of this CollapsingQParser.\nBut do we need to have a new factory for primitive map to switch between hash map and array? I think we could need this if we often had both cases (high load and low load of the array) AND if we had a way to switch automatically. But I suppose we don't know in advance (so we don't switch auto), and that most often the load is low.\nSo I suggest that we don't add the complexity of these new classes (the new util.numeric package) and we just use HPPC primitive map directly.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402207235", "createdAt": "2020-04-02T10:21:58Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java", "diffHunk": "@@ -524,6 +533,7 @@ public int docID() {\n \n     public OrdScoreCollector(int maxDoc,\n                              int segments,\n+                             PrimitiveMapFactory mapFactory,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1190118cfe8c4ccb5c564d0fdc712f6a12372d39", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/1190118cfe8c4ccb5c564d0fdc712f6a12372d39", "committedDate": "2020-04-04T03:22:45Z", "message": "Adding benchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "committedDate": "2020-04-07T09:26:24Z", "message": "SOLR-14365: Switch to dynamic map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05e40c11a837fc732158d35e8d228337e434e9ae", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/05e40c11a837fc732158d35e8d228337e434e9ae", "committedDate": "2020-04-07T09:27:46Z", "message": "Comments update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/66de7721d182defb4b8143063cc1f6b0d3fc4963", "committedDate": "2020-04-07T09:28:51Z", "message": "Remove benchmark code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDg2NDYy", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-389086462", "createdAt": "2020-04-07T12:55:59Z", "commit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMjo1NjowMFrOGCCK9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMjo1Njo1OVrOGCCNYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NTkwOA==", "bodyText": "Safer to add +1\n(int) (threshold(expectedMaxSize) / HashContainers.DEFAULT_LOAD_FACTOR) + 1", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404785908", "createdAt": "2020-04-07T12:56:00Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import com.carrotsearch.hppc.HashContainers;\n+\n+public interface DynamicMap {\n+  static boolean useArrayBased(int expectedMaxSize) {\n+    // for small size, prefer using array based\n+    return expectedMaxSize < (1 << 12);\n+  }\n+\n+  static int threshold(int expectedMaxSize) {\n+    return expectedMaxSize >>> 6;\n+  }\n+\n+  static int mapExpectedElements(int expectedMaxSize) {\n+    return (int) (threshold(expectedMaxSize) / HashContainers.DEFAULT_LOAD_FACTOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NjUyOQ==", "bodyText": "Safer to test >=\nif (this.hashMap.size() >= threshold) {", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404786529", "createdAt": "2020-04-07T12:56:59Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {\n+        growBuffer(key + 1);\n+      }\n+      keyValues[key] = value;\n+    } else {\n+      this.hashMap.put(key, value);\n+      this.maxSize = Math.max(key, maxSize);\n+      if (this.hashMap.size() > threshold) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MzMwMjEy", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-389330212", "createdAt": "2020-04-07T17:20:07Z", "commit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyMDowN1rOGCOEJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyMDowN1rOGCOEJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDc3NA==", "bodyText": "Actually I missed here something risky: what if a large key is provided? We have no protection here yet. Nothing prevents the user to put a key 500M. In this case we should not grow the array too large just for one key.\nMaybe we should have a strong limit on the map capacity in the constructor.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404980774", "createdAt": "2020-04-07T17:20:07Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDI4NzI4", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-389428728", "createdAt": "2020-04-07T19:34:17Z", "commit": {"oid": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTozNDoxOFrOGCTA6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTozNDozM1rOGCTBXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MTg2NA==", "bodyText": "if assertions are enabled, then perhaps return false so as to have tests test the DynamicMap.  I've seen @yonik use this technique in data structure sizing and thought it was clever.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405061864", "createdAt": "2020-04-07T19:34:18Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -17,13 +17,19 @@\n \n package org.apache.solr.util.numeric;\n \n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n+import com.carrotsearch.hppc.HashContainers;\n \n-public interface IntIntMap {\n-  void set(int key, int value);\n-  int get(int key);\n-  void forEachValue(IntConsumer consumer);\n-  void remove(int key);\n-  int size();\n+public interface DynamicMap {\n+  static boolean useArrayBased(int expectedMaxSize) {\n+    // for small data set, prefer using array based\n+    return expectedMaxSize < (1 << 12);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MTk4MQ==", "bodyText": "Needs docs!", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405061981", "createdAt": "2020-04-07T19:34:33Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -17,13 +17,19 @@\n \n package org.apache.solr.util.numeric;\n \n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n+import com.carrotsearch.hppc.HashContainers;\n \n-public interface IntIntMap {\n-  void set(int key, int value);\n-  int get(int key);\n-  void forEachValue(IntConsumer consumer);\n-  void remove(int key);\n-  int size();\n+public interface DynamicMap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA3Mzk5", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-389607399", "createdAt": "2020-04-08T02:08:46Z", "commit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODo0NlrOGCcfyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODo0NlrOGCcfyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzIyNw==", "bodyText": "@dsmiley @bruno-roustant If we do not allow resizing automatically (which I would like to do), then how can we deal with this case?", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405217227", "createdAt": "2020-04-08T02:08:46Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java", "diffHunk": "@@ -2258,29 +2215,20 @@ public void collapse(int collapseKey, int contextDoc, int globalDoc) throws IOEx\n         final int idx;\n         if((idx = cmap.indexOf(collapseKey)) >= 0) {\n           int pointer = cmap.indexGet(idx);\n-          if(comp.test(currentVal, testValues[pointer])) {\n-            testValues[pointer]= currentVal;\n-            docs[pointer] = globalDoc;\n+          if(comp.test(currentVal, testValues.get(pointer))) {\n+            testValues.set(pointer, currentVal);\n+            docs.set(pointer, globalDoc);\n             if(needsScores) {\n-              scores[pointer] = scorer.score();\n+              scores.set(pointer, scorer.score());\n             }\n           }\n         } else {\n           ++index;\n           cmap.put(collapseKey, index);\n-          if(index == testValues.length) {\n-            testValues = ArrayUtil.grow(testValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 894}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/2748def6330d1e7b63bb10e13ab2757d67d4c614", "committedDate": "2020-04-08T08:46:54Z", "message": "Rename set(key, val) -> put(key, val) and add javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODI0MzE2", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-389824316", "createdAt": "2020-04-08T09:54:56Z", "commit": {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwOTo1NDo1NlrOGCn1lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoxNTo1OFrOGCsdPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwMzAyOA==", "bodyText": "Javadoc: similar to java.util.function.IntConsumer", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405403028", "createdAt": "2020-04-08T09:54:56Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/FloatConsumer.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+@FunctionalInterface\n+public interface FloatConsumer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwNjkzNQ==", "bodyText": "We can be explicit and say: more than key x 4B, so for a max key 100M it may allocate more than 400 MB.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405406935", "createdAt": "2020-04-08T10:01:25Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntFloatDynamicMap implements DynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  /**\n+   * Create map with expected max value of key.\n+   * Although the map will automatically do resizing to be able to hold key >= {@code expectedKeyMax}.\n+   * But putting key much larger than {@code expectedKeyMax} is discourage since it can leads to use LOT OF memory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxMTE3Mw==", "bodyText": "The javadoc in the constructor is good, but I'm concerned that this util class may be used elsewhere without clearly reading/understanding the risk. Mainly because the class is named Map, and a Map generally can take any key value.\nCould we create a second constructor with a third param, something like \"hardLimitKeyMax\" which would be checked here otherwise throw an IllegalArgumentException? It could have a default limit of 10x expectedKeyMax in the first constructor for example. And it could be increased if someone knows what she is doing.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405411173", "createdAt": "2020-04-08T10:08:43Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDc3NA=="}, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODcxNw==", "bodyText": "Did you test and debug when the DynamicMap upgrades from a map to an array internally? I mean in debug mode step by step here. I think the map first enlarges and rehashes just before the upgrade to an array.\nLet's take an example with expectedKeyMax = 500K.\nthis.threshold = threshold(expectedKeyMax) = 500000/64 = 7812\nIntFloatHashMap initial capacity = mapExpectedElements(expectedKeyMax) = (int) (threshold(expectedKeyMax) / 0.75f) = (int) (7812 / 0.75f) = 10416\nIntFloatHashMap internal threshold = ceil(initial capacity * 0.75) = ceil(10416 * 0.75) = 7812\nInternally the HPPC map enlarges during a put() when its size == 7812 before incrementing the size.\nHere the condition to upgrade to an array triggers when the map size after the put is > 7812, so at 7813.\nSo I think the map first enlarges and rehashes just before we upgrade to an array, which would be wasteful.\nAlso, the map internal threshold is ceil(initial capacity * 0.75), but it could be without ceil() for other implementations. To be safe wrt the float rounding, I suggested to add +1 in DynamicMap. mapExpectedElements(int), but it is probably better to be safe here.", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405478717", "createdAt": "2020-04-08T12:15:58Z", "author": {"login": "bruno-roustant"}, "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {\n+        growBuffer(key + 1);\n+      }\n+      keyValues[key] = value;\n+    } else {\n+      this.hashMap.put(key, value);\n+      this.maxSize = Math.max(key, maxSize);\n+      if (this.hashMap.size() > threshold) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NjUyOQ=="}, "originalCommit": {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDc2NjU1", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-390076655", "createdAt": "2020-04-08T15:19:10Z", "commit": {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc4d33f850e8cf11a0616cadc1fef07ed5be9f35", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/cc4d33f850e8cf11a0616cadc1fef07ed5be9f35", "committedDate": "2020-04-09T02:12:39Z", "message": "Move classes to util package and adding test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNDU2MjMz", "url": "https://github.com/apache/lucene-solr/pull/1395#pullrequestreview-390456233", "createdAt": "2020-04-09T02:43:30Z", "commit": {"oid": "cc4d33f850e8cf11a0616cadc1fef07ed5be9f35"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47a9793a97d3784689d6374769f36c0111adf09c", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/47a9793a97d3784689d6374769f36c0111adf09c", "committedDate": "2020-04-09T03:04:50Z", "message": "Fix precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77635050d238c8fbe517fc41b42de5d58d14c0da", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/77635050d238c8fbe517fc41b42de5d58d14c0da", "committedDate": "2020-04-09T06:59:26Z", "message": "Update CHANGES"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e148071042056587bd934796bce3c27da81f922", "author": {"user": {"login": "CaoManhDat", "name": "Cao Manh Dat"}}, "url": "https://github.com/apache/lucene-solr/commit/0e148071042056587bd934796bce3c27da81f922", "committedDate": "2020-04-10T07:51:45Z", "message": "Merge branch 'master' into jira/SOLR-14365"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2075, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}