{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1OTYyNzc5", "number": 1737, "title": "SOLR-14615: Implement CPU Utilization Based Circuit Breaker", "bodyText": "This commit introduces CPU based circuit breaker. This circuit breaker\ntracks the average CPU load per minute and triggers if the value exceeds\na configurable value.\nThis commit also adds a specific control flag for Memory Circuit Breaker\nto allow enabling/disabling the same.", "createdAt": "2020-08-11T08:48:18Z", "url": "https://github.com/apache/lucene-solr/pull/1737", "merged": true, "mergeCommit": {"oid": "2f37f401715b6cefe0425ca591c6764f2072045e"}, "closed": true, "closedAt": "2020-08-20T07:51:27Z", "author": {"login": "atris"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9ywO-AH2gAyNDY1OTYyNzc5OjI3YTY2YTAxMTdhMWFhN2RmMThhZjlhNDk3N2UyYWI4Y2YxMTc3ZmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAp73eAH2gAyNDY1OTYyNzc5OmQ5NjRkZGIzYWRmNDk0Yzg0MTdiMmQwM2U0Yjc5YTM0ZjVjODYzNWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "27a66a0117a1aa7df18af9a4977e2ab8cf1177fc", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/27a66a0117a1aa7df18af9a4977e2ab8cf1177fc", "committedDate": "2020-08-11T08:43:24Z", "message": "SOLR-14615: Implement CPU Utilization Based Circuit Breaker\n\nThis commit introduces CPU based circuit breaker. This circuit breaker\ntracks the average CPU load per minute and triggers if the value exceeds\na configurable value.\n\nThis commit also adds a specific control flag for Memory Circuit Breaker\nto allow enabling/disabling the same."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf897f8ea89c5aed93cbbc242a9da1eedfbbe539", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/cf897f8ea89c5aed93cbbc242a9da1eedfbbe539", "committedDate": "2020-08-11T08:45:07Z", "message": "Remove redundant stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96513f0e2fc47e23c32deda7c972e00e2e6ec85f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/96513f0e2fc47e23c32deda7c972e00e2e6ec85f", "committedDate": "2020-08-11T08:46:41Z", "message": "Add CHANGES.txt entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f44a29841e2e6bb8555702b81eca358bb10f52e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/1f44a29841e2e6bb8555702b81eca358bb10f52e", "committedDate": "2020-08-11T08:51:35Z", "message": "Remove redundant print statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/342f5277de21d8284292e769266ffdf5c1afd1c0", "committedDate": "2020-08-11T11:00:41Z", "message": "Update to use Java MXBean"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjM1Mjcy", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-465235272", "createdAt": "2020-08-11T16:30:28Z", "commit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjozMDoyOFrOG-_3Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjozNToyMlrOG_ADKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMTI2Ng==", "bodyText": "thread locals should be static", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468711266", "createdAt": "2020-08-11T16:30:28Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjMxNA==", "bodyText": "I don't think CPU load average is typically measured on a 0-100 scale. Can you confirm some sample values of what calculateLiveCPUUsage returns?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468712314", "createdAt": "2020-08-11T16:32:08Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -811,10 +818,18 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n-  private void validateMemoryBreakerThreshold() {\n+  private void validateCircuitBreakerThresholds() {\n     if (useCircuitBreakers) {\n-      if (memoryCircuitBreakerThresholdPct > 95 || memoryCircuitBreakerThresholdPct < 50) {\n-        throw new IllegalArgumentException(\"Valid value range of memoryCircuitBreakerThresholdPct is 50 -  95\");\n+      if (isMemoryCircuitBreakerEnabled) {\n+        if (memoryCircuitBreakerThresholdPct > 95 || memoryCircuitBreakerThresholdPct < 50) {\n+          throw new IllegalArgumentException(\"Valid value range of memoryCircuitBreakerThresholdPct is 50 -  95\");\n+        }\n+      }\n+\n+      if (isCpuCircuitBreakerEnabled) {\n+        if (cpuCircuitBreakerThresholdPct > 95 || cpuCircuitBreakerThresholdPct < 40) {\n+          throw new IllegalArgumentException(\"Valid value range for cpuCircuitBreakerThresholdPct is 40 - 95\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNDI4MA==", "bodyText": "return false if only if warn enabled seems odd.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468714280", "createdAt": "2020-08-11T16:35:22Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();\n+  private final ThreadLocal<Double> allowedCPUUsage = new ThreadLocal<>();\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.isCpuCircuitBreakerEnabled = solrConfig.isCpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThresholdPct;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!isCpuCircuitBreakerEnabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0972a36314ae643583817530938a5704bb90d9bb", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/0972a36314ae643583817530938a5704bb90d9bb", "committedDate": "2020-08-11T18:25:11Z", "message": "Update per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c5d95cd9e35bf56e47da12754deb7daeda7d3746", "committedDate": "2020-08-12T07:46:27Z", "message": "Rename parameter and remove ceiling on the threshold range"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzEzNTcw", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-465313570", "createdAt": "2020-08-11T18:15:42Z", "commit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoxNTo0MlrOG_DphA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzo0NzoyN1rOHA1NZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzI1Mg==", "bodyText": "these are unused", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468773252", "createdAt": "2020-08-11T18:15:42Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzMzNg==", "bodyText": "class can be static", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468773336", "createdAt": "2020-08-11T18:15:52Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -240,4 +303,15 @@ protected long calculateLiveMemoryUsage() {\n       return Long.MIN_VALUE; // Random number guaranteed to not trip the circuit breaker\n     }\n   }\n+\n+  private class FakeCPUCircuitBreaker extends CPUCircuitBreaker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNTczNQ==", "bodyText": "Why is 40 a good lower bound?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470615735", "createdAt": "2020-08-14T13:14:05Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,67 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+To enable/disable JVM heap usage based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isMemoryCircuitBreakerEnabled>true</isMemoryCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold as a percentage of the max heap allocated to the JVM, use the following parameter.\n \n [source,xml]\n ----\n <memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n ----\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n \n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker\n+This circuit breaker tracks CPU utilization and triggers if the average CPU utilization over the last minute\n+exceeds a configurable threshold.\n+\n+To enable/disable CPU utilization based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isCpuCircuitBreakerEnabled>true</isCpuCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold in units of CPU utilization, use the following parameter.\n+[source,xml]\n+----\n+<cpuCircuitBreakerThreshold>75</cpuCircuitBreakerThreshold>\n+----\n+The range of valid values for this parameter is [40 to infinity].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNTg2NQ==", "bodyText": "s/does not/do not", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470615865", "createdAt": "2020-08-14T13:14:21Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,67 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+To enable/disable JVM heap usage based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isMemoryCircuitBreakerEnabled>true</isMemoryCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold as a percentage of the max heap allocated to the JVM, use the following parameter.\n \n [source,xml]\n ----\n <memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n ----\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n \n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker\n+This circuit breaker tracks CPU utilization and triggers if the average CPU utilization over the last minute\n+exceeds a configurable threshold.\n+\n+To enable/disable CPU utilization based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isCpuCircuitBreakerEnabled>true</isCpuCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold in units of CPU utilization, use the following parameter.\n+[source,xml]\n+----\n+<cpuCircuitBreakerThreshold>75</cpuCircuitBreakerThreshold>\n+----\n+The range of valid values for this parameter is [40 to infinity].\n+\n+Note that both these circuit breakers are checked for each incoming search request and consider the current heap usage of the node and average CPU usage over the last minute, respectively.\n+The checks does not impact performance, but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n == Performance Considerations\n-It is worth noting that while JVM circuit breaker does not add any noticeable overhead per query, having too many\n+It is worth noting that while JVM or CPU circuit breakers does not add any noticeable overhead per query, having too many", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxODQxMQ==", "bodyText": "Be more explicit about the CPU check using the \"1 min load avg\"\nSince this is a relatively complicated metric (compared to straight memory usage) let's also provide a link - \"For more information on how load avg is calculated refer to https://en.wikipedia.org/wiki/Load_(computing)\"\nIs this the same on Windows? Can we enlist one of our Windows install havers to check this out? @dweiss ?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470618411", "createdAt": "2020-08-14T13:19:22Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,67 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+To enable/disable JVM heap usage based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isMemoryCircuitBreakerEnabled>true</isMemoryCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold as a percentage of the max heap allocated to the JVM, use the following parameter.\n \n [source,xml]\n ----\n <memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n ----\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n \n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker\n+This circuit breaker tracks CPU utilization and triggers if the average CPU utilization over the last minute\n+exceeds a configurable threshold.\n+\n+To enable/disable CPU utilization based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isCpuCircuitBreakerEnabled>true</isCpuCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold in units of CPU utilization, use the following parameter.\n+[source,xml]\n+----\n+<cpuCircuitBreakerThreshold>75</cpuCircuitBreakerThreshold>\n+----\n+The range of valid values for this parameter is [40 to infinity].\n+\n+Note that both these circuit breakers are checked for each incoming search request and consider the current heap usage of the node and average CPU usage over the last minute, respectively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxODU4NA==", "bodyText": "static class", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470618584", "createdAt": "2020-08-14T13:19:43Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -179,7 +236,13 @@ public void testResponseWithCBTiming() {\n     );\n   }\n \n-  private class MockCircuitBreaker extends CircuitBreaker {\n+  private void removeAllExistingCircuitBreakers() {\n+    List<CircuitBreaker> registeredCircuitBreakers = h.getCore().getCircuitBreakerManager().getRegisteredCircuitBreakers();\n+\n+    registeredCircuitBreakers.clear();\n+  }\n+\n+  private class MockCircuitBreaker extends MemoryCircuitBreaker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxODg2NA==", "bodyText": "thread.interrupt", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470618864", "createdAt": "2020-08-14T13:20:15Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {\n+            if (!e.getMessage().startsWith(\"Circuit Breakers tripped\")) {\n+              if (log.isInfoEnabled()) {\n+                String logMessage = \"Expected error message for testFakeCPUCircuitBreaker was not received. Error message \" + e.getMessage();\n+                log.info(logMessage);\n+              }\n+              throw new RuntimeException(\"Expected error message was not received. Error message \" + e.getMessage());\n+            }\n+            failureCount.incrementAndGet();\n+          } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+          }\n+        });\n+      }\n+\n+      executor.shutdown();\n+      try {\n+        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyODYxNg==", "bodyText": "Can we simplify this whole block to assertThat(e.getMessage(), containsString(\"Circuit Breakers tripped\"))", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470628616", "createdAt": "2020-08-14T13:37:57Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {\n+            if (!e.getMessage().startsWith(\"Circuit Breakers tripped\")) {\n+              if (log.isInfoEnabled()) {\n+                String logMessage = \"Expected error message for testFakeCPUCircuitBreaker was not received. Error message \" + e.getMessage();\n+                log.info(logMessage);\n+              }\n+              throw new RuntimeException(\"Expected error message was not received. Error message \" + e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA==", "bodyText": "Does circuit breaker throw a more specific exception? It's kind of cumbersome from a client API perspective that they need to inspect the string message for knowing that they should retry from circuit breakers.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470631364", "createdAt": "2020-08-14T13:43:01Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMzgyOQ==", "bodyText": "save this Future and assert that it did not throw an exception", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470633829", "createdAt": "2020-08-14T13:47:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzY4NDQw", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-468368440", "createdAt": "2020-08-17T11:04:41Z", "commit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMTowNDo0MlrOHBkPsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMToyNjo1MlrOHBk4CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw==", "bodyText": "Javadoc for OSMxBean says \"This method is designed to provide a hint about the system load and may be queried frequently.\" Not sure what \"frequently\" means here, though...\nIt will be interesting to see the dynamic behavior of this breaker - I'm somewhat worried that the 1-min average may be too unstable and we end up flip-flopping between the states too often (eg. every dozen requests or so). Depending on the volume of momentary load (eg. an ongoing large merge or split shard) the 1-min average may exceed a threshold even though it doesn't properly reflect a sustained longer-term overload that we should worry about. Average load is a convenient lie ;)\nOTOH that's the only method we have in the OS MXBean, so we would have to compute that longer-term average ourselves, which is messy... so I guess we'll see .", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471404467", "createdAt": "2020-08-17T11:04:42Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNzQwNQ==", "bodyText": "I think that on ThreadLocal.get() you would get a null value and consequently an NPE. You would have to use ThreadLocal.withInitial(supplier) to get a Double(0) here.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471407405", "createdAt": "2020-08-17T11:10:58Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private static final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();\n+  private static final ThreadLocal<Double> allowedCPUUsage = new ThreadLocal<>();\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.isCpuCircuitBreakerEnabled = solrConfig.isCpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThreshold;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!isCpuCircuitBreakerEnabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+      }\n+\n+      return false;\n+    }\n+\n+    allowedCPUUsage.set(localAllowedCPUUsage);\n+\n+    seenCPUUsage.set(localSeenCPUUsage);\n+\n+    return (localSeenCPUUsage >= localAllowedCPUUsage);\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenCPUUsage.get() == 0L || allowedCPUUsage.get() == 0L) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwODQzOQ==", "bodyText": "Also, caching doesn't have to be complicated .. you simply check the elapsed time since last request and if it's longer than timeout you refresh the value first, it's probably less than 10 lines of code.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471408439", "createdAt": "2020-08-17T11:13:16Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwODkyMg==", "bodyText": "We know it's a boolean and it's in the MemoryCircuitBreaker, why not simply call it enabled (like many other Solr plugins do)?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471408922", "createdAt": "2020-08-17T11:14:24Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -43,6 +43,7 @@\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n+  private boolean isMemoryCircuitBreakerEnabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMDIyNg==", "bodyText": "I'm not sure if the boolean flags should always contain is, also I generally hate too long names... ;) we already know this is a section for circuit breakers, so the name doesn't have to repeat all of it. How about cpuBreakerEnabled, memoryBreakerEnabled etc?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471410226", "createdAt": "2020-08-17T11:16:57Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -229,9 +229,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n \n     useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    isCpuCircuitBreakerEnabled = getBool(\"circuitBreaker/isCpuCircuitBreakerEnabled\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMzM2NA==", "bodyText": "Currently the CircuitBreakerManager.toErrorMessage uses individual breaker's getDebugInfo to construct the error message. I think we should improve these individual messages to clearly say why a break was tripped. Currently it's not obvious - eg. when a mem breaker trips it just reports the current and total memory but not the thresholdPct.\nMaybe we need a different method like CircuitBreaker.getErrorMessage ?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471413364", "createdAt": "2020-08-17T11:24:04Z", "author": {"login": "sigram"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA=="}, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxNDc5Mw==", "bodyText": "This is still not removed in the latest rev?\nAlso, we can be more helpful here: maybe add something like \"typically 1-min average CPU load may often reach values of 10s for a busy machine, but values consistently above 20 and higher indicate progressively serious contention.\" - or something like that.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471414793", "createdAt": "2020-08-17T11:26:52Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,67 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+To enable/disable JVM heap usage based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isMemoryCircuitBreakerEnabled>true</isMemoryCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold as a percentage of the max heap allocated to the JVM, use the following parameter.\n \n [source,xml]\n ----\n <memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n ----\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n \n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker\n+This circuit breaker tracks CPU utilization and triggers if the average CPU utilization over the last minute\n+exceeds a configurable threshold.\n+\n+To enable/disable CPU utilization based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<isCpuCircuitBreakerEnabled>true</isCpuCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold in units of CPU utilization, use the following parameter.\n+[source,xml]\n+----\n+<cpuCircuitBreakerThreshold>75</cpuCircuitBreakerThreshold>\n+----\n+The range of valid values for this parameter is [40 to infinity].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNTczNQ=="}, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdd4f219f4fb7bad694fe96d05e6e90318f3289f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/bdd4f219f4fb7bad694fe96d05e6e90318f3289f", "committedDate": "2020-08-17T18:20:12Z", "message": "Update per comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4Nzc4MjMw", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-468778230", "createdAt": "2020-08-17T19:35:55Z", "commit": {"oid": "bdd4f219f4fb7bad694fe96d05e6e90318f3289f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOTozNTo1NVrOHB4MqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOTozNTo1NVrOHB4MqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczMTM2OQ==", "bodyText": "withInitial is supposed to be on the declaration, not on each use", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471731369", "createdAt": "2020-08-17T19:35:55Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -91,11 +91,18 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenCPUUsage.get() == 0L || allowedCPUUsage.get() == 0L) {\n+\n+    if (seenCPUUsage.withInitial(supplier).get() == 0.0 || seenCPUUsage.withInitial(supplier).get() == 0.0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd4f219f4fb7bad694fe96d05e6e90318f3289f"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "095a6f26eb549be4bf749392660fa35742db2625", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/095a6f26eb549be4bf749392660fa35742db2625", "committedDate": "2020-08-18T04:12:50Z", "message": "Use withInitial correctly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe997a4893c59cfc37ad016c709a76c9af27aa4a", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/fe997a4893c59cfc37ad016c709a76c9af27aa4a", "committedDate": "2020-08-18T04:29:21Z", "message": "Remove redundant import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/98612bcf3acae5583c678f928e9d8103009b825e", "committedDate": "2020-08-18T04:44:31Z", "message": "More precommit stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTcyMzA5", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-469172309", "createdAt": "2020-08-18T09:56:19Z", "commit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwOTo1NjoxOVrOHCMQ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozMTo1NFrOHCNa-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2MDEyMA==", "bodyText": "Can we please simplify these names? they are awfully verbose and repeating the parts that are already unique and obvious.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472060120", "createdAt": "2020-08-18T09:56:19Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -229,9 +229,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n \n     useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    cpuCircuitBreakerEnabled = getBool(\"circuitBreaker/cpuCircuitBreakerEnabled\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MTA4Nw==", "bodyText": "Uh ... I see there's still some misunderstanding about this. The call itself is directly passed to the native method that invokes stdlib getloadavg, which in turn reads these values from the /proc pseudo-fs. So, the cost is truly minimal and the call doesn't block - if it turns out that it's still too costly to call for every request then we can introduce some timeout-based caching.\nThese averages are so called exponentially weighted moving averages, so indeed a 1-min average has traces of past load values from outside the 1-min window, which helps in smoothing it. This may turn out to be sufficient to avoid false positives due to short-term spikes (such as large merges). Linux loadavg represents to some degree a combined CPU + disk IO load, so indeed intensive IO operations will affect it.\nWe always have an option to use Codahale Meter to easily calculate 5- and 15-min EWMAs if it turns out that we're getting too many false positives. Until then users can configure higher thresholds, thus reducing the number of false positives at the cost of higher contention.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472071087", "createdAt": "2020-08-18T10:15:58Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, "originalCommit": {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjY1OQ==", "bodyText": "Maybe \"greater than allocated threshold\" ?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472072659", "createdAt": "2020-08-18T10:19:00Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean enabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private static final ThreadLocal<Double> seenCPUUsage = ThreadLocal.withInitial(() -> 0.0);\n+\n+  private static final ThreadLocal<Double> allowedCPUUsage = ThreadLocal.withInitial(() -> 0.0);\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.enabled = solrConfig.cpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThreshold;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!enabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+      }\n+\n+      return false;\n+    }\n+\n+    allowedCPUUsage.set(localAllowedCPUUsage);\n+\n+    seenCPUUsage.set(localSeenCPUUsage);\n+\n+    return (localSeenCPUUsage >= localAllowedCPUUsage);\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+\n+    if (seenCPUUsage.get() == 0.0 || seenCPUUsage.get() == 0.0) {\n+      log.warn(\"CPUCircuitBreaker's monitored values (seenCPUUSage, allowedCPUUsage) not set\");\n+    }\n+\n+    return \"seenCPUUSage=\" + seenCPUUsage.get() + \" allowedCPUUsage=\" + allowedCPUUsage.get();\n+  }\n+\n+  @Override\n+  public String getErrorMessage() {\n+    return \"CPU Circuit Breaker Triggered. Seen CPU usage \" + seenCPUUsage.get() + \" and allocated threshold \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU5OQ==", "bodyText": "Similarly, \"greater than allocated threshold\" ?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472073599", "createdAt": "2020-08-18T10:20:50Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -88,13 +95,19 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenMemory.get() == 0L || allowedMemory.get() == 0L) {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {\n       log.warn(\"MemoryCircuitBreaker's monitored values (seenMemory, allowedMemory) not set\");\n     }\n \n     return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n   }\n \n+  @Override\n+  public String getErrorMessage() {\n+    return \"Memory Circuit Breaker Triggered. Seen JVM heap memory usage \" + seenMemory.get() + \" and allocated threshold \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NDQ1Nw==", "bodyText": "The same comment applies as in the CPU breaker regarding caching vs. calling this for every request. The cost should be minimal, it's just making a fast native call to read a value.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472074457", "createdAt": "2020-08-18T10:22:35Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -76,6 +79,10 @@ public boolean isTripped() {\n       return false;\n     }\n \n+    if (!enabled) {\n+      return false;\n+    }\n+\n     long localAllowedMemory = getCurrentMemoryThreshold();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODE2Ng==", "bodyText": "I hate typing too much :)  and overly verbose names are often easier to mistype.\nWhat do you think about this (note the plural circuitBreakers - we have more than one now!):\n<circuitBreakers enabled=\"true\">\n <cpuBreaker enabled=\"true\" threshold=\"75\"/>\n <memBreaker enabled=\"true\" threshold=\"75\"/>\n...\n</circuitBreakers>", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472078166", "createdAt": "2020-08-18T10:30:05Z", "author": {"login": "sigram"}, "path": "solr/core/src/test-files/solr/collection1/conf/solrconfig-memory-circuitbreaker.xml", "diffHunk": "@@ -82,8 +82,14 @@\n \n     <useCircuitBreakers>true</useCircuitBreakers>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODU3Mw==", "bodyText": "If we change the format of the config this section needs to be updated too.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472078573", "createdAt": "2020-08-18T10:30:52Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,68 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3OTA5OA==", "bodyText": "The value of 75 would rarely make sense for a production system, maybe change this to 20?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472079098", "createdAt": "2020-08-18T10:31:54Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -35,33 +35,68 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n <useCircuitBreakers>false</useCircuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+To enable/disable JVM heap usage based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerEnabled>true</memoryCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold as a percentage of the max heap allocated to the JVM, use the following parameter.\n \n [source,xml]\n ----\n <memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n ----\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n \n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker\n+This circuit breaker tracks CPU utilization and triggers if the average CPU utilization over the last one minute\n+exceeds a configurable threshold. Note that the value used in computation is over the last one minute -- so a sudden\n+spike in traffic that goes down might still cause the circuit breaker to trigger for a short while before it resolves\n+and updates the value. For more details of the calculation, please see https://en.wikipedia.org/wiki/Load_(computing)\n+\n+To enable/disable CPU utilization based circuit breaker, use the following configuration:\n+\n+[source,xml]\n+----\n+<cpuCircuitBreakerEnabled>true</cpuCircuitBreakerEnabled>\n+----\n+\n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you.\n+\n+To set the triggering threshold in units of CPU utilization, use the following parameter.\n+[source,xml]\n+----\n+<cpuCircuitBreakerThreshold>75</cpuCircuitBreakerThreshold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98612bcf3acae5583c678f928e9d8103009b825e"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cada13b4dddcfa6010c5bef87bb984afa08cbf42", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/cada13b4dddcfa6010c5bef87bb984afa08cbf42", "committedDate": "2020-08-18T11:29:53Z", "message": "Update per comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MjgzNzY2", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-469283766", "createdAt": "2020-08-18T11:36:30Z", "commit": {"oid": "cada13b4dddcfa6010c5bef87bb984afa08cbf42"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5Mjg0ODEx", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-469284811", "createdAt": "2020-08-18T11:36:50Z", "commit": {"oid": "cada13b4dddcfa6010c5bef87bb984afa08cbf42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "committedDate": "2020-08-18T14:32:55Z", "message": "Fix Compilation Errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNjc5MjM5", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-470679239", "createdAt": "2020-08-19T17:15:32Z", "commit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoxNTozM1rOHDRnAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzoyMDozOVrOHDRzmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjI4OA==", "bodyText": "I don't think this was supposed to change", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196288", "createdAt": "2020-08-19T17:15:33Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -88,13 +95,20 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenMemory.get() == 0L || allowedMemory.get() == 0L) {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjMyOA==", "bodyText": "static", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196328", "createdAt": "2020-08-19T17:15:37Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -43,22 +43,25 @@\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n+  private boolean enabled;\n   private final long heapMemoryThreshold;\n \n   // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n-  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n-  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> seenMemory = ThreadLocal.withInitial(() -> 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjgwMg==", "bodyText": "Do we have to suppress here? I'd rather not have warnings in the new code to begin with", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196802", "createdAt": "2020-08-19T17:16:28Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -41,6 +45,9 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+@SuppressWarnings({\"rawtypes\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NzEzMw==", "bodyText": "Future<?>", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473197133", "createdAt": "2020-08-19T17:17:04Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -119,33 +130,42 @@ public void testBuildingMemoryPressure() {\n     AtomicInteger failureCount = new AtomicInteger();\n \n     try {\n+      removeAllExistingCircuitBreakers();\n+\n       CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore().getSolrConfig());\n \n       h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n \n+      List<Future> futures = new ArrayList<>();\n+\n       for (int i = 0; i < 5; i++) {\n-        executor.submit(() -> {\n+        Future future = executor.submit(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NzgzMA==", "bodyText": "@sigram we could call this Load Avg Based Circuit Breaker, WDYT? Maybe that is too much implementation detail?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473197830", "createdAt": "2020-08-19T17:18:23Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -32,36 +32,58 @@ will be disabled globally. Per circuit breaker configurations are specified in t\n \n [source,xml]\n ----\n-<useCircuitBreakers>false</useCircuitBreakers>\n+<circuitBreakers enabled=\"true\">\n+  <!-- All specific configs in this section -->\n+</circuitBreakers>\n ----\n \n+This flag acts as the highest authority and global controller of circuit breakers. For using specific circuit breakers, each one\n+needs to be individually enabled in addition to this flag being enabled.\n+\n == Currently Supported Circuit Breakers\n \n === JVM Heap Usage Based Circuit Breaker\n This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n exceeds a configured percentage of maximum heap allocated to the JVM (-Xmx). The main configuration for this circuit breaker is\n controlling the threshold percentage at which the breaker will trip.\n \n-It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n-of valid values for this parameter is [50, 95], both inclusive.\n+Configuration for JVM heap usage based circuit breaker:\n \n [source,xml]\n ----\n-<memoryCircuitBreakerThresholdPct>75</memoryCircuitBreakerThresholdPct>\n+<memBreaker enabled=\"true\" threshold=\"75\"/>\n ----\n \n+Note that this configuration will be overridden by the global circuit breaker flag -- if circuit breakers are disabled, this flag\n+will not help you. Also, the triggering threshold is defined as a percentage of the max heap allocated to the JVM.\n+\n+It does not logically make sense to have a threshold below 50% and above 95% of the max heap allocated to the JVM. Hence, the range\n+of valid values for this parameter is [50, 95], both inclusive.\n+\n Consider the following example:\n \n JVM has been allocated a maximum heap of 5GB (-Xmx) and memoryCircuitBreakerThresholdPct is set to 75. In this scenario, the heap usage\n at which the circuit breaker will trip is 3.75GB.\n \n-Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node, i.e every search\n-request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n-but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n \n+=== CPU Utilization Based Circuit Breaker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5ODczNw==", "bodyText": "This is not part of this CB, right?", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473198737", "createdAt": "2020-08-19T17:19:33Z", "author": {"login": "madrob"}, "path": "solr/server/solr/configsets/_default/conf/solrconfig.xml", "diffHunk": "@@ -615,10 +612,29 @@\n      was caused by tripped circuit breakers).\n     -->\n     <!--\n-   <memoryCircuitBreakerThresholdPct>100</memoryCircuitBreakerThresholdPct>\n+   <memBreaker enabled=\"true\" threshold=\"75\"/>\n     -->\n \n-  </circuitBreaker>\n+      <!-- CPU Circuit Breaker Configuration\n+\n+     Specific configuration for CPU utilization based circuit breaker. This configuration defines whether the circuit breaker is enabled\n+     and the average load over the last minute at which the circuit breaker should start rejecting queries.\n+\n+     Consider a scenario where the max heap allocated is 4 GB and memoryCircuitBreakerThreshold is\n+     defined as 75. Threshold JVM usage will be 4 * 0.75 = 3 GB. Its generally a good idea to keep this value between 75 - 80% of maximum heap\n+     allocated.\n+\n+     If, at any point, the current JVM heap usage goes above 3 GB, queries will be rejected until the heap usage goes below 3 GB again.\n+     If you see queries getting rejected with 503 error code, check for \"Circuit Breakers tripped\"\n+     in logs and the corresponding error message should tell you what transpired (if the failure\n+     was caused by tripped circuit breakers).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTA5NQ==", "bodyText": "log, not sys out.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473199095", "createdAt": "2020-08-19T17:19:55Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -206,11 +286,12 @@ public FakeMemoryPressureCircuitBreaker(SolrConfig solrConfig) {\n     @Override\n     protected long calculateLiveMemoryUsage() {\n       // Return a number large enough to trigger a pushback from the circuit breaker\n+      System.out.println(\"I AM SENDING MAX VALUE\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTUxNQ==", "bodyText": "Better practice to declare this right before the try block, without intervening declarations.", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473199515", "createdAt": "2020-08-19T17:20:39Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +177,60 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNjg2ODk2", "url": "https://github.com/apache/lucene-solr/pull/1737#pullrequestreview-470686896", "createdAt": "2020-08-19T17:25:42Z", "commit": {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d964ddb3adf494c8417b2d03e4b79a34f5c8635e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d964ddb3adf494c8417b2d03e4b79a34f5c8635e", "committedDate": "2020-08-20T06:08:44Z", "message": "Update per comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2352, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}