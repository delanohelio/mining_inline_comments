{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1ODU5NDE4", "number": 1802, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxMTo1OTo1MlrOEeD-3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMDo1Nzo0N1rOEeGqNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5OTU3OTgwOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxMTo1OTo1MlrOHJiScQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxMjo1NzowMVrOHJio7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc2MTAwOQ==", "bodyText": "Hey that's my UweSays statement!", "url": "https://github.com/apache/lucene-solr/pull/1802#discussion_r479761009", "createdAt": "2020-08-30T11:59:52Z", "author": {"login": "uschindler"}, "path": "buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.gradle;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.util.Elements;\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.util.DocTrees;\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import jdk.javadoc.doclet.StandardDoclet;\n+\n+/**\n+ * Checks for missing javadocs, where missing also means \"only whitespace\" or \"license header\".\n+ * Has option --missing-level (package, class, method) so that we can improve over time.\n+ * Has option --missing-ignore to ignore individual elements (such as split packages).\n+ * Has option --missing-method to apply \"method\" level to selected packages (fix one at a time).\n+ */\n+public class MissingDoclet extends StandardDoclet {\n+  private static final int PACKAGE = 0;\n+  private static final int CLASS = 1;\n+  private static final int METHOD = 2;\n+  int level = METHOD;\n+  Reporter reporter;\n+  DocletEnvironment docEnv;\n+  DocTrees docTrees;\n+  Elements elementUtils;\n+  Set<String> ignored = Collections.emptySet();\n+  Set<String> methodPackages = Collections.emptySet();\n+  \n+  @Override\n+  public Set<Doclet.Option> getSupportedOptions() {\n+    Set<Doclet.Option> options = new HashSet<>();\n+    options.addAll(super.getSupportedOptions());\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"level to enforce for missing javadocs: [package, class, method]\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-level\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"level\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        switch(arguments.get(0)) {\n+          case \"package\":\n+            level = PACKAGE;\n+            return true;\n+          case \"class\":\n+            level = CLASS;\n+            return true;\n+          case \"method\":\n+            level = METHOD;\n+            return true;\n+          default:\n+            return false;\n+        }\n+      }\n+    });\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"comma separated list of element names to ignore (e.g. as a workaround for split packages)\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-ignore\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"ignoredNames\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        ignored = new HashSet<>(Arrays.asList(arguments.get(0).split(\",\")));\n+        return true;\n+      }\n+    });\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"comma separated list of packages to check at 'method' level\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-method\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"packages\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        methodPackages = new HashSet<>(Arrays.asList(arguments.get(0).split(\",\")));\n+        return true;\n+      }\n+    });\n+    return options;\n+  }\n+\n+  @Override\n+  public void init(Locale locale, Reporter reporter) {\n+    this.reporter = reporter;\n+    super.init(locale, reporter);\n+  }\n+\n+  @Override\n+  public boolean run(DocletEnvironment docEnv) {\n+    this.docEnv = docEnv;\n+    this.docTrees = docEnv.getDocTrees();\n+    this.elementUtils = docEnv.getElementUtils();\n+    for (var element : docEnv.getIncludedElements()) {\n+      check(element);\n+    }\n+\n+    return super.run(docEnv);\n+  }\n+  \n+  /**\n+   * Returns effective check level for this element\n+   */\n+  private int level(Element element) {\n+    String pkg = elementUtils.getPackageOf(element).getQualifiedName().toString();\n+    if (methodPackages.contains(pkg)) {\n+      return METHOD;\n+    } else {\n+      return level;\n+    }\n+  }\n+  \n+  /** \n+   * Check an individual element.\n+   * This checks packages and types from the doctrees.\n+   * It will recursively check methods/fields from encountered types when the level is \"method\"\n+   */\n+  private void check(Element element) {\n+    switch(element.getKind()) {\n+      case MODULE:\n+        // don't check the unnamed module, it won't have javadocs\n+        if (!((ModuleElement)element).isUnnamed()) {\n+          checkComment(element);\n+        }\n+        break;\n+      case PACKAGE:\n+        checkComment(element);\n+        break;\n+      // class-like elements, check them, then recursively check their children (fields and methods)\n+      case CLASS:\n+      case INTERFACE:\n+      case ENUM:\n+      case ANNOTATION_TYPE:\n+        if (level(element) >= CLASS) {\n+          checkComment(element);\n+          for (var subElement : element.getEnclosedElements()) {\n+            // don't check enclosed types, otherwise we'll double-check since they are in the included docTree\n+            if (subElement.getKind() == ElementKind.METHOD || \n+                subElement.getKind() == ElementKind.CONSTRUCTOR || \n+                subElement.getKind() == ElementKind.FIELD || \n+                subElement.getKind() == ElementKind.ENUM_CONSTANT) {\n+              check(subElement);\n+            }\n+          }\n+        }\n+        break;\n+      // method-like elements, check them if we are configured to do so\n+      case METHOD:\n+      case CONSTRUCTOR:\n+      case FIELD:\n+      case ENUM_CONSTANT:\n+        if (level(element) >= METHOD && !isOverridden(element) && !isSyntheticEnumMethod(element)) {\n+          checkComment(element);\n+        }\n+        break;\n+      default:\n+        error(element, \"I don't know how to analyze \" + element.getKind() + \" yet.\");\n+    }\n+  }\n+  \n+  /** Return true if the method is annotated with Override, if so, don't require javadocs (they'll be copied) */\n+  private boolean isOverridden(Element element) {\n+    for (var annotation : element.getAnnotationMirrors()) {\n+      if (annotation.getAnnotationType().toString().equals(Override.class.getName())) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  \n+  /** \n+   * Return true if the method is synthetic enum method (values/valueOf).\n+   * According to the doctree documentation, the \"included\" set never includes synthetic elements.\n+   * It should not happen but it happens!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cae4218ff605366dbae53011265c8a29add3be"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc2Njc2NQ==", "bodyText": "yeah i forgot to attribute this to the author!", "url": "https://github.com/apache/lucene-solr/pull/1802#discussion_r479766765", "createdAt": "2020-08-30T12:57:01Z", "author": {"login": "rmuir"}, "path": "buildSrc/src/main/java/org/apache/lucene/gradle/MissingDoclet.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.gradle;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.util.Elements;\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.util.DocTrees;\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import jdk.javadoc.doclet.StandardDoclet;\n+\n+/**\n+ * Checks for missing javadocs, where missing also means \"only whitespace\" or \"license header\".\n+ * Has option --missing-level (package, class, method) so that we can improve over time.\n+ * Has option --missing-ignore to ignore individual elements (such as split packages).\n+ * Has option --missing-method to apply \"method\" level to selected packages (fix one at a time).\n+ */\n+public class MissingDoclet extends StandardDoclet {\n+  private static final int PACKAGE = 0;\n+  private static final int CLASS = 1;\n+  private static final int METHOD = 2;\n+  int level = METHOD;\n+  Reporter reporter;\n+  DocletEnvironment docEnv;\n+  DocTrees docTrees;\n+  Elements elementUtils;\n+  Set<String> ignored = Collections.emptySet();\n+  Set<String> methodPackages = Collections.emptySet();\n+  \n+  @Override\n+  public Set<Doclet.Option> getSupportedOptions() {\n+    Set<Doclet.Option> options = new HashSet<>();\n+    options.addAll(super.getSupportedOptions());\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"level to enforce for missing javadocs: [package, class, method]\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-level\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"level\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        switch(arguments.get(0)) {\n+          case \"package\":\n+            level = PACKAGE;\n+            return true;\n+          case \"class\":\n+            level = CLASS;\n+            return true;\n+          case \"method\":\n+            level = METHOD;\n+            return true;\n+          default:\n+            return false;\n+        }\n+      }\n+    });\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"comma separated list of element names to ignore (e.g. as a workaround for split packages)\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-ignore\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"ignoredNames\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        ignored = new HashSet<>(Arrays.asList(arguments.get(0).split(\",\")));\n+        return true;\n+      }\n+    });\n+    options.add(new Doclet.Option() {\n+      @Override\n+      public int getArgumentCount() {\n+        return 1;\n+      }\n+\n+      @Override\n+      public String getDescription() {\n+        return \"comma separated list of packages to check at 'method' level\";\n+      }\n+\n+      @Override\n+      public Kind getKind() {\n+        return Option.Kind.STANDARD;\n+      }\n+\n+      @Override\n+      public List<String> getNames() {\n+        return Collections.singletonList(\"--missing-method\");\n+      }\n+\n+      @Override\n+      public String getParameters() {\n+        return \"packages\";\n+      }\n+\n+      @Override\n+      public boolean process(String option, List<String> arguments) {\n+        methodPackages = new HashSet<>(Arrays.asList(arguments.get(0).split(\",\")));\n+        return true;\n+      }\n+    });\n+    return options;\n+  }\n+\n+  @Override\n+  public void init(Locale locale, Reporter reporter) {\n+    this.reporter = reporter;\n+    super.init(locale, reporter);\n+  }\n+\n+  @Override\n+  public boolean run(DocletEnvironment docEnv) {\n+    this.docEnv = docEnv;\n+    this.docTrees = docEnv.getDocTrees();\n+    this.elementUtils = docEnv.getElementUtils();\n+    for (var element : docEnv.getIncludedElements()) {\n+      check(element);\n+    }\n+\n+    return super.run(docEnv);\n+  }\n+  \n+  /**\n+   * Returns effective check level for this element\n+   */\n+  private int level(Element element) {\n+    String pkg = elementUtils.getPackageOf(element).getQualifiedName().toString();\n+    if (methodPackages.contains(pkg)) {\n+      return METHOD;\n+    } else {\n+      return level;\n+    }\n+  }\n+  \n+  /** \n+   * Check an individual element.\n+   * This checks packages and types from the doctrees.\n+   * It will recursively check methods/fields from encountered types when the level is \"method\"\n+   */\n+  private void check(Element element) {\n+    switch(element.getKind()) {\n+      case MODULE:\n+        // don't check the unnamed module, it won't have javadocs\n+        if (!((ModuleElement)element).isUnnamed()) {\n+          checkComment(element);\n+        }\n+        break;\n+      case PACKAGE:\n+        checkComment(element);\n+        break;\n+      // class-like elements, check them, then recursively check their children (fields and methods)\n+      case CLASS:\n+      case INTERFACE:\n+      case ENUM:\n+      case ANNOTATION_TYPE:\n+        if (level(element) >= CLASS) {\n+          checkComment(element);\n+          for (var subElement : element.getEnclosedElements()) {\n+            // don't check enclosed types, otherwise we'll double-check since they are in the included docTree\n+            if (subElement.getKind() == ElementKind.METHOD || \n+                subElement.getKind() == ElementKind.CONSTRUCTOR || \n+                subElement.getKind() == ElementKind.FIELD || \n+                subElement.getKind() == ElementKind.ENUM_CONSTANT) {\n+              check(subElement);\n+            }\n+          }\n+        }\n+        break;\n+      // method-like elements, check them if we are configured to do so\n+      case METHOD:\n+      case CONSTRUCTOR:\n+      case FIELD:\n+      case ENUM_CONSTANT:\n+        if (level(element) >= METHOD && !isOverridden(element) && !isSyntheticEnumMethod(element)) {\n+          checkComment(element);\n+        }\n+        break;\n+      default:\n+        error(element, \"I don't know how to analyze \" + element.getKind() + \" yet.\");\n+    }\n+  }\n+  \n+  /** Return true if the method is annotated with Override, if so, don't require javadocs (they'll be copied) */\n+  private boolean isOverridden(Element element) {\n+    for (var annotation : element.getAnnotationMirrors()) {\n+      if (annotation.getAnnotationType().toString().equals(Override.class.getName())) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  \n+  /** \n+   * Return true if the method is synthetic enum method (values/valueOf).\n+   * According to the doctree documentation, the \"included\" set never includes synthetic elements.\n+   * It should not happen but it happens!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc2MTAwOQ=="}, "originalCommit": {"oid": "19cae4218ff605366dbae53011265c8a29add3be"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMDAxODQ2OnYy", "diffSide": "RIGHT", "path": "gradle/validation/forbidden-apis.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMDo1Nzo0N1rOHJlk3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQyMDo1Nzo0N1rOHJlk3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg3OA==", "bodyText": "No longer needed.", "url": "https://github.com/apache/lucene-solr/pull/1802#discussion_r479814878", "createdAt": "2020-08-30T20:57:47Z", "author": {"login": "uschindler"}, "path": "gradle/validation/forbidden-apis.gradle", "diffHunk": "@@ -103,6 +103,13 @@ allprojects { prj ->\n       ]\n     }\n \n+    // Doclet does use exotic JDK APIs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d7c780aba8fa4df789d8760a919525a8a215c86"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1338, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}