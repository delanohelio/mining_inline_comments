{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODIwNDgx", "number": 2132, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMTo0MlrOFFVsWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozOTowOFrOFMlioQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTQyNjE3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMTo0MlrOIFz8DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMTo0MlrOIFz8DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDc0OQ==", "bodyText": "NULL_DEREFERENCE:  object returned by FacetStream.cloudSolrClient.getClusterStateProvider() could be null and is dereferenced at line 562.", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r542964749", "createdAt": "2020-12-15T01:01:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -545,6 +557,18 @@ public void open() throws IOException {\n       cloudSolrClient = new Builder(hosts, Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000).build();\n     }\n \n+    if (params.getBool(\"plist\", true)) {\n+      params.remove(\"plist\");\n+      final List<String> resolved = cloudSolrClient.getClusterStateProvider().resolveAlias(collection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDcxODI4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNjo1MFrOIGRKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNjo1MFrOIGRKHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MzQ4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for(int i=0; i<sorts.length; i++) {\n          \n          \n            \n                for (int i = 0; i < sorts.length; i++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543443487", "createdAt": "2020-12-15T15:26:50Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDcyMTU3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNzoyMFrOIGRMBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNzoyMFrOIGRMBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0Mzk3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n          \n          \n            \n                if (s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543443975", "createdAt": "2020-12-15T15:27:20Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDcyNDM1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNzo0NFrOIGRNjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNzo0NFrOIGRNjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NDM2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n          \n          \n            \n                } else if (s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543444367", "createdAt": "2020-12-15T15:27:44Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n+      order = \"asc\";\n+      fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n+    } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDcyOTQzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyODo0M1rOIGRQmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyODo0M1rOIGRQmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NTE0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad sort caluse '%s'.\",s));\n          \n          \n            \n                  throw new IOException(String.format(Locale.ROOT, \"invalid expression - bad sort caluse '%s'.\", s));", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543445146", "createdAt": "2020-12-15T15:28:43Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n+      order = \"asc\";\n+      fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n+    } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n+      order = \"desc\";\n+      fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n+    } else {\n+      throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad sort caluse '%s'.\",s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDczNTQ2OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyOTo0NVrOIGRUJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyOTo0NVrOIGRUJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NjA1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int c=0; c < parallelStreams.length; c++) {\n          \n          \n            \n                for (int c = 0; c < parallelStreams.length; c++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543446054", "createdAt": "2020-12-15T15:29:45Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -842,10 +874,73 @@ public int getCost() {\n \n   @Override\n   public StreamComparator getStreamSort() {\n-    if(bucketSorts.length > 1) {\n-      return new MultipleFieldComparator(bucketSorts);\n+    return (bucketSorts.length > 1) ? new MultipleFieldComparator(bucketSorts) : bucketSorts[0];\n+  }\n+\n+  @Override\n+  public TupleStream[] parallelize(List<String> partitions) throws IOException {\n+    TupleStream[] parallelStreams = new TupleStream[partitions.size()];\n+\n+    // prefer a different node for each collection if possible as we don't want the same remote node\n+    // being the coordinator if possible, otherwise, our plist isn't distributing the load as well\n+    final Set<String> preferredNodes = new HashSet<>(Math.max((int) (parallelStreams.length/.75f) + 1, 16));\n+\n+    for (int c=0; c < parallelStreams.length; c++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc0MDk3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMDo1MVrOIGRXdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMDo1MVrOIGRXdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NjkwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int m=0; m < rollup.length; m++) {\n          \n          \n            \n                for (int m = 0; m < rollup.length; m++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543446902", "createdAt": "2020-12-15T15:30:51Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.solr.client.solrj.io.comp.StreamComparator;\n+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.Metric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.WeightedSumMetric;\n+\n+/**\n+ * Indicates the underlying stream source supports parallelizing metrics computation across collections\n+ * using a rollup of metrics from each collection.\n+ */\n+public interface ParallelMetricsRollup {\n+  TupleStream[] parallelize(List<String> partitions) throws IOException;\n+  StreamComparator getParallelListSortOrder() throws IOException;\n+  RollupStream getRollupStream(SortStream sortStream, Metric[] rollupMetrics) throws IOException;\n+  Map<String,String> getRollupSelectFields(Metric[] rollupMetrics);\n+\n+  default Optional<TupleStream> openParallelStream(StreamContext context, List<String> partitions, Metric[] metrics) throws IOException {\n+    Optional<Metric[]> maybeRollupMetrics = getRollupMetrics(metrics);\n+    if (maybeRollupMetrics.isEmpty())\n+      return Optional.empty(); // some metric is incompatible with doing a rollup over the plist results\n+\n+    TupleStream[] parallelStreams = parallelize(partitions);\n+\n+    // the tuples from each plist need to be sorted using the same order to do a rollup\n+    Metric[] rollupMetrics = maybeRollupMetrics.get();\n+    StreamComparator comparator = getParallelListSortOrder();\n+    SortStream sortStream = new SortStream(new ParallelListStream(parallelStreams), comparator);\n+    RollupStream rollup = getRollupStream(sortStream, rollupMetrics);\n+    SelectStream select = new SelectStream(rollup, getRollupSelectFields(rollupMetrics));\n+    select.setStreamContext(context);\n+    select.open();\n+\n+    return Optional.of(select);\n+  }\n+\n+  default Optional<Metric[]> getRollupMetrics(Metric[] metrics) {\n+    Metric[] rollup = new Metric[metrics.length];\n+    CountMetric count = null;\n+    for (int m=0; m < rollup.length; m++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc0Mzc3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMToyNVrOIGRZLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMToyNVrOIGRZLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NzM0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      for (int n=m+1; n < metrics.length; n++) {\n          \n          \n            \n                      for (int n = m+1; n < metrics.length; n++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543447340", "createdAt": "2020-12-15T15:31:25Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.solr.client.solrj.io.comp.StreamComparator;\n+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.Metric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.WeightedSumMetric;\n+\n+/**\n+ * Indicates the underlying stream source supports parallelizing metrics computation across collections\n+ * using a rollup of metrics from each collection.\n+ */\n+public interface ParallelMetricsRollup {\n+  TupleStream[] parallelize(List<String> partitions) throws IOException;\n+  StreamComparator getParallelListSortOrder() throws IOException;\n+  RollupStream getRollupStream(SortStream sortStream, Metric[] rollupMetrics) throws IOException;\n+  Map<String,String> getRollupSelectFields(Metric[] rollupMetrics);\n+\n+  default Optional<TupleStream> openParallelStream(StreamContext context, List<String> partitions, Metric[] metrics) throws IOException {\n+    Optional<Metric[]> maybeRollupMetrics = getRollupMetrics(metrics);\n+    if (maybeRollupMetrics.isEmpty())\n+      return Optional.empty(); // some metric is incompatible with doing a rollup over the plist results\n+\n+    TupleStream[] parallelStreams = parallelize(partitions);\n+\n+    // the tuples from each plist need to be sorted using the same order to do a rollup\n+    Metric[] rollupMetrics = maybeRollupMetrics.get();\n+    StreamComparator comparator = getParallelListSortOrder();\n+    SortStream sortStream = new SortStream(new ParallelListStream(parallelStreams), comparator);\n+    RollupStream rollup = getRollupStream(sortStream, rollupMetrics);\n+    SelectStream select = new SelectStream(rollup, getRollupSelectFields(rollupMetrics));\n+    select.setStreamContext(context);\n+    select.open();\n+\n+    return Optional.of(select);\n+  }\n+\n+  default Optional<Metric[]> getRollupMetrics(Metric[] metrics) {\n+    Metric[] rollup = new Metric[metrics.length];\n+    CountMetric count = null;\n+    for (int m=0; m < rollup.length; m++) {\n+      Metric nextRollup;\n+      Metric next = metrics[m];\n+      if (next instanceof SumMetric) {\n+        // sum of sums\n+        nextRollup = new SumMetric(next.getIdentifier());\n+      } else if (next instanceof MinMetric) {\n+        // min of mins\n+        nextRollup = new MinMetric(next.getIdentifier());\n+      } else if (next instanceof MaxMetric) {\n+        // max of max\n+        nextRollup = new MaxMetric(next.getIdentifier());\n+      } else if (next instanceof CountMetric) {\n+        // sum of counts\n+        nextRollup = new SumMetric(next.getIdentifier());\n+        count = (CountMetric)next;\n+      } else if (next instanceof MeanMetric) {\n+        // WeightedSumMetric must have a count to compute the weighted avg. rollup from ...\n+        // if the user is not requesting count, then we can't parallelize\n+        if (count == null) {\n+          // just look past the current position\n+          for (int n=m+1; n < metrics.length; n++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc0NjUxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMTo1MlrOIGRaxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjo0MToyOFrOIQY7oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0Nzc1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(o instanceof Long) {\n          \n          \n            \n                } else if (o instanceof Long) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543447750", "createdAt": "2020-12-15T15:31:52Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java", "diffHunk": "@@ -86,7 +86,7 @@ public void update(Tuple tuple) {\n       if(l > longMax) {\n         longMax = l;\n       }\n-    } else {\n+    } else if(o instanceof Long) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NjYwOQ==", "bodyText": "the current format is consistent with the rest of the source file, best not to mix formatting even if it's wrong", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554056609", "createdAt": "2021-01-08T16:41:28Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java", "diffHunk": "@@ -86,7 +86,7 @@ public void update(Tuple tuple) {\n       if(l > longMax) {\n         longMax = l;\n       }\n-    } else {\n+    } else if(o instanceof Long) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0Nzc1MA=="}, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc0ODkxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMjoxN1rOIGRcIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMjoxN1rOIGRcIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0ODA5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(o instanceof Long) {\n          \n          \n            \n                } else if (o instanceof Long) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543448098", "createdAt": "2020-12-15T15:32:17Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java", "diffHunk": "@@ -87,7 +87,7 @@ public void update(Tuple tuple) {\n       if(l < longMin) {\n         longMin = l;\n       }\n-    } else {\n+    } else if(o instanceof Long) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc1MzE4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/WeightedSumMetric.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMzowNFrOIGRenw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMzowNFrOIGRenw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0ODczNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543448735", "createdAt": "2020-12-15T15:33:04Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/WeightedSumMetric.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.client.solrj.io.stream.metrics;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.solr.client.solrj.io.Tuple;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n+\n+public class WeightedSumMetric extends Metric {\n+\n+  public static final String FUNC = \"wsum\";\n+\n+  private static final class Part {\n+    private final double value;\n+    private final long count;\n+\n+    Part(long count, double value) {\n+      this.count = count;\n+      this.value = value;\n+    }\n+\n+    double weighted(final long total) {\n+      return ((double) count / total) * value;\n+    }\n+  }\n+\n+  private String valueCol;\n+  private String countCol;\n+  private List<Part> parts;\n+\n+  public WeightedSumMetric(String valueCol, String countCol) {\n+    init(valueCol, countCol, false);\n+  }\n+\n+  public WeightedSumMetric(String valueCol, String countCol, boolean outputLong) {\n+    init(valueCol, countCol, outputLong);\n+  }\n+\n+  public WeightedSumMetric(StreamExpression expression, StreamFactory factory) throws IOException {\n+    // grab all parameters out\n+    String functionName = expression.getFunctionName();\n+    if (!FUNC.equals(functionName)) {\n+      throw new IOException(\"Expected '\" + FUNC + \"' function but found \" + functionName);\n+    }\n+    String valueCol = factory.getValueOperand(expression, 0);\n+    String countCol = factory.getValueOperand(expression, 1);\n+    String outputLong = factory.getValueOperand(expression, 2);\n+\n+    // validate expression contains only what we want.\n+    if (null == valueCol) {\n+      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expected %s(valueCol,countCol)\", expression, FUNC));\n+    }\n+\n+    boolean ol = false;\n+    if (outputLong != null) {\n+      ol = Boolean.parseBoolean(outputLong);\n+    }\n+\n+    init(valueCol, countCol, ol);\n+  }\n+\n+  private void init(String valueCol, String countCol, boolean outputLong) {\n+    this.valueCol = valueCol;\n+    this.countCol = countCol != null ? countCol : \"count(*)\";\n+    this.outputLong = outputLong;\n+    setFunctionName(FUNC);\n+    setIdentifier(FUNC, \"(\", valueCol, \", \" + countCol + \")\");\n+  }\n+\n+  public void update(Tuple tuple) {\n+    Object c = tuple.get(countCol);\n+    Object o = tuple.get(valueCol);\n+    if (c instanceof Number && o instanceof Number) {\n+      if (parts == null) {\n+        parts = new LinkedList<>();\n+      }\n+      Number count = (Number) c;\n+      Number value = (Number) o;\n+      parts.add(new Part(count.longValue(), value.doubleValue()));\n+    }\n+  }\n+\n+  public Metric newInstance() {\n+    return new WeightedSumMetric(valueCol, countCol, outputLong);\n+  }\n+\n+  public String[] getColumns() {\n+    return new String[]{valueCol, countCol};\n+  }\n+\n+  public Number getValue() {\n+    long total = sumCounts();\n+    double wavg = 0d;\n+    for (Part next : parts) {\n+      wavg += next.weighted(total);\n+    }\n+    return outputLong ? Math.round(wavg) : wavg;\n+  }\n+\n+  private long sumCounts() {\n+    long total = 0L;\n+    for (Part next : parts) {\n+      total += next.count;\n+    }\n+    return total;\n+  }\n+\n+  @Override\n+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {\n+    return new StreamExpression(getFunctionName()).withParameter(valueCol).withParameter(countCol).withParameter(Boolean.toString(outputLong));\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDc1NjQyOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/ParallelFacetStreamOverAliasTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMzo0NFrOIGRgnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMzo0NFrOIGRgnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0OTI0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i=0; i < dists.length; i++) {\n          \n          \n            \n                for (int i = 0; i < dists.length; i++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543449247", "createdAt": "2020-12-15T15:33:44Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/ParallelFacetStreamOverAliasTest.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.util.Precision;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.io.SolrClientCache;\n+import org.apache.solr.client.solrj.io.Tuple;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.request.UpdateRequest;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.handler.SolrDefaultStreamFactory;\n+import org.apache.solr.util.LogLevel;\n+import org.apache.solr.util.RTimer;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * objective of this test suite is to test scalability of Streaming expressions for large deployments,\n+ * for example where there are many collections with high sharding and each collection has millions of documents\n+ */\n+@SolrTestCaseJ4.SuppressSSL\n+@LuceneTestCase.SuppressCodecs({\"Lucene3x\", \"Lucene40\", \"Lucene41\", \"Lucene42\", \"Lucene45\"})\n+@LogLevel(\"org.apache.solr.client.solrj.io.stream=INFO;org.apache.solr.common.cloud.ZkStateReader=WARN;org.apache.solr.metrics=WARN;org.apache.solr.core.SolrCore=WARN;org.apache.solr.cloud=WARN;org.apache.solr.update=WARN;org.apache.solr.rest=ERROR;org.apache.solr.servlet.HttpSolrCall=WARN;org.apache.solr=WARN;org.apache.solr.client.solrj.impl=INFO\")\n+public class ParallelFacetStreamOverAliasTest extends SolrCloudTestCase {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private static final String ALIAS_NAME = \"SOME_ALIAS_WITH_MANY_COLLS\";\n+\n+  private static final String id = \"id\";\n+  private static final int NUM_COLLECTIONS = 2;\n+  private static final int NUM_DOCS_PER_COLLECTION = 40;\n+  private static final int NUM_SHARDS_PER_COLLECTION = 4;\n+  private static final int CARD = 10;\n+\n+  private static List<String> listOfCollections;\n+  private static final RandomGenerator rand = new JDKRandomGenerator(5150);\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    final RTimer timer = new RTimer();\n+    configureCluster(NUM_COLLECTIONS).withMetrics(false)\n+        .addConfig(\"conf\", getFile(\"solrj\").toPath().resolve(\"solr\").resolve(\"configsets\").resolve(\"streaming\").resolve(\"conf\"))\n+        .configure();\n+    cleanup();\n+    setupCollectionsAndAlias();\n+\n+    if (log.isInfoEnabled())\n+      log.info(\"Took {}ms to setup cluster with {} collections\", timer.getTime(), NUM_COLLECTIONS);\n+  }\n+\n+  /**\n+   * setup the testbed with necessary collections, documents, and alias\n+   */\n+  public static void setupCollectionsAndAlias() throws Exception {\n+\n+    final NormalDistribution[] dists = new NormalDistribution[CARD];\n+    for (int i=0; i < dists.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzQwNTA5OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DrillStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNDoxMVrOIQYr3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNDoxMVrOIQYr3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1MjU3Mg==", "bodyText": "This refactor makes use of the enhancement provided by SOLR-14987 to reuse HttpSolrClients per host vs. one per replica", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554052572", "createdAt": "2021-01-08T16:34:11Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DrillStream.java", "diffHunk": "@@ -252,29 +253,27 @@ public void setStreamContext(StreamContext streamContext) {\n   }\n \n   protected void constructStreams() throws IOException {\n-\n     try {\n-\n       Object pushStream = ((Expressible) tupleStream).toExpression(streamFactory);\n-\n-      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n-\n-      for(int w=0; w<shardUrls.size(); w++) {\n-        ModifiableSolrParams paramsLoc = new ModifiableSolrParams();\n-        paramsLoc.set(DISTRIB,\"false\"); // We are the aggregator.\n-        paramsLoc.set(\"expr\", pushStream.toString());\n-        paramsLoc.set(\"qt\",\"/export\");\n-        paramsLoc.set(\"fl\", fl);\n-        paramsLoc.set(\"sort\", sort);\n-        paramsLoc.set(\"q\", q);\n-        String url = shardUrls.get(w);\n-        SolrStream solrStream = new SolrStream(url, paramsLoc);\n+      final ModifiableSolrParams paramsLoc = new ModifiableSolrParams();\n+      paramsLoc.set(DISTRIB,\"false\"); // We are the aggregator.\n+      paramsLoc.set(\"expr\", pushStream.toString());\n+      paramsLoc.set(\"qt\",\"/export\");\n+      paramsLoc.set(\"fl\", fl);\n+      paramsLoc.set(\"sort\", sort);\n+      paramsLoc.set(\"q\", q);\n+      getReplicas(this.zkHost, this.collection, this.streamContext, paramsLoc).forEach(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83bae9c8cd681001fee303b34ed61bb746caba3e"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzQxNjA4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNzowOVrOIQYygg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNzowOVrOIQYygg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NDI3NA==", "bodyText": "This source file did not adhere to the community code format so I reformatted it. It's bad practice in general, but since my PR was getting dinged for format issues, I chose to fix globally in this file vs. piecemeal.", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554054274", "createdAt": "2021-01-08T16:37:09Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -20,15 +20,19 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzQxOTQxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozODowOVrOIQY0mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozODowOVrOIQY0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NDgxMA==", "bodyText": "this is the main hook to see if the auto-plist approach should apply to this facet expression", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554054810", "createdAt": "2021-01-08T16:38:09Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -537,14 +555,29 @@ public void setStreamContext(StreamContext context) {\n   }\n \n   public void open() throws IOException {\n-    if(cache != null) {\n+    if (cache != null) {\n       cloudSolrClient = cache.getCloudSolrClient(zkHost);\n     } else {\n       final List<String> hosts = new ArrayList<>();\n       hosts.add(zkHost);\n       cloudSolrClient = new Builder(hosts, Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000).build();\n     }\n \n+    // Parallelize the facet expression across multiple collections for an alias using plist if possible\n+    if (params.getBool(\"plist\", defaultPlistEnabled)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 619}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzQyMzA1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozOTowOFrOIQY2wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozOTowOFrOIQY2wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NTM2MA==", "bodyText": "Implementation of the ParallelMetricsRollup interface starts here ...", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554055360", "createdAt": "2021-01-08T16:39:08Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -842,10 +881,99 @@ public int getCost() {\n \n   @Override\n   public StreamComparator getStreamSort() {\n-    if(bucketSorts.length > 1) {\n-      return new MultipleFieldComparator(bucketSorts);\n+    return (bucketSorts.length > 1) ? new MultipleFieldComparator(bucketSorts) : bucketSorts[0];\n+  }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 921}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 973, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}