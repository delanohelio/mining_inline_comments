{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NjU5NDE0", "number": 1606, "title": "SOLR-14588: Implement Circuit Breakers", "bodyText": "This commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based circuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error if the defined threshold is breached, thus giving headroom to existing indexing and search requests to complete.", "createdAt": "2020-06-23T15:46:01Z", "url": "https://github.com/apache/lucene-solr/pull/1606", "merged": true, "mergeCommit": {"oid": "7b54902f681542ae49293df9bc9e5ac1694d465c"}, "closed": true, "closedAt": "2020-06-25T15:36:23Z", "author": {"login": "atris"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuHpq9gBqjM0NzM2Nzk3OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuwbOrgFqTQzNzYxMzE1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a", "committedDate": "2020-06-23T11:28:26Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "committedDate": "2020-06-23T16:01:00Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTI4Mjg1", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-435928285", "createdAt": "2020-06-23T15:58:49Z", "commit": {"oid": "56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNTo1ODo0OVrOGnwAxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNjoxNDowNVrOGnwpaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNDI3OA==", "bodyText": "prefer entrySet", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444334278", "createdAt": "2020-06-23T15:58:49Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    assert circuitBreakerType != null && circuitBreaker != null;\n+\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = new HashMap<>();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNTkyMg==", "bodyText": "Does this have to be set when useCircuitBreakers is false? I would like our configs to be more tolerant.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444335922", "createdAt": "2020-06-23T16:01:06Z", "author": {"login": "madrob"}, "path": "solr/core/src/test-files/solr/collection1/conf/solrconfig-cache-enable-disable.xml", "diffHunk": "@@ -70,6 +70,10 @@\n \n     <queryResultWindowSize>10</queryResultWindowSize>\n \n+    <useCircuitBreakers>false</useCircuitBreakers>\n+\n+    <memoryCircuitBreakerThreshold>100</memoryCircuitBreakerThreshold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNzk4NQ==", "bodyText": "this would be better as seenMemory=X allowedMemory=Y - a little bit less human readable but a lot easier to grep for or search in something like Splunk.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444337985", "createdAt": "2020-06-23T16:04:06Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTI2MQ==", "bodyText": "Should we validate that this is between 0 and 100?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341261", "createdAt": "2020-06-23T16:08:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,9 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTUxNw==", "bodyText": "Is this checking for overflow? How does the error condition occur otherwise?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341517", "createdAt": "2020-06-23T16:09:16Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTg4OQ==", "bodyText": "I think this makes more sense to be a long. Returning fractional bytes is meaningless.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341889", "createdAt": "2020-06-23T16:09:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjIxMw==", "bodyText": "commit-optimize-commit in a loop won't get you multiple segments", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444342213", "createdAt": "2020-06-23T16:10:20Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjU2MQ==", "bodyText": "Probably want to also call executor.shutdown in addition to null?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444342561", "createdAt": "2020-06-23T16:10:51Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzQyNw==", "bodyText": "Use logger instead of system.out", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444343427", "createdAt": "2020-06-23T16:12:07Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() throws Exception {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    for (int i = 0; i < 5; i++) {\n+      System.out.println(\"i is \" + i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzY5MQ==", "bodyText": "use unit asserts instead of java asserts please", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444343691", "createdAt": "2020-06-23T16:12:31Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() throws Exception {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    for (int i = 0; i < 5; i++) {\n+      System.out.println(\"i is \" + i);\n+      executor.submit(() -> {\n+        try {\n+          h.query(req(\"name:\\\"john smith\\\"\"));\n+        } catch (SolrException e) {\n+          failureCount.incrementAndGet();\n+        } catch (Exception e) {\n+          throw new RuntimeException(e.getMessage());\n+        }\n+      });\n+    }\n+\n+    executor.shutdown();\n+    try {\n+      executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException e) {\n+      throw new RuntimeException(e.getMessage());\n+    }\n+\n+    assert failureCount.get() == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw==", "bodyText": "Is this expensive to get? If we're doing it for every query, I'd want to make sure that it is an efficient call.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444344367", "createdAt": "2020-06-23T16:13:35Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+\n+    return actualLimit;\n+  }\n+\n+  /**\n+   * Calculate the live memory usage for the system. This method has package visibility\n+   * to allow using for testing\n+   * @return Memory usage in bytes\n+   */\n+  protected long calculateLiveMemoryUsage() {\n+    return MEMORY_MX_BEAN.getHeapMemoryUsage().getUsed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDY4MQ==", "bodyText": "This should be constant, right? Get it once at constructor?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444344681", "createdAt": "2020-06-23T16:14:05Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9704538f8fc4764286a82b2010cd27f718d861c0", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/9704538f8fc4764286a82b2010cd27f718d861c0", "committedDate": "2020-06-23T16:37:39Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "committedDate": "2020-06-23T16:01:00Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "9704538f8fc4764286a82b2010cd27f718d861c0", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/9704538f8fc4764286a82b2010cd27f718d861c0", "committedDate": "2020-06-23T16:37:39Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "committedDate": "2020-06-23T18:03:11Z", "message": "Update per comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDM4MzY4", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-436038368", "createdAt": "2020-06-23T18:15:30Z", "commit": {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNTozMFrOGn1EaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNTozMFrOGn1EaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzEyOQ==", "bodyText": "We only want to do this validation if circuitBreakers are enabled, right?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444417129", "createdAt": "2020-06-23T18:15:30Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);\n+\n+    if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDM5NTEy", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-436039512", "createdAt": "2020-06-23T18:17:05Z", "commit": {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNzowNVrOGn1HlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNzowNVrOGn1HlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzk0MA==", "bodyText": "This will never be true.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444417940", "createdAt": "2020-06-23T18:17:05Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3284e7841349c64b9057200cbcb69e171b09ca81", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/3284e7841349c64b9057200cbcb69e171b09ca81", "committedDate": "2020-06-23T18:31:39Z", "message": "More comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "356cc2ce2bdf28b06dc9d51026314b5afff7649e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/356cc2ce2bdf28b06dc9d51026314b5afff7649e", "committedDate": "2020-06-23T19:08:04Z", "message": "Add comment explaining memory calculation choices"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDg3MjQw", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-436087240", "createdAt": "2020-06-23T19:24:50Z", "commit": {"oid": "356cc2ce2bdf28b06dc9d51026314b5afff7649e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOToyNDo1MFrOGn3YXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOToyNDo1MFrOGn3YXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTAwNA==", "bodyText": "I was thinking of moving this outside of SolrCore, so custom Circuit breakers could be implemented and plugged without any change to SolrCore? What do you think?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444455004", "createdAt": "2020-06-23T19:24:50Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/core/SolrCore.java", "diffHunk": "@@ -1164,6 +1171,16 @@ private SolrCoreMetricManager initCoreMetricManager(SolrConfig config) {\n     return coreMetricManager;\n   }\n \n+  private CircuitBreakerManager initCircuitBreakerManager() {\n+    CircuitBreakerManager circuitBreakerManager = new CircuitBreakerManager();\n+\n+    // Install the default circuit breakers\n+    CircuitBreaker memoryCircuitBreaker = new MemoryCircuitBreaker(this);\n+    circuitBreakerManager.registerCircuitBreaker(CircuitBreakerType.MEMORY, memoryCircuitBreaker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356cc2ce2bdf28b06dc9d51026314b5afff7649e"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93765b35d47bf40eb2358c5d025dc087e610ec0c", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/93765b35d47bf40eb2358c5d025dc087e610ec0c", "committedDate": "2020-06-24T09:05:50Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef6f804b232d7f3c4ba7361c4b80ed2242198dbf", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/ef6f804b232d7f3c4ba7361c4b80ed2242198dbf", "committedDate": "2020-06-24T09:10:00Z", "message": "Update obsolete comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/bed17e4266f1b6152acd58e56d737fda01ae222d", "committedDate": "2020-06-24T09:23:07Z", "message": "Fix Precommit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzI2ODQ3", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-436726847", "createdAt": "2020-06-24T14:52:24Z", "commit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo1MjoyNFrOGoV3HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNToxNjoxNVrOGoW8jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NDM5Nw==", "bodyText": "nit: s/practise/practice", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444954397", "createdAt": "2020-06-24T14:52:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NTIyMA==", "bodyText": "Why is there an assert here? It might be fine to leave it, but I'm curious what the intent is. If you want this check to happen in production, then you probably need to use something like Objects.assertNotNull()", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444955220", "createdAt": "2020-06-24T14:53:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    assert circuitBreakerType != null && circuitBreaker != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NzUyNA==", "bodyText": "s/seen memory/seenMemory - one word for log processing", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444957524", "createdAt": "2020-06-24T14:56:30Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTI3OA==", "bodyText": "Is this thread safe? If there are multiple queries happening, concurrent with GC, would these values be stale?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444961278", "createdAt": "2020-06-24T15:01:22Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MzYxNA==", "bodyText": "Does this make sense? It indicates an error condition in the JVM, right? Can move this check to the constructor and throw an Exception since we'd effectively be blocking all queries at that point anyway?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444963614", "createdAt": "2020-06-24T15:04:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2NjE0OA==", "bodyText": "Use a try-finally to make sure this executor is shut down.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444966148", "createdAt": "2020-06-24T15:08:03Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2ODgwNQ==", "bodyText": "A question about the design of this class... We have methods for registering a custom circuit breaker, and some notion of default circuit breakers, but I don't see an easy way to add additional ones. Ideally this would be through the XML or through some kind of schema API or could be very powerful combined with the Package API. I don't have a full idea of what this needs to look like, and this is fine as is to commit now, but I'd really like us to come back to this and develop the idea further. Possibly as a SIP?", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444968805", "createdAt": "2020-06-24T15:11:33Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2OTUxOA==", "bodyText": "I think we would want to have two separate controls for this.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444969518", "createdAt": "2020-06-24T15:12:32Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,19 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MjE3NQ==", "bodyText": "Do we want to time this and include that in the response (useful for both passed and failed breakers)", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444972175", "createdAt": "2020-06-24T15:16:15Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,19 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c1b57c262df097ad95678baa516f08056975440", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/7c1b57c262df097ad95678baa516f08056975440", "committedDate": "2020-06-24T18:36:50Z", "message": "Moce to ThreadLocal and add timing for debugging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDI4MDkz", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-437028093", "createdAt": "2020-06-24T21:43:18Z", "commit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo0MzoxOVrOGokKnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo1Mzo1MlrOGokcxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODc2Nw==", "bodyText": "Need .get() here.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445188767", "createdAt": "2020-06-24T21:43:19Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -44,25 +48,20 @@ public boolean isCircuitBreakerGauntletTripped() {\n       return false;\n     }\n \n-    allowedMemory = getCurrentMemoryThreshold();\n+    allowedMemory.set(getCurrentMemoryThreshold());\n \n-    seenMemory = calculateLiveMemoryUsage();\n+    seenMemory.set(calculateLiveMemoryUsage());\n \n-    return (seenMemory >= allowedMemory);\n+    return (seenMemory.get() >= allowedMemory.get());\n   }\n \n   @Override\n   public String printDebugInfo() {\n-    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;\n+    return \"seenMemory=\" + seenMemory + \" allowedMemory=\" + allowedMemory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTMxNA==", "bodyText": "I'm not sure this is the right error code. A 5xx code usually indicates a server error - and I'm not sure how we effectively convey to clients that this error is something that is ok to retry. They might log the message, but retry logic will typically look at the code returned as a first branch in the decision tree. Need to think about this and maybe look at some examples.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445191314", "createdAt": "2020-06-24T21:49:05Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n+\n+      if (timer != null) {\n+        RTimerTree subt = timer.sub(\"circuitbreaker\");\n+        rb.setTimer(subt.sub(\"circuitbreaker\"));\n+      }\n+      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n+      rsp.add(STATUS, FAILURE);\n+      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTg1OQ==", "bodyText": "I'd like for all of this to be dynamically configurable at some point, but it doesn't have to be in this PR. Can add it to the future SIP or create a separate JIRA for it, as you think would be appropriate.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445191859", "createdAt": "2020-06-24T21:50:18Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,11 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5Mjc1Mw==", "bodyText": "I'd combine this with the later call to req.getRequestTimer so that we're not doing that twice. You're also checking this before we call rb.setDebug(), so it probably is always false at this point.\nWe should be timing the circuitBreakerCheck as well (Lines 299-300).", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445192753", "createdAt": "2020-06-24T21:52:16Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MzQxMg==", "bodyText": "We never stop this subtimer.", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445193412", "createdAt": "2020-06-24T21:53:52Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n+\n+      if (timer != null) {\n+        RTimerTree subt = timer.sub(\"circuitbreaker\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c1b57c262df097ad95678baa516f08056975440"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "073113908be650e36d85ae1ac4745e48bccd6d7b", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/073113908be650e36d85ae1ac4745e48bccd6d7b", "committedDate": "2020-06-25T07:42:29Z", "message": "Update timer usage and debug print info"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjEzMTU2", "url": "https://github.com/apache/lucene-solr/pull/1606#pullrequestreview-437613156", "createdAt": "2020-06-25T15:31:47Z", "commit": {"oid": "073113908be650e36d85ae1ac4745e48bccd6d7b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2657, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}