{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2NDc3Njkz", "number": 2141, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDo0NzoyMlrOFFhZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo1NTozMFrOFL5e9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzM0NDA1OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDo0NzoyMlrOIGEnuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjoyNzozOVrOIMFmRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIzODA3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Do we want to depcate this entirely now ?\n          \n          \n            \n                    // Do we want to deprecate this entirely now ?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r543238073", "createdAt": "2020-12-15T10:47:22Z", "author": {"login": "jbampton"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -195,10 +201,13 @@ private Scorer opt(Collection<ScorerSupplier> optional, int minShouldMatch,\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to depcate this entirely now ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NTU0MQ==", "bodyText": "Fixed. Thanks!", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r549545541", "createdAt": "2020-12-29T02:27:39Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -195,10 +201,13 @@ private Scorer opt(Collection<ScorerSupplier> optional, int minShouldMatch,\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to depcate this entirely now ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIzODA3Mw=="}, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzc5ODUzOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNzozMDo1NVrOII9OPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjoyNzo1NlrOIMFmZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MjU4OA==", "bodyText": "maybe we should make sure the minShouldMatch is not equal either, since it would be better to use the conjunction scorer otherwise?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r546262588", "createdAt": "2020-12-19T17:30:55Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,19 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;\n+  int freq;\n+\n+  WANDScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch) throws IOException {\n     super(weight);\n \n+    if (minShouldMatch > scorers.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NTU3NQ==", "bodyText": "Makes sense. I've updated the condition and the exception message.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r549545575", "createdAt": "2020-12-29T02:27:56Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,19 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;\n+  int freq;\n+\n+  WANDScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch) throws IOException {\n     super(weight);\n \n+    if (minShouldMatch > scorers.size()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MjU4OA=="}, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzc5ODg3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNzozMToyN1rOII9OZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjoyOToyM1rOIMFnbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MjYzMA==", "bodyText": "this line is suspicious, is minShouldMatch ever negative?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r546262630", "createdAt": "2020-12-19T17:31:27Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,19 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;\n+  int freq;\n+\n+  WANDScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch) throws IOException {\n     super(weight);\n \n+    if (minShouldMatch > scorers.size()) {\n+      throw new IllegalArgumentException(\"minShouldMatch should be <= the number of scorers\");\n+    }\n+\n     this.minCompetitiveScore = 0;\n+    this.minShouldMatch = minShouldMatch > 0 ? minShouldMatch : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NTgzNw==", "bodyText": "I put it there originally to guard against any accidental invalid negative minShouldMatch being passed in, but yeah it should probably be handled as assertion. I've updated it.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r549545837", "createdAt": "2020-12-29T02:29:23Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,19 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;\n+  int freq;\n+\n+  WANDScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch) throws IOException {\n     super(weight);\n \n+    if (minShouldMatch > scorers.size()) {\n+      throw new IllegalArgumentException(\"minShouldMatch should be <= the number of scorers\");\n+    }\n+\n     this.minCompetitiveScore = 0;\n+    this.minShouldMatch = minShouldMatch > 0 ? minShouldMatch : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MjYzMA=="}, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzgyMzM4OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNzo1OTozNVrOII9ZoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjoyOTozNVrOIMFngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTUwNQ==", "bodyText": "Actually I think it's important to merge both loops, in order to stop calling advanceTail as soon as possible.\nWithout doing this, your change is still correct, but it doesn't leverage minShouldMatch in order to make the query run faster, which is a pity.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r546265505", "createdAt": "2020-12-19T17:59:35Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -271,6 +280,19 @@ public boolean matches() throws IOException {\n             return false;\n           }\n         }\n+\n+        // minCompetitiveScore satisfied, now checks if the doc has enough required number of matches\n+        // Combining this loop with the above makes for complicated conditional checks, so keeping them separate for readability", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NTg1OQ==", "bodyText": "Makes sense. I gave this a second try and actually able to arrive at a clean looking solution. Please let me know if this version looks good.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r549545859", "createdAt": "2020-12-29T02:29:35Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -271,6 +280,19 @@ public boolean matches() throws IOException {\n             return false;\n           }\n         }\n+\n+        // minCompetitiveScore satisfied, now checks if the doc has enough required number of matches\n+        // Combining this loop with the above makes for complicated conditional checks, so keeping them separate for readability", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2NTUwNQ=="}, "originalCommit": {"oid": "9a523f46c3decf1ad4c9e12a59944bd35ff14abf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYwNDA1OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMDo0OTozNFrOINSfkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjowMDo0MlrOIOy85A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNTM5Mw==", "bodyText": "Actually this bit was correct, we should instead fix WANDScorer to take minShouldMatch into account the same way MinShouldMatchSumScorer does.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550805393", "createdAt": "2021-01-01T20:49:34Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -74,11 +74,13 @@ private long computeCost() {\n       return minRequiredCost.getAsLong();\n     } else {\n       final Collection<ScorerSupplier> optionalScorers = subs.get(Occur.SHOULD);\n-      final long shouldCost =\n-          MinShouldMatchSumScorer.cost(\n-              optionalScorers.stream().mapToLong(ScorerSupplier::cost),\n-              optionalScorers.size(),\n-              minShouldMatch);\n+      // nocommit The cost calculation here copies that in WANDScorer's constructor, and may need to be adjusted?\n+      final long shouldCost = scoreMode == ScoreMode.TOP_SCORES ?\n+                              optionalScorers.stream().mapToLong(ScorerSupplier::cost).sum() :\n+                              MinShouldMatchSumScorer.cost(\n+                                      optionalScorers.stream().mapToLong(ScorerSupplier::cost),\n+                                      optionalScorers.size(),\n+                                      minShouldMatch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTc2NA==", "bodyText": "I see. Previously I wasn't entirely sure about the handling here. I've reverted the related changes and updated WANDScorer to share the same cost function with that of minShouldMatchSumScorer.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552385764", "createdAt": "2021-01-06T06:00:42Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -74,11 +74,13 @@ private long computeCost() {\n       return minRequiredCost.getAsLong();\n     } else {\n       final Collection<ScorerSupplier> optionalScorers = subs.get(Occur.SHOULD);\n-      final long shouldCost =\n-          MinShouldMatchSumScorer.cost(\n-              optionalScorers.stream().mapToLong(ScorerSupplier::cost),\n-              optionalScorers.size(),\n-              minShouldMatch);\n+      // nocommit The cost calculation here copies that in WANDScorer's constructor, and may need to be adjusted?\n+      final long shouldCost = scoreMode == ScoreMode.TOP_SCORES ?\n+                              optionalScorers.stream().mapToLong(ScorerSupplier::cost).sum() :\n+                              MinShouldMatchSumScorer.cost(\n+                                      optionalScorers.stream().mapToLong(ScorerSupplier::cost),\n+                                      optionalScorers.size(),\n+                                      minShouldMatch);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNTM5Mw=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYxNTg0OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMTowNjoyNlrOINSktw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDoxNToxNFrOIRXFTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjcxMQ==", "bodyText": "Maybe not now in order to keep this PR contained, but it would be nice if we could handle this case with WANDScorer too indeed.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550806711", "createdAt": "2021-01-01T21:06:26Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -230,10 +232,13 @@ private Scorer opt(\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to deprecate this entirely now ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTM5NQ==", "bodyText": "Sounds good. I've removed the no commit comment for now, but let me give it a second try in the next few days.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552385395", "createdAt": "2021-01-06T05:59:20Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -230,10 +232,13 @@ private Scorer opt(\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to deprecate this entirely now ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjcxMQ=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1MzY0Nw==", "bodyText": "I've taken a second look at this, and had the following thoughts / questions:\nPreviously, in Boolean2ScorerSupplier#opt, the scorer picking logic is\nif (minShouldMatch > 1) {\n  return MinShouldMatchSumScorer...\n} else if (scoreMode == ScoreMode.TOP_SCORES) {\n  return WANDScorer...\n} else {\n  return DisjunctionSumScorer...\n}\n\nWith the current changes in this PR, we now have\nif (scoreMode == ScoreMode.TOP_SCORES) {\n  return WANDScorer...\n} else if (minShouldMatch > 1) {\n  return MinShouldMatchSumScorer...\n} else {\n  return DisjunctionSumScorer...\n}\n\nI noticed that with trivial changes, WANDScorer seems to be usable for all ScoreMode when scoreMode.needsScore == true as well (passed all existing tests with trivial updates). So we can arrive at something like this\nif (scoreMode.needsScore()) {\n  return WANDScorer...\n} else if (minShouldMatch > 1) {\n  return MinShouldMatchSumScorer...\n} else {\n  return DisjunctionSumScorer...\n}\n\nIs there a reason WANDScorer is only used for TOP_DOCS before? I did read up the documentation and discussion in https://issues.apache.org/jira/browse/LUCENE-4100, but it's a bit long so I'm not sure I'm following all the details there.\nFollowing the above, since WANDScorer can already handle the case where minShouldMatch == 0, then I can see MinShouldMatchSumScorer be merged into WANDScorer mostly to handle non-scoring mode, arriving at\nif (?) {\n  return WANDScorer...\n} else {\n  return DisjunctionSumScorer...\n}\n\nAt this point, it actually seems like WANDScorer can handle all the cases already, so DisjunctionSumScorer can be deprecated as well to just return WANDScorer here?\nIs the above the right reasoning of how things would go for the deprecation?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r553153647", "createdAt": "2021-01-07T07:32:53Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -230,10 +232,13 @@ private Scorer opt(\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to deprecate this entirely now ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjcxMQ=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA3NDg5Mg==", "bodyText": "Is there a reason WANDScorer is only used for TOP_DOCS before?\n\nMostly because it's a bit slower since it needs to track two priority queues and one linked list, when the simple DisjunctionScorer only needs to track a single priority queue.\n\nsince WANDScorer can already handle the case where minShouldMatch == 0, then I can see MinShouldMatchSumScorer be merged into WANDScorer mostly to handle non-scoring mode\n\n+1 to give it a try in a follow-up PR!", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r555074892", "createdAt": "2021-01-11T14:15:14Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/Boolean2ScorerSupplier.java", "diffHunk": "@@ -230,10 +232,13 @@ private Scorer opt(\n       for (ScorerSupplier scorer : optional) {\n         optionalScorers.add(scorer.get(leadCost));\n       }\n-      if (minShouldMatch > 1) {\n+\n+      if (scoreMode == ScoreMode.TOP_SCORES) {\n+        return new WANDScorer(weight, optionalScorers, minShouldMatch);\n+      } else if (minShouldMatch > 1) {\n+        // nocommit minShouldMath > 1 && scoreMode != ScoreMode.TOP_SCORES still requires MinShouldMatchSumScorer.\n+        // Do we want to deprecate this entirely now ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjcxMQ=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYxNjM3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMTowNjo0N1rOINSk7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNTo1NzowN1rOIOy5IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjc2NA==", "bodyText": "Let's make it final?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550806764", "createdAt": "2021-01-01T21:06:47Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,21 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDgwMA==", "bodyText": "Done.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552384800", "createdAt": "2021-01-06T05:57:07Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,21 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjc2NA=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYxNzAzOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMTowNzozMVrOINSlNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMTowNzozMVrOINSlNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNjgzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assert minShouldMatch >=0 : \"minShouldMatch should not be negative, but got \" + minShouldMatch;\n          \n          \n            \n                assert minShouldMatch >= 0 : \"minShouldMatch should not be negative, but got \" + minShouldMatch;", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550806836", "createdAt": "2021-01-01T21:07:31Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -130,10 +130,21 @@ private static long scaleMinScore(float minScore, int scalingFactor) {\n \n   int upTo; // upper bound for which max scores are valid\n \n-  WANDScorer(Weight weight, Collection<Scorer> scorers) throws IOException {\n+  int minShouldMatch;\n+  int freq;\n+\n+  WANDScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch) throws IOException {\n     super(weight);\n \n+    if (minShouldMatch >= scorers.size()) {\n+      throw new IllegalArgumentException(\"minShouldMatch should be < the number of scorers\");\n+    }\n+\n     this.minCompetitiveScore = 0;\n+\n+    assert minShouldMatch >=0 : \"minShouldMatch should not be negative, but got \" + minShouldMatch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYyNzcwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMToxNzoxNVrOINSppw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjowMToyOVrOIOy9pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNzk3NQ==", "bodyText": "Indeed I don't think we need it, but I like doing it so that the approximation doesn't return documents knowing that no match is possible.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550807975", "createdAt": "2021-01-01T21:17:15Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -447,6 +461,23 @@ private int doNextCompetitiveCandidate() throws IOException {\n       }\n     }\n \n+      // nocommit Do we still need the following given TwoPhaseIterator.matches already performs the check\n+//     minCompetitiveScore satisfied, now checks if the doc has enough required number of matches", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTk1Nw==", "bodyText": "Makes sense.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552385957", "createdAt": "2021-01-06T06:01:29Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -447,6 +461,23 @@ private int doNextCompetitiveCandidate() throws IOException {\n       }\n     }\n \n+      // nocommit Do we still need the following given TwoPhaseIterator.matches already performs the check\n+//     minCompetitiveScore satisfied, now checks if the doc has enough required number of matches", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwNzk3NQ=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTYzMDIzOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMToyMDoyMlrOINSqyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjowMjo0MVrOIOy-2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwODI2NQ==", "bodyText": "I don't think we should advanceTail here, which may be costly. We should just make sure that freq + tailSize >= minShouldMatch and otherwise call your else block.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r550808265", "createdAt": "2021-01-01T21:20:22Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -447,6 +461,23 @@ private int doNextCompetitiveCandidate() throws IOException {\n       }\n     }\n \n+      // nocommit Do we still need the following given TwoPhaseIterator.matches already performs the check\n+//     minCompetitiveScore satisfied, now checks if the doc has enough required number of matches\n+//    while (freq < minShouldMatch) {\n+//      if (freq + tailSize >= minShouldMatch) {\n+//        // a match on doc is still possible, try to\n+//        // advance scorers from the tail\n+//        advanceTail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjI2NQ==", "bodyText": "Makes sense. I've updated the code to include this check in the while loop condition.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552386265", "createdAt": "2021-01-06T06:02:41Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/WANDScorer.java", "diffHunk": "@@ -447,6 +461,23 @@ private int doNextCompetitiveCandidate() throws IOException {\n       }\n     }\n \n+      // nocommit Do we still need the following given TwoPhaseIterator.matches already performs the check\n+//     minCompetitiveScore satisfied, now checks if the doc has enough required number of matches\n+//    while (freq < minShouldMatch) {\n+//      if (freq + tailSize >= minShouldMatch) {\n+//        // a match on doc is still possible, try to\n+//        // advance scorers from the tail\n+//        advanceTail();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgwODI2NQ=="}, "originalCommit": {"oid": "a7b48f03824182e233d773c29d4e62326aefade8"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDIwNDcwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/ScorerUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo1NTozMFrOIPVzUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwNzozMzowNlrOIPh0tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1Njc1Mw==", "bodyText": "can you keep it pkg-private?", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r552956753", "createdAt": "2021-01-06T20:55:30Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/ScorerUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.util.stream.LongStream;\n+import java.util.stream.StreamSupport;\n+import org.apache.lucene.util.PriorityQueue;\n+\n+/** Util class for Scorer related methods */\n+public class ScorerUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e53bf6e79c5822671fe0e56f5b7edc63abcb2e1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1MzcxOA==", "bodyText": "Done.", "url": "https://github.com/apache/lucene-solr/pull/2141#discussion_r553153718", "createdAt": "2021-01-07T07:33:06Z", "author": {"login": "zacharymorn"}, "path": "lucene/core/src/java/org/apache/lucene/search/ScorerUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.util.stream.LongStream;\n+import java.util.stream.StreamSupport;\n+import org.apache.lucene.util.PriorityQueue;\n+\n+/** Util class for Scorer related methods */\n+public class ScorerUtil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1Njc1Mw=="}, "originalCommit": {"oid": "3e53bf6e79c5822671fe0e56f5b7edc63abcb2e1"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 980, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}