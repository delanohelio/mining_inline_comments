{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzExNzYx", "number": 1467, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToxNzoxMlrOD3rQuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMzo1N1rOD4HKMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzA3MDY0OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToxNzoxMlrOGOD68A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToyMTozMlrOGOEHhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM5NzQ4OA==", "bodyText": "Why not implement these like they are done on 8x?  I suspect introspection tools like \"luke\" / Solr analysis page may choke if this isn't done right.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417397488", "createdAt": "2020-04-29T15:17:12Z", "author": {"login": "dsmiley"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -364,4 +325,60 @@ public BytesRef term() throws IOException {\n     }\n   }\n \n+  /**\n+   * Used for sharing automata between segments\n+   *\n+   * Levenshtein automata are large and expensive to build; we don't want to build\n+   * them directly on the query because this can blow up caches that use queries\n+   * as keys; we also don't want to rebuild them for every segment.  This attribute\n+   * allows the FuzzyTermsEnum to build the automata once for its first segment\n+   * and then share them for subsequent segment calls.\n+   */\n+  private interface AutomatonAttribute extends Attribute {\n+    CompiledAutomaton[] getAutomata();\n+    int getTermLength();\n+    void init(Supplier<FuzzyAutomatonBuilder> builder);\n+  }\n+\n+  private static class AutomatonAttributeImpl extends AttributeImpl implements AutomatonAttribute {\n+\n+    private CompiledAutomaton[] automata;\n+    private int termLength;\n+\n+    @Override\n+    public CompiledAutomaton[] getAutomata() {\n+      return automata;\n+    }\n+\n+    @Override\n+    public int getTermLength() {\n+      return termLength;\n+    }\n+\n+    @Override\n+    public void init(Supplier<FuzzyAutomatonBuilder> supplier) {\n+      if (automata != null) {\n+        return;\n+      }\n+      FuzzyAutomatonBuilder builder = supplier.get();\n+      this.termLength = builder.getTermLength();\n+      this.automata = builder.buildAutomatonSet();\n+    }\n+\n+    @Override\n+    public void clear() {\n+      this.automata = null;\n+    }\n+\n+    @Override\n+    public void reflectWith(AttributeReflector reflector) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMDcxMA==", "bodyText": "It's a private implementation and only gets used internally to FuzzyTermsEnum, so I don't see how the analysis page or luke would get presented with one of these?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417400710", "createdAt": "2020-04-29T15:21:32Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -364,4 +325,60 @@ public BytesRef term() throws IOException {\n     }\n   }\n \n+  /**\n+   * Used for sharing automata between segments\n+   *\n+   * Levenshtein automata are large and expensive to build; we don't want to build\n+   * them directly on the query because this can blow up caches that use queries\n+   * as keys; we also don't want to rebuild them for every segment.  This attribute\n+   * allows the FuzzyTermsEnum to build the automata once for its first segment\n+   * and then share them for subsequent segment calls.\n+   */\n+  private interface AutomatonAttribute extends Attribute {\n+    CompiledAutomaton[] getAutomata();\n+    int getTermLength();\n+    void init(Supplier<FuzzyAutomatonBuilder> builder);\n+  }\n+\n+  private static class AutomatonAttributeImpl extends AttributeImpl implements AutomatonAttribute {\n+\n+    private CompiledAutomaton[] automata;\n+    private int termLength;\n+\n+    @Override\n+    public CompiledAutomaton[] getAutomata() {\n+      return automata;\n+    }\n+\n+    @Override\n+    public int getTermLength() {\n+      return termLength;\n+    }\n+\n+    @Override\n+    public void init(Supplier<FuzzyAutomatonBuilder> supplier) {\n+      if (automata != null) {\n+        return;\n+      }\n+      FuzzyAutomatonBuilder builder = supplier.get();\n+      this.termLength = builder.getTermLength();\n+      this.automata = builder.buildAutomatonSet();\n+    }\n+\n+    @Override\n+    public void clear() {\n+      this.automata = null;\n+    }\n+\n+    @Override\n+    public void reflectWith(AttributeReflector reflector) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM5NzQ4OA=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzMzMDI4OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxNTo1NFrOGOGiOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo1MjozM1rOGOT23Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0MDMxMg==", "bodyText": "nitpick: compare the term first, as it is most likely to return false for different fuzzy", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417440312", "createdAt": "2020-04-29T16:15:54Z", "author": {"login": "dsmiley"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -237,22 +216,9 @@ public boolean equals(Object obj) {\n     if (getClass() != obj.getClass())\n       return false;\n     FuzzyQuery other = (FuzzyQuery) obj;\n-    // Note that we don't need to compare termLength or automata because they\n-    // are entirely determined by the other fields\n-    if (maxEdits != other.maxEdits)\n-      return false;\n-    if (prefixLength != other.prefixLength)\n-      return false;\n-    if (maxExpansions != other.maxExpansions)\n-      return false;\n-    if (transpositions != other.transpositions)\n-      return false;\n-    if (term == null) {\n-      if (other.term != null)\n-        return false;\n-    } else if (!term.equals(other.term))\n-      return false;\n-    return true;\n+    return Objects.equals(maxEdits, other.maxEdits) && Objects.equals(prefixLength, other.prefixLength)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1ODU4OQ==", "bodyText": "Is there a school of thought that we want to compare most likely to differ objects first, competing with the school that advocates comparing primitive types first because they are faster?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417658589", "createdAt": "2020-04-29T22:52:33Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -237,22 +216,9 @@ public boolean equals(Object obj) {\n     if (getClass() != obj.getClass())\n       return false;\n     FuzzyQuery other = (FuzzyQuery) obj;\n-    // Note that we don't need to compare termLength or automata because they\n-    // are entirely determined by the other fields\n-    if (maxEdits != other.maxEdits)\n-      return false;\n-    if (prefixLength != other.prefixLength)\n-      return false;\n-    if (maxExpansions != other.maxExpansions)\n-      return false;\n-    if (transpositions != other.transpositions)\n-      return false;\n-    if (term == null) {\n-      if (other.term != null)\n-        return false;\n-    } else if (!term.equals(other.term))\n-      return false;\n-    return true;\n+    return Objects.equals(maxEdits, other.maxEdits) && Objects.equals(prefixLength, other.prefixLength)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0MDMxMg=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODcwNTU3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyAutomatonBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMzowMTo0OFrOGOUDkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzoyOTo0NlrOGOdG_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTg0MQ==", "bodyText": "I'm confused about the difference between when we would want the full automaton set and when we want the max edit automaton. When is one useful but not the other? Is this a simple optimization to skip building the relatively inexpensive (exponentially less expensive, even) fewer edit automata?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417661841", "createdAt": "2020-04-29T23:01:48Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyAutomatonBuilder.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.util.UnicodeUtil;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+import org.apache.lucene.util.automaton.LevenshteinAutomata;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+\n+/**\n+ * Builds a set of CompiledAutomaton for fuzzy matching on a given term,\n+ * with specified maximum edit distance, fixed prefix and whether or not\n+ * to allow transpositions.\n+ */\n+class FuzzyAutomatonBuilder {\n+\n+  private final String term;\n+  private final int maxEdits;\n+  private final LevenshteinAutomata levBuilder;\n+  private final String prefix;\n+  private final int termLength;\n+\n+  FuzzyAutomatonBuilder(String term, int maxEdits, int prefixLength, boolean transpositions) {\n+    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n+      throw new IllegalArgumentException(\"max edits must be 0..\" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE + \", inclusive; got: \" + maxEdits);\n+    }\n+    if (prefixLength < 0) {\n+      throw new IllegalArgumentException(\"prefixLength cannot be less than 0\");\n+    }\n+    this.term = term;\n+    this.maxEdits = maxEdits;\n+    int[] codePoints = stringToUTF32(term);\n+    this.termLength = codePoints.length;\n+    prefixLength = Math.min(prefixLength, codePoints.length);\n+    int[] suffix = new int[codePoints.length - prefixLength];\n+    System.arraycopy(codePoints, prefixLength, suffix, 0, suffix.length);\n+    this.levBuilder = new LevenshteinAutomata(suffix, Character.MAX_CODE_POINT, transpositions);\n+    this.prefix = UnicodeUtil.newString(codePoints, 0, prefixLength);\n+  }\n+\n+  CompiledAutomaton[] buildAutomatonSet() {\n+    CompiledAutomaton[] compiled = new CompiledAutomaton[maxEdits + 1];\n+    for (int i = 0; i <= maxEdits; i++) {\n+      try {\n+        compiled[i] = new CompiledAutomaton(levBuilder.toAutomaton(i, prefix), true, false);\n+      }\n+      catch (TooComplexToDeterminizeException e) {\n+        throw new FuzzyTermsEnum.FuzzyTermsException(term, e);\n+      }\n+    }\n+    return compiled;\n+  }\n+\n+  CompiledAutomaton buildMaxEditAutomaton() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxMDE3Mw==", "bodyText": "Just the max is useful for highlighting or for other fuzzy searches that don't do the TopTerms pruning (we use it for a fuzzy interval query in elasticsearch, for example)", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417810173", "createdAt": "2020-04-30T07:29:46Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyAutomatonBuilder.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.util.UnicodeUtil;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+import org.apache.lucene.util.automaton.LevenshteinAutomata;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+\n+/**\n+ * Builds a set of CompiledAutomaton for fuzzy matching on a given term,\n+ * with specified maximum edit distance, fixed prefix and whether or not\n+ * to allow transpositions.\n+ */\n+class FuzzyAutomatonBuilder {\n+\n+  private final String term;\n+  private final int maxEdits;\n+  private final LevenshteinAutomata levBuilder;\n+  private final String prefix;\n+  private final int termLength;\n+\n+  FuzzyAutomatonBuilder(String term, int maxEdits, int prefixLength, boolean transpositions) {\n+    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n+      throw new IllegalArgumentException(\"max edits must be 0..\" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE + \", inclusive; got: \" + maxEdits);\n+    }\n+    if (prefixLength < 0) {\n+      throw new IllegalArgumentException(\"prefixLength cannot be less than 0\");\n+    }\n+    this.term = term;\n+    this.maxEdits = maxEdits;\n+    int[] codePoints = stringToUTF32(term);\n+    this.termLength = codePoints.length;\n+    prefixLength = Math.min(prefixLength, codePoints.length);\n+    int[] suffix = new int[codePoints.length - prefixLength];\n+    System.arraycopy(codePoints, prefixLength, suffix, 0, suffix.length);\n+    this.levBuilder = new LevenshteinAutomata(suffix, Character.MAX_CODE_POINT, transpositions);\n+    this.prefix = UnicodeUtil.newString(codePoints, 0, prefixLength);\n+  }\n+\n+  CompiledAutomaton[] buildAutomatonSet() {\n+    CompiledAutomaton[] compiled = new CompiledAutomaton[maxEdits + 1];\n+    for (int i = 0; i <= maxEdits; i++) {\n+      try {\n+        compiled[i] = new CompiledAutomaton(levBuilder.toAutomaton(i, prefix), true, false);\n+      }\n+      catch (TooComplexToDeterminizeException e) {\n+        throw new FuzzyTermsEnum.FuzzyTermsException(term, e);\n+      }\n+    }\n+    return compiled;\n+  }\n+\n+  CompiledAutomaton buildMaxEditAutomaton() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTg0MQ=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTU1NzUwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo1MzowOVrOGOvoVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMToyOTo1M1rOGPigTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzYyMQ==", "bodyText": "Does this still build the automata each time?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418113621", "createdAt": "2020-04-30T15:53:09Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -183,7 +162,7 @@ public void visit(QueryVisitor visitor) {\n       if (maxEdits == 0 || prefixLength >= term.text().length()) {\n         visitor.consumeTerms(this, term);\n       } else {\n-        automata[automata.length - 1].visit(visitor, this, field);\n+        visitor.consumeTermsMatching(this, term.field(), () -> getAutomata().runAutomaton);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NzE1MA==", "bodyText": "Only if the visitor implementation actually needs it, we're passing a Supplier now.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418947150", "createdAt": "2020-05-02T11:29:53Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -183,7 +162,7 @@ public void visit(QueryVisitor visitor) {\n       if (maxEdits == 0 || prefixLength >= term.text().length()) {\n         visitor.consumeTerms(this, term);\n       } else {\n-        automata[automata.length - 1].visit(visitor, this, field);\n+        visitor.consumeTermsMatching(this, term.field(), () -> getAutomata().runAutomaton);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzYyMQ=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTYwMzc0OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjowNDoyN1rOGOwGZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTowMDo1NVrOGQkWAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw==", "bodyText": "The java doc on this suggest that we need to be using an AttributeFactory, but that might be overkill here?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418121317", "createdAt": "2020-04-30T16:04:27Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4MDE5Nw==", "bodyText": "I don't think we can use an AttributeFactory here because the attribute source has already been created.  This seems to work fine though - @thetaphi can probably tell me if I've done something wrong?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418480197", "createdAt": "2020-05-01T09:41:26Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4MjI4OA==", "bodyText": "Uh. You sure you tagged the right sentient here? xD", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418482288", "createdAt": "2020-05-01T09:48:54Z", "author": {"login": "thetaphi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY0MjcxMA==", "bodyText": "@uschindler", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418642710", "createdAt": "2020-05-01T17:21:00Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNTg1Nw==", "bodyText": "I think that's fine here. There is only one implementation that's all internally used.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r420025857", "createdAt": "2020-05-05T11:00:55Z", "author": {"login": "uschindler"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTYwNDUzOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjowNDo0MFrOGOwG6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTowNjowNVrOGQkfuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTQ0OA==", "bodyText": "why not getAttribute? If we're sharing this across segments, then I think we want to reuse the same one each time, right?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418121448", "createdAt": "2020-04-30T16:04:40Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());\n+    AutomatonAttribute aa = atts.addAttribute(AutomatonAttribute.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ3OTU2Ng==", "bodyText": "addAttribute will return the already existing attribute if it's there, but create one if it isn't.  getAttribute won't work here because it won't do the create part.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418479566", "createdAt": "2020-05-01T09:39:11Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());\n+    AutomatonAttribute aa = atts.addAttribute(AutomatonAttribute.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTQ0OA=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyODM0Nw==", "bodyText": "GetAttribute is also fine, because you added the impl a line before. If the attribute wouldn't be there, adding it won't work, because it's all private. So all: That's just a matter of preference. I'd check how we do this at other places.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r420028347", "createdAt": "2020-05-05T11:06:05Z", "author": {"login": "uschindler"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());\n+    AutomatonAttribute aa = atts.addAttribute(AutomatonAttribute.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTQ0OA=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTY0MTQ1OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMzo1N1rOGOwfBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwOTo0MzoyNFrOGPGCZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNzYyMA==", "bodyText": "do we need to update the java docs on multi term query to reflect that fuzzy query also uses the attribute source now as well?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418127620", "createdAt": "2020-04-30T16:13:57Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -193,7 +172,7 @@ protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOExc\n     if (maxEdits == 0 || prefixLength >= term.text().length()) {  // can only match if it's exact\n       return new SingleTermsEnum(terms.iterator(), term.bytes());\n     }\n-    return new FuzzyTermsEnum(terms, atts, getTerm(), termLength, maxEdits, automata);\n+    return new FuzzyTermsEnum(terms, atts, getTerm(), maxEdits, prefixLength, transpositions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4MDc0MA==", "bodyText": "Good idea, will update", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418480740", "createdAt": "2020-05-01T09:43:24Z", "author": {"login": "romseygeek"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -193,7 +172,7 @@ protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOExc\n     if (maxEdits == 0 || prefixLength >= term.text().length()) {  // can only match if it's exact\n       return new SingleTermsEnum(terms.iterator(), term.bytes());\n     }\n-    return new FuzzyTermsEnum(terms, atts, getTerm(), termLength, maxEdits, automata);\n+    return new FuzzyTermsEnum(terms, atts, getTerm(), maxEdits, prefixLength, transpositions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNzYyMA=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 804, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}