{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1ODUxNzA2", "number": 1548, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowMToyN1rOEBZQmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoxMzozNFrOECThVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODk3ODgxOnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowMToyN1rOGdNxSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxODowMDo0MFrOGdUdxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4NzQ5Ng==", "bodyText": "I found this section a little bit hard to read, would prefer something more verbose but potentially easier to understand at a glance.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433287496", "createdAt": "2020-06-01T15:01:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NzE5MQ==", "bodyText": "Extracted two methods and simplified flow.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433397191", "createdAt": "2020-06-01T18:00:40Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4NzQ5Ng=="}, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTAwMTk0OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowNzo0OVrOGdOAFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowNzo0OVrOGdOAFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTI4Ng==", "bodyText": "I think one way to make this cleaner is to extract getStatusResponse().getResponse.get(\"MOCK_FINISHED\") out into a separate method.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433291286", "createdAt": "2020-06-01T15:07:49Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTAwODM1OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowOTozNFrOGdOD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1OToyOVrOGdUbOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjI3Mg==", "bodyText": "Do we really care about checking for a3 here? Why not check once after the loop?", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292272", "createdAt": "2020-06-01T15:09:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;\n       for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n+        if (acoll3 == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjUzNw==", "bodyText": "moved", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396537", "createdAt": "2020-06-01T17:59:29Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;\n       for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n+        if (acoll3 == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjI3Mg=="}, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTAxMjI4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToxMDozNFrOGdOGSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1OTo0OVrOGdUb9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5Mjg3NA==", "bodyText": "Assuming the queue works as advertised, can we skip checking a0 and only check a1?", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292874", "createdAt": "2020-06-01T15:10:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjcyNA==", "bodyText": "Removed check for task 0, left only task 1", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396724", "createdAt": "2020-06-01T17:59:49Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5Mjg3NA=="}, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTAxNDgxOnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToxMToxMVrOGdOHyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxODowMDowMFrOGdUcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MzI1Ng==", "bodyText": "Inconsistent naming: acoll0, acoll1, then acoll3.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433293256", "createdAt": "2020-06-01T15:11:11Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjgzMw==", "bodyText": "Thanks. Fixed.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396833", "createdAt": "2020-06-01T18:00:00Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MzI1Ng=="}, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODUyNDM4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoxMzozNFrOGert1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoxMzozNFrOGert1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyNjcwOA==", "bodyText": "nit: javadoc complains about this not being a visible reference", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r434826708", "createdAt": "2020-06-03T20:13:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -77,42 +76,68 @@ private void testFillWorkQueue() throws Exception {\n         distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n             \"collection\", \"A_COLL\",\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n-            ASYNC, String.valueOf(i),\n+            ASYNC, Integer.toString(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n-\n       }\n-      Thread.sleep(100);//wait and post the next message\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Wait until we see the second A_COLL task getting processed (assuming the first got processed as well)\n+      Long task1CollA = waitForTaskToCompleted(client, 1);\n+\n+      assertNotNull(\"Queue did not process first two tasks on A_COLL, can't run test\", task1CollA);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", checkTaskHasCompleted(client, 2));\n+\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long taskCollB = waitForTaskToCompleted(client, 200);\n \n-      Long acoll = null, bcoll = null;\n-      for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll != null && bcoll != null) break;\n-        Thread.sleep(100);\n+      // We do not wait for the long running task to finish, that would be a waste of time.\n+      Long task2CollA = checkTaskHasCompleted(client, 2);\n+\n+      // Given the wait delay (500 iterations of 100ms), the task has plenty of time to complete, so this is not expected.\n+      assertNotNull(\"Task on  B_COLL did not complete, can't test\", taskCollB);\n+      // We didn't wait for the 3rd A_COLL task to complete (test can run quickly) but if it did, we expect the B_COLL to have finished first.\n+      assertTrue(\"task2CollA: \" + task2CollA + \" taskCollB: \" + taskCollB, task2CollA  == null || task2CollA > taskCollB);\n+    }\n+  }\n+\n+  /**\n+   * Verifies the status of an async task submitted to the Overseer Collection queue.\n+   * @return <code>null</code> if the task has not completed, the completion timestamp if the task has completed\n+   * (see {@link org.apache.solr.cloud.api.collections.OverseerCollectionMessageHandler#mockOperation}).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481408a6b07d3dc9e469e329c7341d85a6b3a120"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1438, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}