{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Njc2OTc1", "number": 1725, "title": "LUCENE-9449 Skip docs with _doc sort and \"after\"", "bodyText": "Enhance DocComparator to provide an iterator over competitive documents\nwhen searching with \"after\" FieldDoc.\nThis iterator can quickly position on the desired \"after\" document,\nand skip all documents before \"after\" or even whole segments\nthat contain only documents before \"after\".\nRelated to LUCENE-9280", "createdAt": "2020-08-07T15:49:24Z", "url": "https://github.com/apache/lucene-solr/pull/1725", "merged": true, "mergeCommit": {"oid": "99220677fe409bab5c4206dc31f186d0c4335280"}, "closed": true, "closedAt": "2020-09-08T18:16:27Z", "author": {"login": "mayya-sharipova"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8mWU3gH2gAyNDY0Njc2OTc1OjNmYmM0NGExNjQyYmMyZDYxZjMyZjgyYTljM2Y1OGYxNTNhYTI0YTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdG7bAugH2gAyNDY0Njc2OTc1OmU2OWZhMjdlZmI1OGRiNDYyYzhiYWVlMjEzYmVmNGI0ZjNkOTI1ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8", "committedDate": "2020-08-07T15:42:19Z", "message": "LUCENE-9449 Skip docs with _doc sort and \"after\"\n\nEnhance DocComparator to provide an iterator over competitive documents\nwhen searching with \"after\" FieldDoc.\nThis iterator can quickly position on the desired \"after\" document,\nand skip all documents before \"after\" or even whole segments\nthat contain only documents before \"after\".\n\nRelated to LUCENE-9280"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzEzNDQ0", "url": "https://github.com/apache/lucene-solr/pull/1725#pullrequestreview-465313444", "createdAt": "2020-08-11T18:15:31Z", "commit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoxNTozMVrOG_DpFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoyMDoxN1rOG_DzZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzE0Mg==", "bodyText": "Can we force the in to be a FieldComparator.DocComparator ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468773142", "createdAt": "2020-08-11T18:15:31Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FilteringDocLeafComparator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This comparator is used when there is sort by _doc asc together with \"after\" FieldDoc.\n+ * The comparator provides an iterator that can quickly skip to the desired \"after\" document.\n+ */\n+public class FilteringDocLeafComparator implements FilteringLeafFieldComparator {\n+    private final FieldComparator.DocComparator in;\n+    private DocIdSetIterator topValueIterator; // iterator that starts from topValue if possible\n+    private final int minDoc;\n+    private final int maxDoc;\n+    private final int docBase;\n+    private boolean iteratorUpdated = false;\n+\n+    public FilteringDocLeafComparator(LeafFieldComparator in, LeafReaderContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzkyMg==", "bodyText": "Do we really need to add the hasAfter ? Can we check the if the topValue in the DocComparator is greater than 0 instead ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468773922", "createdAt": "2020-08-11T18:17:01Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -68,10 +68,12 @@ public int compareValues(T first, T second) {\n    * @param comparator \u2013 comparator to wrap\n    * @param reverse \u2013 if this sort is reverse\n    * @param singleSort \u2013 true if this sort is based on a single field and there are no other sort fields for tie breaking\n+   * @param hasAfter \u2013 true if this sort has after FieldDoc\n    * @return comparator wrapped as a filtering comparator or the original comparator if the filtering functionality\n    * is not implemented for it\n    */\n-  public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse, boolean singleSort) {\n+  public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse, boolean singleSort,\n+      boolean hasAfter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NDM4MQ==", "bodyText": "Can we avoid adding hasAfter here ? See my comment below.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468774381", "createdAt": "2020-08-11T18:17:50Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java", "diffHunk": "@@ -160,18 +160,20 @@ private FieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompet\n    *          The number of hits to retain. Must be greater than zero.\n    * @param filterNonCompetitiveDocs\n    *    {@code true} If comparators should be allowed to filter non-competitive documents, {@code false} otherwise\n+   * @param hasAfter\n+   *    {@code true} If this sort has \"after\" FieldDoc\n    */\n   public static <T extends FieldValueHitQueue.Entry> FieldValueHitQueue<T> create(SortField[] fields, int size,\n-      boolean filterNonCompetitiveDocs) {\n+      boolean filterNonCompetitiveDocs, boolean hasAfter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NDU5Ng==", "bodyText": "Not sure that hasAfter is really needed here.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468774596", "createdAt": "2020-08-11T18:18:16Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java", "diffHunk": "@@ -121,7 +121,7 @@ protected boolean lessThan(final Entry hitA, final Entry hitB) {\n   }\n   \n   // prevent instantiation and extension.\n-  private FieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompetitiveDocs) {\n+  private FieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompetitiveDocs, boolean hasAfter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NDczOQ==", "bodyText": "Not sure that hasAfter is really needed here.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468774739", "createdAt": "2020-08-11T18:18:31Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java", "diffHunk": "@@ -95,8 +95,8 @@ protected boolean lessThan(final Entry hitA, final Entry hitB) {\n    */\n   private static final class MultiComparatorsFieldValueHitQueue<T extends FieldValueHitQueue.Entry> extends FieldValueHitQueue<T> {\n \n-    public MultiComparatorsFieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompetitiveDocs) {\n-      super(fields, size, filterNonCompetitiveDocs);\n+    public MultiComparatorsFieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompetitiveDocs, boolean hasAfter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3NTc4MQ==", "bodyText": "Maybe rename to AfterDocLeafComparator ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r468775781", "createdAt": "2020-08-11T18:20:17Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FilteringDocLeafComparator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This comparator is used when there is sort by _doc asc together with \"after\" FieldDoc.\n+ * The comparator provides an iterator that can quickly skip to the desired \"after\" document.\n+ */\n+public class FilteringDocLeafComparator implements FilteringLeafFieldComparator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fbc44a1642bc2d61f32f82a9c3f58f153aa24a8"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fcddf791993bce00984f4bd7d6d2fd57184d59f", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/5fcddf791993bce00984f4bd7d6d2fd57184d59f", "committedDate": "2020-08-12T21:35:25Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/fabfca569b34b28d0a7a7c452e38139c8d67ef00", "committedDate": "2020-08-20T19:26:14Z", "message": "Implement filtering functionality in DocComparator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86163306d275f546a1d1f11e748a4c6db535dd57", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/86163306d275f546a1d1f11e748a4c6db535dd57", "committedDate": "2020-08-20T19:04:56Z", "message": "Implement filtering functionality in DocComparator"}, "afterCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/fabfca569b34b28d0a7a7c452e38139c8d67ef00", "committedDate": "2020-08-20T19:26:14Z", "message": "Implement filtering functionality in DocComparator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTMzNjY3", "url": "https://github.com/apache/lucene-solr/pull/1725#pullrequestreview-471933667", "createdAt": "2020-08-20T19:44:50Z", "commit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0NDo1MFrOHEQ1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDoyOToyMFrOHESL_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzMjA2NQ==", "bodyText": "I don't understand why this function is needed ? Can't you just pass the information when the DocComparator is created in the SortField ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474232065", "createdAt": "2020-08-20T19:44:50Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FieldComparator.java", "diffHunk": "@@ -136,6 +136,13 @@ public int compareValues(T first, T second) {\n     }\n   }\n \n+  /**\n+   * Informs the comparator that sorting is done in reverse.\n+   * This is necessary only for skipping functionality.\n+   */\n+  public void setReverse() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzOTM0Ng==", "bodyText": "Is  it really needed ? Maybe we should set GREATER_THAN_OR_EQUAL_TO every time a TOP_SCORES collection reaches  the total hits threshold ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474239346", "createdAt": "2020-08-20T19:59:13Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FilteringLeafFieldComparator.java", "diffHunk": "@@ -32,8 +33,22 @@\n   DocIdSetIterator competitiveIterator() throws IOException;\n \n   /**\n-   * Informs this leaf comparator that it is allowed to start updating its competitive iterator.\n-   * This method is called from a collector when queue becomes full and threshold is reached.\n+   * Informs this leaf comparator that hits threshold is reached.\n+   * This method is called from a collector when hits threshold is reached.\n+   * For some filtering comparators (e.g. {@code FilteringDocLeafComparator} reaching\n+   * hits threshold is enough to start updating their iterators, even when queue is not yet full.\n    */\n-  void setCanUpdateIterator() throws IOException;\n+  void setHitsThresholdReached() throws IOException;\n+\n+  /**\n+   * Informs this leaf comparator that queue has become full.\n+   * This method is called from a collector when queue becomes full.\n+   */\n+  void setQueueFull() throws IOException;\n+\n+  /**\n+   * Returns {@code true} if the competitive iterator is updated.\n+   * This tells the calling collector that it can update the {@code TotalHits.Relation} to {GREATER_THAN_OR_EQUAL_TO}\n+   */\n+  boolean iteratorUpdated() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MTE5MQ==", "bodyText": "We should be able to early terminate here if the total hits threshold has been reached. If it's not reached yet, we can early terminate later in setHitsThresholdReached.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474241191", "createdAt": "2020-08-20T20:02:50Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/comparators/DocComparator.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search.comparators;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.FilteringLeafFieldComparator;\n+import org.apache.lucene.search.LeafFieldComparator;\n+import org.apache.lucene.search.Scorable;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Comparator that sorts by asc _doc\n+ */\n+public class DocComparator extends FieldComparator<Integer> {\n+    private final int[] docIDs;\n+    private int topValue;\n+    private boolean topValueSet;\n+    private boolean reverse = false; // only used to check if skipping functionality should be enabled\n+\n+    /** Creates a new comparator based on document ids for {@code numHits} */\n+    public DocComparator(int numHits) {\n+        docIDs = new int[numHits];\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        // No overflow risk because docIDs are non-negative\n+        return docIDs[slot1] - docIDs[slot2];\n+    }\n+\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) {\n+        // TODO: can we \"map\" our docIDs to the current\n+        // reader? saves having to then subtract on every\n+        // compare call\n+        return new DocLeafComparator(context);\n+    }\n+\n+    @Override\n+    public void setTopValue(Integer value) {\n+        topValue = value;\n+        topValueSet = true;\n+    }\n+\n+    @Override\n+    public Integer value(int slot) {\n+        return Integer.valueOf(docIDs[slot]);\n+    }\n+\n+    @Override\n+    public void setReverse() {\n+        reverse = true;\n+    }\n+\n+\n+    /**\n+     * DocLeafComparator with skipping functionality.\n+     * When sort by _doc asc and \"after\" document is set,\n+     * the comparator provides an iterator that can quickly skip to the desired \"after\" document.\n+     */\n+    private class DocLeafComparator implements FilteringLeafFieldComparator {\n+        private final int docBase;\n+        private int bottom;\n+\n+        private final boolean enableSkipping;\n+        private final int minDoc;\n+        private final int maxDoc;\n+        private DocIdSetIterator topValueIterator; // iterator that starts from topValue\n+\n+        private boolean iteratorUpdated = false;\n+\n+        public DocLeafComparator(LeafReaderContext context) {\n+            this.docBase = context.docBase;\n+            // skipping functionality is enabled if topValue is set and sort is asc\n+            this.enableSkipping = topValueSet && reverse == false ? true: false;\n+            if (enableSkipping) {\n+                this.minDoc = topValue + 1;\n+                this.maxDoc = context.reader().maxDoc();\n+                this.topValueIterator = DocIdSetIterator.all(maxDoc);\n+            } else {\n+                this.minDoc = -1;\n+                this.maxDoc = -1;\n+                this.topValueIterator = null;\n+            }\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) {\n+            bottom = docIDs[slot];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0NDE5OA==", "bodyText": "Any query sorted by doc id can early terminate after N matches. That's an important aspect of the optimization since it can be handled by the hits threshold transparently. If there is no after value, the threshold should be an upper bound of the number of document that we will collect in the comparator.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474244198", "createdAt": "2020-08-20T20:09:06Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/comparators/DocComparator.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search.comparators;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.FilteringLeafFieldComparator;\n+import org.apache.lucene.search.LeafFieldComparator;\n+import org.apache.lucene.search.Scorable;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Comparator that sorts by asc _doc\n+ */\n+public class DocComparator extends FieldComparator<Integer> {\n+    private final int[] docIDs;\n+    private int topValue;\n+    private boolean topValueSet;\n+    private boolean reverse = false; // only used to check if skipping functionality should be enabled\n+\n+    /** Creates a new comparator based on document ids for {@code numHits} */\n+    public DocComparator(int numHits) {\n+        docIDs = new int[numHits];\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        // No overflow risk because docIDs are non-negative\n+        return docIDs[slot1] - docIDs[slot2];\n+    }\n+\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) {\n+        // TODO: can we \"map\" our docIDs to the current\n+        // reader? saves having to then subtract on every\n+        // compare call\n+        return new DocLeafComparator(context);\n+    }\n+\n+    @Override\n+    public void setTopValue(Integer value) {\n+        topValue = value;\n+        topValueSet = true;\n+    }\n+\n+    @Override\n+    public Integer value(int slot) {\n+        return Integer.valueOf(docIDs[slot]);\n+    }\n+\n+    @Override\n+    public void setReverse() {\n+        reverse = true;\n+    }\n+\n+\n+    /**\n+     * DocLeafComparator with skipping functionality.\n+     * When sort by _doc asc and \"after\" document is set,\n+     * the comparator provides an iterator that can quickly skip to the desired \"after\" document.\n+     */\n+    private class DocLeafComparator implements FilteringLeafFieldComparator {\n+        private final int docBase;\n+        private int bottom;\n+\n+        private final boolean enableSkipping;\n+        private final int minDoc;\n+        private final int maxDoc;\n+        private DocIdSetIterator topValueIterator; // iterator that starts from topValue\n+\n+        private boolean iteratorUpdated = false;\n+\n+        public DocLeafComparator(LeafReaderContext context) {\n+            this.docBase = context.docBase;\n+            // skipping functionality is enabled if topValue is set and sort is asc\n+            this.enableSkipping = topValueSet && reverse == false ? true: false;\n+            if (enableSkipping) {\n+                this.minDoc = topValue + 1;\n+                this.maxDoc = context.reader().maxDoc();\n+                this.topValueIterator = DocIdSetIterator.all(maxDoc);\n+            } else {\n+                this.minDoc = -1;\n+                this.maxDoc = -1;\n+                this.topValueIterator = null;\n+            }\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) {\n+            bottom = docIDs[slot];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MTE5MQ=="}, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI1MzEwNQ==", "bodyText": "That seems redundant. I think we can add a single method: setHitsThresholdReached(int). We have all the other contexts needed in the LeafFieldComparator. The complexity is that setBottom and setHitsThresholdReached(int) are called on the leaves even though they are global events. Maybe forcing the hierarchy of the filtering fields to use a SimpleFieldComparator could simplify things ? This way you don't have to repeat redundant informations (hits threshold and queue full) on each leave.", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474253105", "createdAt": "2020-08-20T20:26:43Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/FilteringLeafFieldComparator.java", "diffHunk": "@@ -32,8 +33,22 @@\n   DocIdSetIterator competitiveIterator() throws IOException;\n \n   /**\n-   * Informs this leaf comparator that it is allowed to start updating its competitive iterator.\n-   * This method is called from a collector when queue becomes full and threshold is reached.\n+   * Informs this leaf comparator that hits threshold is reached.\n+   * This method is called from a collector when hits threshold is reached.\n+   * For some filtering comparators (e.g. {@code FilteringDocLeafComparator} reaching\n+   * hits threshold is enough to start updating their iterators, even when queue is not yet full.\n    */\n-  void setCanUpdateIterator() throws IOException;\n+  void setHitsThresholdReached() throws IOException;\n+\n+  /**\n+   * Informs this leaf comparator that queue has become full.\n+   * This method is called from a collector when queue becomes full.\n+   */\n+  void setQueueFull() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI1NDMzMw==", "bodyText": "See my previous comment, I think we should call setHitsThresholdReached once, when the threshold is reached.\nSame for setQueueFull that is already call in setBottom. Said differently, this part could be entirely removed ;).", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r474254333", "createdAt": "2020-08-20T20:29:20Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -150,11 +150,15 @@ public void setScorer(Scorable scorer) throws IOException {\n       if (minScoreAcc != null) {\n         updateGlobalMinCompetitiveScore(scorer);\n       }\n-      if (filteringLeafComparator != null && queueFull && hitsThresholdChecker.isThresholdReached()) {\n-        // if queue became full and hitsThreshold was reached in previous segments,\n-        // notify this segment's leaf comparator that its competitive iterator can be updated\n-        filteringLeafComparator.setCanUpdateIterator();\n-        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n+\n+      if (filteringLeafComparator != null && hitsThresholdChecker.isThresholdReached()) {\n+        // hitsThreshold was reached in previous segments, notify this segment's leaf comparator about it\n+        filteringLeafComparator.setHitsThresholdReached();\n+        // if queue became full in previous segments, notify this segment's leaf comparator about it\n+        if (queueFull) filteringLeafComparator.setQueueFull();\n+        if (filteringLeafComparator.iteratorUpdated()) {\n+          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fabfca569b34b28d0a7a7c452e38139c8d67ef00"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "746c8fac88011c61b5e1ed083229724a45993a49", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/746c8fac88011c61b5e1ed083229724a45993a49", "committedDate": "2020-08-26T15:47:46Z", "message": "Address feedback 2\n\n- Redesign numeric comparators so by default they provide skipping\nfunctionality. This resuled in moving comparators to a separate\npackage.\n\n- Remove unnecessary filtering comparator classes, as by default\ncomparators provide skipping functionality\n\n- Remove unncessary checks in TopFieldCollector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21de24296019674f655e1754687a9eed27f0c4c6", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/21de24296019674f655e1754687a9eed27f0c4c6", "committedDate": "2020-08-31T20:27:24Z", "message": "DocComparator return empty iterator after topN hits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26534c5f4ecc5feae42f7fa1f5946b2ecfa03ca5", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/26534c5f4ecc5feae42f7fa1f5946b2ecfa03ca5", "committedDate": "2020-08-31T20:34:33Z", "message": "Merge remote-tracking branch 'upstream/master' into sort-by-doc-optim"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4252fcd88f3b93c1e0b66a8a130e9278115d660e", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/4252fcd88f3b93c1e0b66a8a130e9278115d660e", "committedDate": "2020-08-31T20:58:03Z", "message": "Add package info"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDUzMzE0", "url": "https://github.com/apache/lucene-solr/pull/1725#pullrequestreview-480053314", "createdAt": "2020-09-01T19:30:00Z", "commit": {"oid": "4252fcd88f3b93c1e0b66a8a130e9278115d660e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOTozMDowMFrOHLFNFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOTozMTo0MVrOHLFQgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM4MTY1NA==", "bodyText": "Should it be activated only if the comparator is used as the primary sort ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r481381654", "createdAt": "2020-09-01T19:30:00Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/comparators/DocComparator.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search.comparators;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.LeafFieldComparator;\n+import org.apache.lucene.search.Scorable;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Comparator that sorts by asc _doc\n+ */\n+public class DocComparator extends FieldComparator<Integer> {\n+    private final int[] docIDs;\n+    private final boolean enableSkipping; // if skipping functionality should be enabled\n+    private int bottom;\n+    private int topValue;\n+    private boolean topValueSet;\n+    private boolean bottomValueSet;\n+    private boolean hitsThresholdReached;\n+\n+    /** Creates a new comparator based on document ids for {@code numHits} */\n+    public DocComparator(int numHits, boolean reverse) {\n+        this.docIDs = new int[numHits];\n+        // skipping functionality is enabled if we are sorting by _doc in asc order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4252fcd88f3b93c1e0b66a8a130e9278115d660e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM4MjUzMA==", "bodyText": "Can you add a comment explaining that early termination is already implemented in the collector but we'll remove in a follow up ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r481382530", "createdAt": "2020-09-01T19:31:41Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/search/comparators/DocComparator.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search.comparators;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.LeafFieldComparator;\n+import org.apache.lucene.search.Scorable;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Comparator that sorts by asc _doc\n+ */\n+public class DocComparator extends FieldComparator<Integer> {\n+    private final int[] docIDs;\n+    private final boolean enableSkipping; // if skipping functionality should be enabled\n+    private int bottom;\n+    private int topValue;\n+    private boolean topValueSet;\n+    private boolean bottomValueSet;\n+    private boolean hitsThresholdReached;\n+\n+    /** Creates a new comparator based on document ids for {@code numHits} */\n+    public DocComparator(int numHits, boolean reverse) {\n+        this.docIDs = new int[numHits];\n+        // skipping functionality is enabled if we are sorting by _doc in asc order\n+        this.enableSkipping = (reverse == false);\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        // No overflow risk because docIDs are non-negative\n+        return docIDs[slot1] - docIDs[slot2];\n+    }\n+\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) {\n+        // TODO: can we \"map\" our docIDs to the current\n+        // reader? saves having to then subtract on every\n+        // compare call\n+        return new DocLeafComparator(context);\n+    }\n+\n+    @Override\n+    public void setTopValue(Integer value) {\n+        topValue = value;\n+        topValueSet = true;\n+    }\n+\n+    @Override\n+    public Integer value(int slot) {\n+        return Integer.valueOf(docIDs[slot]);\n+    }\n+\n+\n+    /**\n+     * DocLeafComparator with skipping functionality.\n+     * When sort by _doc asc, after collecting top N matches and enough hits, the comparator\n+     * can skip all the following documents.\n+     * When sort by _doc asc and \"top\" document is set after which search should start,\n+     * the comparator provides an iterator that can quickly skip to the desired \"top\" document.\n+     */\n+    private class DocLeafComparator implements LeafFieldComparator {\n+        private final int docBase;\n+        private final int minDoc;\n+        private final int maxDoc;\n+        private DocIdSetIterator competitiveIterator; // iterator that starts from topValue\n+\n+        public DocLeafComparator(LeafReaderContext context) {\n+            this.docBase = context.docBase;\n+            if (enableSkipping) {\n+                this.minDoc = topValue + 1;\n+                this.maxDoc = context.reader().maxDoc();\n+                this.competitiveIterator = DocIdSetIterator.all(maxDoc);\n+            } else {\n+                this.minDoc = -1;\n+                this.maxDoc = -1;\n+                this.competitiveIterator = null;\n+            }\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) {\n+            bottom = docIDs[slot];\n+            bottomValueSet = true;\n+            updateIterator();\n+        }\n+\n+        @Override\n+        public int compareBottom(int doc) {\n+            // No overflow risk because docIDs are non-negative\n+            return bottom - (docBase + doc);\n+        }\n+\n+        @Override\n+        public int compareTop(int doc) {\n+            int docValue = docBase + doc;\n+            return Integer.compare(topValue, docValue);\n+        }\n+\n+        @Override\n+        public void copy(int slot, int doc) throws IOException {\n+            docIDs[slot] = docBase + doc;\n+        }\n+\n+        @Override\n+        public void setScorer(Scorable scorer) throws IOException {\n+            // update an iterator on a new segment\n+            updateIterator();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator competitiveIterator() {\n+            if (enableSkipping == false) {\n+                return null;\n+            } else {\n+                return new DocIdSetIterator() {\n+                    private int doc;\n+\n+                    @Override\n+                    public int nextDoc() throws IOException {\n+                        return doc = competitiveIterator.nextDoc();\n+                    }\n+\n+                    @Override\n+                    public int docID() {\n+                        return doc;\n+                    }\n+\n+                    @Override\n+                    public long cost() {\n+                        return competitiveIterator.cost();\n+                    }\n+\n+                    @Override\n+                    public int advance(int target) throws IOException {\n+                        return doc = competitiveIterator.advance(target);\n+                    }\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void setHitsThresholdReached() {\n+            hitsThresholdReached = true;\n+            updateIterator();\n+        }\n+\n+        private void updateIterator() {\n+            if (enableSkipping == false || hitsThresholdReached == false) return;\n+            if (bottomValueSet) {\n+                // since we've collected top N matches, we can early terminate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4252fcd88f3b93c1e0b66a8a130e9278115d660e"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "485fe4f532bada2926ad0d38a58496b1d5e93f23", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/485fe4f532bada2926ad0d38a58496b1d5e93f23", "committedDate": "2020-09-01T21:24:40Z", "message": "Enable skipping functionality only on primary sort\n\nAdd a note to remove early termination in collector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7c4e8592b0929464e5758f865c977a67d97ccd7", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/a7c4e8592b0929464e5758f865c977a67d97ccd7", "committedDate": "2020-09-02T13:32:10Z", "message": "Revert \"Enable skipping functionality only on primary sort\"\n\nThis reverts commit 485fe4f532bada2926ad0d38a58496b1d5e93f23."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92fa246c52ad5e25f7388e2ae0fadf173cc347da", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/92fa246c52ad5e25f7388e2ae0fadf173cc347da", "committedDate": "2020-09-02T14:34:33Z", "message": "Enable skipping functionality only on primary sort\n\nAdd a note to remove early termination in collector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c79ae6134b1c767781b1b860f3c7c2e0095c353", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/1c79ae6134b1c767781b1b860f3c7c2e0095c353", "committedDate": "2020-09-02T14:13:57Z", "message": "Enable skipping functionality only on primary sort\n\nAdd a note to remove early termination in collector"}, "afterCommit": {"oid": "92fa246c52ad5e25f7388e2ae0fadf173cc347da", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/92fa246c52ad5e25f7388e2ae0fadf173cc347da", "committedDate": "2020-09-02T14:34:33Z", "message": "Enable skipping functionality only on primary sort\n\nAdd a note to remove early termination in collector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/27ff5193874ad417a66b5bcfad8291f631a8ca24", "committedDate": "2020-09-02T17:49:35Z", "message": "Adding documentation to leaf comparators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTQxMDYy", "url": "https://github.com/apache/lucene-solr/pull/1725#pullrequestreview-482541062", "createdAt": "2020-09-04T10:28:35Z", "commit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyODozNVrOHNIcMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozMToxN1rOHNIhMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTgyNw==", "bodyText": "why do you need that many documents ? 100 should be enough, no ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r483531827", "createdAt": "2020-09-04T10:28:35Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestFieldSortOptimizationSkipping.java", "diffHunk": "@@ -290,5 +299,114 @@ public void testFloatSortOptimization() throws IOException {\n     dir.close();\n   }\n \n+  public void testDocSortOptimizationWithAfter() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);\n+    for (int i = 0; i < numDocs; ++i) {\n+      final Document doc = new Document();\n+      writer.addDocument(doc);\n+      if ((i > 0) && (i % 500 == 0)) {\n+        writer.commit();\n+      }\n+    }\n+    final IndexReader reader = DirectoryReader.open(writer);\n+    IndexSearcher searcher = new IndexSearcher(reader);\n+    final int numHits = 3;\n+    final int totalHitsThreshold = 3;\n+    final int searchAfter = 1400;\n+\n+    // sort by _doc with search after should trigger optimization\n+    {\n+      final Sort sort = new Sort(FIELD_DOC);\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Integer[]{searchAfter});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter + 1 + i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertTrue(collector.isEarlyTerminated());\n+      // check that very few hits were collected, and most hits before searchAfter were skipped\n+      assertTrue(topDocs.totalHits.value < (numDocs - searchAfter));\n+    }\n+\n+    // sort by _doc + _score with search after should trigger optimization\n+    {\n+      final Sort sort = new Sort(FIELD_DOC, FIELD_SCORE);\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Object[]{searchAfter, 1.0f});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter + 1 + i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertTrue(collector.isEarlyTerminated());\n+      // assert that very few hits were collected, and most hits before searchAfter were skipped\n+      assertTrue(topDocs.totalHits.value < (numDocs - searchAfter));\n+    }\n+\n+    // sort by _doc desc should not trigger optimization\n+    {\n+      final Sort sort = new Sort(new SortField(null, SortField.Type.DOC, true));\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Integer[]{searchAfter});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter - 1 - i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      // assert that many hits were collected including all hits before searchAfter\n+      assertTrue(topDocs.totalHits.value > searchAfter);\n+\n+    }\n+\n+    writer.close();\n+    reader.close();\n+    dir.close();\n+  }\n+\n+\n+  public void testDocSortOptimization() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjI2Mg==", "bodyText": "Can you add a test with a boolean query or a simple filter ?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r483532262", "createdAt": "2020-09-04T10:29:34Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestFieldSortOptimizationSkipping.java", "diffHunk": "@@ -290,5 +299,114 @@ public void testFloatSortOptimization() throws IOException {\n     dir.close();\n   }\n \n+  public void testDocSortOptimizationWithAfter() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);\n+    for (int i = 0; i < numDocs; ++i) {\n+      final Document doc = new Document();\n+      writer.addDocument(doc);\n+      if ((i > 0) && (i % 500 == 0)) {\n+        writer.commit();\n+      }\n+    }\n+    final IndexReader reader = DirectoryReader.open(writer);\n+    IndexSearcher searcher = new IndexSearcher(reader);\n+    final int numHits = 3;\n+    final int totalHitsThreshold = 3;\n+    final int searchAfter = 1400;\n+\n+    // sort by _doc with search after should trigger optimization\n+    {\n+      final Sort sort = new Sort(FIELD_DOC);\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Integer[]{searchAfter});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter + 1 + i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertTrue(collector.isEarlyTerminated());\n+      // check that very few hits were collected, and most hits before searchAfter were skipped\n+      assertTrue(topDocs.totalHits.value < (numDocs - searchAfter));\n+    }\n+\n+    // sort by _doc + _score with search after should trigger optimization\n+    {\n+      final Sort sort = new Sort(FIELD_DOC, FIELD_SCORE);\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Object[]{searchAfter, 1.0f});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter + 1 + i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertTrue(collector.isEarlyTerminated());\n+      // assert that very few hits were collected, and most hits before searchAfter were skipped\n+      assertTrue(topDocs.totalHits.value < (numDocs - searchAfter));\n+    }\n+\n+    // sort by _doc desc should not trigger optimization\n+    {\n+      final Sort sort = new Sort(new SortField(null, SortField.Type.DOC, true));\n+      FieldDoc after = new FieldDoc(searchAfter, Float.NaN, new Integer[]{searchAfter});\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      for (int i = 0; i < numHits; i++) {\n+        int expectedDocID = searchAfter - 1 - i;\n+        assertEquals(expectedDocID, topDocs.scoreDocs[i].doc);\n+      }\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      // assert that many hits were collected including all hits before searchAfter\n+      assertTrue(topDocs.totalHits.value > searchAfter);\n+\n+    }\n+\n+    writer.close();\n+    reader.close();\n+    dir.close();\n+  }\n+\n+\n+  public void testDocSortOptimization() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);\n+    for (int i = 0; i < numDocs; ++i) {\n+      final Document doc = new Document();\n+      writer.addDocument(doc);\n+      if ((i > 0) && (i % 500 == 0)) {\n+        writer.commit();\n+      }\n+    }\n+    final IndexReader reader = DirectoryReader.open(writer);\n+    IndexSearcher searcher = new IndexSearcher(reader);\n+    final int numHits = 3;\n+    final int totalHitsThreshold = 3;\n+\n+    // sort by _doc should skip all non-competitive documents\n+    {\n+      final Sort sort = new Sort(FIELD_DOC);\n+      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, null, totalHitsThreshold);\n+      searcher.search(new MatchAllDocsQuery(), collector);\n+      TopDocs topDocs = collector.topDocs();\n+      assertEquals(topDocs.scoreDocs.length, numHits);\n+      for (int i = 0; i < numHits; i++) {\n+        assertEquals(i, topDocs.scoreDocs[i].doc);\n+      }\n+      assertTrue(collector.isEarlyTerminated());\n+      // check that very few hits were collected\n+      assertTrue(topDocs.totalHits.value < 5);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjc2MA==", "bodyText": "1500 seems big for a unit test ;)", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r483532760", "createdAt": "2020-09-04T10:30:33Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestFieldSortOptimizationSkipping.java", "diffHunk": "@@ -290,5 +299,114 @@ public void testFloatSortOptimization() throws IOException {\n     dir.close();\n   }\n \n+  public void testDocSortOptimizationWithAfter() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzEwNQ==", "bodyText": "you can try different values of  search after in a loop to increase the coverage?", "url": "https://github.com/apache/lucene-solr/pull/1725#discussion_r483533105", "createdAt": "2020-09-04T10:31:17Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestFieldSortOptimizationSkipping.java", "diffHunk": "@@ -290,5 +299,114 @@ public void testFloatSortOptimization() throws IOException {\n     dir.close();\n   }\n \n+  public void testDocSortOptimizationWithAfter() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(1500);\n+    for (int i = 0; i < numDocs; ++i) {\n+      final Document doc = new Document();\n+      writer.addDocument(doc);\n+      if ((i > 0) && (i % 500 == 0)) {\n+        writer.commit();\n+      }\n+    }\n+    final IndexReader reader = DirectoryReader.open(writer);\n+    IndexSearcher searcher = new IndexSearcher(reader);\n+    final int numHits = 3;\n+    final int totalHitsThreshold = 3;\n+    final int searchAfter = 1400;\n+\n+    // sort by _doc with search after should trigger optimization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27ff5193874ad417a66b5bcfad8291f631a8ca24"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493d9eb174d30886a248eaa5c2f744f72e98f630", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/493d9eb174d30886a248eaa5c2f744f72e98f630", "committedDate": "2020-09-08T14:10:27Z", "message": "Address feedback for test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45577aa6e7e504c01fbdff38ee35ad9ef36c6380", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/45577aa6e7e504c01fbdff38ee35ad9ef36c6380", "committedDate": "2020-09-08T17:52:30Z", "message": "Merge remote-tracking branch 'upstream/master' into sort-by-doc-optim"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e69fa27efb58db462c8baee213bef4b4f3d92585", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/apache/lucene-solr/commit/e69fa27efb58db462c8baee213bef4b4f3d92585", "committedDate": "2020-09-08T17:54:41Z", "message": "Make a constructor of NumericComparator protected"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2330, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}