{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5OTY4MjA4", "number": 1151, "title": "SOLR-13890: Add \"top-level\" DVTQ implementation", "bodyText": "Description\nThe \"docValuesTermsFilter\" method for TermsQParserPlugin uses per-segment docvalue structures to find matches.  This works well when the number of query terms is small, but as it gets over a few hundred, this quickly becomes less efficient than using a \"top-level\" or global docvalues structure.\nSolution\nThis PR introduces a query that uses the top-level structure and takes advantage of the Two Phase Iterator (TPI) interface to handle queries with large numbers of terms much more efficiently than any of the existing methods.\nTests\nThis PR adds TestTermsQParserPlugin with some tests to cover the new code added here as well as the rest of the terms qparser (which was largely untested).  I also wrote a JUnit performance driver to exhibit perf gains, but that no longer appears in this PR.  See patches on the JIRA issue for that.\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ant precommit and the appropriate test suite.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-01-07T12:27:29Z", "url": "https://github.com/apache/lucene-solr/pull/1151", "merged": true, "mergeCommit": {"oid": "6e4756fd48076abcecc94446ce3defeb3f907cc1"}, "closed": true, "closedAt": "2020-01-13T11:43:21Z", "author": {"login": "gerlowskija"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb3yIkzgH2gAyMzU5OTY4MjA4OmFhYTY3NjVmZGQzMzc5NzNmMDdmOGQzNTc5MWEyYTM0MDhmMmIzZDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb5CqaggFqTM0MTMzNTc0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/aaa6765fdd337973f07f8d35791a2a3408f2b3d7", "committedDate": "2020-01-06T20:25:23Z", "message": "SOLR-13890: Add \"top-level\" DVTQ implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5MjI0OTg0", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-339224984", "createdAt": "2020-01-07T13:11:16Z", "commit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMzoxMToxNlrOFa47xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxMzo1OTowNFrOFa6Gpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc0MDEwMg==", "bodyText": "Is this just a minor improvement or is it necessary?  If just some minor improvement, I recommend you don't touch Lucene in a Solr PR.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363740102", "createdAt": "2020-01-07T13:11:16Z", "author": {"login": "dsmiley"}, "path": "lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java", "diffHunk": "@@ -64,7 +64,7 @@ public static TwoPhaseIterator unwrap(DocIdSetIterator iterator) {\n \n     TwoPhaseIteratorAsDocIdSetIterator(TwoPhaseIterator twoPhaseIterator) {\n       this.twoPhaseIterator = twoPhaseIterator;\n-      this.approximation = twoPhaseIterator.approximation;\n+      this.approximation = twoPhaseIterator.approximation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc0MDI2Nw==", "bodyText": "\"withvery\" -- add space.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363740267", "createdAt": "2020-01-07T13:11:44Z", "author": {"login": "dsmiley"}, "path": "solr/CHANGES.txt", "diffHunk": "@@ -187,6 +187,11 @@ Improvements\n   hl.fragsizeIsMinimum, with defaults that aim to better center matches in fragments than previously. See the ref guide.\n   Regardless of the settings, the passages may be sized differently than before. (N\u00e1ndor M\u00e1trav\u00f6lgyi, David Smiley)\n \n+* SOLR-13890: Add \"top-level\" DV implementation for {!terms} queries.  This approach tends to be more efficient for\n+  queries withvery large numbers of terms.  The new implementation is used by default for method=docValuesTermsFilter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc0NDcwMg==", "bodyText": "Instead of yet another local-param, maybe \"method\" could be docValuesTermsFilterTopLevel and docValuesTermsFilterTopLevel.  The existing docValuesTermsFilter could dispatch to either of those.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363744702", "createdAt": "2020-01-07T13:23:22Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -79,20 +88,34 @@ Query makeFilter(String fname, BytesRef[] byteRefs) {\n     },\n     automaton {\n       @Override\n-      Query makeFilter(String fname, BytesRef[] byteRefs) {\n+      Query makeFilter(String fname, BytesRef[] byteRefs, SolrParams localParams) {\n         ArrayUtil.timSort(byteRefs); // same sort algo as TermInSetQuery's choice\n         Automaton union = Automata.makeStringUnion(Arrays.asList(byteRefs)); // input must be sorted\n         return new AutomatonQuery(new Term(fname), union);//constant scores\n       }\n     },\n     docValuesTermsFilter {//on 4x this is FieldCacheTermsFilter but we use the 5x name any way\n       @Override\n-      Query makeFilter(String fname, BytesRef[] byteRefs) {\n-        return new DocValuesTermsQuery(fname, byteRefs);//constant scores\n+      Query makeFilter(String fname, BytesRef[] byteRefs, SolrParams localParams) {\n+        final String type = localParams.get(SUBMETHOD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc0NTAzNA==", "bodyText": "Instead the line above \"NoEx\" could be removed and then we get an exception", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363745034", "createdAt": "2020-01-07T13:24:08Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -102,6 +125,9 @@ public QParser createParser(String qstr, SolrParams localParams, SolrParams para\n       public Query parse() throws SyntaxError {\n         String fname = localParams.get(QueryParsing.F);\n         FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n+        if (ft == null) {\n+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name [\" + fname + \"] does not exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc0NTQ1MA==", "bodyText": "I don't think you need this class; it seems more confusing than it is useful", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363745450", "createdAt": "2020-01-07T13:25:19Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -138,8 +164,128 @@ public Query parse() throws SyntaxError {\n           bytesRefs[i] = term.toBytesRef();\n         }\n \n-        return method.makeFilter(fname, bytesRefs);\n+        return method.makeFilter(fname, bytesRefs, localParams);\n       }\n     };\n   }\n+\n+  private static abstract class TopLevelTwoPhaseIterator extends TwoPhaseIterator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1MDA3Nw==", "bodyText": "I wouldn't bother implementing ExtendedQuery.  If we want to tweak defaults, we should probably do so to affect all docValuesTermsQuery (both sub-methods) and that can be done by replacing QParser.localParams wrapped with one setting defaults we choose in our QParser.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363750077", "createdAt": "2020-01-07T13:37:33Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -138,8 +164,128 @@ public Query parse() throws SyntaxError {\n           bytesRefs[i] = term.toBytesRef();\n         }\n \n-        return method.makeFilter(fname, bytesRefs);\n+        return method.makeFilter(fname, bytesRefs, localParams);\n       }\n     };\n   }\n+\n+  private static abstract class TopLevelTwoPhaseIterator extends TwoPhaseIterator {\n+    private final int docBase;\n+    private final int nextDocBase;\n+    public TopLevelTwoPhaseIterator(DocIdSetIterator approximation, int docBase, int nextDocBase) {\n+      super(new PerSegmentViewDocIdSetIterator(approximation, docBase, nextDocBase));\n+\n+      this.docBase = docBase;\n+      this.nextDocBase = nextDocBase;\n+    }\n+  }\n+\n+  private static class TopLevelDocValuesTermsQuery extends DocValuesTermsQuery implements ExtendedQuery{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1MzE5NA==", "bodyText": "Can you make this an inner class of topLevelDocValuesTermsQuery or anonymous?  If there is a future need to share it then I think we should pull it out.  I doubt it's as generally useful to be a standalone public class.\nAfter further review, I don't think we need the functionality here at all... see my future feedback", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363753194", "createdAt": "2020-01-07T13:45:02Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/PerSegmentViewDocIdSetIterator.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.search;\n+\n+import java.io.IOException;\n+\n+import org.apache.lucene.search.DocIdSetIterator;\n+\n+/**\n+ * A {@link org.apache.lucene.search.DocIdSetIterator} which allows single-segment access to a wrapped top-level (multi-segment) DISI.\n+ *\n+ * Useful as a shim between a top-level data structure, and logic that attempts to operate on it using segment-level docIds.\n+ * The same wrapped DISI can be used serially by multiple PerSegmentViewDocIdSetIterators\n+ */\n+public class PerSegmentViewDocIdSetIterator extends DocIdSetIterator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1ODgyNw==", "bodyText": "I see that you are using the top level sortedSetDocValues as a DocIdSetIterator approximation.  I can see this works but I think we needn't get that complex, and we miss out on other optimizations by doing so.  I'll post PR comment on how to replace it in a way that also removes TopLevelTwoPhaseIterator.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363758827", "createdAt": "2020-01-07T13:58:08Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -138,8 +164,128 @@ public Query parse() throws SyntaxError {\n           bytesRefs[i] = term.toBytesRef();\n         }\n \n-        return method.makeFilter(fname, bytesRefs);\n+        return method.makeFilter(fname, bytesRefs, localParams);\n       }\n     };\n   }\n+\n+  private static abstract class TopLevelTwoPhaseIterator extends TwoPhaseIterator {\n+    private final int docBase;\n+    private final int nextDocBase;\n+    public TopLevelTwoPhaseIterator(DocIdSetIterator approximation, int docBase, int nextDocBase) {\n+      super(new PerSegmentViewDocIdSetIterator(approximation, docBase, nextDocBase));\n+\n+      this.docBase = docBase;\n+      this.nextDocBase = nextDocBase;\n+    }\n+  }\n+\n+  private static class TopLevelDocValuesTermsQuery extends DocValuesTermsQuery implements ExtendedQuery{\n+    private final String fieldName;\n+    private SortedSetDocValues values;\n+    private LongBitSet queryTermOrdinals;\n+    private boolean matchesAtLeastOneTerm = false;\n+    private boolean cache = true;\n+    private boolean cacheSeparately = false;\n+    private int cost;\n+\n+\n+    public TopLevelDocValuesTermsQuery(String field, BytesRef... terms) {\n+      super(field, terms);\n+      this.fieldName = field;\n+    }\n+\n+    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n+      values = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n+      queryTermOrdinals = new LongBitSet(values.getValueCount());\n+      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n+\n+      long lastOrdFound = 0;\n+      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n+        long ord = lookupTerm(values, term, lastOrdFound);\n+        if (ord >= 0L) {\n+          matchesAtLeastOneTerm = true;\n+          queryTermOrdinals.set(ord);\n+          lastOrdFound = ord;\n+        }\n+      }\n+\n+      return new ConstantScoreWeight(this, boost) {\n+        public Scorer scorer(LeafReaderContext context) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1OTI3MQ==", "bodyText": "I suggest renaming to \"topDocValues\".   The \"top\"-ness vs \"segment\" needs to be made more clear in all variables names here because we dance between them.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r363759271", "createdAt": "2020-01-07T13:59:04Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -138,8 +164,128 @@ public Query parse() throws SyntaxError {\n           bytesRefs[i] = term.toBytesRef();\n         }\n \n-        return method.makeFilter(fname, bytesRefs);\n+        return method.makeFilter(fname, bytesRefs, localParams);\n       }\n     };\n   }\n+\n+  private static abstract class TopLevelTwoPhaseIterator extends TwoPhaseIterator {\n+    private final int docBase;\n+    private final int nextDocBase;\n+    public TopLevelTwoPhaseIterator(DocIdSetIterator approximation, int docBase, int nextDocBase) {\n+      super(new PerSegmentViewDocIdSetIterator(approximation, docBase, nextDocBase));\n+\n+      this.docBase = docBase;\n+      this.nextDocBase = nextDocBase;\n+    }\n+  }\n+\n+  private static class TopLevelDocValuesTermsQuery extends DocValuesTermsQuery implements ExtendedQuery{\n+    private final String fieldName;\n+    private SortedSetDocValues values;\n+    private LongBitSet queryTermOrdinals;\n+    private boolean matchesAtLeastOneTerm = false;\n+    private boolean cache = true;\n+    private boolean cacheSeparately = false;\n+    private int cost;\n+\n+\n+    public TopLevelDocValuesTermsQuery(String field, BytesRef... terms) {\n+      super(field, terms);\n+      this.fieldName = field;\n+    }\n+\n+    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n+      values = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa6765fdd337973f07f8d35791a2a3408f2b3d7"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/cf1b39aaa9295461ed8514b14fff0cf38e10ed79", "committedDate": "2020-01-08T12:36:39Z", "message": "SOLR-13890: Address review comments\n\nThanks to David and Mikhail for review."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5ODQzMTYw", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-339843160", "createdAt": "2020-01-08T12:53:03Z", "commit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5OTU0MzU2", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-339954356", "createdAt": "2020-01-08T15:45:34Z", "commit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNTo0NTozNFrOFbbCLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNTo0OTozOFrOFbbLyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDI5ODc5Nw==", "bodyText": "The advice about commit frequently and thus add a static warming query is very debatable.  \"commit frequently\" ~= NRT and NRT users want to dial down caching, even eliminate.  But but maybe they can tolerate longer latency for freshness provided the query response time isn't incurring costs post-commit.  There's no universal answer.  Yet you did say \"you may benefit\" so I guess what you wrote is fine.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r364298797", "createdAt": "2020-01-08T15:45:34Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -1031,13 +1031,17 @@ The field on which to search. This parameter is required.\n Separator to use when parsing the input. If set to \" \" (a single blank space), will trim additional white space from the input terms. Defaults to  a comma (`,`).\n \n `method`::\n-An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n+An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, `docValuesTermsFilterPerSegment`, `docValuesTermsFilterTopLevel` or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n +\n `booleanQuery` creates a `BooleanQuery` representing the request.  Scales well with index size, but poorly with the number of terms being searched for.\n +\n `termsFilter` the default `method`.  Uses a `BooleanQuery` or a `TermInSetQuery` depending on the number of terms.  Scales well with index size, but only moderately with the number of query terms.\n +\n-`docValuesTermsFilter` uses doc values data structures to process the request.  This method scales well to a large numbers of query terms.  It encompasses two implementations or submethods.  Solr uses heuristics to choose between these at runtime, but users can also pick explicitly by providing a `submethod` parameter with either `toplevel` or `persegment` as a value.  The `persegment` implementation is more general purpose, while `toplevel` is geared for anyone with particularly high numbers of query terms (several hundred to several thousand).  The `toplevel` submethod relies on data structures which are lazily populated after each commit.  If you use this submethod and commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit, and doesn't slow down user requests.\n+`docValuesTermsFilter` chooses between the `docValuesTermsFilterTopLevel` and `docValuesTermsFilterPerSegment` methods (see below) using the number of query terms as a rough heuristic.  Users should typically use this method instead of using `docValuesTermsFilterTopLevel` or `docValuesTermsFilterPerSegment` directly, unless they've done performance testing to validate one or the other methods on queries of all sizes. Depending on the implementation picked, this method may rely on expensive data structures which are lazily populated after each commit.  If you commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit itself and not attached directly to user requests.\n++\n+`docValuesTermsFilterTopLevel` uses top-level doc values data structures to find results.  These data structures are more efficient as the number of query terms grows high (over several hundred). But they are also expensive to build and need to be populated lazily after each commit, causing a sometimes-noticeable slowdown on the first query after each commit.  If you commit frequently, you may benefit from adding a static warming query to your `solrconfig.xml` so that this is done as a part of the commit itself and not attached directly to user requests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDI5OTg1Nw==", "bodyText": "Maybe right up front here first declare that this method is only appropriate when the field has docValues?  That's more important and differentiates from terms index based methods.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r364299857", "createdAt": "2020-01-08T15:47:11Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -1031,13 +1031,17 @@ The field on which to search. This parameter is required.\n Separator to use when parsing the input. If set to \" \" (a single blank space), will trim additional white space from the input terms. Defaults to  a comma (`,`).\n \n `method`::\n-An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n+An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, `docValuesTermsFilterPerSegment`, `docValuesTermsFilterTopLevel` or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n +\n `booleanQuery` creates a `BooleanQuery` representing the request.  Scales well with index size, but poorly with the number of terms being searched for.\n +\n `termsFilter` the default `method`.  Uses a `BooleanQuery` or a `TermInSetQuery` depending on the number of terms.  Scales well with index size, but only moderately with the number of query terms.\n +\n-`docValuesTermsFilter` uses doc values data structures to process the request.  This method scales well to a large numbers of query terms.  It encompasses two implementations or submethods.  Solr uses heuristics to choose between these at runtime, but users can also pick explicitly by providing a `submethod` parameter with either `toplevel` or `persegment` as a value.  The `persegment` implementation is more general purpose, while `toplevel` is geared for anyone with particularly high numbers of query terms (several hundred to several thousand).  The `toplevel` submethod relies on data structures which are lazily populated after each commit.  If you use this submethod and commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit, and doesn't slow down user requests.\n+`docValuesTermsFilter` chooses between the `docValuesTermsFilterTopLevel` and `docValuesTermsFilterPerSegment` methods (see below) using the number of query terms as a rough heuristic.  Users should typically use this method instead of using `docValuesTermsFilterTopLevel` or `docValuesTermsFilterPerSegment` directly, unless they've done performance testing to validate one or the other methods on queries of all sizes. Depending on the implementation picked, this method may rely on expensive data structures which are lazily populated after each commit.  If you commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit itself and not attached directly to user requests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwMTI1OQ==", "bodyText": "\"doesn't have the same advantages\" without also listing some positives here makes me think this method is not useful when really it's excellent.  Lots of users would say 300 queries is a \"large number\", and this method is appropriate.  Also this method is very NRT friendly.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r364301259", "createdAt": "2020-01-08T15:49:38Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -1031,13 +1031,17 @@ The field on which to search. This parameter is required.\n Separator to use when parsing the input. If set to \" \" (a single blank space), will trim additional white space from the input terms. Defaults to  a comma (`,`).\n \n `method`::\n-An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n+An optional parameter used to determine which of several query implementations should be used by Solr.  Options are restricted to: `termsFilter`, `booleanQuery`, `automaton`, `docValuesTermsFilterPerSegment`, `docValuesTermsFilterTopLevel` or `docValuesTermsFilter`.  If unspecified, the default value is `termsFilter`.  Each implementation has its own performance characteristics, and users are encouraged to experiment to determine which implementation is most performant for their use-case.  Heuristics are given below.\n +\n `booleanQuery` creates a `BooleanQuery` representing the request.  Scales well with index size, but poorly with the number of terms being searched for.\n +\n `termsFilter` the default `method`.  Uses a `BooleanQuery` or a `TermInSetQuery` depending on the number of terms.  Scales well with index size, but only moderately with the number of query terms.\n +\n-`docValuesTermsFilter` uses doc values data structures to process the request.  This method scales well to a large numbers of query terms.  It encompasses two implementations or submethods.  Solr uses heuristics to choose between these at runtime, but users can also pick explicitly by providing a `submethod` parameter with either `toplevel` or `persegment` as a value.  The `persegment` implementation is more general purpose, while `toplevel` is geared for anyone with particularly high numbers of query terms (several hundred to several thousand).  The `toplevel` submethod relies on data structures which are lazily populated after each commit.  If you use this submethod and commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit, and doesn't slow down user requests.\n+`docValuesTermsFilter` chooses between the `docValuesTermsFilterTopLevel` and `docValuesTermsFilterPerSegment` methods (see below) using the number of query terms as a rough heuristic.  Users should typically use this method instead of using `docValuesTermsFilterTopLevel` or `docValuesTermsFilterPerSegment` directly, unless they've done performance testing to validate one or the other methods on queries of all sizes. Depending on the implementation picked, this method may rely on expensive data structures which are lazily populated after each commit.  If you commit frequently, you may benefit from adding a static warming query to `solrconfig.xml` so that this is done as a part of the commit itself and not attached directly to user requests.\n++\n+`docValuesTermsFilterTopLevel` uses top-level doc values data structures to find results.  These data structures are more efficient as the number of query terms grows high (over several hundred). But they are also expensive to build and need to be populated lazily after each commit, causing a sometimes-noticeable slowdown on the first query after each commit.  If you commit frequently, you may benefit from adding a static warming query to your `solrconfig.xml` so that this is done as a part of the commit itself and not attached directly to user requests.\n++\n+`docValuesTermsFilterPerSegment` uses segment-level doc values data structures to find results.  This is more general purpose than the corresponding \"top level\" method, but doesn't have the same advantages at large numbers of query terms (see above).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5OTU5MjU2", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-339959256", "createdAt": "2020-01-08T15:52:05Z", "commit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNTo1MjowNVrOFbbRPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNTo1MjowNVrOFbbRPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwMjY1NQ==", "bodyText": "If not a SolrIndexSearcher than return super.createWeight    (your idea based on Mikhail's comment)", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r364302655", "createdAt": "2020-01-08T15:52:05Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -142,4 +158,112 @@ public Query parse() throws SyntaxError {\n       }\n     };\n   }\n+\n+  private static class TopLevelDocValuesTermsQuery extends DocValuesTermsQuery implements ExtendedQuery{\n+    private final String fieldName;\n+    private SortedSetDocValues topLevelDocValues;\n+    private LongBitSet topLevelTermOrdinals;\n+    private boolean matchesAtLeastOneTerm = false;\n+    private boolean cache = true;\n+    private boolean cacheSeparately = false;\n+    private int cost;\n+\n+\n+    public TopLevelDocValuesTermsQuery(String field, BytesRef... terms) {\n+      super(field, terms);\n+      this.fieldName = field;\n+    }\n+\n+    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n+      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf1b39aaa9295461ed8514b14fff0cf38e10ed79"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02c1f3300af549bdbae379a3bc802c916d3371c", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/d02c1f3300af549bdbae379a3bc802c916d3371c", "committedDate": "2020-01-08T19:35:45Z", "message": "SOLR-13890: Address review comments, round 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a88e559f4f66fae5b02f73200dc359ee747216e9", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/a88e559f4f66fae5b02f73200dc359ee747216e9", "committedDate": "2020-01-08T19:40:38Z", "message": "SOLR-13890: Address review comments, round 2b\n\nMissed the removal of the unnecessary ExtendedQuery methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54872295e1fa05a30cfa646fbe85e9fbb9fd92b7", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/54872295e1fa05a30cfa646fbe85e9fbb9fd92b7", "committedDate": "2020-01-08T19:42:39Z", "message": "Merge branch 'master' into jira/solr-13890"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTQ2MDA0", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-340946004", "createdAt": "2020-01-10T04:09:44Z", "commit": {"oid": "54872295e1fa05a30cfa646fbe85e9fbb9fd92b7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwNDowOTo0NFrOFcJ2yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwNDoxNjoxOFrOFcJ6fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTkzMQ==", "bodyText": "Compared to other TPIs, I think 3f is too low.  For example DVTQ (in the superclass) is 3f but we also must call advanceExact on the top level DV.  I suggest 10f.  It's a bike-shed number but I just want more than 3 and much less than 100 which is what some of the no-idea but probably expensive TPIs have.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r365065931", "createdAt": "2020-01-10T04:09:44Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -142,4 +158,100 @@ public Query parse() throws SyntaxError {\n       }\n     };\n   }\n+\n+  private static class TopLevelDocValuesTermsQuery extends DocValuesTermsQuery {\n+    private final String fieldName;\n+    private SortedSetDocValues topLevelDocValues;\n+    private LongBitSet topLevelTermOrdinals;\n+    private boolean matchesAtLeastOneTerm = false;\n+\n+\n+    public TopLevelDocValuesTermsQuery(String field, BytesRef... terms) {\n+      super(field, terms);\n+      this.fieldName = field;\n+    }\n+\n+    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n+      if (! (searcher instanceof SolrIndexSearcher)) {\n+        log.debug(\"Falling back to DocValuesTermsQuery because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n+        return super.createWeight(searcher, scoreMode, boost);\n+      }\n+\n+      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n+      topLevelTermOrdinals = new LongBitSet(topLevelDocValues.getValueCount());\n+      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n+\n+      long lastTermOrdFound = 0;\n+      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n+        long currentTermOrd = lookupTerm(topLevelDocValues, term, lastTermOrdFound);\n+        if (currentTermOrd >= 0L) {\n+          matchesAtLeastOneTerm = true;\n+          topLevelTermOrdinals.set(currentTermOrd);\n+          lastTermOrdFound = currentTermOrd;\n+        }\n+      }\n+\n+      return new ConstantScoreWeight(this, boost) {\n+        public Scorer scorer(LeafReaderContext context) throws IOException {\n+          if (! matchesAtLeastOneTerm) {\n+            return null;\n+          }\n+          \n+          SortedSetDocValues segmentDocValues = context.reader().getSortedSetDocValues(fieldName);\n+          if (segmentDocValues == null) {\n+            return null;\n+          }\n+\n+          final int docBase = context.docBase;\n+          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(segmentDocValues) {\n+            public boolean matches() throws IOException {\n+              topLevelDocValues.advanceExact(docBase + approximation.docID());\n+              for(long ord = topLevelDocValues.nextOrd(); ord != -1L; ord = topLevelDocValues.nextOrd()) {\n+                if (topLevelTermOrdinals.get(ord)) {\n+                  return true;\n+                }\n+              }\n+\n+              return false;\n+            }\n+\n+            public float matchCost() {\n+              return 3.0F;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54872295e1fa05a30cfa646fbe85e9fbb9fd92b7"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2Njg3OQ==", "bodyText": "I believe Joel argued strongly we should default both DV impls to cache=false?  You can do that here (and in the other method) easily via WrappedQuery wrapper and setting cache=false.  I mentioned another approach that messes with this.localParams but perhaps that might feel hacky compared to WrappedQuery.  Especially so since makeFilter doesn't have access to change the field this.localParams.", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r365066879", "createdAt": "2020-01-10T04:16:18Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -88,7 +91,20 @@ Query makeFilter(String fname, BytesRef[] byteRefs) {\n     docValuesTermsFilter {//on 4x this is FieldCacheTermsFilter but we use the 5x name any way\n       @Override\n       Query makeFilter(String fname, BytesRef[] byteRefs) {\n-        return new DocValuesTermsQuery(fname, byteRefs);//constant scores\n+        // TODO Further tune this heuristic number\n+        return (byteRefs.length > 700) ? new TopLevelDocValuesTermsQuery(fname, byteRefs) : new DocValuesTermsQuery(fname, byteRefs);\n+      }\n+    },\n+    docValuesTermsFilterTopLevel {\n+      @Override\n+      Query makeFilter(String fname, BytesRef[] byteRefs) {\n+        return new TopLevelDocValuesTermsQuery(fname, byteRefs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54872295e1fa05a30cfa646fbe85e9fbb9fd92b7"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9404d92e0f10e6c9d64255f01c1379549cb81ce8", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/9404d92e0f10e6c9d64255f01c1379549cb81ce8", "committedDate": "2020-01-10T16:07:25Z", "message": "SOLR-13890: Address review comments, round 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04ba90e18ff0cf94a336a94649f5777261bec8db", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/04ba90e18ff0cf94a336a94649f5777261bec8db", "committedDate": "2020-01-10T16:25:14Z", "message": "SOLR-13890: Address review comments, 3b"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMzEwMTQz", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-341310143", "createdAt": "2020-01-10T17:24:06Z", "commit": {"oid": "9404d92e0f10e6c9d64255f01c1379549cb81ce8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNzoyNDowNlrOFca2jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNzoyNDowNlrOFca2jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NDM5Nw==", "bodyText": "right here simply call docValuesTermsFilterTopLevel.makeFilter or docValuesTermsFilterPerSegment.makeFilter.  Yes, enum methods may refer to other enums in the same enum :-)", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r365344397", "createdAt": "2020-01-10T17:24:06Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.java", "diffHunk": "@@ -92,22 +92,28 @@ Query makeFilter(String fname, BytesRef[] byteRefs) {\n       @Override\n       Query makeFilter(String fname, BytesRef[] byteRefs) {\n         // TODO Further tune this heuristic number\n-        return (byteRefs.length > 700) ? new TopLevelDocValuesTermsQuery(fname, byteRefs) : new DocValuesTermsQuery(fname, byteRefs);\n+        return disableCacheByDefault((byteRefs.length > 700) ? new TopLevelDocValuesTermsQuery(fname, byteRefs) : new DocValuesTermsQuery(fname, byteRefs));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9404d92e0f10e6c9d64255f01c1379549cb81ce8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMzExMjIx", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-341311221", "createdAt": "2020-01-10T17:26:05Z", "commit": {"oid": "04ba90e18ff0cf94a336a94649f5777261bec8db"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNzoyNjowNlrOFca5oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNzoyNjowNlrOFca5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NTE4NQ==", "bodyText": "Just a side-comment about our ref docs:  In the ref docs I write or update, I convert them to one sentence per line.  This makes the diffs easy to read!  The pain of no newlines is very apparent here.  Change or not as you wish.  CC @ctargett", "url": "https://github.com/apache/lucene-solr/pull/1151#discussion_r365345185", "createdAt": "2020-01-10T17:26:06Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/other-parsers.adoc", "diffHunk": "@@ -1037,11 +1037,11 @@ An optional parameter used to determine which of several query implementations s\n +\n `termsFilter` the default `method`.  Uses a `BooleanQuery` or a `TermInSetQuery` depending on the number of terms.  Scales well with index size, but only moderately with the number of query terms.\n +\n-`docValuesTermsFilter` can only be used on fields with docValues data.  Chooses between the `docValuesTermsFilterTopLevel` and `docValuesTermsFilterPerSegment` methods using the number of query terms as a rough heuristic.  Users should typically use this method instead of using `docValuesTermsFilterTopLevel` or `docValuesTermsFilterPerSegment` directly, unless they've done performance testing to validate one of the methods on queries of all sizes.  Depending on the implementation picked, this method may rely on expensive data structures which are lazily populated after each commit.  If you commit frequently and your use-case can tolerate a static warming query, consider adding one to `solrconfig.xml` so that this work is done as a part of the commit itself and not attached directly to user requests.\n+`docValuesTermsFilter` can only be used on fields with docValues data.  The `cache` parameter is false by default.  Chooses between the `docValuesTermsFilterTopLevel` and `docValuesTermsFilterPerSegment` methods using the number of query terms as a rough heuristic.  Users should typically use this method instead of using `docValuesTermsFilterTopLevel` or `docValuesTermsFilterPerSegment` directly, unless they've done performance testing to validate one of the methods on queries of all sizes.  Depending on the implementation picked, this method may rely on expensive data structures which are lazily populated after each commit.  If you commit frequently and your use-case can tolerate a static warming query, consider adding one to `solrconfig.xml` so that this work is done as a part of the commit itself and not attached directly to user requests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04ba90e18ff0cf94a336a94649f5777261bec8db"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMzExMjkx", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-341311291", "createdAt": "2020-01-10T17:26:14Z", "commit": {"oid": "04ba90e18ff0cf94a336a94649f5777261bec8db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c676e831c3a118966e3a022074560995d3c1f9f", "author": {"user": {"login": "gerlowskija", "name": "Jason Gerlowski"}}, "url": "https://github.com/apache/lucene-solr/commit/9c676e831c3a118966e3a022074560995d3c1f9f", "committedDate": "2020-01-10T17:59:41Z", "message": "SOLR-13890: Address review commends, round 4"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMzM1NzQ5", "url": "https://github.com/apache/lucene-solr/pull/1151#pullrequestreview-341335749", "createdAt": "2020-01-10T18:14:45Z", "commit": {"oid": "9c676e831c3a118966e3a022074560995d3c1f9f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2356, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}