{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MDQ3ODk5", "number": 1179, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxNTowMVrODY1FvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxNTowMVrODY1FvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYyMjM3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/util/packed/DirectMonotonicReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxNTowMVrOFe6Ndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxNTowMVrOFe6Ndw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NTMxOQ==", "bodyText": "Do we know this incoming long index is small enough not to overflow int after right shift?  Should we use Math.toIntExact instead to confirm?", "url": "https://github.com/apache/lucene-solr/pull/1179#discussion_r367955319", "createdAt": "2020-01-17T14:15:01Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/util/packed/DirectMonotonicReader.java", "diffHunk": "@@ -101,20 +104,99 @@ public static LongValues getInstance(Meta meta, RandomAccessInput data) throws I\n         readers[i] = DirectReader.getInstance(data, meta.bpvs[i], meta.offsets[i]);\n       }\n     }\n-    final int blockShift = meta.blockShift;\n-\n-    final long[] mins = meta.mins;\n-    final float[] avgs = meta.avgs;\n-    return new LongValues() {\n-\n-      @Override\n-      public long get(long index) {\n-        final int block = (int) (index >>> blockShift);\n-        final long blockIndex = index & ((1 << blockShift) - 1);\n-        final long delta = readers[block].get(blockIndex);\n-        return mins[block] + (long) (avgs[block] * blockIndex) + delta;\n+\n+    return new DirectMonotonicReader(meta.blockShift, readers, meta.mins, meta.avgs, meta.bpvs);\n+  }\n+\n+  private final int blockShift;\n+  private final LongValues[] readers;\n+  private final long[] mins;\n+  private final float[] avgs;\n+  private final byte[] bpvs;\n+  private final int nonZeroBpvs;\n+\n+  private DirectMonotonicReader(int blockShift, LongValues[] readers, long[] mins, float[] avgs, byte[] bpvs) {\n+    this.blockShift = blockShift;\n+    this.readers = readers;\n+    this.mins = mins;\n+    this.avgs = avgs;\n+    this.bpvs = bpvs;\n+    if (readers.length != mins.length || readers.length != avgs.length || readers.length != bpvs.length) {\n+      throw new IllegalArgumentException();\n+    }\n+    int nonZeroBpvs = 0;\n+    for (byte b : bpvs) {\n+      if (b != 0) {\n+        nonZeroBpvs++;\n+      }\n+    }\n+    this.nonZeroBpvs = nonZeroBpvs;\n+  }\n+\n+  @Override\n+  public long get(long index) {\n+    final int block = (int) (index >>> blockShift);\n+    final long blockIndex = index & ((1 << blockShift) - 1);\n+    final long delta = readers[block].get(blockIndex);\n+    return mins[block] + (long) (avgs[block] * blockIndex) + delta;\n+  }\n+\n+  /** Get lower/upper bounds for the value at a given index without hitting the direct reader. */\n+  private long[] getBounds(long index) {\n+    final int block = (int) (index >>> blockShift);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "042c0872e93f9ae786431e5e9b556ac50d8c8eed"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 889, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}