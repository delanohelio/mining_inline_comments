{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNjA1MzQ5", "number": 1617, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTo1Njo1MlrOEJLtqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1NjoyMlrOEJP7Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDY0NTUyOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTo1Njo1MlrOGpmJIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1MToyOFrOGps3qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2OTcyOA==", "bodyText": "Hmm is there some (sneaky) reason why we couldn't just do this.mergeReaders = new ArrayList<>(segments.size()); above and then append to that list?  Instead of appending to private ArrayList and then making a copy in the end?", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446269728", "createdAt": "2020-06-26T15:56:52Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -399,6 +416,40 @@ boolean hasFinished() {\n     Optional<Boolean> hasCompletedSuccessfully() {\n       return Optional.ofNullable(mergeCompleted.getNow(null));\n     }\n+\n+\n+    /**\n+     * Called before the merge is committed\n+     */\n+    void onMergeCommit() {\n+    }\n+\n+    /**\n+     * Sets the merge readers for this merge.\n+     */\n+    void initMergeReaders(IOUtils.IOFunction<SegmentCommitInfo, MergeReader> readerFactory) throws IOException {\n+      assert mergeReaders.isEmpty() : \"merge readers must be empty\";\n+      assert mergeCompleted.isDone() == false : \"merge is already done\";\n+      ArrayList<MergeReader> readers = new ArrayList<>(segments.size());\n+      try {\n+        for (final SegmentCommitInfo info : segments) {\n+          // Hold onto the \"live\" reader; we will use this to\n+          // commit merged deletes\n+          readers.add(readerFactory.apply(info));\n+        }\n+      } finally {\n+        // ensure we assign this to close them in the case of an exception\n+        this.mergeReaders = List.copyOf(readers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bafae889a97850087f5804dc17dc86f555824e5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3OTk0NQ==", "bodyText": "I left a comment. I use immutable lists everywhere here it would be fatal if we modify this list outside of OneMerge. I think that justifies the copy.", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446379945", "createdAt": "2020-06-26T19:51:28Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -399,6 +416,40 @@ boolean hasFinished() {\n     Optional<Boolean> hasCompletedSuccessfully() {\n       return Optional.ofNullable(mergeCompleted.getNow(null));\n     }\n+\n+\n+    /**\n+     * Called before the merge is committed\n+     */\n+    void onMergeCommit() {\n+    }\n+\n+    /**\n+     * Sets the merge readers for this merge.\n+     */\n+    void initMergeReaders(IOUtils.IOFunction<SegmentCommitInfo, MergeReader> readerFactory) throws IOException {\n+      assert mergeReaders.isEmpty() : \"merge readers must be empty\";\n+      assert mergeCompleted.isDone() == false : \"merge is already done\";\n+      ArrayList<MergeReader> readers = new ArrayList<>(segments.size());\n+      try {\n+        for (final SegmentCommitInfo info : segments) {\n+          // Hold onto the \"live\" reader; we will use this to\n+          // commit merged deletes\n+          readers.add(readerFactory.apply(info));\n+        }\n+      } finally {\n+        // ensure we assign this to close them in the case of an exception\n+        this.mergeReaders = List.copyOf(readers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2OTcyOA=="}, "originalCommit": {"oid": "1bafae889a97850087f5804dc17dc86f555824e5"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDc4OTA4OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjo0MTo0OVrOGpnkgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1MTozNlrOGps34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI5MzEyMw==", "bodyText": "Hmm how did this sneak in?", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446293123", "createdAt": "2020-06-26T16:41:49Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -459,6 +463,27 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges returned by MergePolicy.findFullFlushMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and will still run to completion independent of the commit\n+   * like normal segment merges. The default is <code>{@value IndexWriterConfig#DEFAULT_MAX_COMMIT_MERGE_WAIT_MILLIS}</code>.\n+   *\n+   * Note: This settings has no effect unless {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}\n+   * has an implementation that actually returns merges which by default doesn't return any merges.\n+   */\n+  public IndexWriterConfig setMaxCommitMergeWaitMillis(long maxCommitMergeWaitMillis) {\n+    this.maxCommitMergeWaitMillis = maxCommitMergeWaitMillis;\n+    return this;\n+  }\n+\n+  /** We only allow sorting on these types */\n+  private static final EnumSet<SortField.Type> ALLOWED_INDEX_SORT_TYPES = EnumSet.of(SortField.Type.STRING,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77152e3c38c05f3c960978f491d0677aa2ccb099"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM0OTk5MA==", "bodyText": "OK I see this was removed earlier in mainline for LUCENE-9330 -- it must've snuck back in as a merge conflict.\nI'll re-remove now.", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446349990", "createdAt": "2020-06-26T18:41:26Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -459,6 +463,27 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges returned by MergePolicy.findFullFlushMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and will still run to completion independent of the commit\n+   * like normal segment merges. The default is <code>{@value IndexWriterConfig#DEFAULT_MAX_COMMIT_MERGE_WAIT_MILLIS}</code>.\n+   *\n+   * Note: This settings has no effect unless {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}\n+   * has an implementation that actually returns merges which by default doesn't return any merges.\n+   */\n+  public IndexWriterConfig setMaxCommitMergeWaitMillis(long maxCommitMergeWaitMillis) {\n+    this.maxCommitMergeWaitMillis = maxCommitMergeWaitMillis;\n+    return this;\n+  }\n+\n+  /** We only allow sorting on these types */\n+  private static final EnumSet<SortField.Type> ALLOWED_INDEX_SORT_TYPES = EnumSet.of(SortField.Type.STRING,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI5MzEyMw=="}, "originalCommit": {"oid": "77152e3c38c05f3c960978f491d0677aa2ccb099"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM4MDAwMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446380003", "createdAt": "2020-06-26T19:51:36Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -459,6 +463,27 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges returned by MergePolicy.findFullFlushMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and will still run to completion independent of the commit\n+   * like normal segment merges. The default is <code>{@value IndexWriterConfig#DEFAULT_MAX_COMMIT_MERGE_WAIT_MILLIS}</code>.\n+   *\n+   * Note: This settings has no effect unless {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}\n+   * has an implementation that actually returns merges which by default doesn't return any merges.\n+   */\n+  public IndexWriterConfig setMaxCommitMergeWaitMillis(long maxCommitMergeWaitMillis) {\n+    this.maxCommitMergeWaitMillis = maxCommitMergeWaitMillis;\n+    return this;\n+  }\n+\n+  /** We only allow sorting on these types */\n+  private static final EnumSet<SortField.Type> ALLOWED_INDEX_SORT_TYPES = EnumSet.of(SortField.Type.STRING,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI5MzEyMw=="}, "originalCommit": {"oid": "77152e3c38c05f3c960978f491d0677aa2ccb099"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTMzNjA3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1NjoyMlrOGps_VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxOTo1NjoyMlrOGps_VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM4MTkwOA==", "bodyText": "I am torn if we'd use a double or long here. I think we used double in other places but I do like a discrete value better...", "url": "https://github.com/apache/lucene-solr/pull/1617#discussion_r446381908", "createdAt": "2020-06-26T19:56:22Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -459,6 +463,21 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges (during {@link IndexWriter#commit}) returned by\n+   * MergePolicy.findFullFlushMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.\n+   * The merges are not cancelled, and will still run to completion independent of the commit,\n+   * like natural segment merges. The default is <code>{@value IndexWriterConfig#DEFAULT_MAX_COMMIT_MERGE_WAIT_MILLIS}</code>.\n+   *\n+   * Note: This settings has no effect unless {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}\n+   * has an implementation that actually returns merges which by default doesn't return any merges.\n+   */\n+  public IndexWriterConfig setMaxCommitMergeWaitMillis(long maxCommitMergeWaitMillis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbca89687ddcda15badfee1ae01e883295da51c6"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1343, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}