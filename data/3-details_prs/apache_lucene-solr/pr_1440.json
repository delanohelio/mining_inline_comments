{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1OTkzNzc5", "number": 1440, "title": "LUCENE-9330: Make SortFields responsible for index sorting and serialization", "bodyText": "This commit adds a new class IndexSorter which handles how a sort should be applied\nto documents in an index:\n\nhow to serialize/deserialize sort info in the segment header\nhow to sort documents within a segment\nhow to sort documents from merging segments\n\nSortField has a getIndexSorter() method, which will return null if the sort cannot be used\nto sort an index (eg if it uses scores or other query-dependent values).  This also requires a\nnew Codec as there is a change to the SegmentInfoFormat", "createdAt": "2020-04-20T11:07:28Z", "url": "https://github.com/apache/lucene-solr/pull/1440", "merged": true, "mergeCommit": {"oid": "de2bad9039054af753bc2c847565f63f05f4fdd7"}, "closed": true, "closedAt": "2020-05-22T12:33:07Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZc7QJgH2gAyNDA1OTkzNzc5OmY1NGViMzkxZmE1OTkzNDM3NDVjMmUzMzFmZTE5MzcyNDk5YjcxOGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjvsIDAH2gAyNDA1OTkzNzc5OjFhMTU0OGM2MTQ0N2E1OTEzZWMyZjg5ZjdjNjZkYzAxYzNjYjA4NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f54eb391fa599343745c2e331fe19372499b718b", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/f54eb391fa599343745c2e331fe19372499b718b", "committedDate": "2020-04-20T10:56:15Z", "message": "Make SortFields responsible for index sorting and serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bd0aab1b94b6366eba833827b6e3692ac7dc88b", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/6bd0aab1b94b6366eba833827b6e3692ac7dc88b", "committedDate": "2020-04-20T14:52:38Z", "message": "Use SortFieldProvider SPI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b08ce257e2a2842f53343931d9652839b4d50243", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/b08ce257e2a2842f53343931d9652839b4d50243", "committedDate": "2020-04-20T15:01:03Z", "message": "sandbox codecs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0afbc1d2d7b6fc2c1db75364ac9bc7122fd659e4", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/0afbc1d2d7b6fc2c1db75364ac9bc7122fd659e4", "committedDate": "2020-04-20T19:08:31Z", "message": "Further cleanup in DIC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/247ef622e51476a882a8f7cf706968f339d04813", "committedDate": "2020-04-21T10:19:28Z", "message": "javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDY2NzQ0", "url": "https://github.com/apache/lucene-solr/pull/1440#pullrequestreview-397466744", "createdAt": "2020-04-21T16:22:22Z", "commit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjoyNTozNVrOGJNFDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Nzo0NlrOGJN_tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwNDY1NQ==", "bodyText": "Two licenses?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412304655", "createdAt": "2020-04-21T16:25:35Z", "author": {"login": "jpountz"}, "path": "lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene84/package.html", "diffHunk": "@@ -0,0 +1,42 @@\n+<!--\n+  Licensed to the Apache Software Foundation (ASF) under one or more\n+  contributor license agreements.  See the NOTICE file distributed with\n+  this work for additional information regarding copyright ownership.\n+  The ASF licenses this file to You under the Apache License, Version 2.0\n+  (the \"License\"); you may not use this file except in compliance with\n+  the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+  -->\n+\n+<!doctype html public \"-//w3c//dtd html 4.0 transitional//en\">\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwNDc4Mg==", "bodyText": "assert that the bytes have been fully consumed?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412304782", "createdAt": "2020-04-21T16:25:46Z", "author": {"login": "jpountz"}, "path": "lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java", "diffHunk": "@@ -171,133 +168,17 @@ public SegmentInfo read(Directory directory, String segmentName, byte[] segmentI\n       SortField[] sortField = new SortField[numSortFields];\n       for (int i = 0; i < numSortFields; ++i) {\n         SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_FIELD);\n-        final String field = readString(SI_SORT_FIELD.length, scratch);\n+        assert StringHelper.startsWith(scratch.get(), SI_SORT_NAME);\n+        final String provider = readString(SI_SORT_NAME.length, scratch);\n \n         SimpleTextUtil.readLine(input, scratch);\n         assert StringHelper.startsWith(scratch.get(), SI_SORT_TYPE);\n-        final String typeAsString = readString(SI_SORT_TYPE.length, scratch);\n-\n-        final SortField.Type type;\n-        SortedSetSelector.Type selectorSet = null;\n-        SortedNumericSelector.Type selectorNumeric = null;\n-        switch (typeAsString) {\n-          case \"string\":\n-            type = SortField.Type.STRING;\n-            break;\n-          case \"long\":\n-            type = SortField.Type.LONG;\n-            break;\n-          case \"int\":\n-            type = SortField.Type.INT;\n-            break;\n-          case \"double\":\n-            type = SortField.Type.DOUBLE;\n-            break;\n-          case \"float\":\n-            type = SortField.Type.FLOAT;\n-            break;\n-          case \"multi_valued_string\":\n-            type = SortField.Type.STRING;\n-            selectorSet = readSetSelector(input, scratch);\n-            break;\n-          case \"multi_valued_long\":\n-            type = SortField.Type.LONG;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_int\":\n-            type = SortField.Type.INT;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_double\":\n-            type = SortField.Type.DOUBLE;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_float\":\n-            type = SortField.Type.FLOAT;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          default:\n-            throw new CorruptIndexException(\"unable to parse sort type string: \" + typeAsString, input);\n-        }\n \n         SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_REVERSE);\n-        final boolean reverse = Boolean.parseBoolean(readString(SI_SORT_REVERSE.length, scratch));\n-\n-        SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_MISSING);\n-        final String missingLastAsString = readString(SI_SORT_MISSING.length, scratch);\n-        final Object missingValue;\n-        switch (type) {\n-          case STRING:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              case \"first\":\n-                missingValue = SortField.STRING_FIRST;\n-                break;\n-              case \"last\":\n-                missingValue = SortField.STRING_LAST;\n-                break;\n-              default:\n-                throw new CorruptIndexException(\"unable to parse missing string: \" + typeAsString, input);\n-            }\n-            break;\n-          case LONG:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Long.parseLong(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case INT:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Integer.parseInt(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case DOUBLE:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Double.parseDouble(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case FLOAT:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Float.parseFloat(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          default:\n-            throw new AssertionError();\n-        }\n-        if (selectorSet != null) {\n-          sortField[i] = new SortedSetSortField(field, reverse);\n-        } else if (selectorNumeric != null) {\n-          sortField[i] = new SortedNumericSortField(field, type, reverse);\n-        } else {\n-          sortField[i] = new SortField(field, type, reverse);\n-        }\n-        if (missingValue != null) {\n-          sortField[i].setMissingValue(missingValue);\n-        }\n+        assert StringHelper.startsWith(scratch.get(), SI_SORT_BYTES);\n+        BytesRef serializedSort = SimpleTextUtil.fromBytesRefString(readString(SI_SORT_BYTES.length, scratch));\n+        final ByteArrayDataInput bytes = new ByteArrayDataInput(serializedSort.bytes, serializedSort.offset, serializedSort.length);\n+        sortField[i] = SortFieldProvider.forName(provider).loadSortField(bytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwODMwOA==", "bodyText": "can we remove this since getDocValues already returns an iterator? (we might need to do T extends DocIdSetIterator above)", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412308308", "createdAt": "2020-04-21T16:31:21Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesWriter.java", "diffHunk": "@@ -21,12 +21,10 @@\n \n import org.apache.lucene.codecs.DocValuesConsumer;\n import org.apache.lucene.search.DocIdSetIterator;\n-import org.apache.lucene.search.SortField;\n \n-abstract class DocValuesWriter {\n-  abstract void finish(int numDoc);\n+abstract class DocValuesWriter<T> {\n   abstract void flush(SegmentWriteState state, Sorter.DocMap sortMap, DocValuesConsumer consumer) throws IOException;\n-  abstract Sorter.DocComparator getDocComparator(int numDoc, SortField sortField) throws IOException;\n+  abstract T getDocValues();\n   abstract DocIdSetIterator getDocIdSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMDY2NQ==", "bodyText": "I wonder if it would work to move it to SortFieldProvider instead for symmetry, so that the serialization and deserialization logic would be in the same place.", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412310665", "createdAt": "2020-04-21T16:34:17Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexSorter.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.LongValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.apache.lucene.util.packed.PackedInts;\n+\n+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;\n+\n+/**\n+ * Handles how documents should be sorted in an index, both within a segment and between\n+ * segments.\n+ *\n+ * Implementers must provide the following methods:\n+ * {@link #getDocComparator(LeafReader)} - an object that determines how documents within a segment are to be sorted\n+ * {@link #getComparableProviders(List)} - an array of objects that return a sortable long value per document and segment\n+ * {@link #serialize(DataOutput)} - how the sort should be written into the segment header\n+ * {@link #getProviderName()} - the SPI-registered name of a {@link SortFieldProvider} to deserialize the sort\n+ *\n+ * The companion {@link SortFieldProvider} should be registered with SPI via {@code META-INF/services}\n+ */\n+public interface IndexSorter {\n+\n+  /** Used for sorting documents across segments */\n+  public interface ComparableProvider {\n+    /**\n+     * Returns a long so that the natural ordering of long values matches the\n+     * ordering of doc IDs for the given comparator\n+     */\n+    long getAsComparableLong(int docID) throws IOException;\n+  }\n+\n+  /** A comparator of doc IDs, used for sorting documents within a segment */\n+  public interface DocComparator {\n+    /** Compare docID1 against docID2. The contract for the return value is the\n+     *  same as {@link Comparator#compare(Object, Object)}. */\n+    int compare(int docID1, int docID2);\n+  }\n+\n+  /**\n+   * Get an array of {@link ComparableProvider}, one per segment, for merge sorting documents in different segments\n+   * @param readers the readers to be merged\n+   */\n+  public abstract ComparableProvider[] getComparableProviders(List<? extends LeafReader> readers) throws IOException;\n+\n+  /**\n+   * Get a comparator that determines the sort order of docs within a single Reader.\n+   *\n+   * NB We cannot simply use the {@link FieldComparator} API because it requires docIDs to be sent\n+   * in-order. The default implementations allocate array[maxDoc] to hold native values for comparison,\n+   * but 1) they are transient (only alive while sorting this one segment) and 2) in the typical\n+   * index sorting case, they are only used to sort newly flushed segments, which will be smaller\n+   * than merged segments\n+   *\n+   * @param reader the Reader to sort\n+   */\n+  public abstract DocComparator getDocComparator(LeafReader reader) throws IOException;\n+\n+  /**\n+   * Serializes the parent SortField.  This is used to write Sort information into the Segment header\n+   *\n+   * @see SortFieldProvider#loadSortField(DataInput)\n+   */\n+  public abstract void serialize(DataOutput out) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMjg4Mw==", "bodyText": "There is an even nicer syntax now.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new IndexSorter.DocComparator[0]));\n          \n          \n            \n                return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(IndexSorter.DocComparator[]::new));", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412312883", "createdAt": "2020-04-21T16:37:27Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -94,29 +89,100 @@ public DefaultIndexingChain(DocumentsWriterPerThread docWriter) {\n     termsHash = new FreqProxTermsWriter(docWriter, termVectorsWriter);\n   }\n \n+  private LeafReader getDocValuesReader(int maxDoc) {\n+    return new DocValuesReader() {\n+      @Override\n+      public NumericDocValues getNumericDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.NUMERIC) {\n+          return (NumericDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n+          return (BinaryDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedDocValues getSortedDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n+          return (SortedDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED_NUMERIC) {\n+          return (SortedNumericDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n+          return (SortedSetDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public FieldInfos getFieldInfos() {\n+        return fieldInfos.finish();\n+      }\n+\n+      @Override\n+      public int maxDoc() {\n+        return maxDoc;\n+      }\n+    };\n+  }\n+\n   private Sorter.DocMap maybeSortSegment(SegmentWriteState state) throws IOException {\n     Sort indexSort = state.segmentInfo.getIndexSort();\n     if (indexSort == null) {\n       return null;\n     }\n \n-    List<Sorter.DocComparator> comparators = new ArrayList<>();\n+    LeafReader docValuesReader = getDocValuesReader(state.segmentInfo.maxDoc());\n+\n+    List<IndexSorter.DocComparator> comparators = new ArrayList<>();\n     for (int i = 0; i < indexSort.getSort().length; i++) {\n       SortField sortField = indexSort.getSort()[i];\n-      PerField perField = getPerField(sortField.getField());\n-      if (perField != null && perField.docValuesWriter != null &&\n-          finishedDocValues.contains(perField.fieldInfo.name) == false) {\n-          perField.docValuesWriter.finish(state.segmentInfo.maxDoc());\n-          Sorter.DocComparator cmp = perField.docValuesWriter.getDocComparator(state.segmentInfo.maxDoc(), sortField);\n-          comparators.add(cmp);\n-          finishedDocValues.add(perField.fieldInfo.name);\n-      } else {\n-        // safe to ignore, sort field with no values or already seen before\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      if (sorter == null) {\n+        throw new UnsupportedOperationException(\"Cannot sort index using sort field \" + sortField);\n       }\n+      comparators.add(sorter.getDocComparator(docValuesReader));\n     }\n     Sorter sorter = new Sorter(indexSort);\n     // returns null if the documents are already sorted\n-    return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new Sorter.DocComparator[comparators.size()]));\n+    return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new IndexSorter.DocComparator[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzc3MA==", "bodyText": "should it be an actual exception instead of an assertion? Or are we checking it up-front already?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412313770", "createdAt": "2020-04-21T16:38:54Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -527,45 +589,61 @@ private void indexPoint(PerField fp, IndexableField field) throws IOException {\n     fp.pointValuesWriter.addPackedValue(docState.docID, field.binaryValue());\n   }\n \n-  private void validateIndexSortDVType(Sort indexSort, String fieldName, DocValuesType dvType) {\n+  private void validateIndexSortDVType(Sort indexSort, String fieldToValidate, DocValuesType dvType) throws IOException {\n     for (SortField sortField : indexSort.getSort()) {\n-      if (sortField.getField().equals(fieldName)) {\n-        switch (dvType) {\n-          case NUMERIC:\n-            if (sortField.getType().equals(SortField.Type.INT) == false &&\n-                  sortField.getType().equals(SortField.Type.LONG) == false &&\n-                  sortField.getType().equals(SortField.Type.FLOAT) == false &&\n-                  sortField.getType().equals(SortField.Type.DOUBLE) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      assert sorter != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDM2NQ==", "bodyText": "when I first saw this class I thought it would be similar to DocValuesProducer, maybe rename to DocValuesLeafReader to clear potential confusion?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412314365", "createdAt": "2020-04-21T16:39:55Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesReader.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+\n+import org.apache.lucene.util.Bits;\n+\n+abstract class DocValuesReader extends LeafReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjk4Mg==", "bodyText": "make it lucene.internal?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412316982", "createdAt": "2020-04-21T16:44:03Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -392,4 +491,31 @@ public SortField rewrite(IndexSearcher searcher) throws IOException {\n   public boolean needsScores() {\n     return type == Type.SCORE;\n   }\n+\n+  /**\n+   * Returns an {@link IndexSorter} used for sorting index segments by this SortField.\n+   *\n+   * If the SortField cannot be used for index sorting (for example, if it uses scores or\n+   * other query-dependent values) then this method should return {@code null}\n+   *\n+   * SortFields that implement this method should also implement a constructor that\n+   * takes a {@link DataInput} for deserialization, to match the {@link IndexSorter#serialize(DataOutput)}\n+   * method on the returned IndexSorter\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzQ3Mg==", "bodyText": "maybe reuse the class name like we do for codecs, ie. SortField?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317472", "createdAt": "2020-04-21T16:44:48Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -120,6 +126,99 @@ public SortField(String field, Type type, boolean reverse) {\n     this.reverse = reverse;\n   }\n \n+  /** A SortFieldProvider for field sorts */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this Provider is registered under */\n+    public static final String NAME = \"field\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzU5MQ==", "bodyText": "maybe reuse the class name?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317591", "createdAt": "2020-04-21T16:44:58Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java", "diffHunk": "@@ -83,6 +89,80 @@ public SortedNumericSortField(String field, SortField.Type type, boolean reverse\n     this.type = type;\n   }\n \n+  /** A SortFieldProvider for this sort field */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"sortedNumericField\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzk3NQ==", "bodyText": "use the class name?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317975", "createdAt": "2020-04-21T16:45:32Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java", "diffHunk": "@@ -68,6 +72,54 @@ public SortedSetSortField(String field, boolean reverse, SortedSetSelector.Type\n     }\n     this.selector = selector;\n   }\n+\n+  /** A SortFieldProvider for this sort */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"sortedSetField\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxOTY3MQ==", "bodyText": "can it be package private?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412319671", "createdAt": "2020-04-21T16:47:46Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexSorter.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.LongValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.apache.lucene.util.packed.PackedInts;\n+\n+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;\n+\n+/**\n+ * Handles how documents should be sorted in an index, both within a segment and between\n+ * segments.\n+ *\n+ * Implementers must provide the following methods:\n+ * {@link #getDocComparator(LeafReader)} - an object that determines how documents within a segment are to be sorted\n+ * {@link #getComparableProviders(List)} - an array of objects that return a sortable long value per document and segment\n+ * {@link #serialize(DataOutput)} - how the sort should be written into the segment header\n+ * {@link #getProviderName()} - the SPI-registered name of a {@link SortFieldProvider} to deserialize the sort\n+ *\n+ * The companion {@link SortFieldProvider} should be registered with SPI via {@code META-INF/services}\n+ */\n+public interface IndexSorter {\n+\n+  /** Used for sorting documents across segments */\n+  public interface ComparableProvider {\n+    /**\n+     * Returns a long so that the natural ordering of long values matches the\n+     * ordering of doc IDs for the given comparator\n+     */\n+    long getAsComparableLong(int docID) throws IOException;\n+  }\n+\n+  /** A comparator of doc IDs, used for sorting documents within a segment */\n+  public interface DocComparator {\n+    /** Compare docID1 against docID2. The contract for the return value is the\n+     *  same as {@link Comparator#compare(Object, Object)}. */\n+    int compare(int docID1, int docID2);\n+  }\n+\n+  /**\n+   * Get an array of {@link ComparableProvider}, one per segment, for merge sorting documents in different segments\n+   * @param readers the readers to be merged\n+   */\n+  public abstract ComparableProvider[] getComparableProviders(List<? extends LeafReader> readers) throws IOException;\n+\n+  /**\n+   * Get a comparator that determines the sort order of docs within a single Reader.\n+   *\n+   * NB We cannot simply use the {@link FieldComparator} API because it requires docIDs to be sent\n+   * in-order. The default implementations allocate array[maxDoc] to hold native values for comparison,\n+   * but 1) they are transient (only alive while sorting this one segment) and 2) in the typical\n+   * index sorting case, they are only used to sort newly flushed segments, which will be smaller\n+   * than merged segments\n+   *\n+   * @param reader the Reader to sort\n+   */\n+  public abstract DocComparator getDocComparator(LeafReader reader) throws IOException;\n+\n+  /**\n+   * Serializes the parent SortField.  This is used to write Sort information into the Segment header\n+   *\n+   * @see SortFieldProvider#loadSortField(DataInput)\n+   */\n+  public abstract void serialize(DataOutput out) throws IOException;\n+\n+  /**\n+   * The SPI-registered name of a {@link SortFieldProvider} that will deserialize the parent SortField\n+   */\n+  public abstract String getProviderName();\n+\n+  /**\n+   * Provide a NumericDocValues instance for a LeafReader\n+   */\n+  public interface NumericDocValuesProvider {\n+    /**\n+     * Returns the NumericDocValues instance for this LeafReader\n+     */\n+    NumericDocValues get(LeafReader reader) throws IOException;\n+  }\n+\n+  /**\n+   * Provide a SortedDocValues instance for a LeafReader\n+   */\n+  public interface SortedDocValuesProvider {\n+    /**\n+     * Returns the SortedDocValues instance for this LeafReader\n+     */\n+    SortedDocValues get(LeafReader reader) throws IOException;\n+  }\n+\n+  /**\n+   * Serialize an object into a DataOutput\n+   */\n+  public interface Serializer {\n+    /** Serializes an object into a DataOutput */\n+    void serialize(DataOutput out) throws IOException;\n+  }\n+\n+  /**\n+   * Sorts documents based on integer values from a NumericDocValues instance\n+   */\n+  public static final class IntSorter implements IndexSorter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "303e38b76de8208261c6e1ee2b6dd219c1561f0a", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/303e38b76de8208261c6e1ee2b6dd219c1561f0a", "committedDate": "2020-04-22T08:20:14Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df302381100657e8591648f64d0590f16985972", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/7df302381100657e8591648f64d0590f16985972", "committedDate": "2020-04-22T09:35:25Z", "message": "feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODk3OTM5", "url": "https://github.com/apache/lucene-solr/pull/1440#pullrequestreview-398897939", "createdAt": "2020-04-23T08:58:44Z", "commit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo1ODo0NVrOGKejCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTozMjozN1rOGKgAJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzOTQzMg==", "bodyText": "you could use a package-info.java instead. We use the html version in backward-codecs because there are otherwise conflicts if the package also exists in core, but it looks like you removed the package from core here so we could use a package-info.java in backward-codecs?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413639432", "createdAt": "2020-04-23T08:58:45Z", "author": {"login": "jpountz"}, "path": "lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene70/package.html", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+<html>\n+<head>\n+  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n+</head>\n+<body>\n+Lucene 7.0 file format.\n+</body>\n+</html>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NzQxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private LeafReader getDocValuesReader(int maxDoc) {\n          \n          \n            \n              private LeafReader getDocValuesLeafReader(int maxDoc) {", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413647416", "createdAt": "2020-04-23T09:09:59Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -94,29 +89,100 @@ public DefaultIndexingChain(DocumentsWriterPerThread docWriter) {\n     termsHash = new FreqProxTermsWriter(docWriter, termVectorsWriter);\n   }\n \n+  private LeafReader getDocValuesReader(int maxDoc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MTY5Mg==", "bodyText": "I'd have a slight preferenrece for throwing an UOE here, would it work?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413651692", "createdAt": "2020-04-23T09:16:08Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -527,45 +589,63 @@ private void indexPoint(PerField fp, IndexableField field) throws IOException {\n     fp.pointValuesWriter.addPackedValue(docState.docID, field.binaryValue());\n   }\n \n-  private void validateIndexSortDVType(Sort indexSort, String fieldName, DocValuesType dvType) {\n+  private void validateIndexSortDVType(Sort indexSort, String fieldToValidate, DocValuesType dvType) throws IOException {\n     for (SortField sortField : indexSort.getSort()) {\n-      if (sortField.getField().equals(fieldName)) {\n-        switch (dvType) {\n-          case NUMERIC:\n-            if (sortField.getType().equals(SortField.Type.INT) == false &&\n-                  sortField.getType().equals(SortField.Type.LONG) == false &&\n-                  sortField.getType().equals(SortField.Type.FLOAT) == false &&\n-                  sortField.getType().equals(SortField.Type.DOUBLE) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      if (sorter == null) {\n+        throw new IllegalStateException(\"Cannot sort index with sort order \" + sortField);\n+      }\n+      sorter.getDocComparator(new DocValuesLeafReader() {\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.NUMERIC) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be NUMERIC but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptyNumeric();\n+        }\n \n-          case BINARY:\n-            throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.BINARY) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be BINARY but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptyBinary();\n+        }\n \n-          case SORTED:\n-            if (sortField.getType().equals(SortField.Type.STRING) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySorted();\n+        }\n \n-          case SORTED_NUMERIC:\n-            if (sortField instanceof SortedNumericSortField == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED_NUMERIC) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED_NUMERIC but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySortedNumeric(0);\n+        }\n \n-          case SORTED_SET:\n-            if (sortField instanceof SortedSetSortField == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED_SET) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED_SET but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySortedSet();\n+        }\n \n-          default:\n-            throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n+        @Override\n+        public FieldInfos getFieldInfos() {\n+          throw new UnsupportedOperationException();\n         }\n-        break;\n-      }\n+\n+        @Override\n+        public int maxDoc() {\n+          return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NjIwMA==", "bodyText": "javadocs?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413656200", "createdAt": "2020-04-23T09:22:36Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortFieldProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.NamedSPILoader;\n+\n+/**\n+ * Reads a named SortField from a segment info file, used to record index sorts\n+ */\n+public abstract class SortFieldProvider implements NamedSPILoader.NamedSPI {\n+\n+  private static class Holder {\n+    private static final NamedSPILoader<SortFieldProvider> LOADER = new NamedSPILoader<>(SortFieldProvider.class);\n+\n+    static NamedSPILoader<SortFieldProvider> getLoader() {\n+      if (LOADER == null) {\n+        throw new IllegalStateException(\"You tried to lookup a SortFieldProvider by name before all SortFieldProviders could be initialized. \"+\n+            \"This likely happens if you call SortFieldProvider#forName from a SortFieldProviders's ctor.\");\n+      }\n+      return LOADER;\n+    }\n+  }\n+\n+  /**\n+   * Looks up a SortFieldProvider by name\n+   */\n+  public static SortFieldProvider forName(String name) {\n+    return Holder.getLoader().lookup(name);\n+  }\n+\n+  /**\n+   * Lists all available SortFieldProviders\n+   */\n+  public static Set<String> availableSortFieldProviders() {\n+    return Holder.getLoader().availableServices();\n+  }\n+\n+  /**\n+   * Reloads the SortFieldProvider list from the given {@link ClassLoader}.\n+   * Changes to the list are visible after the method ends, all\n+   * iterators ({@link #availableSortFieldProviders()} ()},...) stay consistent.\n+   *\n+   * <p><b>NOTE:</b> Only new SortFieldProviders are added, existing ones are\n+   * never removed or replaced.\n+   *\n+   * <p><em>This method is expensive and should only be called for discovery\n+   * of new SortFieldProviders on the given classpath/classloader!</em>\n+   */\n+  public static void reloadSortFieldProviders(ClassLoader classLoader) {\n+    Holder.getLoader().reload(classLoader);\n+  }\n+\n+  public static void serialize(SortField sf, DataOutput output) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NjYxNw==", "bodyText": "javadocs?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413656617", "createdAt": "2020-04-23T09:23:13Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortFieldProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.NamedSPILoader;\n+\n+/**\n+ * Reads a named SortField from a segment info file, used to record index sorts\n+ */\n+public abstract class SortFieldProvider implements NamedSPILoader.NamedSPI {\n+\n+  private static class Holder {\n+    private static final NamedSPILoader<SortFieldProvider> LOADER = new NamedSPILoader<>(SortFieldProvider.class);\n+\n+    static NamedSPILoader<SortFieldProvider> getLoader() {\n+      if (LOADER == null) {\n+        throw new IllegalStateException(\"You tried to lookup a SortFieldProvider by name before all SortFieldProviders could be initialized. \"+\n+            \"This likely happens if you call SortFieldProvider#forName from a SortFieldProviders's ctor.\");\n+      }\n+      return LOADER;\n+    }\n+  }\n+\n+  /**\n+   * Looks up a SortFieldProvider by name\n+   */\n+  public static SortFieldProvider forName(String name) {\n+    return Holder.getLoader().lookup(name);\n+  }\n+\n+  /**\n+   * Lists all available SortFieldProviders\n+   */\n+  public static Set<String> availableSortFieldProviders() {\n+    return Holder.getLoader().availableServices();\n+  }\n+\n+  /**\n+   * Reloads the SortFieldProvider list from the given {@link ClassLoader}.\n+   * Changes to the list are visible after the method ends, all\n+   * iterators ({@link #availableSortFieldProviders()} ()},...) stay consistent.\n+   *\n+   * <p><b>NOTE:</b> Only new SortFieldProviders are added, existing ones are\n+   * never removed or replaced.\n+   *\n+   * <p><em>This method is expensive and should only be called for discovery\n+   * of new SortFieldProviders on the given classpath/classloader!</em>\n+   */\n+  public static void reloadSortFieldProviders(ClassLoader classLoader) {\n+    Holder.getLoader().reload(classLoader);\n+  }\n+\n+  public static void serialize(SortField sf, DataOutput output) throws IOException {\n+    IndexSorter sorter = sf.getIndexSorter();\n+    if (sorter == null) {\n+      throw new IllegalArgumentException(\"Cannot serialize sort field \" + sf);\n+    }\n+    SortFieldProvider provider = SortFieldProvider.forName(sorter.getProviderName());\n+    provider.writeSortField(sf, output);\n+  }\n+\n+  /** The name this SortFieldProvider is registered under */\n+  protected final String name;\n+\n+  /**\n+   * Creates a new SortFieldProvider.\n+   * <p>\n+   * The provided name will be written into the index segment: in order to\n+   * for the segment to be read this class should be registered with Java's\n+   * SPI mechanism (registered in META-INF/ of your jar file, etc).\n+   * @param name must be all ascii alphanumeric, and less than 128 characters in length.\n+   */\n+  protected SortFieldProvider(String name) {\n+    this.name = name;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return name;\n+  }\n+\n+  /**\n+   * Loads a SortField from serialized bytes\n+   */\n+  public abstract SortField loadSortField(DataInput in) throws IOException;\n+\n+  public abstract void writeSortField(SortField sf, DataOutput out) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NzQ5Ng==", "bodyText": "I wonder if there are undesired consequences of dropping this?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413657496", "createdAt": "2020-04-23T09:24:29Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortedDocValuesWriter.java", "diffHunk": "@@ -79,11 +78,6 @@ public void addValue(int docID, BytesRef value) {\n     lastDocID = docID;\n   }\n \n-  @Override\n-  public void finish(int maxDoc) {\n-    updateBytesUsed();\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df302381100657e8591648f64d0590f16985972"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY2MzI3MA==", "bodyText": "I suggested it because I was seeing your change as a cleanup to the way that we support configuring index sorts. experimental would work for me too, what I like is to signal users that we feel free to make breaking changes to these APIs.", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413663270", "createdAt": "2020-04-23T09:32:37Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -392,4 +491,31 @@ public SortField rewrite(IndexSearcher searcher) throws IOException {\n   public boolean needsScores() {\n     return type == Type.SCORE;\n   }\n+\n+  /**\n+   * Returns an {@link IndexSorter} used for sorting index segments by this SortField.\n+   *\n+   * If the SortField cannot be used for index sorting (for example, if it uses scores or\n+   * other query-dependent values) then this method should return {@code null}\n+   *\n+   * SortFields that implement this method should also implement a constructor that\n+   * takes a {@link DataInput} for deserialization, to match the {@link IndexSorter#serialize(DataOutput)}\n+   * method on the returned IndexSorter\n+   */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjk4Mg=="}, "originalCommit": {"oid": "247ef622e51476a882a8f7cf706968f339d04813"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7103b98018a08ac00f7379f6ab959f16554b2b07", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/7103b98018a08ac00f7379f6ab959f16554b2b07", "committedDate": "2020-04-23T10:00:01Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18d83686caf6ce31e5d658ec39d07de4e383d35b", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/18d83686caf6ce31e5d658ec39d07de4e383d35b", "committedDate": "2020-04-23T11:17:01Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b608eb5821b5e9d81c9ec737188f08a07aa4041", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/3b608eb5821b5e9d81c9ec737188f08a07aa4041", "committedDate": "2020-04-23T11:34:26Z", "message": "Add CHANGES"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "063fa710a3aabad9ca2e11c8d98c983487567a7d", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/063fa710a3aabad9ca2e11c8d98c983487567a7d", "committedDate": "2020-04-23T13:08:13Z", "message": "Add test for backwards-codecs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bc533cbbdf7467137fb0ed2d866827851c9f251", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/0bc533cbbdf7467137fb0ed2d866827851c9f251", "committedDate": "2020-04-24T11:31:33Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "082b2ced58d316def6c2f3099ae180a447682569", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/082b2ced58d316def6c2f3099ae180a447682569", "committedDate": "2020-04-24T11:36:56Z", "message": "Pass maxDoc directly to IndexSorter.getDocComparator()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f160e01549648548e8a23200fbc5a81105d1179a", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/f160e01549648548e8a23200fbc5a81105d1179a", "committedDate": "2020-04-24T12:28:07Z", "message": "package-info.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e5f1e0773a6dd90a6d8801dd707653272f246a3", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/6e5f1e0773a6dd90a6d8801dd707653272f246a3", "committedDate": "2020-05-05T13:41:42Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "135ca9958a33afd6892bc6e4c2822ff39917b166", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/135ca9958a33afd6892bc6e4c2822ff39917b166", "committedDate": "2020-05-07T10:46:57Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1", "committedDate": "2020-05-07T11:04:31Z", "message": "Don't call back to reader.maxDoc()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19801ee084887203803f99c41b98641bd885656c", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/19801ee084887203803f99c41b98641bd885656c", "committedDate": "2020-05-07T13:42:27Z", "message": "Revert \"Don't call back to reader.maxDoc()\"\n\nThis reverts commit 240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f38d0e4c474d9bcf4fb021973c4aeb98302c9ac9", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/f38d0e4c474d9bcf4fb021973c4aeb98302c9ac9", "committedDate": "2020-05-07T13:42:33Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "578ce8e47e258e169ac9f51a9130413e7a8fb922", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/578ce8e47e258e169ac9f51a9130413e7a8fb922", "committedDate": "2020-05-07T13:47:03Z", "message": "Compilation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjgyNDQx", "url": "https://github.com/apache/lucene-solr/pull/1440#pullrequestreview-413282441", "createdAt": "2020-05-18T05:36:31Z", "commit": {"oid": "578ce8e47e258e169ac9f51a9130413e7a8fb922"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTozNjozMVrOGWoFkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTozNzowMlrOGWoF-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODY0MQ==", "bodyText": "Can we look into not using enum ordinals for serialization? It makes something that looks as harmless as reordering an enum cause backward-compatibility breaks. E.g. maybe we could have a mapping between Type constants and int IDs as a constant on this class?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r426378641", "createdAt": "2020-05-18T05:36:31Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -120,6 +126,104 @@ public SortField(String field, Type type, boolean reverse) {\n     this.reverse = reverse;\n   }\n \n+  /** A SortFieldProvider for field sorts */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this Provider is registered under */\n+    public static final String NAME = \"SortField\";\n+\n+    /** Creates a new Provider */\n+    public Provider() {\n+      super(NAME);\n+    }\n+\n+    @Override\n+    public SortField readSortField(DataInput in) throws IOException {\n+      SortField sf = new SortField(in.readString(), readType(in), in.readInt() == 1);\n+      if (in.readInt() == 1) {\n+        // missing object\n+        switch (sf.type) {\n+          case STRING:\n+            int missingString = in.readInt();\n+            if (missingString == 1) {\n+              sf.setMissingValue(STRING_FIRST);\n+            }\n+            else {\n+              sf.setMissingValue(STRING_LAST);\n+            }\n+            break;\n+          case INT:\n+            sf.setMissingValue(in.readInt());\n+            break;\n+          case LONG:\n+            sf.setMissingValue(in.readLong());\n+            break;\n+          case FLOAT:\n+            sf.setMissingValue(NumericUtils.sortableIntToFloat(in.readInt()));\n+            break;\n+          case DOUBLE:\n+            sf.setMissingValue(NumericUtils.sortableLongToDouble(in.readLong()));\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Cannot deserialize sort of type \" + sf.type);\n+        }\n+      }\n+      return sf;\n+    }\n+\n+    @Override\n+    public void writeSortField(SortField sf, DataOutput out) throws IOException {\n+      sf.serialize(out);\n+    }\n+  }\n+\n+  protected static Type readType(DataInput in) throws IOException {\n+    int type = in.readInt();\n+    if (type >= Type.values().length) {\n+      throw new IllegalArgumentException(\"Can't deserialize SortField - unknown type \" + type);\n+    }\n+    return Type.values()[type];\n+  }\n+\n+  private void serialize(DataOutput out) throws IOException {\n+    out.writeString(field);\n+    out.writeInt(type.ordinal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578ce8e47e258e169ac9f51a9130413e7a8fb922"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODc0Ng==", "bodyText": "same here?", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r426378746", "createdAt": "2020-05-18T05:37:02Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java", "diffHunk": "@@ -83,6 +89,86 @@ public SortedNumericSortField(String field, SortField.Type type, boolean reverse\n     this.type = type;\n   }\n \n+  /** A SortFieldProvider for this sort field */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"SortedNumericSortField\";\n+\n+    /** Creates a new Provider */\n+    public Provider() {\n+      super(NAME);\n+    }\n+\n+    @Override\n+    public SortField readSortField(DataInput in) throws IOException {\n+      SortedNumericSortField sf = new SortedNumericSortField(in.readString(), readType(in), in.readInt() == 1, readSelectorType(in));\n+      if (in.readInt() == 1) {\n+        switch (sf.type) {\n+          case INT:\n+            sf.setMissingValue(in.readInt());\n+            break;\n+          case LONG:\n+            sf.setMissingValue(in.readLong());\n+            break;\n+          case FLOAT:\n+            sf.setMissingValue(NumericUtils.sortableIntToFloat(in.readInt()));\n+            break;\n+          case DOUBLE:\n+            sf.setMissingValue(NumericUtils.sortableLongToDouble(in.readLong()));\n+            break;\n+          default:\n+            throw new AssertionError();\n+        }\n+      }\n+      return sf;\n+    }\n+\n+    @Override\n+    public void writeSortField(SortField sf, DataOutput out) throws IOException {\n+      assert sf instanceof SortedNumericSortField;\n+      ((SortedNumericSortField)sf).serialize(out);\n+    }\n+  }\n+\n+  private static SortedNumericSelector.Type readSelectorType(DataInput in) throws IOException {\n+    int selectorType = in.readInt();\n+    if (selectorType >= SortedNumericSelector.Type.values().length) {\n+      throw new IllegalArgumentException(\"Can't deserialize SortedNumericSortField - unknown selector type \" + selectorType);\n+    }\n+    return SortedNumericSelector.Type.values()[selectorType];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "578ce8e47e258e169ac9f51a9130413e7a8fb922"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e290bb0feb218d1ff299d6fb7191c3628204c122", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/e290bb0feb218d1ff299d6fb7191c3628204c122", "committedDate": "2020-05-22T09:27:36Z", "message": "Merge remote-tracking branch 'origin/master' into sorts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a1548c61447a5913ec2f89f7c66dc01c3cb0858", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/1a1548c61447a5913ec2f89f7c66dc01c3cb0858", "committedDate": "2020-05-22T10:27:10Z", "message": "Serialize sortfield types as strings rather than ords"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2114, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}