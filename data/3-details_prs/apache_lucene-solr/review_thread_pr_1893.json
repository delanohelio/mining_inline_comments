{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NjAyODMw", "number": 1893, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyMzoxMFrOEmRQ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToyNDoxMlrOEnGR4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY0MTg1OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyMzoxMFrOHWM43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDo1Mzo1OVrOHWROmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MTg4Ng==", "bodyText": "Hmm let's upgrade this to a real if not an assert (that requires that assertions are enabled), and change to throw IllegalArgumentException?  In general if it is a problem that a user could legitimately trip up on, it should be a real if, as long as performance impact of such micro-policing is acceptable (which should be the case here).", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493041886", "createdAt": "2020-09-22T21:23:10Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMjk4NQ==", "bodyText": "Changed in the next revision.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493112985", "createdAt": "2020-09-23T00:53:59Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MTg4Ng=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY0MzkwOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyMzo1OVrOHWM6Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDo1NTo0OFrOHWRQqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MjI1MQ==", "bodyText": "This one is a good usage of assert because this should only be violated if there is a bug in this code or our default Codec, etc.  No accidental abuse by users could cause this.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042251", "createdAt": "2020-09-22T21:23:59Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMzUxMg==", "bodyText": "Got it thanks for explaining appropriate usage of assert and IlegalArgumentException", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493113512", "createdAt": "2020-09-23T00:55:48Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MjI1MQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY0Nzk0OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNToyM1rOHWM8rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDo1ODoxN1rOHWRTGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mjg2MQ==", "bodyText": "Can we add a Note here, that the returned FacetLabel are not necessarily in the same order in which they were indexed?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042861", "createdAt": "2020-09-22T21:25:23Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNDEzOQ==", "bodyText": "done in next revision", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493114139", "createdAt": "2020-09-23T00:58:17Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mjg2MQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY0OTAzOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNTo0NFrOHWM9SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDo1ODozM1rOHWRTYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzAxNw==", "bodyText": "Add same Note here as above comment?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043017", "createdAt": "2020-09-22T21:25:44Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNDIwOA==", "bodyText": "done in next revision", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493114208", "createdAt": "2020-09-23T00:58:33Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzAxNw=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY1MDcxOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNjoyMVrOHWM-UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToxMToyMlrOHWRgUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzI4MA==", "bodyText": "Can we upgrade this to a real if?  Caller might legitimately pass in a non-existing facetDimension?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043280", "createdAt": "2020-09-22T21:26:21Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzUyMg==", "bodyText": "done in next revision.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493117522", "createdAt": "2020-09-23T01:11:22Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzI4MA=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY2Nzc0OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozMjoxM1rOHWNIvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo0Nzo1MVrOHWSsog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTk1MA==", "bodyText": "Ahh, be careful here!  Lucene's test-framework sometimes randomly runs without assertions enabled, to help us catch bugs where we accidentally create code relying on assertions (it has happened, do not ask who).\nSo when tests run with assertions disabled then this test would false-fail?  But, if we upgrade to real if that would also fix this.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493045950", "createdAt": "2020-09-22T21:32:13Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {\n+    Directory dir = newDirectory();\n+    Directory taxoDir = newDirectory();\n+\n+    // Writes facet ords to a separate directory from the main index:\n+    DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir, IndexWriterConfig.OpenMode.CREATE);\n+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n+\n+    FacetsConfig config = new FacetsConfig();\n+    config.setHierarchical(\"Publish Date\", true);\n+\n+    for (Document doc : prepareDocuments()) {\n+      writer.addDocument(config.build(taxoWriter, doc));\n+    }\n+\n+    // NRT open\n+    IndexSearcher searcher = newSearcher(writer.getReader());\n+    // NRT open\n+    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);\n+\n+    FacetsCollector fc = new FacetsCollector();\n+    searcher.search(new MatchAllDocsQuery(), fc);\n+\n+    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n+\n+    // Check labels for all dimensions\n+    List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n+    assertTrue(facetLabels.size() == 10);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Author\".equals(l.components[0]))\n+        .map(l -> l.components[1]).collect(Collectors.toSet())\n+        .equals(Set.of(\"Bob\", \"Lisa\", \"Susan\", \"Frank\", \"Tom\")));\n+\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    // Check labels for specific dimension\n+    facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), \"Publish Date\");\n+    assertTrue(facetLabels.size() == 5);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    try {\n+      facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), null, true);\n+      fail(\"Assertion error was not thrown for using docIds supplied in decreasing order\");\n+    } catch (AssertionError ae) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzNzA1OA==", "bodyText": "Nice catch, I changed the implementation of nextFacetLabel(...) methods to throw IllegalArgumentException should docIds be supplied in decreasing order and updated this test to expect an IllegalArgumentException when docIds are supplied in decreasing order.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493137058", "createdAt": "2020-09-23T01:47:51Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {\n+    Directory dir = newDirectory();\n+    Directory taxoDir = newDirectory();\n+\n+    // Writes facet ords to a separate directory from the main index:\n+    DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir, IndexWriterConfig.OpenMode.CREATE);\n+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n+\n+    FacetsConfig config = new FacetsConfig();\n+    config.setHierarchical(\"Publish Date\", true);\n+\n+    for (Document doc : prepareDocuments()) {\n+      writer.addDocument(config.build(taxoWriter, doc));\n+    }\n+\n+    // NRT open\n+    IndexSearcher searcher = newSearcher(writer.getReader());\n+    // NRT open\n+    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);\n+\n+    FacetsCollector fc = new FacetsCollector();\n+    searcher.search(new MatchAllDocsQuery(), fc);\n+\n+    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n+\n+    // Check labels for all dimensions\n+    List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n+    assertTrue(facetLabels.size() == 10);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Author\".equals(l.components[0]))\n+        .map(l -> l.components[1]).collect(Collectors.toSet())\n+        .equals(Set.of(\"Bob\", \"Lisa\", \"Susan\", \"Frank\", \"Tom\")));\n+\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    // Check labels for specific dimension\n+    facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), \"Publish Date\");\n+    assertTrue(facetLabels.size() == 5);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    try {\n+      facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), null, true);\n+      fail(\"Assertion error was not thrown for using docIds supplied in decreasing order\");\n+    } catch (AssertionError ae) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTk1MA=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY3NTMyOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozNDo0OFrOHWNNNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMToyMToyM1rOHYTDvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ==", "bodyText": "Hmm when we switch to BinaryDocValues for this lookup, we could fix this class to persistently hold a single BinaryDocValues, and improve performance for caller that need to look up multiple ordinals, which is the common case.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047095", "createdAt": "2020-09-22T21:34:48Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0ODI5Mw==", "bodyText": "By this class you mean TaxonomyReader because that is where BinaryDocValues will be cached as part of LUCENE-9476 improving performance for callers that need to lookup multiple ordinals ?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493148293", "createdAt": "2020-09-23T02:05:17Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NTYxMA==", "bodyText": "Hmm, I was thinking this new per-segment class (FacetLabelReader) would hold onto a single BinaryDocValues instance, but you're right, that won't work.\nThe facet ordinals are stored / compacted in sorted order in a single BinaryDocValues field which we decode here into decodedOrds.  Resolving those ordinals to FacetLabel is costly, currently retrieving one stored document per ord.  After LUCENE-9450 (switching from stored fields to BDV), we could pull a new BDV for each unique docId passed to nextFacetLabel, and then bulk resolve all the ordinals?\nAnyway, we can pursue all of this later -- this PR already looks awesome -- progress not perfection!", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494395610", "createdAt": "2020-09-24T15:07:07Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3NTAwMA==", "bodyText": "The new per-segment class (FacetLabelReader) holds an instance of DocValuesOrdinalsReader which internally holds a reusable instance of BinaryDocValues.\nIn the nextFacetLabel() method ordinalsSegmentReader.get(docId, decodedOrds) that does the actual decoding of the ordinals is only called once if the input docId is the same as the one supplied in prior invocation of nextFacetLabel().\nSubsequent invocations fetch the ordinals from FacetLabelReader.decodedOrds and use the ordinal to lookup FacetLabels using taxoReader.getPath(ord).\nYes, after LUCENE-9450, we can bulk resolve all the ordinals using a different API, something like -> List<FacetLabels> taxoReader.getPaths(IntRef decodedOrds) and add a new API - FacetLabelReader.allFacetLabels(int docId)", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494675000", "createdAt": "2020-09-25T00:04:36Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDEyNw==", "bodyText": "Yeah, or we could bulk map all ord -> FacetLabel as soon as caller goes to the next docId, and then iterate them one by one with this API.\nAnyway, we don't need to solve that here.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240127", "createdAt": "2020-09-25T21:21:23Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY3ODA3OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozNTozNFrOHWNOuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMTo1ODo1M1rOHXCcYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzQ4MA==", "bodyText": "Could we make a small change to an existing randomized test, maybe TestTaxonomyFacetCounts.testRandom, to use this API to randomly retrieve N facet labels?  (So we exercise the class beyond the simplish testBasic ... maybe we uncover a rare bug, somewhere).", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047480", "createdAt": "2020-09-22T21:35:34Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxOTMyOQ==", "bodyText": "Done in this revision", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493919329", "createdAt": "2020-09-23T21:58:53Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzQ4MA=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDI2NzEzOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxMTowNFrOHXfsYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMjo1NjoxMFrOHXvUXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODU2MA==", "bodyText": "Thank you for adding this utility method so tests can easily use the new utility class!\nCan we rename this to getAllTaxonomyFacetLabels, and add javadoc explaining that the outer list is one entry per matched hit, and the inner list is one entry per FacetLabel belonging to that hit?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494398560", "createdAt": "2020-09-24T15:11:04Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java", "diffHunk": "@@ -56,6 +60,28 @@ public Facets getTaxonomyFacetCounts(TaxonomyReader taxoReader, FacetsConfig con\n     return facets;\n   }\n \n+  public List<List<FacetLabel>> getTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, FacetsCollector fc) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NDU1OQ==", "bodyText": "done in the next revision.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494654559", "createdAt": "2020-09-24T22:56:10Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java", "diffHunk": "@@ -56,6 +60,28 @@ public Facets getTaxonomyFacetCounts(TaxonomyReader taxoReader, FacetsConfig con\n     return facets;\n   }\n \n+  public List<List<FacetLabel>> getTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, FacetsCollector fc) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODU2MA=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDI3OTU1OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxMzo0OFrOHXf0Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMjo1OToyN1rOHXvYPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMDUxNQ==", "bodyText": "Hmm why are these null checks necessary?  Are we really seeing null in the argument?  Oh, I guess this legitimately happens when the hit had no facets?  Maybe add a comment?  Hmm, actually, looking at how actual and expected are populated, neither of them seems to add null?  One of them filters out empty list but the other does not?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494400515", "createdAt": "2020-09-24T15:13:48Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {\n+      if (o1 == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NTU0OQ==", "bodyText": "Thanks for catching this @mikemccand. I fixed the actualLabels to exclude empty lists. The null checks were just me being extra cautious. I realized they were unnecessary and removed them :-)", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494655549", "createdAt": "2020-09-24T22:59:27Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {\n+      if (o1 == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMDUxNQ=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDI5MjM3OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxNjoyNFrOHXf7xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzozMDoxOFrOHXv95A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMjUwMQ==", "bodyText": "I'm confused why we are sorting the top list?  Isn't the top list in order of the hits?  And we want to confirm, for a given docId hit, that expected and actual labels match?\nOK, I think I understand: this test does not index anything allowing you to track which original doc mapped to which FacetLabel, so then you cannot know, per segment, which docs ended up where :)\nGiven that, I think it's OK to do the top-level sort of all List<FacetLabel> across all hits.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494402501", "createdAt": "2020-09-24T15:16:24Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2NTE4OA==", "bodyText": "Yes, a document with Nth position in the input sequence might end up with Kth docId in a random segment making it harder to compare actual and expected labels.\nThanks for confirming that the approach is acceptable.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494665188", "createdAt": "2020-09-24T23:30:18Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMjUwMQ=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDMyODAzOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToyNDoxMlrOHXgSLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDozMTozNlrOHYZSlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA==", "bodyText": "Hmm I think expectedLabels filters out empty List<FacetLabel> but actualLabels does not, so this might false trip?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494408238", "createdAt": "2020-09-24T15:24:12Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNzI2OQ==", "bodyText": "Nice catch, thanks.  I fixed actualLabels generation in FacetTestCase.getAllTaxonomyFacetLabels() method to filter out empty List<facetLabels>.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494637269", "createdAt": "2020-09-24T22:06:37Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDY2MQ==", "bodyText": "Hmm I don't like filtering out \"no facet fields\" case from FacetTestCase.getAllTaxonomyFacetLabels() -- that means callers cannot safely map hits to the List<FacetLabel>?\nCould we instead keep the empty lists in both expected and actual?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240661", "createdAt": "2020-09-25T21:22:34Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0MjIyOA==", "bodyText": "Done. I made changes to keep empty lists in both expectedLabels and actualLabels and also updated javadoc for FacetTestCase.getAllTaxonomyFacetLabels() to reflect this for actualLabels", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495342228", "createdAt": "2020-09-26T00:31:36Z", "author": {"login": "goankur"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1234, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}