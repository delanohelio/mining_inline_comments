{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NzEwMTI5", "number": 1686, "title": "SOLR-13528: Implement Request Rate Limiters", "bodyText": "This commit introduces two functionalities: request rate limiting and ability to identify requests based on type (indexing, search, admin). The default rate limiter rate limits query requests based on configurable parameters which can be set in web.xml. Note that this rate limiting works at a JVM level, not a core/collection level.", "createdAt": "2020-07-21T19:47:32Z", "url": "https://github.com/apache/lucene-solr/pull/1686", "merged": true, "mergeCommit": {"oid": "a074418da0d03b6beff2ca4199660c04f6348dfb"}, "closed": true, "closedAt": "2020-08-07T20:06:07Z", "author": {"login": "atris"}, "timelineItems": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4LUSCgFqTQ1NTE5NDM3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8p4jYgH2gAyNDU0NzEwMTI5OjBkMmY4OGQxOGFmNjRmYjA0NmE5NDk5ODZjOTlhMjlhZTYxYjExNTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTk0Mzc3", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-455194377", "createdAt": "2020-07-24T21:26:24Z", "commit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMToyNjoyNFrOG2-MdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMTo1Njo0NlrOG2-zUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NTI4NQ==", "bodyText": "nit: use <> instead of explicit types.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460295285", "createdAt": "2020-07-24T21:26:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= 10;\n+  public final static long DEFAULT_EXPIRATION_TIME_INMS = 300;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<String, RequestRateLimiter>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NTkyMA==", "bodyText": "Unused.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460295920", "createdAt": "2020-07-24T21:28:10Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();\n+  }\n+\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+\n+    if (!rateLimiterConfig.isEnabled) {\n+      return true;\n+    }\n+\n+    boolean accepted = allowedConcurrentRequests.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS);\n+\n+    if (!accepted) {\n+      AsyncContext asyncContext = request.startAsync();\n+      AsyncListener asyncListener = buildAsyncListener();\n+\n+      if (rateLimiterConfig.requestExpirationTimeInMS > 0) {\n+        asyncContext.setTimeout(rateLimiterConfig.requestExpirationTimeInMS);\n+      }\n+\n+      asyncContext.addListener(asyncListener);\n+      listenerQueue.add(asyncListener);\n+      waitQueue.add(asyncContext);\n+    }\n+\n+    return accepted;\n+  }\n+\n+  public boolean resumePendingOperation() {\n+    AsyncContext asyncContext = waitQueue.poll();\n+\n+    if (asyncContext != null) {\n+      try {\n+        asyncContext.dispatch();\n+        return true;\n+      }\n+      catch (IllegalStateException x) {\n+        if (log.isWarnEnabled()) {\n+          String errorMessage = x.getMessage();\n+          log.warn(errorMessage);\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  public void decrementConcurrentRequests() {\n+    allowedConcurrentRequests.release();\n+  }\n+\n+  public void close() {\n+    while (!waitQueue.isEmpty()) {\n+      AsyncContext asyncContext = waitQueue.poll();\n+\n+      asyncContext.complete();\n+    }\n+\n+    listenerQueue.clear();\n+  }\n+\n+  private AsyncListener buildAsyncListener() {\n+    return new AsyncListener() {\n+      @Override\n+      public void onComplete(AsyncEvent asyncEvent) throws IOException {\n+\n+      }\n+\n+      @Override\n+      public void onTimeout(AsyncEvent asyncEvent) throws IOException {\n+        AsyncContext asyncContext = asyncEvent.getAsyncContext();\n+\n+        if (!waitQueue.remove(asyncContext)) {\n+          return;\n+        }\n+\n+        HttpServletResponse servletResponse = ((HttpServletResponse)asyncEvent.getSuppliedResponse());\n+        String responseMessage = \"Too many requests for this request type.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NjI4Nw==", "bodyText": "We never poll this queue, what is it used for?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460296287", "createdAt": "2020-07-24T21:29:12Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODE3OA==", "bodyText": "should this be in the finally block instead?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460298178", "createdAt": "2020-07-24T21:34:39Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -331,6 +338,10 @@ public void close() {\n           metricManager = null;\n         }\n       }\n+\n+      if (rateLimitManager != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODI4OA==", "bodyText": "SolrException or SolrServerException probably", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460298288", "createdAt": "2020-07-24T21:34:59Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +389,16 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5OTM2MA==", "bodyText": "I'm confused as to why this exists. If a query request completes, why does that mean that we have room for an update request now?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460299360", "createdAt": "2020-07-24T21:38:17Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= 10;\n+  public final static long DEFAULT_EXPIRATION_TIME_INMS = 300;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<String, RequestRateLimiter>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+\n+  // NOTE: It is upto specific rate limiter implementation to handle queuing of rejected requests.\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    return requestRateLimiter.handleRequest(request);\n+  }\n+\n+  // Resume a pending request from one of the registered rate limiters.\n+  // The current model is round robin -- iterate over the list and get a pending request and resume it.\n+\n+  // TODO: This should be a priority queue based model\n+  public void resumePendingRequest(HttpServletRequest request) {\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    RequestRateLimiter previousRequestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (previousRequestRateLimiter == null) {\n+      // No rate limiter for this request type\n+      return;\n+    }\n+\n+    // Give preference to the previous request's rate limiter\n+    if (previousRequestRateLimiter.resumePendingOperation()) {\n+      return;\n+    }\n+\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMTkzNw==", "bodyText": "This seems trivial to forge. Can we tie this into the authentication code paths somehow so that we can really trust that the request is coming from a server instead of just some application claiming to be a server?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460301937", "createdAt": "2020-07-24T21:46:09Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -358,7 +358,11 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n     if (parser == null) {\n       parser = this.parser;\n     }\n-    \n+\n+    Header[] contextHeaders = new Header[2];\n+    contextHeaders[0] = new BasicHeader(CommonParams.SOLR_REQUEST_CONTEXT_PARAM, getContext().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMjQ4OQ==", "bodyText": "Is there anywhere else that we can configure this? I thought the trend was to move away from putting things in web.xml as much as possible.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460302489", "createdAt": "2020-07-24T21:47:58Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are automatically queued asynchronously with\n+a configurable timeout.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMjc5Mg==", "bodyText": "This is a maximum number for the JVM? Not collection or core specific? 10 seems like a very low default.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460302792", "createdAt": "2020-07-24T21:49:01Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are automatically queued asynchronously with\n+a configurable timeout.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is 10.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMjk2Nw==", "bodyText": "What does a value of 0 mean?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460302967", "createdAt": "2020-07-24T21:49:42Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are automatically queued asynchronously with\n+a configurable timeout.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is 10.\n+[source,xml]\n+----\n+<param-name>maxQueryRequests</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>15</param-value>\n+----\n+\n+==== Request Slot Allocation Wait Time\n+Wait time in ms for which a request will wait for a slot to be available when all slots are full,\n+before the request is put into the wait queue. This allows requests to have a chance to proceed if\n+the unavailability of the request slots for this rate limiter is a transient phenomenon. Default value\n+is -1, indicating no wait.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMzIwNQ==", "bodyText": "What does 0 mean here? Do negative values mean no expiration?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460303205", "createdAt": "2020-07-24T21:50:17Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are automatically queued asynchronously with\n+a configurable timeout.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is 10.\n+[source,xml]\n+----\n+<param-name>maxQueryRequests</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>15</param-value>\n+----\n+\n+==== Request Slot Allocation Wait Time\n+Wait time in ms for which a request will wait for a slot to be available when all slots are full,\n+before the request is put into the wait queue. This allows requests to have a chance to proceed if\n+the unavailability of the request slots for this rate limiter is a transient phenomenon. Default value\n+is -1, indicating no wait.\n+[source,xml]\n+----\n+<param-name>queryWaitForSlotAllocationInMS</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>100</param-value>\n+----\n+\n+==== Request Expiration Time\n+Time in ms after which a request will expire in the wait queue. Default value is 200 ms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMzQ5NA==", "bodyText": "This should be configurable to enable/disable", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460303494", "createdAt": "2020-07-24T21:51:11Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are automatically queued asynchronously with\n+a configurable timeout.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is 10.\n+[source,xml]\n+----\n+<param-name>maxQueryRequests</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>15</param-value>\n+----\n+\n+==== Request Slot Allocation Wait Time\n+Wait time in ms for which a request will wait for a slot to be available when all slots are full,\n+before the request is put into the wait queue. This allows requests to have a chance to proceed if\n+the unavailability of the request slots for this rate limiter is a transient phenomenon. Default value\n+is -1, indicating no wait.\n+[source,xml]\n+----\n+<param-name>queryWaitForSlotAllocationInMS</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>100</param-value>\n+----\n+\n+==== Request Expiration Time\n+Time in ms after which a request will expire in the wait queue. Default value is 200 ms.\n+[source,xml]\n+----\n+<param-name>queryRequestExpirationTimeInMS</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>200</param-value>\n+----\n+\n+== Salient Points\n+\n+These are some of the things to keep in mind when using rate limiters\n+\n+=== Over Subscribing\n+It is possible to define a size of quota for a request type which exceeds the size\n+of the available threadpool. Solr does not enforce rules on the size of a quota that\n+can be define for a request type. This is intentionally done to allow users full\n+control on their quota allocation. However, if the quota exceeds the available threadpool's\n+size, the standard queuing policies of the threadpool will kick in.\n+\n+=== Work Stealing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMzc0NQ==", "bodyText": "There is a race condition here where new incoming requests can get in before resume of an existing request.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460303745", "createdAt": "2020-07-24T21:52:04Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -441,6 +463,13 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n       consumeInputFully(request, response);\n       SolrRequestInfo.reset();\n       SolrRequestParsers.cleanupMultipartFiles(request);\n+\n+      if (accepted) {\n+        rateLimitManager.decrementActiveRequests(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwNTIzMg==", "bodyText": "Is this different from admin requests sent with async=[async-id]?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460305232", "createdAt": "2020-07-24T21:56:46Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();\n+  }\n+\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+\n+    if (!rateLimiterConfig.isEnabled) {\n+      return true;\n+    }\n+\n+    boolean accepted = allowedConcurrentRequests.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS);\n+\n+    if (!accepted) {\n+      AsyncContext asyncContext = request.startAsync();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTY5ODc3", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460569877", "createdAt": "2020-08-04T07:41:18Z", "commit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNzo0MToxOFrOG7U00w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODoxMDoxNFrOG7VzeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2MDM3MQ==", "bodyText": "Don't want to nit-pick but 'stealing' sounds like when something is taken undesirably. Considering this is a config setting, I'd suggest using something else here.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464860371", "createdAt": "2020-08-04T07:41:18Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/QueryRateLimiter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_CONCURRENT_REQUESTS;\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class QueryRateLimiter extends RequestRateLimiter {\n+  final static String IS_QUERY_RATE_LIMITER_ENABLED = \"isQueryRateLimiterEnabled\";\n+  final static String MAX_QUERY_REQUESTS = \"maxQueryRequests\";\n+  final static String QUERY_WAIT_FOR_SLOT_ALLOCATION_INMS = \"queryWaitForSlotAllocationInMS\";\n+  final static String QUERY_GUARANTEED_SLOTS = \"queryGuaranteedSlots\";\n+  final static String QUERY_ALLOW_WORK_STEALING = \"queryAllowWorkStealing\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2MDU0MQ==", "bodyText": "Can we add some java doc to clarify what does this implementation do?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464860541", "createdAt": "2020-08-04T07:41:39Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/QueryRateLimiter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_CONCURRENT_REQUESTS;\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class QueryRateLimiter extends RequestRateLimiter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MDAyMA==", "bodyText": "Forgot to remove this ?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464870020", "createdAt": "2020-08-04T07:58:39Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +385,20 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage());\n+      }\n+\n+      if (!accepted) {\n+        String errorMessage = \"Too many requests for this request type.\" +\n+            \"Please try after some time or increase the quota for this request type\";\n+\n+        response.sendError(429, errorMessage);\n+        //throw new SolrException(ErrorCode.TOO_MANY_REQUESTS, \"FOOFOOOFOO\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MDIzMQ==", "bodyText": "@VisibleForTesting ?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464870231", "createdAt": "2020-08-04T07:59:05Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -668,4 +694,9 @@ public void close() {\n   public void closeOnDestroy(boolean closeOnDestroy) {\n     this.closeOnDestroy = closeOnDestroy;\n   }\n+\n+  // Only for testing\n+  void replaceRateLimitManager(RateLimitManager rateLimitManager) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NjQwOA==", "bodyText": "This is really clean!", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464876408", "createdAt": "2020-08-04T08:10:14Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNjE1MDMy", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460615032", "createdAt": "2020-08-04T08:43:40Z", "commit": {"oid": "dd40660e20f2ce3b83305788a6cc102fbf1e8cfe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo0Mzo0MFrOG7W_EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo0Mzo0MFrOG7W_EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NTc2MA==", "bodyText": "s/stealing/borrowing", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464895760", "createdAt": "2020-08-04T08:43:40Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isWorkStealingEnabled */);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd40660e20f2ce3b83305788a6cc102fbf1e8cfe"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNjE1NjM2", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460615636", "createdAt": "2020-08-04T08:44:26Z", "commit": {"oid": "dd40660e20f2ce3b83305788a6cc102fbf1e8cfe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTA2NTUz", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460906553", "createdAt": "2020-08-04T15:07:46Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTowNzo0NlrOG7kzVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozOTo0MVrOG7mL-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMjEzNQ==", "bodyText": "Add a indication here that setting higher slot allocation wait times may be reflected as higher QTime. It's probably apparent to us now, but somebody debugging why their queries are getting slow will likely appreciate the hint.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465122135", "createdAt": "2020-08-04T15:07:46Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,116 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are rejected with HTTP error code 429 (Too Many Requests).\n+\n+Note that rate limiting works at an instance (JVM) level, not at a core or collection level. Consider that when planning capacity.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is number of cores * 3.\n+[source,xml]\n+----\n+<param-name>maxQueryRequests</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>15</param-value>\n+----\n+\n+==== Request Slot Allocation Wait Time\n+Wait time in ms for which a request will wait for a slot to be available when all slots are full,\n+before the request is put into the wait queue. This allows requests to have a chance to proceed if\n+the unavailability of the request slots for this rate limiter is a transient phenomenon. Default value\n+is -1, indicating no wait. 0 will represent the same -- no wait.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMjk1MQ==", "bodyText": "Is there a JIRA for this? Would be good to link to it if it exists (or create it if it does not)", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465122951", "createdAt": "2020-08-04T15:08:54Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,116 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are rejected with HTTP error code 429 (Too Many Requests).\n+\n+Note that rate limiting works at an instance (JVM) level, not at a core or collection level. Consider that when planning capacity.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially\n+pronounced under high stress in production workloads.\n+\n+== Rate Limiter Configurations\n+The default rate limiter is search rate limiter. Accordingly, it can be configured in web.xml under initParams for\n+SolrRequestFilter.\n+\n+[source,xml]\n+----\n+<filter-name>SolrRequestFilter</filter-name>\n+----\n+\n+==== Enable Query Rate Limiter\n+Controls enabling of query rate limiter. Default value is false.\n+[source,xml]\n+----\n+<param-name>isQueryRateLimiterEnabled</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Maximum Number Of Concurrent Requests\n+Allows setting maximum concurrent search requests at a given point in time. Default value is number of cores * 3.\n+[source,xml]\n+----\n+<param-name>maxQueryRequests</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>15</param-value>\n+----\n+\n+==== Request Slot Allocation Wait Time\n+Wait time in ms for which a request will wait for a slot to be available when all slots are full,\n+before the request is put into the wait queue. This allows requests to have a chance to proceed if\n+the unavailability of the request slots for this rate limiter is a transient phenomenon. Default value\n+is -1, indicating no wait. 0 will represent the same -- no wait.\n+[source,xml]\n+----\n+<param-name>queryWaitForSlotAllocationInMS</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>100</param-value>\n+----\n+\n+==== Slot Borrowing Enabled\n+If slot borrowing (described below) is enabled or not. Default value is false.\n+[source,xml]\n+----\n+<param-name>queryAllowSlotBorrowing</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>true</param-value>\n+----\n+\n+==== Guaranteed Slots\n+The number of guaranteed slots that the query rate limiter will reserve irrespective\n+of the load of query requests. This is used only if slot borrowing is enabled and acts\n+as the threshold beyond which query rate limiter will not allow other request types to\n+borrow slots from its quota. Default value is allowed number of concurrent requests / 2.\n+[source,xml]\n+----\n+<param-name>queryGuaranteedSlots</param-name>\n+----\n+[source,xml]\n+----\n+<param-value>200</param-value>\n+----\n+\n+== Salient Points\n+\n+These are some of the things to keep in mind when using rate limiters\n+\n+=== Over Subscribing\n+It is possible to define a size of quota for a request type which exceeds the size\n+of the available threadpool. Solr does not enforce rules on the size of a quota that\n+can be define for a request type. This is intentionally done to allow users full\n+control on their quota allocation. However, if the quota exceeds the available threadpool's\n+size, the standard queuing policies of the threadpool will kick in.\n+\n+=== Slot Borrowing\n+If a quota does not have backlog but other quotas do, then the relatively less busier quota can\n+\"borrow\" slot from the busier quotas. This is done on a round robin basis today with a futuristic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMzgxMA==", "bodyText": "Can we file a JIRA for finer grained request rate limiting?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465123810", "createdAt": "2020-08-04T15:10:11Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,116 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are rejected with HTTP error code 429 (Too Many Requests).\n+\n+Note that rate limiting works at an instance (JVM) level, not at a core or collection level. Consider that when planning capacity.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyNTg3OA==", "bodyText": "This talks about indexing and searching requests, but I only see configuration for query rate limiters below. If update requests are not considered here, we should look at that as follow-on work, and the docs should reflect the state of things.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465125878", "createdAt": "2020-08-04T15:13:00Z", "author": {"login": "madrob"}, "path": "solr/solr-ref-guide/src/rate-limiters.adoc", "diffHunk": "@@ -0,0 +1,116 @@\n+= Request Rate Limiters\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr allows rate limiting per request type. Each request type can be allocated a maximum allowed number of concurrent requests\n+that can be active. The default rate limiting is implemented for updates and searches.\n+\n+If a request exceeds the request quota, further incoming requests are rejected with HTTP error code 429 (Too Many Requests).\n+\n+Note that rate limiting works at an instance (JVM) level, not at a core or collection level. Consider that when planning capacity.\n+\n+== When To Use Rate Limiters\n+Rate limiters should be used when the user wishes to allocate a guaranteed capacity of the request threadpool to a specific\n+request type. Indexing and search requests are mostly competing with each other for CPU resources. This becomes especially", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc0NQ==", "bodyText": "unneeded?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465141745", "createdAt": "2020-08-04T15:35:13Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -387,7 +394,13 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\");\n       }\n \n-      return new HttpGet(basePath + path + wparams.toQueryString());\n+      //return new HttpGet(basePath + path + wparams.toQueryString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjM4MA==", "bodyText": "let's extract this to a method, along with lines 445 and 366", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465142380", "createdAt": "2020-08-04T15:36:08Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -387,7 +394,13 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\");\n       }\n \n-      return new HttpGet(basePath + path + wparams.toQueryString());\n+      //return new HttpGet(basePath + path + wparams.toQueryString());\n+\n+      HttpGet result = new HttpGet(basePath + path + wparams.toQueryString());\n+\n+      result.addHeader(contextHeaders[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjkyOQ==", "bodyText": "This is maybe more of an admin request? WDYT?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465142929", "createdAt": "2020-08-04T15:36:55Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/SolrPing.java", "diffHunk": "@@ -54,6 +54,11 @@ protected SolrPingResponse createResponse(SolrClient client) {\n   public ModifiableSolrParams getParams() {\n     return params;\n   }\n+\n+  @Override\n+  public String getRequestType() {\n+    return SolrRequestType.QUERY.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDgyNw==", "bodyText": "Something about this that I think bothers me is that we don't make a differentiation between distinct handlers, so we can't use this to build QoS levels. Like I can't say that RTG should always go through while /select might be acceptable to throttle and /spellcheck is even lower priority.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465144827", "createdAt": "2020-08-04T15:39:41Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/QueryRequest.java", "diffHunk": "@@ -76,5 +76,9 @@ public SolrParams getParams() {\n     return query;\n   }\n \n+  @Override\n+  public String getRequestType() {\n+    return SolrRequestType.QUERY.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTc0Njk1", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460974695", "createdAt": "2020-08-04T16:25:26Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNToyNlrOG7oDJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNToyNlrOG7oDJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTMzMw==", "bodyText": "nit: Collections.singleton", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465175333", "createdAt": "2020-08-04T16:25:26Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -98,6 +99,8 @@\n   private static final Charset FALLBACK_CHARSET = StandardCharsets.UTF_8;\n   private static final String DEFAULT_PATH = \"/select\";\n   private static final long serialVersionUID = -946812319974801896L;\n+\n+  protected static final Set<Integer> UNMATCHED_ACCEPTED_ERROR_CODES = new HashSet<>(Arrays.asList(429));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTc1MTgx", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460975181", "createdAt": "2020-08-04T16:25:59Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNTo1OVrOG7oElg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNTo1OVrOG7oElg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTcwMg==", "bodyText": "I don't understand when this condition occurs. Can you add some comments explaining it?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465175702", "createdAt": "2020-08-04T16:25:59Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -624,6 +641,12 @@ private HttpEntityEnclosingRequestBase fillContentStream(\n       if (procCt != null) {\n         String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n         if (!procMimeType.equals(mimeType)) {\n+          if (isUnmatchedErrorCode(mimeType, httpStatus)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTk4Mjg3", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-460998287", "createdAt": "2020-08-04T16:55:49Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjo1NTo0OVrOG7pLvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyNToxM1rOG7qONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzkxNw==", "bodyText": "This is always false due to type mismatch.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465193917", "createdAt": "2020-08-04T16:55:49Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NDA0Nw==", "bodyText": "do we need a call to handleRequest here?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465194047", "createdAt": "2020-08-04T16:56:02Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NjgyOQ==", "bodyText": "Please add some comments here clarifying that callers must acquire the semaphore lease before adding requests to the map (and must delete from the map before returning the lease).", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465196829", "createdAt": "2020-08-04T17:00:31Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMzMwNQ==", "bodyText": "Potential deadlock - reorder this. Possibly consider using computeIfPresent.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465203305", "createdAt": "2020-08-04T17:12:04Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+        continue;\n+      }\n+\n+      if (requestRateLimiter.getRateLimiterConfig().isSlotBorrowingEnabled && requestRateLimiter.allowSlotBorrowing()) {\n+        return requestRateLimiter;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  // Decrement the active requests in the rate limiter for the corresponding request type.\n+  public void decrementActiveRequests(HttpServletRequest request) {\n+    RequestRateLimiter requestRateLimiter = activeRequestsMap.get(request);\n+\n+    if (requestRateLimiter == null) {\n+      // No rate limiter for this request type\n+      return;\n+    }\n+\n+    requestRateLimiter.decrementConcurrentRequests();\n+    activeRequestsMap.remove(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTg3Ng==", "bodyText": "I feel like this is insufficient. If this request is part of its own queue, but there is another request of this same type that is currently borrowing a slot from another queue, then we shout prioritize returning the borrowed slot instead of our own.\nThis might have potential performance implications and can lead to livelock/request starvation.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465205876", "createdAt": "2020-08-04T17:16:30Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+        continue;\n+      }\n+\n+      if (requestRateLimiter.getRateLimiterConfig().isSlotBorrowingEnabled && requestRateLimiter.allowSlotBorrowing()) {\n+        return requestRateLimiter;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  // Decrement the active requests in the rate limiter for the corresponding request type.\n+  public void decrementActiveRequests(HttpServletRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjk1OA==", "bodyText": "This is required, make it a constructor parameter on the builder?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465206958", "createdAt": "2020-08-04T17:18:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -184,6 +187,11 @@ public void init(FilterConfig config) throws ServletException\n       coresInit = createCoreContainer(solrHomePath, extraProperties);\n       this.httpClient = coresInit.getUpdateShardHandler().getDefaultHttpClient();\n       setupJvmMetrics(coresInit);\n+      RateLimitManager.Builder builder = new RateLimitManager.Builder();\n+\n+      builder.setConfig(config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzE1NA==", "bodyText": "Thread.currentThread.interrupt", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465207154", "createdAt": "2020-08-04T17:18:45Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +386,19 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzY4Nw==", "bodyText": "assertEquals", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465207687", "createdAt": "2020-08-04T17:19:39Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODAzMg==", "bodyText": "nit: use a lambda?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465208032", "createdAt": "2020-08-04T17:20:13Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwOTA1NA==", "bodyText": "assertThat(e.getMessage(), contains(...))", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465209054", "createdAt": "2020-08-04T17:22:06Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwOTQwOQ==", "bodyText": "Should we assert anything about the result of this?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465209409", "createdAt": "2020-08-04T17:22:40Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMDIxMQ==", "bodyText": "should this ever be false?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465210211", "createdAt": "2020-08-04T17:24:02Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMDkzMg==", "bodyText": "I'd like to see some testing around the slot borrowing?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465210932", "createdAt": "2020-08-04T17:25:13Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDYzMzU3", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-461063357", "createdAt": "2020-08-04T18:26:54Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODoyNjo1NFrOG7sXHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODoyNjo1NFrOG7sXHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NTk4Mg==", "bodyText": "Might want to declare both of these as final ?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465245982", "createdAt": "2020-08-04T18:26:54Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else reject the same.\n+ */\n+public class RequestRateLimiter {\n+  private Semaphore allowedConcurrentRequests;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDY0MTUz", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-461064153", "createdAt": "2020-08-04T18:28:05Z", "commit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODoyODowNlrOG7sZgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODozMjoxM1rOG7sipA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NjU5NA==", "bodyText": "You could declare all of these as final", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465246594", "createdAt": "2020-08-04T18:28:06Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n+          mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n+      assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n+      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n+              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n+          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  private static class MockRequestRateLimiter extends RequestRateLimiter {\n+    AtomicInteger incomingRequestCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NzUwNQ==", "bodyText": "this throws is redundant here considering we always throw a RuntimeException", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465247505", "createdAt": "2020-08-04T18:29:45Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0ODkzMg==", "bodyText": "Let's change these assertions to assertEquals? It's going to help debug or get more information from failure. assertTrue only prints true/false, but equals provides information like expected X but got Y", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465248932", "createdAt": "2020-08-04T18:32:13Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65539a3d56e370522b3449434ded38e08bf7af1"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNDAzMTEz", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-461403113", "createdAt": "2020-08-05T07:21:59Z", "commit": {"oid": "212a91a46cbac9286213bca5c972f7799db8489b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyMTo1OVrOG79YzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNzoyMTo1OVrOG79YzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNDk0MA==", "bodyText": "can we specify that this is per JVM/Solr instance?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465524940", "createdAt": "2020-08-05T07:21:59Z", "author": {"login": "anshumg"}, "path": "solr/solr-ref-guide/src/index.adoc", "diffHunk": "@@ -124,6 +125,8 @@ The *<<getting-started.adoc#getting-started,Getting Started>>* section guides yo\n *<<legacy-scaling-and-distribution.adoc#legacy-scaling-and-distribution,Legacy Scaling and Distribution>>*: This section tells you how to grow a Solr distribution by dividing a large index into sections called shards, which are then distributed across multiple servers, or by replicating a single index across multiple services.\n \n *<<circuit-breakers.adoc#circuit-breakers,Circuit Breakers>>*: This section talks about circuit breakers, a way of allowing a higher stability of Solr nodes and increased service level guarantees of requests that are accepted by Solr.\n+\n+*<<rate-limiters.adoc#rate-limiters,Request Rate Limiters>>*: This section talks about request rate limiters, a way of guaranteeing throughput per request type and dedicating resource quotas by resource type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "212a91a46cbac9286213bca5c972f7799db8489b"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzUwMjQ3", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-462750247", "createdAt": "2020-08-06T17:55:00Z", "commit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzo1NTowMFrOG8-Paw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTowODowNVrOG9EUxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NzQ5OQ==", "bodyText": "s/gexperimental/experimental", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466587499", "createdAt": "2020-08-06T17:55:00Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -92,17 +100,28 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n    * For each request rate limiter whose type that is not of the type of the request which got rejected,\n    * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n    * If allotted, return else try next request type.\n+   *\n+   * @lucene.gexperimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODg3MA==", "bodyText": "nit: swap the parameters. assertEquals(expected, actual)", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466588870", "createdAt": "2020-08-06T17:57:20Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4OTA4MQ==", "bodyText": "(expected, actual)", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466589081", "createdAt": "2020-08-06T17:57:45Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MDU3Mg==", "bodyText": "if numFound == 0, then as you said this means the request was throttled? So we should be in the catch block at that point? I don't think we need the conditional then, right?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466660572", "createdAt": "2020-08-06T20:14:14Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(() -> {\n+          try {\n+            QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+            if (response.getResults().getNumFound() > 0) {\n+              assertEquals(100, response.getResults().getNumFound());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTIwNQ==", "bodyText": "assertTrue(future.get()); for when it doesn't throw an exception?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466661205", "createdAt": "2020-08-06T20:15:32Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(() -> {\n+          try {\n+            QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+            if (response.getResults().getNumFound() > 0) {\n+              assertEquals(100, response.getResults().getNumFound());\n+            }\n+          } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+          }\n+\n+          return true;\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTg2OA==", "bodyText": "given that this pattern is repeated between the tests, can we pull it into a separate method?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466661868", "createdAt": "2020-08-06T20:16:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MjU3OA==", "bodyText": "maybe declare this as a ConcurrentMap just to really drive the point home?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466662578", "createdAt": "2020-08-06T20:18:16Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -38,9 +41,14 @@\n  * rate limiting is being done for a specific request type.\n  */\n public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n   public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n   private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  // IMPORTANT: The slot from the corresponding rate limiter should be acquired before adding the request\n+  // to this map. Subsequently, the request should be deleted from the map before the slot is released.\n   private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MzE1OQ==", "bodyText": "Add a comment something like // Can't borrow from ourselves", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466663159", "createdAt": "2020-08-06T20:19:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -92,17 +100,28 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n    * For each request rate limiter whose type that is not of the type of the request which got rejected,\n    * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n    * If allotted, return else try next request type.\n+   *\n+   * @lucene.gexperimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n   private RequestRateLimiter trySlotBorrowing(String requestType) {\n     for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n       RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n \n-      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.toString().equals(requestType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2ODkzMw==", "bodyText": "combine these into populateHeaders(HttpMessage, Header[])", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466668933", "createdAt": "2020-08-06T20:30:55Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -723,14 +716,35 @@ private HttpEntityEnclosingRequestBase fillContentStream(\n     }\n   }\n \n-  // When raising an error using HTTP sendError, mime types can be mismatched\n+  // When raising an error using HTTP sendError, mime types can be mismatched. This is specifically true when\n+  // SolrDispatchFilter uses the sendError mechanism since the expected MIME type of response is not HTML but\n+  // HTTP sendError generates a HTML output, which can lead to mismatch\n   private boolean isUnmatchedErrorCode(String mimeType, int httpStatus) {\n     if (mimeType.equalsIgnoreCase(\"text/html\") && UNMATCHED_ACCEPTED_ERROR_CODES.contains(httpStatus)) {\n       return true;\n     }\n \n     return false;\n   }\n+\n+  private Header[] buildRequestSpecificHeaders(@SuppressWarnings({\"rawtypes\"}) final SolrRequest request) {\n+    Header[] contextHeaders = new Header[2];\n+\n+    contextHeaders[0] = new BasicHeader(CommonParams.SOLR_REQUEST_CONTEXT_PARAM, getContext().toString());\n+    contextHeaders[1] = new BasicHeader(CommonParams.SOLR_REQUEST_TYPE_PARAM, request.getRequestType());\n+\n+    return contextHeaders;\n+  }\n+\n+  private void populateHeadersInResult(HttpGet result, Header[] contextHeaders) {\n+    result.addHeader(contextHeaders[0]);\n+    result.addHeader(contextHeaders[1]);\n+  }\n+\n+  private void populateHeadersInRequestBase(HttpEntityEnclosingRequestBase postOrPut, Header[] contextHeaders) {\n+    postOrPut.addHeader(contextHeaders[0]);\n+    postOrPut.addHeader(contextHeaders[1]);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3Mzk2Mw==", "bodyText": "This is suspicious, given that we don't synchronize on the instance when trying to acquire permits directly (non-borrowed). I understand that the goal is to prevent a race between checking that there are enough sufficient permits and acquiring one of the extras... but the java docs for available permits also suggests that it is for debugging or testing only, not a real concurrency construct. The proper way to do this might be two semaphores - one for dedicated slots and one for shared slots. Incoming requests for this limiter can take from the shared slots first and then if those run out then they can go to the reserved slots. Borrow requests can only go to the share slot semaphore. Would need to track which pool we took from then, which makes this less ideal.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466673963", "createdAt": "2020-08-06T20:41:08Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -53,6 +53,8 @@ public boolean handleRequest() throws InterruptedException {\n    * Whether to allow another request type to borrow a slot from this request rate limiter. Typically works fine\n    * if there is a relatively lesser load on this request rate limiter's type compared to the others (think of skew).\n    * @return true if allow, false otherwise\n+   *\n+   * @lucene.experimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n   public boolean allowSlotBorrowing() {\n     synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTc4MA==", "bodyText": "Also need to restore interrupted status.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466675780", "createdAt": "2020-08-06T20:44:46Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -53,6 +53,8 @@ public boolean handleRequest() throws InterruptedException {\n    * Whether to allow another request type to borrow a slot from this request rate limiter. Typically works fine\n    * if there is a relatively lesser load on this request rate limiter's type compared to the others (think of skew).\n    * @return true if allow, false otherwise\n+   *\n+   * @lucene.experimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n   public boolean allowSlotBorrowing() {\n     synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3Mzk2Mw=="}, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NzE3Mw==", "bodyText": "Did we give up on using the authentication plugin info to determine if this is an internal request or not?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466687173", "createdAt": "2020-08-06T21:08:05Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  // IMPORTANT: The slot from the corresponding rate limiter should be acquired before adding the request\n+  // to this map. Subsequently, the request should be deleted from the map before the slot is released.\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d2916ae38c001b9b4cc7ff6e083130ba3604de"}, "originalPosition": 64}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35c9caa9c4ab459aefff3112b32c05639703770e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/35c9caa9c4ab459aefff3112b32c05639703770e", "committedDate": "2020-08-07T10:10:42Z", "message": "Move to a dedicated pool and more fixes"}, "afterCommit": {"oid": "51b38a88c2844080865d90fda0aa57ebf4369f90", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/51b38a88c2844080865d90fda0aa57ebf4369f90", "committedDate": "2020-08-07T10:15:09Z", "message": "Move to a dedicated pool and more fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMzk1MDcz", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-463395073", "createdAt": "2020-08-07T15:15:13Z", "commit": {"oid": "3fd6aad10476ae5bbbf9387ea20968c0e634b799"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNToxNToxM1rOG9dxiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNToxNToxM1rOG9dxiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNDEzNw==", "bodyText": "I would write this as something like:\nclass SemaphoreWrapper() {\n  Semaphore wrapped;\n\n  release() {\n    if (wrapped != null) wrapped.release();\n  }\n}\n\n  public SempahoreWrapper handleRequest() throws InterruptedException {\n      if (!rateLimiterConfig.isEnabled) {\n       return nopPool; // = new SemaphoreWrapper(null);\n     }\n\n    if (guaranteedSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n       return new SemaphoreWrapper(guaranteedSlotsPool);\n     }\n\n    if (borrowableSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n       return new SemaphoreWrapper(borrowableSlotsPool);\n     }\n \n      return null;\n   }\n\nAnd probably have the limiter own the wrappers and return the right thing each time instead of creating a new wrapper.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467104137", "createdAt": "2020-08-07T15:15:13Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -58,18 +58,18 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n   public Pair<Boolean, AcquiredSlotMetadata> handleRequest() throws InterruptedException {\n \n     if (!rateLimiterConfig.isEnabled) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, null);\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(null, null));\n     }\n \n     if (guaranteedSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, false));\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, guaranteedSlotsPool));\n     }\n \n     if (borrowableSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, true));\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, borrowableSlotsPool));\n     }\n \n-    return new Pair<Boolean, AcquiredSlotMetadata>(false, null);\n+    return new Pair<Boolean, AcquiredSlotMetadata>(false, new AcquiredSlotMetadata(null, null));\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd6aad10476ae5bbbf9387ea20968c0e634b799"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDY3NDM4", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-463467438", "createdAt": "2020-08-07T17:03:15Z", "commit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowMzoxNVrOG9hSTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxMzoyOVrOG9hlzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MTY3Ng==", "bodyText": "I'd prefer to see these as pre declared members so that we're not allocating a new metadata on each request.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467161676", "createdAt": "2020-08-07T17:03:15Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -55,21 +54,21 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n    * NOTE: Always check for a null metadata object even if this method returns a true -- this will be the scenario when\n    * rate limiters are not enabled.\n    * */\n-  public Pair<Boolean, AcquiredSlotMetadata> handleRequest() throws InterruptedException {\n+  public SlotMetadata handleRequest() throws InterruptedException {\n \n     if (!rateLimiterConfig.isEnabled) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(null, null));\n+      return new SlotMetadata(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzI5MA==", "bodyText": "This seems like an implementation detail that we don't need to expose?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467163290", "createdAt": "2020-08-07T17:06:36Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -152,14 +143,22 @@ public RateLimiterConfig(SolrRequest.SolrRequestType requestType, boolean isEnab\n     }\n   }\n \n-  // Represents the metadata for an acquired slot\n-  static class AcquiredSlotMetadata {\n-    public RequestRateLimiter requestRateLimiter;\n-    public Semaphore usedPool;\n+  // Represents the metadata for a slot\n+  static class SlotMetadata {\n+    private Semaphore usedPool;\n \n-    public AcquiredSlotMetadata(RequestRateLimiter requestRateLimiter, Semaphore usedPool) {\n-      this.requestRateLimiter = requestRateLimiter;\n+    public SlotMetadata(Semaphore usedPool) {\n       this.usedPool = usedPool;\n     }\n+\n+    public void decrementRequest() {\n+      if (usedPool != null) {\n+        usedPool.release();\n+      }\n+    }\n+\n+    public boolean isUsedPoolNull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTA3OA==", "bodyText": "I think I would flip this condition so that we only have one return point from the method.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165078", "createdAt": "2020-08-07T17:10:10Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -147,19 +145,16 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n \n   // Decrement the active requests in the rate limiter for the corresponding request type.\n   public void decrementActiveRequests(HttpServletRequest request) {\n-    RequestRateLimiter.AcquiredSlotMetadata acquiredSlotMetadata = activeRequestsMap.get(request);\n+    RequestRateLimiter.SlotMetadata slotMetadata = activeRequestsMap.get(request);\n \n-    if (acquiredSlotMetadata == null) {\n+    if (slotMetadata == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTQwNg==", "bodyText": "This should never happen, right?", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165406", "createdAt": "2020-08-07T17:10:48Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -132,12 +130,12 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n           Thread.currentThread().interrupt();\n         }\n \n-        if (result != null && result.first()) {\n-          if (result.second() == null) {\n-            throw new IllegalStateException(\"AcquiredSlotMetadata object null even when slot is acquired and rate limiters are enabled\");\n-          }\n+        if (result == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTYzMg==", "bodyText": "javadoc on this is out of date, still refers to booleans", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165632", "createdAt": "2020-08-07T17:11:16Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -80,20 +79,12 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n    *\n    * @lucene.experimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n-  public Pair<Boolean, AcquiredSlotMetadata> allowSlotBorrowing() throws InterruptedException {\n+  public SlotMetadata allowSlotBorrowing() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NjExMw==", "bodyText": "nit: use proper javadoc", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467166113", "createdAt": "2020-08-07T17:12:17Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  private final Map<HttpServletRequest, RequestRateLimiter.SlotMetadata> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NjY3MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467166670", "createdAt": "2020-08-07T17:13:29Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -152,14 +143,22 @@ public RateLimiterConfig(SolrRequest.SolrRequestType requestType, boolean isEnab\n     }\n   }\n \n-  // Represents the metadata for an acquired slot\n-  static class AcquiredSlotMetadata {\n-    public RequestRateLimiter requestRateLimiter;\n-    public Semaphore usedPool;\n+  // Represents the metadata for a slot\n+  static class SlotMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c658dcd1841d7f07e3e1acfc6726990418058cff", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c658dcd1841d7f07e3e1acfc6726990418058cff", "committedDate": "2020-08-07T18:00:48Z", "message": "First cut at identifying request types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a6598caf6c139dacfa7268e731708070f88590e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/2a6598caf6c139dacfa7268e731708070f88590e", "committedDate": "2020-08-07T18:00:48Z", "message": "First cut at request level rate limiter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3ae7db2e75078aec0d87c42b0ec4b20e746d505", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c3ae7db2e75078aec0d87c42b0ec4b20e746d505", "committedDate": "2020-08-07T18:00:48Z", "message": "Get Query Test Passing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20d53a49f0bbab13dc8de128e964fb6b4f812f76", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/20d53a49f0bbab13dc8de128e964fb6b4f812f76", "committedDate": "2020-08-07T18:00:48Z", "message": "Make tests more intense"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7128313d9adc701d6a47233566403383d7eeabe", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c7128313d9adc701d6a47233566403383d7eeabe", "committedDate": "2020-08-07T18:00:48Z", "message": "Pass all tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4b91567e40451798a5f937cfda537195418e809", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/b4b91567e40451798a5f937cfda537195418e809", "committedDate": "2020-08-07T18:00:48Z", "message": "Basic Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9ed4891697af34678e3b78e01fc10dd901d0b91", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c9ed4891697af34678e3b78e01fc10dd901d0b91", "committedDate": "2020-08-07T18:00:48Z", "message": "Remove erratic character"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "067beab1073b21025977148ed599b5c853ed50d5", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/067beab1073b21025977148ed599b5c853ed50d5", "committedDate": "2020-08-07T18:00:48Z", "message": "More Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e68b4b380e407b371993f7626989aa2197c5af63", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e68b4b380e407b371993f7626989aa2197c5af63", "committedDate": "2020-08-07T18:00:48Z", "message": "Give priority to previous request's rate limiter when taking next request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d27b7d5fa2ea2e70364693e2f58cc5a9495d46cb", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d27b7d5fa2ea2e70364693e2f58cc5a9495d46cb", "committedDate": "2020-08-07T18:00:49Z", "message": "Better Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "724ef32aa7cbc2213667be5aa6f798572ca2bcad", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/724ef32aa7cbc2213667be5aa6f798572ca2bcad", "committedDate": "2020-08-07T18:00:49Z", "message": "Remove index rate limiter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58c51b6d9be3b949f62acb21d2ad35bfd1f54740", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/58c51b6d9be3b949f62acb21d2ad35bfd1f54740", "committedDate": "2020-08-07T18:00:49Z", "message": "More refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8144a3bf4f67ea2579fb155f39751b8e58baeff7", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/8144a3bf4f67ea2579fb155f39751b8e58baeff7", "committedDate": "2020-08-07T18:01:44Z", "message": "Update CHANGES>txt entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "957582bd99374b96281935419d665161c0358dab", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/957582bd99374b96281935419d665161c0358dab", "committedDate": "2020-08-07T18:01:44Z", "message": "More stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8218c9530c886d8dcd3ae0bbbbfb0ea513134a03", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/8218c9530c886d8dcd3ae0bbbbfb0ea513134a03", "committedDate": "2020-08-07T18:01:44Z", "message": "Remove redundant definitions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3041eefc5a2bed425ddb6f0fafdc9eea34057f71", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/3041eefc5a2bed425ddb6f0fafdc9eea34057f71", "committedDate": "2020-08-07T18:01:44Z", "message": "Rename configuration parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df6e0163e0a456e3ba7e2b86eadb902315393f56", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/df6e0163e0a456e3ba7e2b86eadb902315393f56", "committedDate": "2020-08-07T18:01:44Z", "message": "Add missing request type impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c32e4e625333d88b6d95cc2fbc8e53f8d2685e6", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/0c32e4e625333d88b6d95cc2fbc8e53f8d2685e6", "committedDate": "2020-08-07T18:01:44Z", "message": "Renaming variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "860a47fafff67101faee981f6e43e60766a43355", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/860a47fafff67101faee981f6e43e60766a43355", "committedDate": "2020-08-07T18:01:44Z", "message": "Make HttpSolrClient handle 503"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eb67b83755e4e6913ec559baf09393b920afdb0", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/5eb67b83755e4e6913ec559baf09393b920afdb0", "committedDate": "2020-08-07T18:01:44Z", "message": "Add new parameter and error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29e79734b91bde1af5cad2ac1436587f99ffee03", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/29e79734b91bde1af5cad2ac1436587f99ffee03", "committedDate": "2020-08-07T18:01:44Z", "message": "Update error sending mechanism"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d74d096bdd35ca572979d0706310e93fa9f328f5", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d74d096bdd35ca572979d0706310e93fa9f328f5", "committedDate": "2020-08-07T18:01:44Z", "message": "Fix wrong doc link"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd3e46d94eba2ad511e4b69381b1d35be8c77678", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/dd3e46d94eba2ad511e4b69381b1d35be8c77678", "committedDate": "2020-08-07T18:01:44Z", "message": "Strict log checking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0190f279218d3a0c59b037e55f373139f48e1fc5", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/0190f279218d3a0c59b037e55f373139f48e1fc5", "committedDate": "2020-08-07T18:01:44Z", "message": "Fix Gradle precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fe6f4fdb411a75ef06a10b0d8424068fcd58dd9", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/7fe6f4fdb411a75ef06a10b0d8424068fcd58dd9", "committedDate": "2020-08-07T18:01:44Z", "message": "More stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8368b7d5790d2e6fcfa958cfccfa219176bfbb5d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/8368b7d5790d2e6fcfa958cfccfa219176bfbb5d", "committedDate": "2020-08-07T18:01:44Z", "message": "Fix Review Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2180c798b9c54bbcf296f6ac91dfd88cafd01f10", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/2180c798b9c54bbcf296f6ac91dfd88cafd01f10", "committedDate": "2020-08-07T18:01:44Z", "message": "Remove redundant mock rate limiter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0495aecd14564cf269c053b21a80037afe441032", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/0495aecd14564cf269c053b21a80037afe441032", "committedDate": "2020-08-07T18:01:44Z", "message": "Do not block rejected requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25dd53d4cee10ffdb4dad4a1074f0bd24935c04a", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/25dd53d4cee10ffdb4dad4a1074f0bd24935c04a", "committedDate": "2020-08-07T18:01:44Z", "message": "More Stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aaaf4a10f592688be8632d0185fb50665b7e3bd", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/6aaaf4a10f592688be8632d0185fb50665b7e3bd", "committedDate": "2020-08-07T18:01:44Z", "message": "Update per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cafbd3e0c05e40954838c4fb0d04e15e8fc3a0a4", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/cafbd3e0c05e40954838c4fb0d04e15e8fc3a0a4", "committedDate": "2020-08-07T18:01:44Z", "message": "More updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c03c57b61a41a0e8ba792cf756d572c1f79becc3", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c03c57b61a41a0e8ba792cf756d572c1f79becc3", "committedDate": "2020-08-07T18:01:44Z", "message": "More stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59175512b9608586190be13eb944593219d424b7", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/59175512b9608586190be13eb944593219d424b7", "committedDate": "2020-08-07T18:01:44Z", "message": "More review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2df9dc4948b3fbc33a2a1bfd8a645b40c9d2e393", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/2df9dc4948b3fbc33a2a1bfd8a645b40c9d2e393", "committedDate": "2020-08-07T18:01:44Z", "message": "Fix Precommit Failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2db8bdc7ff43d86e66590c0e0e39b96f561c38f9", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/2db8bdc7ff43d86e66590c0e0e39b96f561c38f9", "committedDate": "2020-08-07T18:01:44Z", "message": "Move to a dedicated pool and more fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "877d008f36e0acf99060910e270e9ce07ff179c6", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/877d008f36e0acf99060910e270e9ce07ff179c6", "committedDate": "2020-08-07T18:01:45Z", "message": "Stricter type casting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f67e8ec0b2c38990808ab499f4a1ef483d42e9e", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/6f67e8ec0b2c38990808ab499f4a1ef483d42e9e", "committedDate": "2020-08-07T18:01:45Z", "message": "Remove redundant params"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65fb7565b861cbf71da4c9ee9b4d7b7cc0f3791b", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/65fb7565b861cbf71da4c9ee9b4d7b7cc0f3791b", "committedDate": "2020-08-07T18:01:45Z", "message": "Refactor metadata to use better null semantics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efa5bce5ef1e74a93ccfa4fb04bcdae1d7351956", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/efa5bce5ef1e74a93ccfa4fb04bcdae1d7351956", "committedDate": "2020-08-07T18:01:45Z", "message": "Refactor to use pools"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "committedDate": "2020-08-07T18:01:45Z", "message": "Update per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e35a15736d7507dab31d3d8d8fc23db8538dd29c", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e35a15736d7507dab31d3d8d8fc23db8538dd29c", "committedDate": "2020-08-07T18:01:45Z", "message": "Fix test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b768f1d6f60411786781ff2307d16fbf7e27444", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/1b768f1d6f60411786781ff2307d16fbf7e27444", "committedDate": "2020-08-07T17:51:23Z", "message": "Fix test"}, "afterCommit": {"oid": "e35a15736d7507dab31d3d8d8fc23db8538dd29c", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e35a15736d7507dab31d3d8d8fc23db8538dd29c", "committedDate": "2020-08-07T18:01:45Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d7991dae8af503ddb63b674d6072c0e9ca8ce7", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/71d7991dae8af503ddb63b674d6072c0e9ca8ce7", "committedDate": "2020-08-07T18:03:59Z", "message": "Update CHANGES.txt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12c71a553759d33c12bf7810d10581cb83cc3878", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/12c71a553759d33c12bf7810d10581cb83cc3878", "committedDate": "2020-08-07T18:19:32Z", "message": "Remove wrong entry"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTMyNTU0", "url": "https://github.com/apache/lucene-solr/pull/1686#pullrequestreview-463532554", "createdAt": "2020-08-07T18:51:46Z", "commit": {"oid": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1MTo0N1rOG9kbwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1MzowN1rOG9kdww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzI0OA==", "bodyText": "Should be != null, right? Check the condition wherever this is called too, might need to invert those.", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467213248", "createdAt": "2020-08-07T18:51:47Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -157,7 +162,7 @@ public void decrementRequest() {\n       }\n     }\n \n-    public boolean isUsedPoolNull() {\n+    public boolean isReleasable() {\n       return usedPool == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzc2Mw==", "bodyText": "can this be static? pretty minor but since it doesn't do anything, it can be shared by all the instances and save some memory", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467213763", "createdAt": "2020-08-07T18:53:07Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -40,32 +42,35 @@\n   private final Semaphore borrowableSlotsPool;\n \n   private final RateLimiterConfig rateLimiterConfig;\n+  private final SlotMetadata guaranteedSlotMetadata;\n+  private final SlotMetadata borrowedSlotMetadata;\n+  private final SlotMetadata nullSlotMetadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c26359d5c38eb0d1a8b5e57f08c0a190508745", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/64c26359d5c38eb0d1a8b5e57f08c0a190508745", "committedDate": "2020-08-07T18:58:49Z", "message": "Fix method usage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a13dc369ac8cf24388231b4aa0adb4efb31144e6", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/a13dc369ac8cf24388231b4aa0adb4efb31144e6", "committedDate": "2020-08-07T19:06:41Z", "message": "Fix statics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48bb56c92256603c41de5f7721c344a99927f149", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/48bb56c92256603c41de5f7721c344a99927f149", "committedDate": "2020-08-07T19:15:24Z", "message": "Fix blah"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d2f88d18af64fb046a949986c99a29ae61b1159", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/0d2f88d18af64fb046a949986c99a29ae61b1159", "committedDate": "2020-08-07T19:49:25Z", "message": "Move static initialization"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2485, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}