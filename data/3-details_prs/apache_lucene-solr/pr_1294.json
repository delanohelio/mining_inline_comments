{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNjM3NTI5", "number": 1294, "title": "LUCENE-9074: Slice Allocation Control Plane For Concurrent Searches", "bodyText": "This commit introduces a mechanism to control allocation of threads to slices planned for a query.\nThe default implementation uses the size of backlog queue of the executor to determine if a slice\nshould be allocated a new thread\nSupersedes #1214", "createdAt": "2020-02-27T04:56:32Z", "url": "https://github.com/apache/lucene-solr/pull/1294", "merged": true, "mergeCommit": {"oid": "9ed71a6efe2d11fd184de53d4191753b2183b73e"}, "closed": true, "closedAt": "2020-04-01T15:12:26Z", "author": {"login": "atris"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIUIMwAFqTM2NTQxNjM0MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABee-jS9gFqTY3OTI5MzA4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NDE2MzQx", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-365416341", "createdAt": "2020-02-27T05:03:04Z", "commit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNTowMzowNFrOFvFVbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNTowNDoxN1rOFvFWXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNDc5OQ==", "bodyText": "To quote @jpountz :\n\"this doesn't need an executor, does it?\"\nIt is needed since executor is a final member of IndexSearcher hence needs to be initialized? We could potentially always set it null since it anyways wont be used but that seemed a bit counter intuitive. WDYT?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r384914799", "createdAt": "2020-02-27T05:03:04Z", "author": {"login": "atris"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +215,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutionControlPlane sliceExecutionControlPlane) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw==", "bodyText": "To quote @jpountz\n\"the generics on this interface look over-engineered?\"\nI am not sure as to what the correct generics should be. Could you please advice?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r384915037", "createdAt": "2020-02-27T05:04:17Z", "author": {"login": "atris"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Execution control plane which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+public interface SliceExecutionControlPlane<C, T extends Runnable> {\n+  /**\n+   * Invoke all slices that are allocated for the query\n+   */\n+  C invokeAll(Collection<T> tasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/3e9cd7f33ca4c490c3066e0e4c2508fb1482f965", "committedDate": "2020-02-27T04:55:02Z", "message": "Update exception handling to reflect original exception stack"}, "afterCommit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/ab1e377bdc9642145e0e1be4ee2334198df55642", "committedDate": "2020-02-27T05:06:00Z", "message": "Update exception handling to reflect original exception stack"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NjIxNDEx", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-365621411", "createdAt": "2020-02-27T11:55:02Z", "commit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMTo1NTowMlrOFvPcYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjowMTo0MVrOFvPocw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MDQxNg==", "bodyText": "I think it does not need to be generic at all since the only use case is for Future and FutureTask. In fact the interface serves no visible purpose; we could simply rename DefaultSliceExecutionControlPlane to SliceExecutionControlPlane and nothing else would change. Since we're on naming, the naming seems rather grandiose for my tastes. I tend to think of a ControlPlane as a component in a distributed system, but I struggle to come up with anything better. Maybe SliceRunner?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385080416", "createdAt": "2020-02-27T11:55:02Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Execution control plane which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+public interface SliceExecutionControlPlane<C, T extends Runnable> {\n+  /**\n+   * Invoke all slices that are allocated for the query\n+   */\n+  C invokeAll(Collection<T> tasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, "originalCommit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjU0NA==", "bodyText": "The logic around this boolean is hard to read. I think it would be clearer if we restructure the logic a bit and avoid modifying an incoming boolean parameter", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385082544", "createdAt": "2020-02-27T11:59:36Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/search/DefaultSliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Implementation of SliceExecutionControlPlane with queue backpressure based thread allocation\n+ */\n+public class DefaultSliceExecutionControlPlane implements SliceExecutionControlPlane<List<Future>, FutureTask> {\n+  private final Executor executor;\n+\n+  public DefaultSliceExecutionControlPlane(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  @Override\n+  public List<Future> invokeAll(Collection<FutureTask> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(FutureTask task, List<Future> futures,\n+                             boolean shouldExecuteOnCallerThread) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjcxMg==", "bodyText": "else?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385082712", "createdAt": "2020-02-27T12:00:02Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/search/DefaultSliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Implementation of SliceExecutionControlPlane with queue backpressure based thread allocation\n+ */\n+public class DefaultSliceExecutionControlPlane implements SliceExecutionControlPlane<List<Future>, FutureTask> {\n+  private final Executor executor;\n+\n+  public DefaultSliceExecutionControlPlane(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  @Override\n+  public List<Future> invokeAll(Collection<FutureTask> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(FutureTask task, List<Future> futures,\n+                             boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+        shouldExecuteOnCallerThread = true;\n+      }\n+    }\n+\n+    if (shouldExecuteOnCallerThread) {\n+      try {\n+        task.run();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzUwNw==", "bodyText": "could we add this to the first if block? ie executor.execute() .. futures.add() ...?  Then use early return and you don't need to modify the incoming parameter", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385083507", "createdAt": "2020-02-27T12:01:41Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/search/DefaultSliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Implementation of SliceExecutionControlPlane with queue backpressure based thread allocation\n+ */\n+public class DefaultSliceExecutionControlPlane implements SliceExecutionControlPlane<List<Future>, FutureTask> {\n+  private final Executor executor;\n+\n+  public DefaultSliceExecutionControlPlane(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  @Override\n+  public List<Future> invokeAll(Collection<FutureTask> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(FutureTask task, List<Future> futures,\n+                             boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+        shouldExecuteOnCallerThread = true;\n+      }\n+    }\n+\n+    if (shouldExecuteOnCallerThread) {\n+      try {\n+        task.run();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjcxMg=="}, "originalCommit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642"}, "originalPosition": 93}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/ab1e377bdc9642145e0e1be4ee2334198df55642", "committedDate": "2020-02-27T05:06:00Z", "message": "Update exception handling to reflect original exception stack"}, "afterCommit": {"oid": "a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "committedDate": "2020-02-27T17:30:53Z", "message": "Update exception handling to reflect original exception stack"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "committedDate": "2020-02-27T17:30:53Z", "message": "Update exception handling to reflect original exception stack"}, "afterCommit": {"oid": "36adb01f7f47689a2b0b17b1b901adc6a6463cdb", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/36adb01f7f47689a2b0b17b1b901adc6a6463cdb", "committedDate": "2020-02-27T17:38:20Z", "message": "Update exception handling to reflect original exception stack"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODI4MDEx", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-369828011", "createdAt": "2020-03-05T18:54:38Z", "commit": {"oid": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODo1NDozOFrOFyfx-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowMjoxNVrOFygDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgxOQ==", "bodyText": "it feels wrong to not take the one from the constructor?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388493819", "createdAt": "2020-03-05T18:54:38Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +213,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutionControlPlane sliceExecutionControlPlane) {\n+    assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    reader = context.reader();\n+    this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : sliceExecutionControlPlane;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NzA0Mg==", "bodyText": "Is there anything we need to do with the executor that we couldn't do with the sliceExecutionControlPlane?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388497042", "createdAt": "2020-03-05T19:00:01Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +215,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutionControlPlane sliceExecutionControlPlane) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNDc5OQ=="}, "originalCommit": {"oid": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NzUxMQ==", "bodyText": "Let's avoid introducing warnings about generics, FutureTask needs to be parameterized?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388497511", "createdAt": "2020-03-05T19:00:57Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -662,34 +676,19 @@ public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOEx\n       }\n       query = rewrite(query);\n       final Weight weight = createWeight(query, scoreMode, 1);\n-      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n-      for (int i = 0; i < leafSlices.length - 1; ++i) {\n+      final List<FutureTask> listTasks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5ODE4OA==", "bodyText": "nit: I'd prefer a simpler name, e.g. SliceExecutor", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388498188", "createdAt": "2020-03-05T19:02:15Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Execution control plane which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutionControlPlane {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjA0MTk0", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-372204194", "createdAt": "2020-03-10T18:12:46Z", "commit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODoxMjo0NlrOF0bJUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODozMDo1MVrOF0bzzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxNTAyNA==", "bodyText": "maybe this should delegate to the below constructor?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390515024", "createdAt": "2020-03-10T18:12:46Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +213,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutor = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMTc5OQ==", "bodyText": "we don't need this catch block as task.run() doesn't declare any non-runtime exception?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390521799", "createdAt": "2020-03-10T18:24:13Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected <C> void processTask(final FutureTask<C> task, final List<Future<C>> futures,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+        futures.add(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+\n+    try {\n+      futures.add(CompletableFuture.completedFuture(task.get()));\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  // Private helper method to run a task on the caller thread\n+  private void runTaskOnCallerThread(FutureTask task) {\n+    try {\n+      task.run();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMjc3Mw==", "bodyText": "we shouldn't make this method public if it returns a pkg-private class, let's make the method pkg-private too? Or even remove it entirely as I'm not seeing any call site for it?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390522773", "createdAt": "2020-03-10T18:25:48Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -933,6 +932,13 @@ public Executor getExecutor() {\n     return executor;\n   }\n \n+  /**\n+   * Returns this searchers slice execution control plane or <code>null</code> if no executor was provided\n+   */\n+  public SliceExecutor getSliceExecutor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzQzNw==", "bodyText": "I wonder whether this is the right API. We could change the return type to void and use Runnable instead of FutureTask and that would still work, right? The return value isn't really useful since it has the same content as the input collection? So what about making it just: public void invokeAll(Collection<? extends Runnable> tasks)?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390523437", "createdAt": "2020-03-10T18:26:55Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzk2Mw==", "bodyText": "we should never use generic types without type parameters, can you address all these compilation warnings?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390523963", "createdAt": "2020-03-10T18:27:43Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyNTkwMw==", "bodyText": "this has the same effect as futures.add(task) unless I'm missing something", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390525903", "createdAt": "2020-03-10T18:30:51Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected <C> void processTask(final FutureTask<C> task, final List<Future<C>> futures,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+        futures.add(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+\n+    try {\n+      futures.add(CompletableFuture.completedFuture(task.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjEzNDg2", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-384213486", "createdAt": "2020-03-30T20:41:03Z", "commit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDo0MTowM1rOF97YIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTowMToxNFrOF98CRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDI4OQ==", "bodyText": "maybe do assert (sliceExecutor == null) == (executor==null); which is shorter and not harder to read?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400480289", "createdAt": "2020-03-30T20:41:03Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -208,9 +210,22 @@ public IndexSearcher(IndexReader r, Executor executor) {\n    * @lucene.experimental\n    */\n   public IndexSearcher(IndexReaderContext context, Executor executor) {\n+    this(context, executor, getSliceExecutionControlPlane(executor));\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutor sliceExecutor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    if (executor == null) {\n+      assert sliceExecutor == null;\n+    }\n+    if (sliceExecutor == null) {\n+      assert executor == null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MzA1Ng==", "bodyText": "I believe you meant tasks, not threads.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * threads should be active. If the limit is exceeded, further segments are searched on the caller thread\n          \n          \n            \n             * tasks should be active. If the limit is exceeded, further segments are searched on the caller thread", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400483056", "createdAt": "2020-03-30T20:46:19Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/QueueSizeBasedExecutor.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+/**\n+ * Derivative of SliceExecutor that controls the number of active threads\n+ * that are used for a single query. At any point, no more than (maximum pool size of the executor * LIMITING_FACTOR)\n+ * threads should be active. If the limit is exceeded, further segments are searched on the caller thread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Njk4NQ==", "bodyText": "do we really need a helper for this?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400486985", "createdAt": "2020-03-30T20:53:32Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public void invokeAll(Collection<? extends Runnable> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    int i = 0;\n+\n+    for (Runnable task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, shouldExecuteOnCallerThread);\n+      ++i;\n+    };\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(final Runnable task,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+  }\n+\n+  // Private helper method to run a task on the caller thread\n+  private void runTaskOnCallerThread(Runnable task) {\n+    task.run();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTYwNw==", "bodyText": "or just boolean shouldExecuteOnCallerThread = random().nextBoolean()?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400489607", "createdAt": "2020-03-30T20:58:24Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runCPTest(ThreadPoolExecutor service, boolean useRandomCP) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomCP == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader2.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            searcher.search(query, Integer.MAX_VALUE, sort);\n+            searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private class RandomBlockingSliceExecutor extends SliceExecutor {\n+\n+    public RandomBlockingSliceExecutor(Executor executor) {\n+      super(executor);\n+    }\n+\n+    @Override\n+    public void invokeAll(Collection<? extends Runnable> tasks){\n+\n+      for (Runnable task : tasks) {\n+        boolean shouldExecuteOnCallerThread = false;\n+\n+        if (random().nextBoolean()) {\n+          shouldExecuteOnCallerThread = true;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDUxNQ==", "bodyText": "should we assert on the results?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400490515", "createdAt": "2020-03-30T21:00:05Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runCPTest(ThreadPoolExecutor service, boolean useRandomCP) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomCP == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader2.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            searcher.search(query, Integer.MAX_VALUE, sort);\n+            searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDg1OQ==", "bodyText": "what is CP the acronym of?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400490859", "createdAt": "2020-03-30T21:00:46Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTA3Nw==", "bodyText": "why are we not reusing reader1?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400491077", "createdAt": "2020-03-30T21:01:14Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -70,13 +75,31 @@ public void setUp() throws Exception {\n     }\n     reader = iw.getReader();\n     iw.close();\n+\n+    Random random = random();\n+    RandomIndexWriter iw2 = new RandomIndexWriter(random(), dir2, newIndexWriterConfig().setMergePolicy(newLogMergePolicy()));\n+    for (int i = 0; i < 100; i++) {\n+      Document doc = new Document();\n+      doc.add(newStringField(\"field\", Integer.toString(i), Field.Store.NO));\n+      doc.add(newStringField(\"field2\", Boolean.toString(i % 2 == 0), Field.Store.NO));\n+      doc.add(new SortedDocValuesField(\"field2\", new BytesRef(Boolean.toString(i % 2 == 0))));\n+      iw2.addDocument(doc);\n+\n+      if (random.nextBoolean()) {\n+        iw2.commit();\n+      }\n+    }\n+    reader2 = iw2.getReader();\n+    iw2.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8e10b15248593f94419f55bbc86b9b90448b75"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NTQzNjI3", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-385543627", "createdAt": "2020-04-01T12:40:15Z", "commit": {"oid": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0MDoxNlrOF--ruA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0Mjo0MFrOF--xOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4MzAzMg==", "bodyText": "this is covered by the below assert already?", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401583032", "createdAt": "2020-04-01T12:40:16Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -208,9 +210,21 @@ public IndexSearcher(IndexReader r, Executor executor) {\n    * @lucene.experimental\n    */\n   public IndexSearcher(IndexReaderContext context, Executor executor) {\n+    this(context, executor, getSliceExecutionControlPlane(executor));\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutor sliceExecutor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    if (executor == null) {\n+      assert sliceExecutor == null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDQ0Mw==", "bodyText": "we should use assertTrue rather than assert in tests, since the latter only runs when assertions are enabled, and it can be useful to run tests with assertions disabled to make sure that the logic remains correct when assertions are off", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401584443", "createdAt": "2020-04-01T12:42:40Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +354,89 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedSliceExecutor() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runSliceExecutorTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingSliceExecutor() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runSliceExecutorTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runSliceExecutorTest(ThreadPoolExecutor service, boolean useRandomSliceExecutor) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomSliceExecutor == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE, sort);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);\n+            assert topDocs.totalHits.value > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78685d24a194f22b7a4ac0f75070cb3d2e15c460", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/78685d24a194f22b7a4ac0f75070cb3d2e15c460", "committedDate": "2020-04-01T14:24:12Z", "message": "Update with more tests and rethought strategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17c275ed33efeac77570d34e23861625da9a1142", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/17c275ed33efeac77570d34e23861625da9a1142", "committedDate": "2020-04-01T14:24:12Z", "message": "Update exception handling to reflect original exception stack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12bfa34e8b76b0ee3ce9717de52b966789d770a3", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/12bfa34e8b76b0ee3ce9717de52b966789d770a3", "committedDate": "2020-04-01T14:24:12Z", "message": "Refactor the check code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9cc78111413002f4206c3854584cade413a55d8", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e9cc78111413002f4206c3854584cade413a55d8", "committedDate": "2020-04-01T14:24:12Z", "message": "Remove the interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415aae16772e6bf39a0181e2d92a661e8411921f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/415aae16772e6bf39a0181e2d92a661e8411921f", "committedDate": "2020-04-01T14:24:12Z", "message": "Change visibility of classes to package-private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "838c8b3a26fcf02af56a615c7a702dcedbb96d69", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/838c8b3a26fcf02af56a615c7a702dcedbb96d69", "committedDate": "2020-04-01T14:24:12Z", "message": "Renaming and better generic typecasting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5dc07ccf2695d66fee76190a1be89ab6b79bb4f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/f5dc07ccf2695d66fee76190a1be89ab6b79bb4f", "committedDate": "2020-04-01T14:24:12Z", "message": "Refactor the core API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a57e06191841245ef4b3fe67626bd288cafdfcbb", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/a57e06191841245ef4b3fe67626bd288cafdfcbb", "committedDate": "2020-04-01T14:24:12Z", "message": "Precommit failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8a0d616ede47c3eb10f66bbd74353341ca39e32", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c8a0d616ede47c3eb10f66bbd74353341ca39e32", "committedDate": "2020-04-01T14:24:12Z", "message": "More checkstyle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68f1d8bf437e242a635c523d0ecef2cd862586df", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/68f1d8bf437e242a635c523d0ecef2cd862586df", "committedDate": "2020-04-01T14:24:12Z", "message": "Fix per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/efe4903b1020c4adba7db456f146bb7e75099f1d", "committedDate": "2020-04-01T14:24:12Z", "message": "Update asserts used"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14", "committedDate": "2020-04-01T12:33:08Z", "message": "Fix per comments"}, "afterCommit": {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/efe4903b1020c4adba7db456f146bb7e75099f1d", "committedDate": "2020-04-01T14:24:12Z", "message": "Update asserts used"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MjkzMDg3", "url": "https://github.com/apache/lucene-solr/pull/1294#pullrequestreview-679293087", "createdAt": "2021-06-09T07:18:46Z", "commit": {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0wOVQwNzoxODo0N1rOJqAx7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0wOVQwNzoxODo0N1rOJqAx7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0ODAzMjc1MQ==", "bodyText": "Was there a reason for not making SliceExecutor public ?\nI'd want to inject my own SliceExecutor without having to fork Lucene", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r648032751", "createdAt": "2021-06-09T07:18:47Z", "author": {"login": "16pierre"}, "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2156, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}