{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MDg4ODQ1", "number": 1504, "title": "SOLR-14462: cache more than one autoscaling session", "bodyText": "Description\nAllow caching and reusing multiple Sessions for computing replica placement. With a single cached session and fixed timeout, under high collection creation load multiple new sessions are created at once against the same cluster state and placement decisions do not take into account most other placement decisions. Moreover, existing code could not cache more than one session, so most sessions were used for a single placement decision.\nSolution\nMultiple sessions can be cached and reused. Although not optimal (parallel sessions do not see the changes done by each other) this is still an improvement over existing implementation because more context is used for placement (sessions are reused). Also, less sessions are created because all created sessions are candidates for reuse (not only a single one).\nTests\nTests in class TestPolicy were run and adapted to some method signature changes.\nA new test testMultiSessionsCache explicitly verifying multiple sessions can be cached was added.\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ant precommit and the appropriate test suite.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-05-11T12:58:59Z", "url": "https://github.com/apache/lucene-solr/pull/1504", "merged": true, "mergeCommit": {"oid": "25428013fb0ed8f8fdbebdef3f1d65dea77129c2"}, "closed": true, "closedAt": "2020-06-24T20:02:44Z", "author": {"login": "murblanc"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchWW-DgFqTQxMjE3NjU3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcueMb4AH2gAyNDE2MDg4ODQ1OjBiYmMxYTU4YTgyMmUxNzkxM2YyODMyODgzZDVkNGM5YWMxNTE3MDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMTc2NTcw", "url": "https://github.com/apache/lucene-solr/pull/1504#pullrequestreview-412176570", "createdAt": "2020-05-14T20:54:16Z", "commit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDo1NDoxN1rOGVt03w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMzo0MzowOVrOGVxyYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNDA5NQ==", "bodyText": "Minor: \"requirees\" -> requires", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425424095", "createdAt": "2020-05-14T20:54:17Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,55 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    COMPUTING, // A command is actively using and modifying the session to compute placements\n+    EXECUTING // A command is not done yet processing its changes but no longer uses the session\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requirees a session to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTcxMw==", "bodyText": "Assuming the thread could be waiting on the lockObj for a while, it might make more sense to leave at the beginning of the critical section?", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425429713", "createdAt": "2020-05-14T21:04:56Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n     private SessionWrapper createSession(SolrCloudManager cloudManager) throws InterruptedException, IOException {\n-      synchronized (lockObj) {\n+      if (log.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDk5OQ==", "bodyText": "Nit: rename to \"hasViableSession\" or something since it also requires zkVersion check", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425474999", "createdAt": "2020-05-14T22:55:43Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MzQ1NA==", "bodyText": "Do we know how many sessions we might have at any given time? Could this be expensive? I suppose it guarantees savings of 1-10 seconds in cases where allowWait is true and there's nothing worth waiting for; just wondering what average case scenario is", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425483454", "createdAt": "2020-05-14T23:24:09Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4ODk5NA==", "bodyText": "Wrote up a slightly different implementation here: https://gist.github.com/megancarey/ae2bad53d320ef660ef45c8b003901e1\nNo more redundant code but I suppose worse in terms of memory, since it makes a recursive call", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425488994", "createdAt": "2020-05-14T23:43:09Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa6aea1e6828cd442af3cdaefbacd192e3a9cfcf", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/fa6aea1e6828cd442af3cdaefbacd192e3a9cfcf", "committedDate": "2020-05-20T10:48:48Z", "message": "SOLR-14462 initial. Cahcing multuiple Autoscaling sessions. Tests not run."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c3a361a6715709bc2b353a60001796525486367", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/2c3a361a6715709bc2b353a60001796525486367", "committedDate": "2020-05-20T10:48:49Z", "message": "SOLR-14462 added unit test for multi session cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f725053f5fef3e1b540711e192accbe9aaf43fba", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/f725053f5fef3e1b540711e192accbe9aaf43fba", "committedDate": "2020-05-20T11:23:11Z", "message": "fix gradle precommit issues and minor changes from PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e09f8fabe9bc87c263476467dd13b611c77c80e", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/8e09f8fabe9bc87c263476467dd13b611c77c80e", "committedDate": "2020-05-20T16:39:48Z", "message": "Get Session creation outside of the critical session of session wrapper management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "808b966f2dc89b1f4388c41f41394c68516332ec", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/808b966f2dc89b1f4388c41f41394c68516332ec", "committedDate": "2020-05-11T12:30:38Z", "message": "SOLR-14462 added unit test for multi session cache"}, "afterCommit": {"oid": "8e09f8fabe9bc87c263476467dd13b611c77c80e", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/8e09f8fabe9bc87c263476467dd13b611c77c80e", "committedDate": "2020-05-20T16:39:48Z", "message": "Get Session creation outside of the critical session of session wrapper management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/bfa7753932f60c0e76b508b850db1a890d314b54", "committedDate": "2020-05-20T16:59:32Z", "message": "Make gradle precommit happy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Nzk4NDE4", "url": "https://github.com/apache/lucene-solr/pull/1504#pullrequestreview-415798418", "createdAt": "2020-05-21T00:14:38Z", "commit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMDoxNDozOFrOGYiF3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMDozNjowNVrOGYic9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NzU2NQ==", "bodyText": "Minor: \"yeet\" \ud83d\ude04", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428377565", "createdAt": "2020-05-21T00:14:38Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,78 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    /**\n+     * A command is actively using and modifying the session to compute placements\n+     */\n+    COMPUTING,\n+    /**\n+     * A command is not done yet processing its changes but no longer updates or even uses the session\n+     */\n+    EXECUTING\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requires a session to\n+   * compute operations:\n+   * <ol>\n+   * <li>see if there is an available non expired session in the cache,</li>\n+   * <li>if yes, borrow it.</li>\n+   * <li>if no, create a new one and borrow it.</li>\n+   * <li>after computing (update) operations are done, {@link #returnSession(SessionWrapper)} back to the cache so it's\n+   * again available for borrowing.</li>\n+   * <li>after all borrowers are done computing then executing with the session, {@link #release(SessionWrapper)} it,\n+   * which removes it from the cache.</li>\n+   * </ol>\n    */\n   static class SessionRef {\n+    /**\n+     * Lock protecting access to {@link #sessionWrapperSet} and to {@link #creationsInProgress}\n+     */\n     private final Object lockObj = new Object();\n-    private SessionWrapper sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n \n+    /**\n+     * Sessions currently in use in {@link Status#COMPUTING} or {@link Status#EXECUTING} states. As soon as all\n+     * uses of a session are over, that session is removed from this set. Sessions not actively in use are NOT kept around.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private Set<SessionWrapper> sessionWrapperSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+\n+    /**\n+     * Number of sessions currently being created but not yeet present in {@link #sessionWrapperSet}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODAwMA==", "bodyText": "Minor: over-indented?", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428378000", "createdAt": "2020-05-21T00:15:57Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,78 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    /**\n+     * A command is actively using and modifying the session to compute placements\n+     */\n+    COMPUTING,\n+    /**\n+     * A command is not done yet processing its changes but no longer updates or even uses the session\n+     */\n+    EXECUTING\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requires a session to\n+   * compute operations:\n+   * <ol>\n+   * <li>see if there is an available non expired session in the cache,</li>\n+   * <li>if yes, borrow it.</li>\n+   * <li>if no, create a new one and borrow it.</li>\n+   * <li>after computing (update) operations are done, {@link #returnSession(SessionWrapper)} back to the cache so it's\n+   * again available for borrowing.</li>\n+   * <li>after all borrowers are done computing then executing with the session, {@link #release(SessionWrapper)} it,\n+   * which removes it from the cache.</li>\n+   * </ol>\n    */\n   static class SessionRef {\n+    /**\n+     * Lock protecting access to {@link #sessionWrapperSet} and to {@link #creationsInProgress}\n+     */\n     private final Object lockObj = new Object();\n-    private SessionWrapper sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n \n+    /**\n+     * Sessions currently in use in {@link Status#COMPUTING} or {@link Status#EXECUTING} states. As soon as all\n+     * uses of a session are over, that session is removed from this set. Sessions not actively in use are NOT kept around.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private Set<SessionWrapper> sessionWrapperSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+\n+    /**\n+     * Number of sessions currently being created but not yeet present in {@link #sessionWrapperSet}.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private int creationsInProgress = 0;\n \n     public SessionRef() {\n     }\n \n-\n-    //only for debugging\n-    SessionWrapper getSessionWrapper() {\n-      return sessionWrapper;\n+    // used only by tests\n+    boolean isEmpty() {\n+      synchronized (lockObj) {\n+        return sessionWrapperSet.isEmpty();\n+      }\n     }\n \n     /**\n      * All operations suggested by the current session object\n      * is complete. Do not even cache anything\n      */\n     private void release(SessionWrapper sessionWrapper) {\n+      boolean present;\n       synchronized (lockObj) {\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime && this.sessionWrapper.refCount.get() <= 0) {\n-          log.debug(\"session set to NULL\");\n-          this.sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n-        } // else somebody created a new session b/c of expiry . So no need to do anything about it\n+        present = sessionWrapperSet.remove(sessionWrapper);\n+      }\n+      if (!present) {\n+        log.warn(\"released session {} not found in session set\", sessionWrapper.getCreateTime());\n+      } else {\n+          TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3OTA0NA==", "bodyText": "Minor: put allowWait at beginning of check to short-circuit if allowWait is false", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428379044", "createdAt": "2020-05-21T00:19:54Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +463,149 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n-\n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    /**\n+     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n+     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n+     *\n+     * Some waiting is done in two cases:\n+     * <ul>\n+     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n+     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n+     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n+     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n+     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n+     * </ul>\n+     *\n+     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n+     * one even though some differentiated waits could have led to better reuse and less session creations.\n+     *\n+     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n+     *                  will happen...\n+     */\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n-          return createSession(cloudManager);\n-        } else {\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        // Best case scenario: an available session\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        }\n+\n+        // Wait for a while before deciding what to do if waiting could help...\n+        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3OTk1MQ==", "bodyText": "I think we want to put lines 543-552 in the if statement, since we probably don't want to check for an available session twice in  immediate succession if allowWait is false/there are no candidate sessions to wait for.", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428379951", "createdAt": "2020-05-21T00:23:15Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +463,149 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n-\n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    /**\n+     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n+     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n+     *\n+     * Some waiting is done in two cases:\n+     * <ul>\n+     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n+     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n+     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n+     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n+     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n+     * </ul>\n+     *\n+     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n+     * one even though some differentiated waits could have led to better reuse and less session creations.\n+     *\n+     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n+     *                  will happen...\n+     */\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n-          return createSession(cloudManager);\n-        } else {\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        // Best case scenario: an available session\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        }\n+\n+        // Wait for a while before deciding what to do if waiting could help...\n+        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {\n+          // Either an existing session might be returned and become usable while we wait, or a session in the process of being\n+          // created might finish creation, be used then returned and become usable. So we wait.\n+          // wait 1 to 10 secs. Random to help spread wakeups.\n+          long waitForMs = (long) (Math.random() * 9 * 1000) + 1000;\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING (or {} creations in progress). starting wait of {}ms\",\n+                creationsInProgress, waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+        }\n+\n+        // We've waited (or not), now we can either reuse immediately an available session, or immediately create a new one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MzQ3OQ==", "bodyText": "Might want to add a test for creationsInProgress? But would probably require refactoring/exposing creationsInProgress", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428383479", "createdAt": "2020-05-21T00:36:05Z", "author": {"login": "megancarey"}, "path": "solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy.java", "diffHunk": "@@ -1709,13 +1708,134 @@ public DistribStateManager getDistribStateManager() {\n     assertEquals(2, s1.getRefCount());\n \n     s2[0].release();\n-    assertFalse(sessionRef.getSessionWrapper() == PolicyHelper.SessionWrapper.DEFAULT_INSTANCE);\n+    assertFalse(sessionRef.isEmpty());\n     s1.release();\n-    assertTrue(sessionRef.getSessionWrapper() == PolicyHelper.SessionWrapper.DEFAULT_INSTANCE);\n+    assertTrue(sessionRef.isEmpty());\n \n \n   }\n \n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "committedDate": "2020-05-21T05:58:28Z", "message": "minor changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f366b48a81b3c314441e9e0f30be1159b6a31196", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/f366b48a81b3c314441e9e0f30be1159b6a31196", "committedDate": "2020-06-11T10:59:41Z", "message": "Merge branch 'master' into SOLR-14462"}, "afterCommit": {"oid": "8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "committedDate": "2020-05-21T05:58:28Z", "message": "minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "730999e5f9859792bdb9dbba51e3a309cc3d9d6f", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/730999e5f9859792bdb9dbba51e3a309cc3d9d6f", "committedDate": "2020-06-24T18:02:48Z", "message": "Merge branch 'master' into SOLR-14462"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bbc1a58a822e17913f2832883d5d4c9ac151706", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/0bbc1a58a822e17913f2832883d5d4c9ac151706", "committedDate": "2020-06-24T18:17:20Z", "message": "SOLR-14462: clean up test and remove warnings"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2700, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}