{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MDc2ODYw", "number": 2010, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNjoxM1rOEv-iLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo1MDozOVrOE6ZYSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQzMDg2OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNjoxM1rOHlRFqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNjoxM1rOHlRFqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTMzOQ==", "bodyText": "nit: alphabetize imports", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508839339", "createdAt": "2020-10-20T21:06:13Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -31,6 +31,7 @@\n import java.util.function.Supplier;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.common.cloud.GlobalStateVars;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ1Mzk4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxMjo1MFrOHlRTag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowMjowMVrOHlSyEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mjg1OA==", "bodyText": "?", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508842858", "createdAt": "2020-10-20T21:12:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java", "diffHunk": "@@ -63,7 +61,7 @@ public void test() throws Exception {\n     testMigrateSSL(new SSLTestConfig(false, false));\n   }\n   \n-  public void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {\n+  private void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzA4OQ==", "bodyText": "it's an internal test method and doesn't need to be public but I'll rename it to make it clear", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508867089", "createdAt": "2020-10-20T22:02:01Z", "author": {"login": "thelabdude"}, "path": "solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java", "diffHunk": "@@ -63,7 +61,7 @@ public void test() throws Exception {\n     testMigrateSSL(new SSLTestConfig(false, false));\n   }\n   \n-  public void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {\n+  private void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mjg1OA=="}, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ2MDc4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxNDo1M1rOHlRXZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowMjoxM1rOHlSyYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzg3Ng==", "bodyText": "I prefer the enum singleton pattern", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508843876", "createdAt": "2020-10-20T21:14:53Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzE2OQ==", "bodyText": "ah yes, good call, thanks", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508867169", "createdAt": "2020-10-20T22:02:13Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzg3Ng=="}, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ2NTI5OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxNjowN1rOHlRaGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NDowOVrOHlSjrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDU2OQ==", "bodyText": "null on unchanged seems like a trap to me", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844569", "createdAt": "2020-10-20T21:16:07Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();\n+\n+  public static GlobalStateVars singleton() {\n+    return _singleton;\n+  }\n+\n+  private String urlScheme = System.getProperty(URL_SCHEME, HTTP);\n+\n+  // no new! you have to use the static singleton!\n+  private GlobalStateVars() {\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public void setUrlScheme(final String urlScheme) {\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme or null if the supplied url remains unchanged.\n+   */\n+  public String applyUrlSchemeIfChanged(final String url) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQwNA==", "bodyText": "yeah, it's ugly for sure, but wanted to capture the fact that the url didn't change ... how about Optional instead?", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508863404", "createdAt": "2020-10-20T21:54:09Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();\n+\n+  public static GlobalStateVars singleton() {\n+    return _singleton;\n+  }\n+\n+  private String urlScheme = System.getProperty(URL_SCHEME, HTTP);\n+\n+  // no new! you have to use the static singleton!\n+  private GlobalStateVars() {\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public void setUrlScheme(final String urlScheme) {\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme or null if the supplied url remains unchanged.\n+   */\n+  public String applyUrlSchemeIfChanged(final String url) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDU2OQ=="}, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ2NzgzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxNjo0N1rOHlRblg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxNjo0N1rOHlRblg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDk1MA==", "bodyText": "Use Objects.requireNonNull", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844950", "createdAt": "2020-10-20T21:16:47Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -20,6 +20,9 @@\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    if (nodeProps == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ5OTUyOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToyNjoyOFrOHlRutA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToyNjoyOFrOHlRutA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0OTg0NA==", "bodyText": "I think it's clearer here if we only have a single return from the method, so we should fall through or have an else.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508849844", "createdAt": "2020-10-20T21:26:28Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java", "diffHunk": "@@ -105,6 +111,17 @@ public static ZkNodeProps load(byte[] bytes) {\n \n   @Override\n   public void write(JSONWriter jsonWriter) {\n+    final String baseUrl = (String)propMap.get(ZkStateReader.BASE_URL_PROP);\n+    if (baseUrl != null && !baseUrl.startsWith(SCHEME_VAR)) {\n+      final int at = baseUrl.indexOf(\"://\");\n+      if (at != -1) {\n+        final String updatedUrl = SCHEME_VAR + baseUrl.substring(at+3);\n+        Map<String,Object> modMap = new LinkedHashMap<>(propMap);\n+        modMap.put(ZkStateReader.BASE_URL_PROP, updatedUrl);\n+        jsonWriter.write(modMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzUyMzMyOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozMzoyOVrOHlR9CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowNjoyOVrOHlS5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzUxMw==", "bodyText": "If we have an initially HTTP cluster, and then one node comes up with HTTPS, then that will bring down the rest of the cluster, right? I don't think we can do this rolling, however.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508853513", "createdAt": "2020-10-20T21:33:29Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -263,4 +275,27 @@ public void close() {\n   public ExecutorService getCoreZkRegisterExecutorService() {\n     return coreZkRegister;\n   }\n+\n+  private void setGlobalUrlScheme(final ZkController zkCtrl) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String urlScheme = zkCtrl.getZkStateReader().getClusterProperty(ZkStateReader.URL_SCHEME, null);\n+    if (StringUtils.isNotEmpty(urlScheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      GlobalStateVars.singleton().setUrlScheme(urlScheme);\n+    } else {\n+      final String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        // it's OK to set the cluster prop to https b/c we're making the cluster more secure, not less\n+        // wouldn't do this for http though\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. Updating the cluster property to match.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2ODkxNw==", "bodyText": "I'll just remove this, not strictly necessary (was trying to save the user some work but could have side-effects)", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508868917", "createdAt": "2020-10-20T22:06:29Z", "author": {"login": "thelabdude"}, "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -263,4 +275,27 @@ public void close() {\n   public ExecutorService getCoreZkRegisterExecutorService() {\n     return coreZkRegister;\n   }\n+\n+  private void setGlobalUrlScheme(final ZkController zkCtrl) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String urlScheme = zkCtrl.getZkStateReader().getClusterProperty(ZkStateReader.URL_SCHEME, null);\n+    if (StringUtils.isNotEmpty(urlScheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      GlobalStateVars.singleton().setUrlScheme(urlScheme);\n+    } else {\n+      final String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        // it's OK to set the cluster prop to https b/c we're making the cluster more secure, not less\n+        // wouldn't do this for http though\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. Updating the cluster property to match.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzUxMw=="}, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU0MDQzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozODo1OVrOHlSHlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowOTo0NFrOHlS-UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjIxMg==", "bodyText": "I don't think we want to encourage further use of this pattern. Let's call it something more specific like UrlSchemeState", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508856212", "createdAt": "2020-10-20T21:38:59Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3MDIyNQ==", "bodyText": "I agree, thanks for confirming ;-)", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508870225", "createdAt": "2020-10-20T22:09:44Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjIxMg=="}, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Nzg2MzA0OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0OToyN1rOHlVHLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0OToyN1rOHlVHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNTI2MA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method ZkStateReader.getLeaderUrl(...) indirectly reads without synchronization from cloud.UrlScheme.INSTANCE.urlScheme. Potentially races with write in method ZkStateReader.forciblyRefreshAllClusterStateSlow().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508905260", "createdAt": "2020-10-20T23:49:27Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -798,7 +799,11 @@ public boolean isClosed() {\n   }\n \n   public String getLeaderUrl(String collection, String shard, int timeout) throws InterruptedException {\n-    ZkCoreNodeProps props = new ZkCoreNodeProps(getLeaderRetry(collection, shard, timeout));\n+    Replica replica = getLeaderRetry(collection, shard, timeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU3MTIzOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozODoyNFrOHmNfrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozODoyNFrOHmNfrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyOTAzOQ==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r509829039", "createdAt": "2020-10-22T01:38:24Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -448,6 +447,11 @@ public boolean isClosed() {\n         return cc.isShutDown();\n       }});\n \n+    // setup the scheme before updating cluster state\n+    setGlobalUrlSchemeFromClusterProps(zkClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzIxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOToyOVrOHtolCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOToyOVrOHtolCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjgwOA==", "bodyText": "NULL_DEREFERENCE:  object baseUrl last assigned on line 30 could be null and is dereferenced by call to getCoreUrl(...) at line 32.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612808", "createdAt": "2020-11-04T20:29:29Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -16,15 +16,20 @@\n  */\n package org.apache.solr.common.cloud;\n \n+import java.util.Objects;\n+\n public class ZkCoreNodeProps {\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    Objects.requireNonNull(nodeProps, \"nodeProps should not be null\");\n     this.nodeProps = nodeProps;\n   }\n   \n   public String getCoreUrl() {\n-    return getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));\n+    String baseUrl = nodeProps.getStr(ZkStateReader.BASE_URL_PROP);\n+    Objects.requireNonNull(baseUrl, \"No base_url in ZkNodeProps! \"+nodeProps.toString());\n+    return getCoreUrl(baseUrl, nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzQxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozMlrOHtolLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozMlrOHtolLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg0NA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) indirectly reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612844", "createdAt": "2020-11-04T20:29:32Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzQzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNFrOHtolMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNFrOHtolMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg1MA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612850", "createdAt": "2020-11-04T20:29:34Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzUwOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNVrOHtolQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNVrOHtolQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg2Ng==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612866", "createdAt": "2020-11-04T20:29:35Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzU4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNlrOHtolTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNlrOHtolTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg3OA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getBaseUrlForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612878", "createdAt": "2020-11-04T20:29:36Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzYwOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOFrOHtolUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOFrOHtolUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg4Mw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlScheme() reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612883", "createdAt": "2020-11-04T20:29:38Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzcyOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOVrOHtolYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOVrOHtolYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg5OA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlSchemeForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612898", "createdAt": "2020-11-04T20:29:39Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0NzgyOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MFrOHtoldg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MFrOHtoldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkxOA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.isOnServer() reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612918", "createdAt": "2020-11-04T20:29:40Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0Nzg4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MVrOHtolfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MVrOHtolfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkyNw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.onChange(...) reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612927", "createdAt": "2020-11-04T20:29:41Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0Nzk1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MlrOHtoliQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MlrOHtoliQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkzNw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.liveNodes outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612937", "createdAt": "2020-11-04T20:29:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0Nzk5OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NFrOHtolkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NFrOHtolkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk0NA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.useLiveNodesUrlScheme outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612944", "createdAt": "2020-11-04T20:29:44Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDE0ODA1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NVrOHtolmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NVrOHtolmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk1Mg==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.useLiveNodesUrlScheme() reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612952", "createdAt": "2020-11-04T20:29:45Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NDc5ODU5OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDozNDowM1rOHtuqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDozNDowM1rOHtuqWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjQ3Mg==", "bodyText": "NULL_DEREFERENCE:  object returned by getBaseUrl() could be null and is dereferenced by call to getCoreUrl(...) at line 237.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517712472", "createdAt": "2020-11-05T00:34:03Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "diffHunk": "@@ -235,11 +234,11 @@ public String getName() {\n   }\n \n   public String getCoreUrl() {\n-    return ZkCoreNodeProps.getCoreUrl(getStr(ZkStateReader.BASE_URL_PROP), core);\n+    return ZkCoreNodeProps.getCoreUrl(getBaseUrl(), core);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8436a396db768840376193ff401ec9c928de7962"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODkxMDA4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo1Mzo0MlrOHuWDrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzozODozMVrOHy4jdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NzkzMg==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController.getLeaderProps(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r518357932", "createdAt": "2020-11-05T20:53:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1401,8 +1420,7 @@ public ZkCoreNodeProps getLeaderProps(final String collection,\n         byte[] data = zkClient.getData(\n             ZkStateReader.getShardLeadersPath(collection, slice), null, null,\n             true);\n-        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(\n-            ZkNodeProps.load(data));\n+        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(ZkNodeProps.load(data));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNzQzMA==", "bodyText": "that'll teach me to fix weird whitespacing!", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r523117430", "createdAt": "2020-11-13T17:38:31Z", "author": {"login": "thelabdude"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1401,8 +1420,7 @@ public ZkCoreNodeProps getLeaderProps(final String collection,\n         byte[] data = zkClient.getData(\n             ZkStateReader.getShardLeadersPath(collection, slice), null, null,\n             true);\n-        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(\n-            ZkNodeProps.load(data));\n+        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(ZkNodeProps.load(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NzkzMg=="}, "originalCommit": {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjEwMzQ3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NjoyMVrOHwPwkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NjoyMVrOHwPwkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTg4OQ==", "bodyText": "Should we instead mention that Solr doesn't support partial TLS enabled clusters?", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520351889", "createdAt": "2020-11-10T07:46:21Z", "author": {"login": "anshumg"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjEwNTQxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NzowMlrOHwPxuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NzowMlrOHwPxuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MjE4NQ==", "bodyText": "\ud83d\udc4d\ud83c\udffd", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520352185", "createdAt": "2020-11-10T07:47:02Z", "author": {"login": "anshumg"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MDQyNzc5OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMTo0NToyMVrOHzAkCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMTo0NToyMVrOHzAkCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0ODY1MA==", "bodyText": "NULL_DEREFERENCE:  object leaderUrl last assigned on line 348 could be null and is dereferenced at line 351.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r523248650", "createdAt": "2020-11-13T21:45:21Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java", "diffHunk": "@@ -344,13 +344,8 @@ final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedExce\n                                                                                             // though\n       try {\n         CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n-        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n-            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n-        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n-        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n-\n-        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n-\n+        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n+        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops);\n         String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n \n         boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db58e20554a82cf5539f2dd08fa58ce12e03f267"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NjY3Njc0OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo0ODo0NFrOH1cx0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo0ODo0NFrOH1cx0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwODA4Mg==", "bodyText": "Java8 doesn't have URLEncoder.encode(String, Charset). Also, it'd through the exception on 8x.\nI like it this way, just saying that you might have to remember that when merging.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525808082", "createdAt": "2020-11-18T04:48:44Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -2131,12 +2128,7 @@ public LeaderElector getOverseerElector() {\n   static String generateNodeName(final String hostName,\n                                  final String hostPort,\n                                  final String hostContext) {\n-    try {\n-      return hostName + ':' + hostPort + '_' +\n-          URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), \"UTF-8\");\n-    } catch (UnsupportedEncodingException e) {\n-      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n-    }\n+    return hostName + ':' + hostPort + '_' + URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NjY4NjgyOnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo1MDozOVrOH1c5DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo1MDozOVrOH1c5DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwOTkzMw==", "bodyText": "Can you please add a space around +.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525809933", "createdAt": "2020-11-18T04:50:39Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java", "diffHunk": "@@ -414,6 +425,11 @@ private void waitForLeader(List<ClientThread> threads, int seq)\n \n   private int getLeaderThread() throws KeeperException, InterruptedException {\n     String leaderUrl = getLeaderUrl(\"collection1\", \"shard1\");\n+    // strip off the scheme\n+    final int at = leaderUrl.indexOf(\"://\");\n+    if (at != -1) {\n+      leaderUrl = leaderUrl.substring(at+3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1168, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}