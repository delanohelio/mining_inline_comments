{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMjIzODgy", "number": 1155, "title": "LUCENE-8962: Add ability to selectively merge on commit", "bodyText": "Description\nIf we have many index writer threads, they will flush their DWPT buffers\non commit, resulting in many small segments, which can be merged before\nthe commit returns.\nSolution\nThis adds a new \"findCommitMerges\" method to MergePolicy, which can specify merges to be executed as part of preparing a commit. By default, we return null for backward compatibility (i.e. don't merge on commit).\nIn IndexWriter, we call findCommitMerges from prepareCommitInternal, after we have cloned the SegmentInfos. If we found commit merges, we wrap each OneMerge so that on completion, they update the cloned SegmentInfos and reference counts of segment files. Outside the flush lock, we wait (up to max time specified in IndexWriterConfig) for the commit merges to complete before calling startCommit.\nAlso, added an IndexWriterEvents callback (configurable through IndexWriterConfig) so that consuming code can be notified of merge on commit events (to emit metrics on time spent waiting for the merges to complete, for example).\nTests\n\nAdded findCommitMerges implementation to MockRandomMergePolicy.\nAdded explicit test case for merge-on-commit behavior in TestIndexWriterMergePolicy.\n\nChecklist\nPlease review the following and check all that apply:\n\n[\u2713] I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n[\u2713] I have created a Jira issue and added the issue ID to my pull request title.\n[\u2713] I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n[\u2713] I have developed this patch against the master branch.\n[\u2713] I have run ant precommit and the appropriate test suite.\n[\u2713] I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-01-07T23:55:58Z", "url": "https://github.com/apache/lucene-solr/pull/1155", "merged": true, "mergeCommit": {"oid": "043c5dff6f44c9bb2415005ac97db3c2c561ab45"}, "closed": true, "closedAt": "2020-03-02T17:19:48Z", "author": {"login": "msfroh"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb59fWkAFqTM0MTg4Nzc5NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcK8b2fgFqTM3MDE3MzczMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxODg3Nzk0", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-341887794", "createdAt": "2020-01-13T14:37:09Z", "commit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNDozNzowOVrOFc48Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNDo0NTo1OFrOFc5OnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzMzNA==", "bodyText": "This relies on some peculiar semantics of SegmentInfos, namely that it manages Segment internally as a List. I guess that's true now, but I wonder if we shouldn't make SegmentInfos actually implement List, have asList return a modifiable List, or at least document and/or add a unit test to TestSegmentInfos enforcing that you can remove while iterating and expect a certain ordering of the elements? It seems to be implicit in the contract given that segments are ordered, but it's not explicitly stated in the javadocs at least.", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365837334", "createdAt": "2020-01-13T14:37:09Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3147,6 +3149,38 @@ public final boolean flushNextBuffer() throws IOException {\n     }\n   }\n \n+  private MergePolicy waitForMergeOnCommitPolicy(MergePolicy source, final SegmentInfos toCommit,\n+                                                 AtomicReference<CountDownLatch> mergeLatchRef) {\n+    return new OneMergeWrappingMergePolicy(source, (toWrap) -> new MergePolicy.OneMerge(toWrap.segments) {\n+      @Override\n+      public void mergeFinished() throws IOException {\n+        super.mergeFinished();\n+        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();\n+        if (mergeAwaitLatch == null) {\n+          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.\n+          return;\n+        }\n+        if (isAborted() == false) {\n+          deleter.incRef(this.info.files());\n+          toCommit.add(this.info.clone());\n+          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);\n+          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);\n+          Set<String> segmentNamesToRemove = new HashSet<>();\n+          for (SegmentCommitInfo sci : this.segments) {\n+            deleter.decRef(sci.files());\n+            segmentNamesToRemove.add(sci.info.name);\n+          }\n+          for (int i = toCommit.size() - 1; i >= 0; i--) {\n+            if (segmentNamesToRemove.contains(toCommit.info(i).info.name)) {\n+              toCommit.remove(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzc2Nw==", "bodyText": "Would we sometimes get !=null and == 0??", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365837767", "createdAt": "2020-01-13T14:37:56Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();\n+                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n+\n+                // Find any merges that can execute on commit (per MergePolicy).\n+                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n+                if (commitMerges != null && commitMerges.merges.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODQzNA==", "bodyText": "I If we fail to registerMerge does it necessarily mean the segment was already being merged?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365838434", "createdAt": "2020-01-13T14:39:14Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();\n+                MergePolicy mergeOnCommitPolicy = waitForMergeOnCommitPolicy(config.getMergePolicy(), toCommit, mergeAwaitLatchRef);\n+\n+                // Find any merges that can execute on commit (per MergePolicy).\n+                commitMerges = mergeOnCommitPolicy.findCommitMerges(segmentInfos, this);\n+                if (commitMerges != null && commitMerges.merges.size() > 0) {\n+                  int mergeCount = 0;\n+                  for (MergePolicy.OneMerge oneMerge : commitMerges.merges) {\n+                    if (registerMerge(oneMerge)) {\n+                      mergeCount++;\n+                    } else {\n+                      throw new IllegalStateException(\"MergePolicy \" + config.getMergePolicy().getClass() +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ4Mw==", "bodyText": "could we wait to create this until we create its CountdownLatch and simplify the null checks below?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365839483", "createdAt": "2020-01-13T14:41:10Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3223,15 +3259,44 @@ private long prepareCommitInternal() throws IOException {\n               // sneak into the commit point:\n               toCommit = segmentInfos.clone();\n \n+              if (anyChanges) {\n+                mergeAwaitLatchRef = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDc2MQ==", "bodyText": "\"... from within ...\"", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365840761", "createdAt": "2020-01-13T14:43:29Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3252,6 +3317,53 @@ private long prepareCommitInternal() throws IOException {\n       } finally {\n         maybeCloseOnTragicEvent();\n       }\n+\n+      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+        CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n+        // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n+        // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n+        // block until  the merges that we registered complete. As they complete, they will update toCommit to\n+        // replace merged segments with the result of each merge.\n+        mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n+        long mergeWaitStart = System.nanoTime();\n+        int abandonedCount = 0;\n+        long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n+        try {\n+          config.getIndexWriterEvents().beginMergeOnCommit();\n+          if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n+            synchronized (this) {\n+              // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n+              // executing mergeFinished (since mergeFinished itself is called from with the IndexWriter lock).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MjA3Ng==", "bodyText": "Typically why would it happen that we abandon some merges? timeout? Would there be any sense in trying to interrupt them?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r365842076", "createdAt": "2020-01-13T14:45:58Z", "author": {"login": "msokolov"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriter.java", "diffHunk": "@@ -3252,6 +3317,53 @@ private long prepareCommitInternal() throws IOException {\n       } finally {\n         maybeCloseOnTragicEvent();\n       }\n+\n+      if (mergeAwaitLatchRef != null && mergeAwaitLatchRef.get() != null) {\n+        CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();\n+        // If we found and registered any merges above, within the flushLock, then we want to ensure that they\n+        // complete execution. Note that since we released the lock, other merges may have been scheduled. We will\n+        // block until  the merges that we registered complete. As they complete, they will update toCommit to\n+        // replace merged segments with the result of each merge.\n+        mergeScheduler.merge(this, MergeTrigger.FULL_FLUSH, true);\n+        long mergeWaitStart = System.nanoTime();\n+        int abandonedCount = 0;\n+        long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);\n+        try {\n+          config.getIndexWriterEvents().beginMergeOnCommit();\n+          if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {\n+            synchronized (this) {\n+              // Need to do this in a synchronized block, to make sure none of our commit merges are currently\n+              // executing mergeFinished (since mergeFinished itself is called from with the IndexWriter lock).\n+              // After we clear the value from mergeAwaitLatchRef, the merges we schedule will still execute as\n+              // usual, but when they finish, they won't attempt to update toCommit or modify segment reference\n+              // counts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8af5ff0d00de33734b7ac03866fae3a2439d807", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/d8af5ff0d00de33734b7ac03866fae3a2439d807", "committedDate": "2020-01-17T23:14:42Z", "message": "LUCENE-8962: Add ability to selectively merge on commit\n\nThis adds a new \"findCommitMerges\" method to MergePolicy, which can\nspecify merges to be executed before the\nIndexWriter.prepareCommitInternal method returns.\n\nIf we have many index writer threads, they will flush their DWPT buffers\non commit, resulting in many small segments, which can be merged before\nthe commit returns."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a04f5f2fb83708fecdb8959588d314ff95124839", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/a04f5f2fb83708fecdb8959588d314ff95124839", "committedDate": "2020-01-17T23:14:42Z", "message": "Add missing Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "376ba0964b4a5428846addee53609bf268456237", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/376ba0964b4a5428846addee53609bf268456237", "committedDate": "2020-01-17T23:14:42Z", "message": "Fix incorrect comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODk5Mzc5", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-344899379", "createdAt": "2020-01-17T23:55:13Z", "commit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMzo1NToxNFrOFfIDmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMzo1NToxNFrOFfIDmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4MjE2OA==", "bodyText": "I just found that this assertion sometimes fails. If there are some pending/running merges left over from the indexing threads, the segments associated with those merges will be excluded from merging on commit. I'll update this test to wait for pending merges to finish before committing.", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r368182168", "createdAt": "2020-01-17T23:55:14Z", "author": {"login": "msfroh"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy.java", "diffHunk": "@@ -277,6 +285,92 @@ public void testSetters() {\n     assertSetters(new LogDocMergePolicy());\n   }\n \n+  public void testMergeOnCommit() throws IOException, InterruptedException {\n+    Directory dir = newDirectory();\n+    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n+        .setMergePolicy(NoMergePolicy.INSTANCE));\n+    for (int i = 0; i < 5; i++) {\n+      TestIndexWriter.addDoc(firstWriter);\n+      firstWriter.flush();\n+    }\n+    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n+    assertEquals(5, firstReader.leaves().size());\n+    firstReader.close();\n+    firstWriter.close();\n+\n+    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n+      @Override\n+      public MergeSpecification findCommitMerges(SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n+        // Optimize down to a single segment on commit\n+        MergeSpecification mergeSpecification = new MergeSpecification();\n+        List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n+        for (SegmentCommitInfo sci : segmentInfos) {\n+          if (mergeContext.getMergingSegments().contains(sci) == false) {\n+            nonMergingSegments.add(sci);\n+          }\n+        }\n+        mergeSpecification.add(new OneMerge(nonMergingSegments));\n+        return mergeSpecification;\n+      }\n+    };\n+\n+    IndexWriter writerWithMergePolicy = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n+        .setMergePolicy(mergeOnCommitPolicy));\n+\n+    writerWithMergePolicy.commit();\n+\n+    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n+    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n+    unmergedReader.close();\n+\n+    TestIndexWriter.addDoc(writerWithMergePolicy);\n+    writerWithMergePolicy.commit();\n+\n+    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n+    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n+    mergedReader.close();\n+\n+    LineFileDocs lineFileDocs = new LineFileDocs(random());\n+    int docCount = atLeast(1000);\n+    AtomicInteger indexedDocs = new AtomicInteger(0);\n+    int numIndexingThreads = atLeast(2);\n+    CountDownLatch startingGun = new CountDownLatch(1);\n+    Collection<Thread> indexingThreads = new ArrayList<>();\n+    for (int i = 0; i < numIndexingThreads; i++) {\n+      Thread t = new Thread(() -> {\n+        try {\n+          while (indexedDocs.getAndIncrement() < docCount) {\n+            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n+            if (rarely()) {\n+              writerWithMergePolicy.commit();\n+            }\n+          }\n+        } catch (IOException e) {\n+          e.printStackTrace();\n+          fail();\n+        }\n+      });\n+      t.start();\n+      indexingThreads.add(t);\n+    }\n+    startingGun.countDown();\n+    for (Thread t : indexingThreads) {\n+      t.join();\n+    }\n+    writerWithMergePolicy.commit();\n+    assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5bf1b6577ed866ec01486bcb928bdf8302d643d"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0907f65a1e59647690d3a2c4d6964ff85ef80d44", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/0907f65a1e59647690d3a2c4d6964ff85ef80d44", "committedDate": "2020-01-19T02:11:50Z", "message": "Refactoring and fix intermittent test failure\n\n1. Made some changes to the callback to update toCommit, leveraging\nSegmentInfos.applyMergeChanges.\n2. I realized that we'll never end up with 0 registered merges, because\nwe throw an exception if we fail to register a merge.\n3. Moved the IndexWriterEvents.beginMergeOnCommit notification to before\nwe call MergeScheduler.merge, since we may not be merging on another\nthread.\n4. There was an intermittent test failure due to randomness in the time\nit takes for merges to complete. Before doing the final commit, we wait\nfor pending merges to finish. We may still end up abandoning the final\nmerge, but we can detect that and assert that either the merge was\nabandoned (and we have > 1 segment) or we did merge down to 1 segment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/bdbf425d561e7905f3f273b6558c2f9bae6cf8a5", "committedDate": "2020-01-19T02:18:27Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwOTAwMDI4", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-350900028", "createdAt": "2020-01-30T15:13:55Z", "commit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNToxMzo1NVrOFjumgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNToxODoyMFrOFjux4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODAwMg==", "bodyText": "Maybe also say that any merges still running after this time will still run to completion, so they are not wasted.", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373008002", "createdAt": "2020-01-30T15:13:55Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java", "diffHunk": "@@ -484,6 +487,23 @@ public IndexWriterConfig setCommitOnClose(boolean commitOnClose) {\n     return this;\n   }\n \n+  /**\n+   * Expert: sets the amount of time to wait for merges returned by MergePolicy.findCommitMerges(...).\n+   * If this time is reached, we proceed with the commit based on segments merged up to that point.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwODkzNQ==", "bodyText": "This is no longer true?  We will just wrap up the commit w/ those merges that did finish, and let the still running merges finish to completion?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373008935", "createdAt": "2020-01-30T15:15:20Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/LiveIndexWriterConfig.java", "diffHunk": "@@ -480,6 +488,22 @@ public String getSoftDeletesField() {\n     return softDeletesField;\n   }\n \n+  /**\n+   * Expert: return the amount of time to wait for merges returned by by MergePolicy.findCommitMerges(...).\n+   * If this time is reached, those merges will be aborted and we will wait again. If this time limit is reached again,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAwOTM5Ng==", "bodyText": "What is isMergingSegment here?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373009396", "createdAt": "2020-01-30T15:16:02Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAxMDkxNA==", "bodyText": "Is this true?  Or will IW (silently) disregard that requested merge?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373010914", "createdAt": "2020-01-30T15:18:20Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * Implementers of this method should use isMergingSegment to exclude any already-merging segments from the returned\n+   * {@link MergeSpecification}. If a segment already registered in a merge is returned, then the commit will fail.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf425d561e7905f3f273b6558c2f9bae6cf8a5"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/4ae6df3b19999e012fcb72460bf12edc23a10427", "committedDate": "2020-01-31T22:50:15Z", "message": "Fix/improve comments based on PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODQ0OTI3", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-351844927", "createdAt": "2020-02-01T00:21:44Z", "commit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDoyMTo0NFrOFkbM-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDoyMzo1N1rOFkbOSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODc0NA==", "bodyText": "Can you add @lucene.experimental here?  That reserves the right to make breaking changes even on feature releases ...", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738744", "createdAt": "2020-02-01T00:21:44Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+\n+package org.apache.lucene.index;\n+\n+/**\n+ * Callback interface to signal various actions taken by IndexWriter.\n+ */\n+public interface IndexWriterEvents {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODgzOA==", "bodyText": "Can you say what exception will be thrown in that case (or add an @throws, below)?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738838", "createdAt": "2020-02-01T00:22:28Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczODk0NA==", "bodyText": "Hmm, maybe improve this (it's not an IndexWriter) to say the merge policy may use this to find already merging segments?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373738944", "createdAt": "2020-02-01T00:23:05Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n+   *\n+   * If a returned {@link OneMerge} includes a segment already included in a registered merge, then the commit will fail.\n+   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n+   *\n+   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n+   * @param mergeContext the IndexWriter to find the merges on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTA4MQ==", "bodyText": "Can you describe a bit more?  E.g. explain that any merges returned here which then finish within the allotted time will be reflected in the commit, so that the number of segments in the commit point may be decreased?", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r373739081", "createdAt": "2020-02-01T00:23:57Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/MergePolicy.java", "diffHunk": "@@ -526,6 +526,19 @@ public abstract MergeSpecification findForcedMerges(\n   public abstract MergeSpecification findForcedDeletesMerges(\n       SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException;\n \n+  /**\n+   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ae6df3b19999e012fcb72460bf12edc23a10427"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d149f0e75103160e16d6f98d052150024594d1ba", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/d149f0e75103160e16d6f98d052150024594d1ba", "committedDate": "2020-02-04T02:23:09Z", "message": "More comment improvements from PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMDEyNzk0", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-353012794", "createdAt": "2020-02-04T14:23:42Z", "commit": {"oid": "d149f0e75103160e16d6f98d052150024594d1ba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b3c2c7203beed824cbdf111affe06cf3522bdeb", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/7b3c2c7203beed824cbdf111affe06cf3522bdeb", "committedDate": "2020-02-05T00:45:31Z", "message": "Rename method and add new MergeTrigger\n\n1. Renamed findCommitMerges -> findFullFlushMerges.\n2. Added MergeTrigger.COMMIT, passed to findFullFlushMerges and to\n   MergeScheduler when merging on commit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c04cfa875be6cd91fe0af69168a23fd459831ed6", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/c04cfa875be6cd91fe0af69168a23fd459831ed6", "committedDate": "2020-02-05T00:54:25Z", "message": "Update renamed method name in strings and comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDcyMzgz", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-370072383", "createdAt": "2020-03-06T04:10:58Z", "commit": {"oid": "c04cfa875be6cd91fe0af69168a23fd459831ed6"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTczNzMx", "url": "https://github.com/apache/lucene-solr/pull/1155#pullrequestreview-370173731", "createdAt": "2020-03-06T09:10:02Z", "commit": {"oid": "c04cfa875be6cd91fe0af69168a23fd459831ed6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOToxMDowM1rOFyxqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOToxMDowM1rOFyxqdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4NjgwNQ==", "bodyText": "I am not really happy with this interface. First and foremost it's only partially used in this PR. I also think it doesn't belong here but rather into a merge policy? I think IW and merge lifecycle should not be tightly coupled. Can we achieve the same with an interface a MP can provide to the IW rather than setting it on the IW config. A pull model should be used here instead IMO.", "url": "https://github.com/apache/lucene-solr/pull/1155#discussion_r388786805", "createdAt": "2020-03-06T09:10:03Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/IndexWriterEvents.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+\n+package org.apache.lucene.index;\n+\n+/**\n+ * Callback interface to signal various actions taken by IndexWriter.\n+ *\n+ * @lucene.experimental\n+ */\n+public interface IndexWriterEvents {\n+  /**\n+   * A default implementation that ignores all events.\n+   */\n+  IndexWriterEvents NULL_EVENTS = new IndexWriterEvents() {\n+    @Override\n+    public void beginMergeOnCommit() { }\n+\n+    @Override\n+    public void finishMergeOnCommit() { }\n+\n+    @Override\n+    public void abandonedMergesOnCommit(int abandonedCount) { }\n+  };\n+\n+  /**\n+   * Signals the start of waiting for a merge on commit, returned from\n+   * {@link MergePolicy#findFullFlushMerges(MergeTrigger, SegmentInfos, MergePolicy.MergeContext)}.\n+   */\n+  void beginMergeOnCommit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c04cfa875be6cd91fe0af69168a23fd459831ed6"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2361, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}