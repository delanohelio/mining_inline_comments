{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2OTIzNDM0", "number": 1394, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1ODoxOFrODtf9vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzowMTo1OVrODuC3Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM2MjIwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1ODoxOFrOF-9Rkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo0NjoxM1rOF_EJTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTk1NQ==", "bodyText": "after?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401559955", "createdAt": "2020-04-01T11:58:18Z", "author": {"login": "juanka588"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "diffHunk": "@@ -1483,6 +1484,81 @@ public void testAddIndexes() throws Exception {\n     IOUtils.close(dir1, dir2);\n   }\n \n+  public void testUpdatesAterAddIndexes() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5084d15c0137d113b81a66eb27738a7b5dd2f32"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MjUyNA==", "bodyText": "thanks, abd5e08", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401672524", "createdAt": "2020-04-01T14:46:13Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "diffHunk": "@@ -1483,6 +1484,81 @@ public void testAddIndexes() throws Exception {\n     IOUtils.close(dir1, dir2);\n   }\n \n+  public void testUpdatesAterAddIndexes() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTk1NQ=="}, "originalCommit": {"oid": "a5084d15c0137d113b81a66eb27738a7b5dd2f32"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDczMTE4OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMzozNDo0NlrOF_A4OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo0NjowNVrOF_EI8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxOTAwMA==", "bodyText": "Had a quick discussion about this line with Jim. This isn't good enough as this might return a field number that already exists in the reader if the field exists in the writer with a number that it less than the number of fields in the reader.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401619000", "createdAt": "2020-04-01T13:34:46Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,30 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = new FieldInfo(fi);\n+          newFields.put(clone.name, clone);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo fi = newFields.get(update.field);\n+          if (fi == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            fi = builder.getOrAdd(update.field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5084d15c0137d113b81a66eb27738a7b5dd2f32"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MjQzNQ==", "bodyText": "How to introduce the same bug but the other way around :(. Thanks for catching this Adrien. I pushed abd5e08 to handle this case properly.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401672435", "createdAt": "2020-04-01T14:46:05Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,30 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = new FieldInfo(fi);\n+          newFields.put(clone.name, clone);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo fi = newFields.get(update.field);\n+          if (fi == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            fi = builder.getOrAdd(update.field);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxOTAwMA=="}, "originalCommit": {"oid": "a5084d15c0137d113b81a66eb27738a7b5dd2f32"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTM0NjA2OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0ODowMVrOF_HAGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozMjowOFrOF_I4ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTMyMA==", "bodyText": "Do we need to set the doc-value type before cloning to make sure the doc-value type is set on the writer? I also wonder if we should use FieldInfos.Builder since this logic you implemented looks similar to FieldInfos.Builder#add.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401719320", "createdAt": "2020-04-01T15:48:01Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,36 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo fi = newFields.get(update.field);\n+          if (fi == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            fi = builder.getOrAdd(update.field);\n+            if (fi.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              fi = cloneFieldInfo(fi, ++maxFieldNumber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "387a7c30eaee45771491b4ff9e8afeff3dac63a8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0OTc5OQ==", "bodyText": "I also wonder if we should use FieldInfos.Builder since this logic you implemented looks similar to FieldInfos.Builder#add.\n\nI don't think it works since the logic there is to use the global field number if the field already exists in another segment. In the logic above we try to re-assign the global field number locally since it clashes with a local one.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401749799", "createdAt": "2020-04-01T16:31:40Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,36 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo fi = newFields.get(update.field);\n+          if (fi == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            fi = builder.getOrAdd(update.field);\n+            if (fi.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              fi = cloneFieldInfo(fi, ++maxFieldNumber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTMyMA=="}, "originalCommit": {"oid": "387a7c30eaee45771491b4ff9e8afeff3dac63a8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1MDE1NA==", "bodyText": "Do we need to set the doc-value type before cloning to make sure the doc-value type is set on the writer?\n\nthanks, I pushed 090ef78", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r401750154", "createdAt": "2020-04-01T16:32:08Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,36 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo fi = newFields.get(update.field);\n+          if (fi == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            fi = builder.getOrAdd(update.field);\n+            if (fi.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              fi = cloneFieldInfo(fi, ++maxFieldNumber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTMyMA=="}, "originalCommit": {"oid": "387a7c30eaee45771491b4ff9e8afeff3dac63a8"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU2ODg1OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1Njo1OFrOF_l7Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNjoyOVrOF_wuew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTkzOA==", "bodyText": "Sorry I wasn't sure how that worked when doing previous reviews, but the field infos of the writer should be updated when the doc-value update is performed. So the FieldInfo should always exist at this point and the doc-value type should always be correct. So we should be able to assert here instead of calling setDocValuesType.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402225938", "createdAt": "2020-04-02T10:56:58Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMjkzOQ==", "bodyText": "I added an assertion to check the dv type of the global field but we still need to set the dv type on the cloned field since it is not preserved by the getOrAdd call.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402402939", "createdAt": "2020-04-02T15:26:29Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTkzOA=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU4MjQzOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTowMTowMlrOF_mDYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNjozOFrOF_wu-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyODA2NQ==", "bodyText": "Sorry I suggested this on the previous review, but the doc-value type is actually supposed to be set on the updateDocValue call, so we should even be able to assert that the doc-value type is correct at this stage instead of setting it.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402228065", "createdAt": "2020-04-02T11:01:02Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzMzkzNw==", "bodyText": "maybe add a comment on the above getOrAdd call to mention that it never needs to add the field?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402233937", "createdAt": "2020-04-02T11:12:58Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyODA2NQ=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMzA2NQ==", "bodyText": "++, 0b5c6c8", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402403065", "createdAt": "2020-04-02T15:26:38Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyODA2NQ=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDYwNTQ1OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTowODoyOFrOF_mR8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNzoxOVrOF_ww4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzMTc5Mw==", "bodyText": "I think we should either have an else branch that updates the maxFieldNumber to avoid conflicts (in case dv updates introduce multiple fields) or always clone the FieldInfo to update the number. I have a preference for the latter since it requires fewer branches and makes the code easier to reason about?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402231793", "createdAt": "2020-04-02T11:08:28Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMzU1Mw==", "bodyText": "Thanks, I reworked the logic to always clone and reassign the field number.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402403553", "createdAt": "2020-04-02T15:27:19Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzMTc5Mw=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDYwNjQxOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMTowODo0N1rOF_mSig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNzoyNFrOF_wxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzMTk0Ng==", "bodyText": "this put call should be unnecessary since the field is already in the map?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402231946", "createdAt": "2020-04-02T11:08:47Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);\n+            }\n+            newFields.put(update.field, globalFieldInfo);\n+          } else {\n+            segmentFieldInfo.setDocValuesType(update.type);\n+            newFields.put(update.field, segmentFieldInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMzYzNA==", "bodyText": "++, removed", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402403634", "createdAt": "2020-04-02T15:27:24Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);\n+            }\n+            newFields.put(update.field, globalFieldInfo);\n+          } else {\n+            segmentFieldInfo.setDocValuesType(update.type);\n+            newFields.put(update.field, segmentFieldInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzMTk0Ng=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDYyMDUyOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMToxMzoyMFrOF_mbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNzozM1rOF_wxmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzNDExNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n          \n          \n            \n                      // if the segment was created externally (and added to this index with IndexWriter#addIndexes(Directory)).", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402234114", "createdAt": "2020-04-02T11:13:20Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMzczOA==", "bodyText": "++", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402403738", "createdAt": "2020-04-02T15:27:33Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzNDExNA=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDYzOTYwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMToxOToxNVrOF_mmhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToxNDo1N1rOF_wMHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzNzA2Mg==", "bodyText": "It might be better to split into one unit test for the addIndexes case when the updated field already exists in the segment, and another one for the case when the updated field doesn't exist in the segment yet?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402237062", "createdAt": "2020-04-02T11:19:15Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "diffHunk": "@@ -1483,6 +1484,83 @@ public void testAddIndexes() throws Exception {\n     IOUtils.close(dir1, dir2);\n   }\n \n+  public void testUpdatesAfterAddIndexes() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5NDE0MA==", "bodyText": "++, I pushed 00d7558", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402394140", "createdAt": "2020-04-02T15:14:57Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java", "diffHunk": "@@ -1483,6 +1484,83 @@ public void testAddIndexes() throws Exception {\n     IOUtils.close(dir1, dir2);\n   }\n \n+  public void testUpdatesAfterAddIndexes() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzNzA2Mg=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTI4NTc5OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDowNDo0OFrOF_s1kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToxNDo0OFrOF_wLmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMzOTIxOQ==", "bodyText": "extra newline", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402339219", "createdAt": "2020-04-02T14:04:48Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -644,6 +656,13 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n     return true;\n   }\n \n+  private FieldInfo cloneFieldInfo(FieldInfo fi, int fieldNumber) {\n+    return new FieldInfo(fi.name, fieldNumber, fi.hasVectors(), fi.omitsNorms(), fi.hasPayloads(),\n+        fi.getIndexOptions(), fi.getDocValuesType(), fi.getDocValuesGen(), new HashMap<>(fi.attributes()),\n+        fi.getPointDimensionCount(), fi.getPointIndexDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5NDAwOA==", "bodyText": "++, 34718cb", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402394008", "createdAt": "2020-04-02T15:14:48Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -644,6 +656,13 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n     return true;\n   }\n \n+  private FieldInfo cloneFieldInfo(FieldInfo fi, int fieldNumber) {\n+    return new FieldInfo(fi.name, fieldNumber, fi.hasVectors(), fi.omitsNorms(), fi.hasPayloads(),\n+        fi.getIndexOptions(), fi.getDocValuesType(), fi.getDocValuesGen(), new HashMap<>(fi.attributes()),\n+        fi.getPointDimensionCount(), fi.getPointIndexDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField());\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMzOTIxOQ=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTMwMjI0OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDowODozN1rOF_tASg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyODo1MFrOF_w1eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0MTk2Mg==", "bodyText": "we should set the DV type here too no?", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402341962", "createdAt": "2020-04-02T14:08:37Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDczMA==", "bodyText": "we should, thanks. I rewrote the logic in my last commits. I thought that addOrGet would preserve the dv type but it doesn't.", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402404730", "createdAt": "2020-04-02T15:28:50Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,39 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> newFields = new HashMap<>();\n         for (FieldInfo fi : reader.getFieldInfos()) {\n-          FieldInfo clone = builder.add(fi);\n-          // copy the stuff FieldInfos.Builder doesn't copy\n-          for (Entry<String,String> e : fi.attributes().entrySet()) {\n-            clone.putAttribute(e.getKey(), e.getValue());\n-          }\n-          clone.setDocValuesGen(fi.getDocValuesGen());\n+          // cannot use builder.add(fi) because it does not preserve\n+          // the local field number. Field numbers can be different from the global ones\n+          // if the segment was created externally (with IndexWriter#addIndexes(Directory)).\n+          FieldInfo clone = cloneFieldInfo(fi, fi.number);\n+          newFields.put(clone.name, clone);\n+          maxFieldNumber = Math.max(clone.number, maxFieldNumber);\n         }\n \n         // create new fields with the right DV type\n+        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n         for (List<DocValuesFieldUpdates> updates : pendingDVUpdates.values()) {\n           DocValuesFieldUpdates update = updates.get(0);\n-          FieldInfo fieldInfo = builder.getOrAdd(update.field);\n-          fieldInfo.setDocValuesType(update.type);\n+          FieldInfo globalFieldInfo =  builder.getOrAdd(update.field);\n+          globalFieldInfo.setDocValuesType(update.type);\n+          FieldInfo segmentFieldInfo = newFields.get(update.field);\n+          if (segmentFieldInfo == null) {\n+            // the field is not present in this segment so we can fallback to the global fields.\n+            if (globalFieldInfo.number <= maxFieldNumber) {\n+              // the global field number is already used in this segment for a different field so we force a new one locally.\n+              globalFieldInfo = cloneFieldInfo(globalFieldInfo, ++maxFieldNumber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0MTk2Mg=="}, "originalCommit": {"oid": "8b4b4e8fcda9fa63babe22f5a0be02fca38a3be8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjA3OTY3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzowMTo1OVrOF_0vzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMToyMTozNFrOGARUeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2ODgxMw==", "bodyText": "nit: we call it byNameelsewhere", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402468813", "createdAt": "2020-04-02T17:01:59Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,37 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> perName = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b5c6c896bcc67f8ec6d9206d5dc9caa5cc5ee81"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkzNjk1Mg==", "bodyText": "9fed431", "url": "https://github.com/apache/lucene-solr/pull/1394#discussion_r402936952", "createdAt": "2020-04-03T11:21:34Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java", "diffHunk": "@@ -543,27 +543,37 @@ public synchronized boolean writeFieldUpdates(Directory dir, FieldInfos.FieldNum\n       \n       try {\n         // clone FieldInfos so that we can update their dvGen separately from\n-        // the reader's infos and write them to a new fieldInfos_gen file\n-        FieldInfos.Builder builder = new FieldInfos.Builder(fieldNumbers);\n-        // cannot use builder.add(reader.getFieldInfos()) because it does not\n-        // clone FI.attributes as well FI.dvGen\n+        // the reader's infos and write them to a new fieldInfos_gen file.\n+        int maxFieldNumber = -1;\n+        Map<String, FieldInfo> perName = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2ODgxMw=="}, "originalCommit": {"oid": "0b5c6c896bcc67f8ec6d9206d5dc9caa5cc5ee81"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 747, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}