{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1ODUxNzA2", "number": 1548, "title": "SOLR-14524: Harden MultiThreadedOCPTest testFillWorkQueue()", "bodyText": "Description\nMake MultiThreadedOCPTest.testFillWorkQueue() less vulnerable to timing issues when test or overseer code are being slowed down by external factors (load, GC etc).\nSolution\nA combination of verifying preconditions (to fail with a meaningful messages helping pinpoint issues for future test hardening), longer task execution time (that does not delay total test runtime) and do light synchronization between test steps and Overseeer processing progress.\nTests\nThis is a test.\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ant precommit and the appropriate test suite.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-06-01T09:14:50Z", "url": "https://github.com/apache/lucene-solr/pull/1548", "merged": true, "mergeCommit": {"oid": "dec692252874a5b60dfb71d8c38643a285975b22"}, "closed": true, "closedAt": "2020-06-04T21:37:25Z", "author": {"login": "murblanc"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcm8hDugH2gAyNDI1ODUxNzA2OjI5OTE0NDVkYTdkYjJkMjAzZmVlM2VmZGM4NWI4ZDBhOWE1NTQzZDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnysQHgH2gAyNDI1ODUxNzA2OjA5MjVmOTA5NjBkZDIyNjRmZmIxNjJhYjQ4MTk3NmYxZmIwY2UyODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/2991445da7db2d203fee3efdc85b8d0a9a5543d1", "committedDate": "2020-06-01T09:05:37Z", "message": "SOLR-14524: make MultiThreadedOCPTest.testFillWorkQueue() less vulnerable to timing issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTE3MDA4", "url": "https://github.com/apache/lucene-solr/pull/1548#pullrequestreview-421917008", "createdAt": "2020-06-01T15:01:27Z", "commit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTowMToyN1rOGdNxSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToxMToxMVrOGdOHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4NzQ5Ng==", "bodyText": "I found this section a little bit hard to read, would prefer something more verbose but potentially easier to understand at a glance.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433287496", "createdAt": "2020-06-01T15:01:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTI4Ng==", "bodyText": "I think one way to make this cleaner is to extract getStatusResponse().getResponse.get(\"MOCK_FINISHED\") out into a separate method.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433291286", "createdAt": "2020-06-01T15:07:49Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjI3Mg==", "bodyText": "Do we really care about checking for a3 here? Why not check once after the loop?", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292272", "createdAt": "2020-06-01T15:09:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;\n       for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n+        if (acoll3 == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5Mjg3NA==", "bodyText": "Assuming the queue works as advertised, can we skip checking a0 and only check a1?", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292874", "createdAt": "2020-06-01T15:10:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MzI1Ng==", "bodyText": "Inconsistent naming: acoll0, acoll1, then acoll3.", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433293256", "createdAt": "2020-06-01T15:11:11Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "481408a6b07d3dc9e469e329c7341d85a6b3a120", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/481408a6b07d3dc9e469e329c7341d85a6b3a120", "committedDate": "2020-06-01T17:44:26Z", "message": "SOLR-14524: comments from madrob"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODk0NTcz", "url": "https://github.com/apache/lucene-solr/pull/1548#pullrequestreview-423894573", "createdAt": "2020-06-03T20:13:34Z", "commit": {"oid": "481408a6b07d3dc9e469e329c7341d85a6b3a120"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoxMzozNFrOGert1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDoxMzozNFrOGert1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyNjcwOA==", "bodyText": "nit: javadoc complains about this not being a visible reference", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r434826708", "createdAt": "2020-06-03T20:13:34Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -77,42 +76,68 @@ private void testFillWorkQueue() throws Exception {\n         distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n             \"collection\", \"A_COLL\",\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n-            ASYNC, String.valueOf(i),\n+            ASYNC, Integer.toString(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n-\n       }\n-      Thread.sleep(100);//wait and post the next message\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Wait until we see the second A_COLL task getting processed (assuming the first got processed as well)\n+      Long task1CollA = waitForTaskToCompleted(client, 1);\n+\n+      assertNotNull(\"Queue did not process first two tasks on A_COLL, can't run test\", task1CollA);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", checkTaskHasCompleted(client, 2));\n+\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long taskCollB = waitForTaskToCompleted(client, 200);\n \n-      Long acoll = null, bcoll = null;\n-      for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll != null && bcoll != null) break;\n-        Thread.sleep(100);\n+      // We do not wait for the long running task to finish, that would be a waste of time.\n+      Long task2CollA = checkTaskHasCompleted(client, 2);\n+\n+      // Given the wait delay (500 iterations of 100ms), the task has plenty of time to complete, so this is not expected.\n+      assertNotNull(\"Task on  B_COLL did not complete, can't test\", taskCollB);\n+      // We didn't wait for the 3rd A_COLL task to complete (test can run quickly) but if it did, we expect the B_COLL to have finished first.\n+      assertTrue(\"task2CollA: \" + task2CollA + \" taskCollB: \" + taskCollB, task2CollA  == null || task2CollA > taskCollB);\n+    }\n+  }\n+\n+  /**\n+   * Verifies the status of an async task submitted to the Overseer Collection queue.\n+   * @return <code>null</code> if the task has not completed, the completion timestamp if the task has completed\n+   * (see {@link org.apache.solr.cloud.api.collections.OverseerCollectionMessageHandler#mockOperation}).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "481408a6b07d3dc9e469e329c7341d85a6b3a120"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0925f90960dd2264ffb162ab481976f1fb0ce283", "author": {"user": {"login": "murblanc", "name": "Ilan Ginzburg"}}, "url": "https://github.com/apache/lucene-solr/commit/0925f90960dd2264ffb162ab481976f1fb0ce283", "committedDate": "2020-06-04T00:12:43Z", "message": "SOLR-14524: make javadoc happy by removing reference to private method"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2571, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}