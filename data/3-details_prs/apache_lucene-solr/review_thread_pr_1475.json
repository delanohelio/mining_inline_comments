{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMTM5Njc5", "number": 1475, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MDo0MlrOEDVbeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MTo1MFrOEDVcvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTMyMjgyOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene86/Lucene86PointsWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MDo0M1rOGgSrag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MDo0M1rOGgSrag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzY0Mg==", "bodyText": "I wonder if we should use the same structure as in the other places by returning here as well a runnable for consistency?", "url": "https://github.com/apache/lucene-solr/pull/1475#discussion_r436513642", "createdAt": "2020-06-08T07:50:43Z", "author": {"login": "iverase"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene86/Lucene86PointsWriter.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.codecs.lucene86;\n+\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.lucene.codecs.CodecUtil;\n+import org.apache.lucene.codecs.MutablePointValues;\n+import org.apache.lucene.codecs.PointsReader;\n+import org.apache.lucene.codecs.PointsWriter;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.FieldInfos;\n+import org.apache.lucene.index.IndexFileNames;\n+import org.apache.lucene.index.MergeState;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.index.PointValues.IntersectVisitor;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.index.SegmentWriteState;\n+import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.util.IOUtils;\n+import org.apache.lucene.util.bkd.BKDReader;\n+import org.apache.lucene.util.bkd.BKDWriter;\n+\n+/** Writes dimensional values */\n+public class Lucene86PointsWriter extends PointsWriter implements Closeable {\n+\n+  /** Outputs used to write the BKD tree data files. */\n+  protected final IndexOutput metaOut, indexOut, dataOut;\n+\n+  final SegmentWriteState writeState;\n+  final int maxPointsInLeafNode;\n+  final double maxMBSortInHeap;\n+  private boolean finished;\n+\n+  /** Full constructor */\n+  public Lucene86PointsWriter(SegmentWriteState writeState, int maxPointsInLeafNode, double maxMBSortInHeap) throws IOException {\n+    assert writeState.fieldInfos.hasPointValues();\n+    this.writeState = writeState;\n+    this.maxPointsInLeafNode = maxPointsInLeafNode;\n+    this.maxMBSortInHeap = maxMBSortInHeap;\n+    String dataFileName = IndexFileNames.segmentFileName(writeState.segmentInfo.name,\n+                                                         writeState.segmentSuffix,\n+                                                         Lucene86PointsFormat.DATA_EXTENSION);\n+    dataOut = writeState.directory.createOutput(dataFileName, writeState.context);\n+    boolean success = false;\n+    try {\n+      CodecUtil.writeIndexHeader(dataOut,\n+                                 Lucene86PointsFormat.DATA_CODEC_NAME,\n+                                 Lucene86PointsFormat.VERSION_CURRENT,\n+                                 writeState.segmentInfo.getId(),\n+                                 writeState.segmentSuffix);\n+\n+      String metaFileName = IndexFileNames.segmentFileName(writeState.segmentInfo.name,\n+          writeState.segmentSuffix,\n+          Lucene86PointsFormat.META_EXTENSION);\n+      metaOut = writeState.directory.createOutput(metaFileName, writeState.context);\n+      CodecUtil.writeIndexHeader(metaOut,\n+          Lucene86PointsFormat.META_CODEC_NAME,\n+          Lucene86PointsFormat.VERSION_CURRENT,\n+          writeState.segmentInfo.getId(),\n+          writeState.segmentSuffix);\n+\n+      String indexFileName = IndexFileNames.segmentFileName(writeState.segmentInfo.name,\n+          writeState.segmentSuffix,\n+          Lucene86PointsFormat.INDEX_EXTENSION);\n+      indexOut = writeState.directory.createOutput(indexFileName, writeState.context);\n+      CodecUtil.writeIndexHeader(indexOut,\n+          Lucene86PointsFormat.INDEX_CODEC_NAME,\n+          Lucene86PointsFormat.VERSION_CURRENT,\n+          writeState.segmentInfo.getId(),\n+          writeState.segmentSuffix);\n+\n+      success = true;\n+    } finally {\n+      if (success == false) {\n+        IOUtils.closeWhileHandlingException(this);\n+      }\n+    }\n+  }\n+\n+  /** Uses the defaults values for {@code maxPointsInLeafNode} (1024) and {@code maxMBSortInHeap} (16.0) */\n+  public Lucene86PointsWriter(SegmentWriteState writeState) throws IOException {\n+    this(writeState, BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n+  }\n+\n+  @Override\n+  public void writeField(FieldInfo fieldInfo, PointsReader reader) throws IOException {\n+\n+    PointValues values = reader.getValues(fieldInfo.name);\n+\n+    try (BKDWriter writer = new BKDWriter(writeState.segmentInfo.maxDoc(),\n+                                          writeState.directory,\n+                                          writeState.segmentInfo.name,\n+                                          fieldInfo.getPointDimensionCount(),\n+                                          fieldInfo.getPointIndexDimensionCount(),\n+                                          fieldInfo.getPointNumBytes(),\n+                                          maxPointsInLeafNode,\n+                                          maxMBSortInHeap,\n+                                          values.size())) {\n+\n+      if (values instanceof MutablePointValues) {\n+        Runnable finalizer = writer.writeField(metaOut, indexOut, dataOut, fieldInfo.name, (MutablePointValues) values);\n+        if (finalizer != null) {\n+          metaOut.writeInt(fieldInfo.number);\n+          finalizer.run();\n+        }\n+        return;\n+      }\n+\n+      values.intersect(new IntersectVisitor() {\n+          @Override\n+          public void visit(int docID) {\n+            throw new IllegalStateException();\n+          }\n+\n+          public void visit(int docID, byte[] packedValue) throws IOException {\n+            writer.add(packedValue, docID);\n+          }\n+\n+          @Override\n+          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+            return Relation.CELL_CROSSES_QUERY;\n+          }\n+        });\n+\n+      // We could have 0 points on merge since all docs with dimensional fields may be deleted:\n+      if (writer.getPointCount() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d814fc5db25afb7802f318dcb2bead5f1fa97673"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTMyNjA3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MTo1MFrOGgStew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MTo1MFrOGgStew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxNDE3MQ==", "bodyText": "Not used any more?", "url": "https://github.com/apache/lucene-solr/pull/1475#discussion_r436514171", "createdAt": "2020-06-08T07:51:50Z", "author": {"login": "iverase"}, "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -627,20 +638,20 @@ assert valueInOrder(valueCount + leafCount,\n       assert (lastDocID = docID) >= 0; // only assign when asserts are enabled\n     }\n \n-    public long finish() throws IOException {\n+    public Runnable finish() throws IOException {\n       if (leafCount > 0) {\n         writeLeafBlock(leafCardinality);\n         leafCardinality = 0;\n         leafCount = 0;\n       }\n \n       if (valueCount == 0) {\n-        return -1;\n+        return null;\n       }\n \n       pointCount = valueCount;\n \n-      long indexFP = out.getFilePointer();\n+      long indexFP = indexOut.getFilePointer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d814fc5db25afb7802f318dcb2bead5f1fa97673"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1503, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}