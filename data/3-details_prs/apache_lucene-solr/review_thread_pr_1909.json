{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwOTQwNzUx", "number": 1909, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo0NTowMVrOEmMnfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo1OTozMVrOEma5Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDg4MDYyOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo0NTowMVrOHWFhtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo0NTowMVrOHWFhtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyMTI3MA==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * NOTE: This reader should only be used for merging. Pulling fields from this ready might be very costly and memory\n          \n          \n            \n             * NOTE: This reader should only be used for merging. Pulling fields from this reader might be very costly and memory", "url": "https://github.com/apache/lucene-solr/pull/1909#discussion_r492921270", "createdAt": "2020-09-22T17:45:01Z", "author": {"login": "jimczi"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -41,21 +41,13 @@\n  * {@link Sort}. This can be used to re-sort and index after it's been created by wrapping all\n  * readers of the index with this reader and adding it to a fresh IndexWriter via\n  * {@link IndexWriter#addIndexes(CodecReader...)}.\n+ * NOTE: This reader should only be used for merging. Pulling fields from this ready might be very costly and memory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3ea2a8bc34b9a1d6b9960156aae80cac5312b49"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzIxOTY2OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo1OTozMVrOHWbXxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMTo0NTo0MlrOHWoSPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3OTE3Mg==", "bodyText": "I think we might cache norms twice if full-text is indexed, as we'd pull norms once for merging norms, and another time to index impacts in postings for the same field.", "url": "https://github.com/apache/lucene-solr/pull/1909#discussion_r493279172", "createdAt": "2020-09-23T07:59:31Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -510,4 +457,52 @@ public LeafMetaData getMetaData() {\n     return metaData;\n   }\n \n+  // we try to cache the last used DV or Norms instance since during merge\n+  // this instance is used more than once. We could in addition to this single instance\n+  // also cache the fields that are used for sorting since we do the work twice for these fields\n+  private String cachedField;\n+  private Object cachedObject;\n+  private boolean cacheIsNorms;\n+\n+  private <T> T getOrCreateNorms(String field, IOSupplier<T> supplier) throws IOException {\n+    return getOrCreate(field, true, supplier);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private synchronized  <T> T getOrCreate(String field, boolean norms, IOSupplier<T> supplier) throws IOException {\n+    if ((field.equals(cachedField) && cacheIsNorms == norms) == false) {\n+      assert assertCreatedOnlyOnce(field, norms);\n+      cachedObject = supplier.get();\n+      cachedField = field;\n+      cacheIsNorms = norms;\n+\n+    }\n+    assert cachedObject != null;\n+    return (T) cachedObject;\n+  }\n+\n+  private final Map<String, Integer> cacheStats = new HashMap<>(); // only with assertions enabled\n+  private boolean assertCreatedOnlyOnce(String field, boolean norms) {\n+    assert Thread.holdsLock(this);\n+    // this is mainly there to make sure we change anything in the way we merge we realize it early\n+    Integer timesCached = cacheStats.compute(field + \"N:\" + norms, (s, i) -> i == null ? 1 : i.intValue() + 1);\n+    if (timesCached > 1) {\n+      assert norms == false :\"[\" + field + \"] norms must not be cached twice\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fa6437128af08c672a506dfbec69f76285b404c"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NzE0MA==", "bodyText": "can you point me to the place where we do this? If that is the case our tests are not good enough here.", "url": "https://github.com/apache/lucene-solr/pull/1909#discussion_r493477140", "createdAt": "2020-09-23T11:28:59Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -510,4 +457,52 @@ public LeafMetaData getMetaData() {\n     return metaData;\n   }\n \n+  // we try to cache the last used DV or Norms instance since during merge\n+  // this instance is used more than once. We could in addition to this single instance\n+  // also cache the fields that are used for sorting since we do the work twice for these fields\n+  private String cachedField;\n+  private Object cachedObject;\n+  private boolean cacheIsNorms;\n+\n+  private <T> T getOrCreateNorms(String field, IOSupplier<T> supplier) throws IOException {\n+    return getOrCreate(field, true, supplier);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private synchronized  <T> T getOrCreate(String field, boolean norms, IOSupplier<T> supplier) throws IOException {\n+    if ((field.equals(cachedField) && cacheIsNorms == norms) == false) {\n+      assert assertCreatedOnlyOnce(field, norms);\n+      cachedObject = supplier.get();\n+      cachedField = field;\n+      cacheIsNorms = norms;\n+\n+    }\n+    assert cachedObject != null;\n+    return (T) cachedObject;\n+  }\n+\n+  private final Map<String, Integer> cacheStats = new HashMap<>(); // only with assertions enabled\n+  private boolean assertCreatedOnlyOnce(String field, boolean norms) {\n+    assert Thread.holdsLock(this);\n+    // this is mainly there to make sure we change anything in the way we merge we realize it early\n+    Integer timesCached = cacheStats.compute(field + \"N:\" + norms, (s, i) -> i == null ? 1 : i.intValue() + 1);\n+    if (timesCached > 1) {\n+      assert norms == false :\"[\" + field + \"] norms must not be cached twice\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3OTE3Mg=="}, "originalCommit": {"oid": "0fa6437128af08c672a506dfbec69f76285b404c"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MjAxMg==", "bodyText": "I think what we do here is we pull the already merged norms instance from disk instead of the one from the source reader. Is that what you mean in PushPostingsWriterBase", "url": "https://github.com/apache/lucene-solr/pull/1909#discussion_r493482012", "createdAt": "2020-09-23T11:35:29Z", "author": {"login": "s1monw"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -510,4 +457,52 @@ public LeafMetaData getMetaData() {\n     return metaData;\n   }\n \n+  // we try to cache the last used DV or Norms instance since during merge\n+  // this instance is used more than once. We could in addition to this single instance\n+  // also cache the fields that are used for sorting since we do the work twice for these fields\n+  private String cachedField;\n+  private Object cachedObject;\n+  private boolean cacheIsNorms;\n+\n+  private <T> T getOrCreateNorms(String field, IOSupplier<T> supplier) throws IOException {\n+    return getOrCreate(field, true, supplier);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private synchronized  <T> T getOrCreate(String field, boolean norms, IOSupplier<T> supplier) throws IOException {\n+    if ((field.equals(cachedField) && cacheIsNorms == norms) == false) {\n+      assert assertCreatedOnlyOnce(field, norms);\n+      cachedObject = supplier.get();\n+      cachedField = field;\n+      cacheIsNorms = norms;\n+\n+    }\n+    assert cachedObject != null;\n+    return (T) cachedObject;\n+  }\n+\n+  private final Map<String, Integer> cacheStats = new HashMap<>(); // only with assertions enabled\n+  private boolean assertCreatedOnlyOnce(String field, boolean norms) {\n+    assert Thread.holdsLock(this);\n+    // this is mainly there to make sure we change anything in the way we merge we realize it early\n+    Integer timesCached = cacheStats.compute(field + \"N:\" + norms, (s, i) -> i == null ? 1 : i.intValue() + 1);\n+    if (timesCached > 1) {\n+      assert norms == false :\"[\" + field + \"] norms must not be cached twice\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3OTE3Mg=="}, "originalCommit": {"oid": "0fa6437128af08c672a506dfbec69f76285b404c"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5MDc1MQ==", "bodyText": "Ah I had forgotten we were doing things this way. Then ignore my comment!", "url": "https://github.com/apache/lucene-solr/pull/1909#discussion_r493490751", "createdAt": "2020-09-23T11:45:42Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -510,4 +457,52 @@ public LeafMetaData getMetaData() {\n     return metaData;\n   }\n \n+  // we try to cache the last used DV or Norms instance since during merge\n+  // this instance is used more than once. We could in addition to this single instance\n+  // also cache the fields that are used for sorting since we do the work twice for these fields\n+  private String cachedField;\n+  private Object cachedObject;\n+  private boolean cacheIsNorms;\n+\n+  private <T> T getOrCreateNorms(String field, IOSupplier<T> supplier) throws IOException {\n+    return getOrCreate(field, true, supplier);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private synchronized  <T> T getOrCreate(String field, boolean norms, IOSupplier<T> supplier) throws IOException {\n+    if ((field.equals(cachedField) && cacheIsNorms == norms) == false) {\n+      assert assertCreatedOnlyOnce(field, norms);\n+      cachedObject = supplier.get();\n+      cachedField = field;\n+      cacheIsNorms = norms;\n+\n+    }\n+    assert cachedObject != null;\n+    return (T) cachedObject;\n+  }\n+\n+  private final Map<String, Integer> cacheStats = new HashMap<>(); // only with assertions enabled\n+  private boolean assertCreatedOnlyOnce(String field, boolean norms) {\n+    assert Thread.holdsLock(this);\n+    // this is mainly there to make sure we change anything in the way we merge we realize it early\n+    Integer timesCached = cacheStats.compute(field + \"N:\" + norms, (s, i) -> i == null ? 1 : i.intValue() + 1);\n+    if (timesCached > 1) {\n+      assert norms == false :\"[\" + field + \"] norms must not be cached twice\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3OTE3Mg=="}, "originalCommit": {"oid": "0fa6437128af08c672a506dfbec69f76285b404c"}, "originalPosition": 234}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1258, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}