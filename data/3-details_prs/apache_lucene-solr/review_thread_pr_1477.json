{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMTk5Mjkz", "number": 1477, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxODoxODozMFrOD4ca1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo1MjoxOVrOD81z-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTEyNDcwOnYy", "diffSide": "RIGHT", "path": "gradle/documentation/documentation.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxODoxODozMFrOGPRi1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1MTo1MVrOGVlcSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTI2OQ==", "bodyText": "I'd rather have it as separate configure(\":lucene\"), configure(\":solr\") blocks... would be easier to separate the logic between the two?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418669269", "createdAt": "2020-05-01T18:18:30Z", "author": {"login": "dweiss"}, "path": "gradle/documentation/documentation.gradle", "diffHunk": "@@ -34,4 +36,11 @@ configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n   ext {\n     docroot = \"${project.buildDir}/documentation\"\n   }\n+  \n+  task copyDocumentationAssets(type: Copy) {\n+    includeEmptyDirs = false\n+    from('site/html')      // lucene", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MzI1Mg==", "bodyText": "Here it's easy to separate, will do!", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418783252", "createdAt": "2020-05-01T23:55:53Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/documentation.gradle", "diffHunk": "@@ -34,4 +36,11 @@ configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n   ext {\n     docroot = \"${project.buildDir}/documentation\"\n   }\n+  \n+  task copyDocumentationAssets(type: Copy) {\n+    includeEmptyDirs = false\n+    from('site/html')      // lucene", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTI2OQ=="}, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4NjcyOQ==", "bodyText": "I did this for the main task. At this place we can also do it, but that's less to maintain.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425286729", "createdAt": "2020-05-14T16:51:51Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/documentation.gradle", "diffHunk": "@@ -34,4 +36,11 @@ configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n   ext {\n     docroot = \"${project.buildDir}/documentation\"\n   }\n+  \n+  task copyDocumentationAssets(type: Copy) {\n+    includeEmptyDirs = false\n+    from('site/html')      // lucene", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTI2OQ=="}, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTEyNTI5OnYy", "diffSide": "RIGHT", "path": "gradle/documentation/markdown.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxODoxODo0NFrOGPRjMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzo1ODo0NVrOGPYiXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTM2MQ==", "bodyText": "Right... same here.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418669361", "createdAt": "2020-05-01T18:18:44Z", "author": {"login": "dweiss"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    def flexmarkVersion = '0.61.24'\n+  \n+    classpath 'com.vladsch.flexmark:flexmark:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-autolink:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-abbreviation:' + flexmarkVersion\n+  }\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    from('.') {            // lucene", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MzgzOQ==", "bodyText": "I was thinking about that too, but this was easier to begin with. I did not want to clone the whole \"Copy\" task several times. If you tell me how to do this easier, give me a hint!\nShould I remove the from here and then add 2 separate configures for lucene and solr just adding the from?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418783839", "createdAt": "2020-05-01T23:58:45Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    def flexmarkVersion = '0.61.24'\n+  \n+    classpath 'com.vladsch.flexmark:flexmark:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-autolink:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-abbreviation:' + flexmarkVersion\n+  }\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    from('.') {            // lucene", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTM2MQ=="}, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTEyNzAxOnYy", "diffSide": "RIGHT", "path": "gradle/documentation/markdown.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxODoxOToxN1rOGPRkOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzo1NjoyNlrOGPYgeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTYyNA==", "bodyText": "Looks legit to me, not a hack? :)", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418669624", "createdAt": "2020-05-01T18:19:17Z", "author": {"login": "dweiss"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    def flexmarkVersion = '0.61.24'\n+  \n+    classpath 'com.vladsch.flexmark:flexmark:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-autolink:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-abbreviation:' + flexmarkVersion\n+  }\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    from('.') {            // lucene\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+    from('site') {         // solr\n+      include '**/*.md'\n+    }\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+class MarkdownFilter extends FilterReader {\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is a hack: it reads whole file, converts it and provides result as a StringReader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MzM1Mw==", "bodyText": "It looks like misuse of a FilterReader, because you do everything in the constructor.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r418783353", "createdAt": "2020-05-01T23:56:26Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    def flexmarkVersion = '0.61.24'\n+  \n+    classpath 'com.vladsch.flexmark:flexmark:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-autolink:' + flexmarkVersion\n+    classpath 'com.vladsch.flexmark:flexmark-ext-abbreviation:' + flexmarkVersion\n+  }\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    from('.') {            // lucene\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+    from('site') {         // solr\n+      include '**/*.md'\n+    }\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+class MarkdownFilter extends FilterReader {\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is a hack: it reads whole file, converts it and provides result as a StringReader", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2OTYyNA=="}, "originalCommit": {"oid": "914ba181f6b8c3c1ad5171d975db1f352cf52349"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODc1ODU4OnYy", "diffSide": "RIGHT", "path": "gradle/documentation/markdown.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxODo0Mzo0OVrOGVpnZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozOTozN1rOGVrcIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1NTEwOA==", "bodyText": "Should we move it to an external file? Then we can have a proper suffix and editor support.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425355108", "createdAt": "2020-05-14T18:43:49Z", "author": {"login": "dweiss"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    def outputFile = file(\"${project.docroot}/index.html\");\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    \n+    inputs.file(defaultCodecFile)\n+    outputs.file(outputFile)\n+    \n+    doLast {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def defaultCodecPackage = matcher.group(1).toLowerCase(Locale.ROOT)\n+      def markdown = \"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aabfb27913598d4b4e95d905f4d72918a8ac4162"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MTEyOQ==", "bodyText": "That was my question. Can we include it in a way so the groovy variables are parsed?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425371129", "createdAt": "2020-05-14T19:12:31Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    def outputFile = file(\"${project.docroot}/index.html\");\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    \n+    inputs.file(defaultCodecFile)\n+    outputs.file(outputFile)\n+    \n+    doLast {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def defaultCodecPackage = matcher.group(1).toLowerCase(Locale.ROOT)\n+      def markdown = \"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1NTEwOA=="}, "originalCommit": {"oid": "aabfb27913598d4b4e95d905f4d72918a8ac4162"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3NTgzMg==", "bodyText": "https://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html\nShould work?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425375832", "createdAt": "2020-05-14T19:21:46Z", "author": {"login": "dweiss"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    def outputFile = file(\"${project.docroot}/index.html\");\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    \n+    inputs.file(defaultCodecFile)\n+    outputs.file(outputFile)\n+    \n+    doLast {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def defaultCodecPackage = matcher.group(1).toLowerCase(Locale.ROOT)\n+      def markdown = \"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1NTEwOA=="}, "originalCommit": {"oid": "aabfb27913598d4b4e95d905f4d72918a8ac4162"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NDk5Mg==", "bodyText": "Cool. So I will place the file next to the legacy XSL file used by Ant. Once Ant is retired, the latter can go away.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425384992", "createdAt": "2020-05-14T19:39:37Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    def outputFile = file(\"${project.docroot}/index.html\");\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    \n+    inputs.file(defaultCodecFile)\n+    outputs.file(outputFile)\n+    \n+    doLast {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def defaultCodecPackage = matcher.group(1).toLowerCase(Locale.ROOT)\n+      def markdown = \"\"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1NTEwOA=="}, "originalCommit": {"oid": "aabfb27913598d4b4e95d905f4d72918a8ac4162"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTIyODEwOnYy", "diffSide": "RIGHT", "path": "gradle/documentation/markdown.gradle", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo1MjoxOVrOGWBsFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMjo0Mjo1MlrOGWDOjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTUyNg==", "bodyText": "Would it be better inserting <!DOCTYPE html> at the beginning (as a valid html5)?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425749526", "createdAt": "2020-05-15T11:52:19Z", "author": {"login": "mocobeta"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import groovy.text.SimpleTemplateEngine;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex(type: MarkdownTemplateTask) {\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    inputs.file(defaultCodecFile)\n+\n+    outputFile = file(\"${project.docroot}/index.html\")\n+    templateFile = file('site/xsl/index.template.md')\n+    \n+    binding = {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def majorVersion = project.version.split(/\\./)[0] as int;\n+      return [\n+        defaultCodecPackage : matcher.group(1).toLowerCase(Locale.ROOT),\n+        version : project.version,\n+        majorVersion : majorVersion,\n+        projectList : getListOfProjectsAsMarkdown(':lucene:')\n+      ]\n+    }\n+  }\n+}\n+\n+configure(project(':solr')) {\n+  markdownToHtml {\n+    from('site') {\n+      include '**/*.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+// filter that can be used with the \"copy\" task of Gradle that transforms Markdown files\n+// from source location to HTML (adding HTML header, styling,...)\n+class MarkdownFilter extends FilterReader {\n+\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is not really a filter: it reads whole file in ctor,\n+    // converts it and provides result downstream as a StringReader\n+    super(new StringReader(convert(reader.text)));\n+  }\n+  \n+  public static String convert(String markdownSource) {\n+    // first replace LUCENE and SOLR issue numbers with a markdown link\n+    markdownSource = markdownSource.replaceAll(/(?s)\\b(LUCENE|SOLR)\\-\\d+\\b/,\n+      '[$0](https://issues.apache.org/jira/browse/$0)');\n+  \n+    // convert the markdown\n+    MutableDataSet options = new MutableDataSet();\n+    options.setFrom(ParserEmulationProfile.MARKDOWN);\n+    options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create(), AttributesExtension.create() ]);\n+    options.set(HtmlRenderer.RENDER_HEADER_ID, true);\n+    options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);\n+    Document parsed = Parser.builder(options).build().parse(markdownSource);\n+\n+    StringBuilder html = new StringBuilder('<html>\\n<head>\\n');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16e75cd068f6d295ba3f3abce5f8adc089246420"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc1NjQzNg==", "bodyText": "Yes, if we add CSS that's a good idea. With the current unstyled stuff this was the simplest we can do.\nIf we change that here, we should also do this in tools/ where Ant's script is located.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425756436", "createdAt": "2020-05-15T12:06:52Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import groovy.text.SimpleTemplateEngine;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex(type: MarkdownTemplateTask) {\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    inputs.file(defaultCodecFile)\n+\n+    outputFile = file(\"${project.docroot}/index.html\")\n+    templateFile = file('site/xsl/index.template.md')\n+    \n+    binding = {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def majorVersion = project.version.split(/\\./)[0] as int;\n+      return [\n+        defaultCodecPackage : matcher.group(1).toLowerCase(Locale.ROOT),\n+        version : project.version,\n+        majorVersion : majorVersion,\n+        projectList : getListOfProjectsAsMarkdown(':lucene:')\n+      ]\n+    }\n+  }\n+}\n+\n+configure(project(':solr')) {\n+  markdownToHtml {\n+    from('site') {\n+      include '**/*.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+// filter that can be used with the \"copy\" task of Gradle that transforms Markdown files\n+// from source location to HTML (adding HTML header, styling,...)\n+class MarkdownFilter extends FilterReader {\n+\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is not really a filter: it reads whole file in ctor,\n+    // converts it and provides result downstream as a StringReader\n+    super(new StringReader(convert(reader.text)));\n+  }\n+  \n+  public static String convert(String markdownSource) {\n+    // first replace LUCENE and SOLR issue numbers with a markdown link\n+    markdownSource = markdownSource.replaceAll(/(?s)\\b(LUCENE|SOLR)\\-\\d+\\b/,\n+      '[$0](https://issues.apache.org/jira/browse/$0)');\n+  \n+    // convert the markdown\n+    MutableDataSet options = new MutableDataSet();\n+    options.setFrom(ParserEmulationProfile.MARKDOWN);\n+    options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create(), AttributesExtension.create() ]);\n+    options.set(HtmlRenderer.RENDER_HEADER_ID, true);\n+    options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);\n+    Document parsed = Parser.builder(options).build().parse(markdownSource);\n+\n+    StringBuilder html = new StringBuilder('<html>\\n<head>\\n');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTUyNg=="}, "originalCommit": {"oid": "16e75cd068f6d295ba3f3abce5f8adc089246420"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2Mzk3Nw==", "bodyText": "Applying CSS was in my mind. I will add the tag later when I add the style file.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425763977", "createdAt": "2020-05-15T12:22:29Z", "author": {"login": "mocobeta"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import groovy.text.SimpleTemplateEngine;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex(type: MarkdownTemplateTask) {\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    inputs.file(defaultCodecFile)\n+\n+    outputFile = file(\"${project.docroot}/index.html\")\n+    templateFile = file('site/xsl/index.template.md')\n+    \n+    binding = {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def majorVersion = project.version.split(/\\./)[0] as int;\n+      return [\n+        defaultCodecPackage : matcher.group(1).toLowerCase(Locale.ROOT),\n+        version : project.version,\n+        majorVersion : majorVersion,\n+        projectList : getListOfProjectsAsMarkdown(':lucene:')\n+      ]\n+    }\n+  }\n+}\n+\n+configure(project(':solr')) {\n+  markdownToHtml {\n+    from('site') {\n+      include '**/*.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+// filter that can be used with the \"copy\" task of Gradle that transforms Markdown files\n+// from source location to HTML (adding HTML header, styling,...)\n+class MarkdownFilter extends FilterReader {\n+\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is not really a filter: it reads whole file in ctor,\n+    // converts it and provides result downstream as a StringReader\n+    super(new StringReader(convert(reader.text)));\n+  }\n+  \n+  public static String convert(String markdownSource) {\n+    // first replace LUCENE and SOLR issue numbers with a markdown link\n+    markdownSource = markdownSource.replaceAll(/(?s)\\b(LUCENE|SOLR)\\-\\d+\\b/,\n+      '[$0](https://issues.apache.org/jira/browse/$0)');\n+  \n+    // convert the markdown\n+    MutableDataSet options = new MutableDataSet();\n+    options.setFrom(ParserEmulationProfile.MARKDOWN);\n+    options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create(), AttributesExtension.create() ]);\n+    options.set(HtmlRenderer.RENDER_HEADER_ID, true);\n+    options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);\n+    Document parsed = Parser.builder(options).build().parse(markdownSource);\n+\n+    StringBuilder html = new StringBuilder('<html>\\n<head>\\n');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTUyNg=="}, "originalCommit": {"oid": "16e75cd068f6d295ba3f3abce5f8adc089246420"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2OTEyNQ==", "bodyText": "I would add CSS in a separate issue. I just want to get everything running first. What do you think about current state?", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425769125", "createdAt": "2020-05-15T12:32:19Z", "author": {"login": "uschindler"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import groovy.text.SimpleTemplateEngine;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex(type: MarkdownTemplateTask) {\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    inputs.file(defaultCodecFile)\n+\n+    outputFile = file(\"${project.docroot}/index.html\")\n+    templateFile = file('site/xsl/index.template.md')\n+    \n+    binding = {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def majorVersion = project.version.split(/\\./)[0] as int;\n+      return [\n+        defaultCodecPackage : matcher.group(1).toLowerCase(Locale.ROOT),\n+        version : project.version,\n+        majorVersion : majorVersion,\n+        projectList : getListOfProjectsAsMarkdown(':lucene:')\n+      ]\n+    }\n+  }\n+}\n+\n+configure(project(':solr')) {\n+  markdownToHtml {\n+    from('site') {\n+      include '**/*.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+// filter that can be used with the \"copy\" task of Gradle that transforms Markdown files\n+// from source location to HTML (adding HTML header, styling,...)\n+class MarkdownFilter extends FilterReader {\n+\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is not really a filter: it reads whole file in ctor,\n+    // converts it and provides result downstream as a StringReader\n+    super(new StringReader(convert(reader.text)));\n+  }\n+  \n+  public static String convert(String markdownSource) {\n+    // first replace LUCENE and SOLR issue numbers with a markdown link\n+    markdownSource = markdownSource.replaceAll(/(?s)\\b(LUCENE|SOLR)\\-\\d+\\b/,\n+      '[$0](https://issues.apache.org/jira/browse/$0)');\n+  \n+    // convert the markdown\n+    MutableDataSet options = new MutableDataSet();\n+    options.setFrom(ParserEmulationProfile.MARKDOWN);\n+    options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create(), AttributesExtension.create() ]);\n+    options.set(HtmlRenderer.RENDER_HEADER_ID, true);\n+    options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);\n+    Document parsed = Parser.builder(options).build().parse(markdownSource);\n+\n+    StringBuilder html = new StringBuilder('<html>\\n<head>\\n');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTUyNg=="}, "originalCommit": {"oid": "16e75cd068f6d295ba3f3abce5f8adc089246420"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NDczMg==", "bodyText": "I would add CSS in a separate issue.\n\nYes I think so too. I will open separate issue for that.", "url": "https://github.com/apache/lucene-solr/pull/1477#discussion_r425774732", "createdAt": "2020-05-15T12:42:52Z", "author": {"login": "mocobeta"}, "path": "gradle/documentation/markdown.gradle", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import com.vladsch.flexmark.ast.Heading;\n+import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;\n+import com.vladsch.flexmark.ext.attributes.AttributesExtension;\n+import com.vladsch.flexmark.ext.autolink.AutolinkExtension;\n+import com.vladsch.flexmark.html.HtmlRenderer;\n+import com.vladsch.flexmark.parser.Parser;\n+import com.vladsch.flexmark.parser.ParserEmulationProfile;\n+import com.vladsch.flexmark.util.ast.Document;\n+import com.vladsch.flexmark.util.data.MutableDataSet;\n+import com.vladsch.flexmark.util.sequence.Escaping;\n+import groovy.text.SimpleTemplateEngine;\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath \"com.vladsch.flexmark:flexmark:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-abbreviation:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-attributes:${scriptDepVersions['flexmark']}\"\n+    classpath \"com.vladsch.flexmark:flexmark-ext-autolink:${scriptDepVersions['flexmark']}\"\n+  }\n+}\n+\n+def getListOfProjectsAsMarkdown = { prefix ->\n+  def projects = allprojects.findAll{ it.path.startsWith(prefix) && it.tasks.findByName('renderSiteJavadoc') }\n+    .sort(false, Comparator.comparing{ (it.name != 'core') as Boolean }\n+      .thenComparing(Comparator.comparing{ (it.name == 'test-framework') as Boolean })\n+      .thenComparing(Comparator.comparing{ it.path }));\n+  return projects.collect{ project ->\n+    def text = \"**[${project.path.substring(prefix.length()).replace(':','-')}](${project.relativeDocPath}/index.html):** ${project.description}\"\n+    if (project.name == 'core') {\n+      text = text.concat(' {style=\"font-size:larger; margin-bottom:.5em\"}')\n+    }\n+    return '* ' + text;\n+  }.join('\\n')\n+}\n+\n+configure(subprojects.findAll { it.path == ':lucene' || it.path == ':solr' }) {\n+  task markdownToHtml(type: Copy) {\n+    filteringCharset = 'UTF-8'\n+    includeEmptyDirs = false\n+    into project.docroot\n+    rename(/\\.md$/, '.html')\n+    filter(MarkdownFilter)\n+  }\n+}\n+\n+configure(project(':lucene')) {\n+  markdownToHtml {\n+    from('.') {\n+      include 'MIGRATE.md'\n+      include 'JRE_VERSION_MIGRATION.md'\n+      include 'SYSTEM_REQUIREMENTS.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex(type: MarkdownTemplateTask) {\n+    def defaultCodecFile = project(':lucene:core').file('src/java/org/apache/lucene/codecs/Codec.java')\n+    inputs.file(defaultCodecFile)\n+\n+    outputFile = file(\"${project.docroot}/index.html\")\n+    templateFile = file('site/xsl/index.template.md')\n+    \n+    binding = {\n+      // static Codec defaultCodec   =   LOADER    .   lookup    (   \"LuceneXXX\"  )   ;\n+      def regex = ~/\\bdefaultCodec\\s*=\\s*LOADER\\s*\\.\\s*lookup\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;/\n+      def matcher = regex.matcher(defaultCodecFile.getText('UTF-8'))\n+      if (!matcher.find()) {\n+        throw GradleException(\"Cannot determine default codec from file ${defaultCodecFile}\")\n+      }\n+      def majorVersion = project.version.split(/\\./)[0] as int;\n+      return [\n+        defaultCodecPackage : matcher.group(1).toLowerCase(Locale.ROOT),\n+        version : project.version,\n+        majorVersion : majorVersion,\n+        projectList : getListOfProjectsAsMarkdown(':lucene:')\n+      ]\n+    }\n+  }\n+}\n+\n+configure(project(':solr')) {\n+  markdownToHtml {\n+    from('site') {\n+      include '**/*.md'\n+    }\n+  }\n+  \n+  task createDocumentationIndex {\n+    // nocommit: this needs to be implemented next\n+  }\n+}\n+\n+// filter that can be used with the \"copy\" task of Gradle that transforms Markdown files\n+// from source location to HTML (adding HTML header, styling,...)\n+class MarkdownFilter extends FilterReader {\n+\n+  public MarkdownFilter(Reader reader) throws IOException {\n+    // this is not really a filter: it reads whole file in ctor,\n+    // converts it and provides result downstream as a StringReader\n+    super(new StringReader(convert(reader.text)));\n+  }\n+  \n+  public static String convert(String markdownSource) {\n+    // first replace LUCENE and SOLR issue numbers with a markdown link\n+    markdownSource = markdownSource.replaceAll(/(?s)\\b(LUCENE|SOLR)\\-\\d+\\b/,\n+      '[$0](https://issues.apache.org/jira/browse/$0)');\n+  \n+    // convert the markdown\n+    MutableDataSet options = new MutableDataSet();\n+    options.setFrom(ParserEmulationProfile.MARKDOWN);\n+    options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create(), AttributesExtension.create() ]);\n+    options.set(HtmlRenderer.RENDER_HEADER_ID, true);\n+    options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);\n+    Document parsed = Parser.builder(options).build().parse(markdownSource);\n+\n+    StringBuilder html = new StringBuilder('<html>\\n<head>\\n');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTUyNg=="}, "originalCommit": {"oid": "16e75cd068f6d295ba3f3abce5f8adc089246420"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1506, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}