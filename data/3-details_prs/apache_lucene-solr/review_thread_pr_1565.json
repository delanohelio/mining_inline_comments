{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNjk4NDU4", "number": 1565, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTowODozOVrOEEdhZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTowODozOVrOEEdhZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTEzNDQ1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTowODozOVrOGiGZPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTowODozOVrOGiGZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwOTUzNA==", "bodyText": "Could have instead picked another path other than CLUSTER_STATE from those created in ZkController.createClusterZkNodes() and explicitly tested it like was done before, but this seemed cleaner.\nOpen to change.", "url": "https://github.com/apache/lucene-solr/pull/1565#discussion_r438409534", "createdAt": "2020-06-10T21:08:39Z", "author": {"login": "murblanc"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -476,27 +476,32 @@ public synchronized void createClusterStateWatchersAndUpdate() throws KeeperExce\n \n     log.debug(\"Updating cluster state from ZooKeeper... \");\n \n-    // on reconnect of SolrZkClient force refresh and re-add watches.\n-    loadClusterProperties();\n-    refreshLiveNodes(new LiveNodeWatcher());\n-    refreshCollections();\n-    refreshCollectionList(new CollectionsChildWatcher());\n-    refreshAliases(aliasesManager);\n-\n-    if (securityNodeListener != null) {\n-      addSecurityNodeWatcher(pair -> {\n-        ConfigData cd = new ConfigData();\n-        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n-        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n-        securityData = cd;\n-        securityNodeListener.run();\n+    try {\n+      // on reconnect of SolrZkClient force refresh and re-add watches.\n+      loadClusterProperties();\n+      refreshLiveNodes(new LiveNodeWatcher());\n+      refreshCollections();\n+      refreshCollectionList(new CollectionsChildWatcher());\n+      refreshAliases(aliasesManager);\n+\n+      if (securityNodeListener != null) {\n+        addSecurityNodeWatcher(pair -> {\n+          ConfigData cd = new ConfigData();\n+          cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n+          cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n+          securityData = cd;\n+          securityNodeListener.run();\n+        });\n+        securityData = getSecurityProps(true);\n+      }\n+\n+      collectionPropsObservers.forEach((k, v) -> {\n+        collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n       });\n-      securityData = getSecurityProps(true);\n+    } catch (KeeperException.NoNodeException nne) {\n+      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n+          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883c4c930672aa8b0cc7f2021f34a8721e7c5c4a"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1461, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}