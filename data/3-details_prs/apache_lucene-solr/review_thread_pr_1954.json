{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4ODIyNjEz", "number": 1954, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNToxNFrOEyC-_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNToxNFrOEyC-_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTEzMTQ4OnYy", "diffSide": "RIGHT", "path": "lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadMatcherFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNToxNFrOHoeTzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNzo1ODozMFrOIPQGrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMTY3Ng==", "bodyText": "NULL_DEREFERENCE:  object returned by org.apache.lucene.queries.payloads.PayloadMatcherFactory.payloadCheckerOpTypeMap.get(payloadType) could be null and is dereferenced at line 72.", "url": "https://github.com/apache/lucene-solr/pull/1954#discussion_r512201676", "createdAt": "2020-10-26T19:05:14Z", "author": {"login": "sonatype-lift"}, "path": "lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadMatcherFactory.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.queries.payloads;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+\n+import org.apache.lucene.queries.payloads.SpanPayloadCheckQuery.PayloadType;\n+import org.apache.lucene.util.BytesRef;\n+\n+/**\n+ * Creates a payload matcher object based on a payload type and an operation.\n+ * PayloadTypes of INT,FLOAT, or STRING are supported.  Inequality operations are supported.\n+ */\n+public class PayloadMatcherFactory {\n+\n+  private static final HashMap<PayloadType, HashMap<String, PayloadMatcher>> payloadCheckerOpTypeMap;\n+  static {\n+    payloadCheckerOpTypeMap= new HashMap<PayloadType, HashMap<String, PayloadMatcher>>();\n+    // ints\n+    HashMap<String, PayloadMatcher> intCheckers = new HashMap<String, PayloadMatcher>();\n+    intCheckers.put(\"lt\", new LTIntPayloadMatcher());\n+    intCheckers.put(\"lte\", new LTEIntPayloadMatcher());\n+    intCheckers.put(\"gt\", new GTIntPayloadMatcher());\n+    intCheckers.put(\"gte\", new GTEIntPayloadMatcher());\n+    HashMap<String, PayloadMatcher> floatCheckers = new HashMap<String, PayloadMatcher>();\n+    floatCheckers.put(\"lt\", new LTFloatPayloadMatcher());\n+    floatCheckers.put(\"lte\", new LTEFloatPayloadMatcher());\n+    floatCheckers.put(\"gt\", new GTFloatPayloadMatcher());\n+    floatCheckers.put(\"gte\", new GTEFloatPayloadMatcher());\n+    // strings\n+    HashMap<String, PayloadMatcher> stringCheckers = new HashMap<String, PayloadMatcher>();\n+    stringCheckers.put(\"lt\", new LTStringPayloadMatcher());\n+    stringCheckers.put(\"lte\", new LTEStringPayloadMatcher());\n+    stringCheckers.put(\"gt\", new GTStringPayloadMatcher());\n+    stringCheckers.put(\"gte\", new GTEStringPayloadMatcher());\n+    // load the matcher maps per payload type\n+    payloadCheckerOpTypeMap.put(PayloadType.INT, intCheckers);\n+    payloadCheckerOpTypeMap.put(PayloadType.FLOAT, floatCheckers);\n+    payloadCheckerOpTypeMap.put(PayloadType.STRING, stringCheckers);\n+  }\n+  \n+  /**\n+   * Return a payload matcher for use in the SpanPayloadCheckQuery that will decode the ByteRef from \n+   * a payload based on the payload type, and apply a matching inequality operations (eq,lt,lte,gt,and gte)\n+   * \n+   * @param payloadType the type of the payload to decode, STRING, INT, FLOAT\n+   * @param op and inequalit operation as the test (example: eq for equals, gt for greater than)\n+   * @return a payload matcher that decodes the payload and applies the operation inequality test.\n+   * \n+   */\n+  public static PayloadMatcher createMatcherForOpAndType(PayloadType payloadType, String op) {\n+    // special optimization, binary/byte comparison\n+    if (op == null || \"eq\".contentEquals(op)) {\n+      return new EQPayloadMatcher();\n+    }\n+    // otherwise, we need to pay attention to the payload type and operation\n+    return payloadCheckerOpTypeMap.get(payloadType).get(op);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "799ae49b6e5fe93b8dc71c39e7205dd702fb40dc"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2MzQwNw==", "bodyText": "added a null test to default to unknown operations resulting in an equality comparison.", "url": "https://github.com/apache/lucene-solr/pull/1954#discussion_r552863407", "createdAt": "2021-01-06T17:58:30Z", "author": {"login": "kwatters"}, "path": "lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadMatcherFactory.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.queries.payloads;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+\n+import org.apache.lucene.queries.payloads.SpanPayloadCheckQuery.PayloadType;\n+import org.apache.lucene.util.BytesRef;\n+\n+/**\n+ * Creates a payload matcher object based on a payload type and an operation.\n+ * PayloadTypes of INT,FLOAT, or STRING are supported.  Inequality operations are supported.\n+ */\n+public class PayloadMatcherFactory {\n+\n+  private static final HashMap<PayloadType, HashMap<String, PayloadMatcher>> payloadCheckerOpTypeMap;\n+  static {\n+    payloadCheckerOpTypeMap= new HashMap<PayloadType, HashMap<String, PayloadMatcher>>();\n+    // ints\n+    HashMap<String, PayloadMatcher> intCheckers = new HashMap<String, PayloadMatcher>();\n+    intCheckers.put(\"lt\", new LTIntPayloadMatcher());\n+    intCheckers.put(\"lte\", new LTEIntPayloadMatcher());\n+    intCheckers.put(\"gt\", new GTIntPayloadMatcher());\n+    intCheckers.put(\"gte\", new GTEIntPayloadMatcher());\n+    HashMap<String, PayloadMatcher> floatCheckers = new HashMap<String, PayloadMatcher>();\n+    floatCheckers.put(\"lt\", new LTFloatPayloadMatcher());\n+    floatCheckers.put(\"lte\", new LTEFloatPayloadMatcher());\n+    floatCheckers.put(\"gt\", new GTFloatPayloadMatcher());\n+    floatCheckers.put(\"gte\", new GTEFloatPayloadMatcher());\n+    // strings\n+    HashMap<String, PayloadMatcher> stringCheckers = new HashMap<String, PayloadMatcher>();\n+    stringCheckers.put(\"lt\", new LTStringPayloadMatcher());\n+    stringCheckers.put(\"lte\", new LTEStringPayloadMatcher());\n+    stringCheckers.put(\"gt\", new GTStringPayloadMatcher());\n+    stringCheckers.put(\"gte\", new GTEStringPayloadMatcher());\n+    // load the matcher maps per payload type\n+    payloadCheckerOpTypeMap.put(PayloadType.INT, intCheckers);\n+    payloadCheckerOpTypeMap.put(PayloadType.FLOAT, floatCheckers);\n+    payloadCheckerOpTypeMap.put(PayloadType.STRING, stringCheckers);\n+  }\n+  \n+  /**\n+   * Return a payload matcher for use in the SpanPayloadCheckQuery that will decode the ByteRef from \n+   * a payload based on the payload type, and apply a matching inequality operations (eq,lt,lte,gt,and gte)\n+   * \n+   * @param payloadType the type of the payload to decode, STRING, INT, FLOAT\n+   * @param op and inequalit operation as the test (example: eq for equals, gt for greater than)\n+   * @return a payload matcher that decodes the payload and applies the operation inequality test.\n+   * \n+   */\n+  public static PayloadMatcher createMatcherForOpAndType(PayloadType payloadType, String op) {\n+    // special optimization, binary/byte comparison\n+    if (op == null || \"eq\".contentEquals(op)) {\n+      return new EQPayloadMatcher();\n+    }\n+    // otherwise, we need to pay attention to the payload type and operation\n+    return payloadCheckerOpTypeMap.get(payloadType).get(op);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMTY3Ng=="}, "originalCommit": {"oid": "799ae49b6e5fe93b8dc71c39e7205dd702fb40dc"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1131, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}