{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MDc2ODYw", "number": 2010, "title": "SOLR-12182: Don't persist base_url in ZK as the scheme is variable, compute from node_name instead", "bodyText": "Description\nSee JIRA for description of the issue: https://issues.apache.org/jira/browse/SOLR-12182\nSolution\nThis PR computes the base_url for a Replica using the stored node_name and a global urlScheme rather than storing the base_url in state.json. This avoids storing an incorrect URL scheme for replicas in persistent storage. The base_url is computed when read back from ZK and dropped when marshaling the Replica state to JSON. This also means we don't need a migration tool as stored state is \"healed\" on-the-fly when read back from ZK.\nThe unfortunate aspect of this PR is we need to keep the URL scheme for the cluster in a global variable (so that it is available when reading from ZK). The global urlScheme still comes from the cluster property but is then stored in a global singleton, see: org.apache.solr.common.cloud.UrlScheme. Alternatively, we could just keep the urlScheme in a static in ZkStateReader, I felt the global singleton UrlScheme.INSTANCE made it clearer that this was a global thing but it also made more sense with my first implementation that tried to make rolling restart upgrades to TLS less chaotic. It's a trivial change to move all this over to ZkStateReader and remove UrlScheme.\nI initially tried setting a ThreadLocal that gives access to the urlScheme whenever we need to read these props from ZK. However, that ended up being problematic because we tend to read ZkNodeProps from ZK in many places. In reality, the urlScheme really is an immutable global variable that should be set once during initialization by reading from the cluster property stored in ZK. So I felt trying to treat this global as something that was highly dynamic made the code overly cumbersome. Put simply, we shouldn't support urlScheme changing in a live node after initialization, it's bad for business.\nI also tried to get rid of the urlScheme cluster property (re: https://issues.apache.org/jira/browse/SOLR-10202) but I'm not sure how SolrCloud client applications can resolve the correct urlScheme for the cluster without this property? On the server-side, sure we can just get the urlScheme from a Java System Property, but that won't be set for remote client applications that initialize via a connection to ZooKeeper. So I'm keeping the cluster property urlScheme for now.\nWe also need to consider how to enable TLS on an existing cluster (with active collections) using a rolling restart process. The current org.apache.solr.cloud.SSLMigrationTest just stopped all test nodes at once and then brought them back with TLS enabled.\nBased on feedback, I've since removed the option to pull the active urlScheme from live nodes as we're not able to ensure zero-downtime when moving from http -> https for clusters with existing collections and live traffic. Put simply, the feature was a bit trappy in that it tried to reduce chaos when doing a rolling restart to enable TLS, but it made no guarantees. Thus, users just need to be sure to enable TLS before building production clusters!\nLastly, I've tried to clean-up some of the places that access the baseUrl on replicas to be more consistent, so you'll see some of that in this PR as well.\nTests\nMany existing tests cover regression caused by these code changes. Added simple unit test for UrlScheme.\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ./gradlew check.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-10-20T20:29:00Z", "url": "https://github.com/apache/lucene-solr/pull/2010", "merged": true, "mergeCommit": {"oid": "a0492840ee8690ddf48369665c744d16c7dd30cb"}, "closed": true, "closedAt": "2020-11-30T19:05:49Z", "author": {"login": "thelabdude"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUdqwSAH2gAyNTA3MDc2ODYwOjYzZmFlZmY4MWE2MzA5NjRlNDUyNzU4ZGI4N2VkNzM2MDA0ODU3MjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdho1mWgH2gAyNTA3MDc2ODYwOjdkMDllZjc1ODQ3ZTAzYTQyZjY3M2UyMThlZGFlMzNkMDBhNDk1NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "63faeff81a630964e452758db87ed73600485723", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/63faeff81a630964e452758db87ed73600485723", "committedDate": "2020-10-20T19:09:40Z", "message": "SOLR-12182: Don't store the URL scheme in state in ZK"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ae741bbf917ce18054eaddcab7264c69947ceea", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/9ae741bbf917ce18054eaddcab7264c69947ceea", "committedDate": "2020-10-20T19:12:46Z", "message": "Merge branch 'master' into jira/solr-12182"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "369793a4ca532d4136ea97bea0af6881de5cdac9", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/369793a4ca532d4136ea97bea0af6881de5cdac9", "committedDate": "2020-10-20T19:27:37Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/73829adb1e9b4247e01de9b20facdbdf8de7bdcb", "committedDate": "2020-10-20T19:30:30Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/a8f2ea35572d6829303f351d85a539d22c2fdc67", "committedDate": "2020-10-20T21:07:16Z", "message": "Check for null value in map"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTMzNjQy", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-513133642", "createdAt": "2020-10-20T21:06:13Z", "commit": {"oid": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNjoxM1rOHlRFqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozODo1OVrOHlSHlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTMzOQ==", "bodyText": "nit: alphabetize imports", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508839339", "createdAt": "2020-10-20T21:06:13Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -31,6 +31,7 @@\n import java.util.function.Supplier;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.common.cloud.GlobalStateVars;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mjg1OA==", "bodyText": "?", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508842858", "createdAt": "2020-10-20T21:12:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java", "diffHunk": "@@ -63,7 +61,7 @@ public void test() throws Exception {\n     testMigrateSSL(new SSLTestConfig(false, false));\n   }\n   \n-  public void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {\n+  private void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzg3Ng==", "bodyText": "I prefer the enum singleton pattern", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508843876", "createdAt": "2020-10-20T21:14:53Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDU2OQ==", "bodyText": "null on unchanged seems like a trap to me", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844569", "createdAt": "2020-10-20T21:16:07Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();\n+\n+  public static GlobalStateVars singleton() {\n+    return _singleton;\n+  }\n+\n+  private String urlScheme = System.getProperty(URL_SCHEME, HTTP);\n+\n+  // no new! you have to use the static singleton!\n+  private GlobalStateVars() {\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public void setUrlScheme(final String urlScheme) {\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme or null if the supplied url remains unchanged.\n+   */\n+  public String applyUrlSchemeIfChanged(final String url) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDk1MA==", "bodyText": "Use Objects.requireNonNull", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844950", "createdAt": "2020-10-20T21:16:47Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -20,6 +20,9 @@\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    if (nodeProps == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0OTg0NA==", "bodyText": "I think it's clearer here if we only have a single return from the method, so we should fall through or have an else.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508849844", "createdAt": "2020-10-20T21:26:28Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java", "diffHunk": "@@ -105,6 +111,17 @@ public static ZkNodeProps load(byte[] bytes) {\n \n   @Override\n   public void write(JSONWriter jsonWriter) {\n+    final String baseUrl = (String)propMap.get(ZkStateReader.BASE_URL_PROP);\n+    if (baseUrl != null && !baseUrl.startsWith(SCHEME_VAR)) {\n+      final int at = baseUrl.indexOf(\"://\");\n+      if (at != -1) {\n+        final String updatedUrl = SCHEME_VAR + baseUrl.substring(at+3);\n+        Map<String,Object> modMap = new LinkedHashMap<>(propMap);\n+        modMap.put(ZkStateReader.BASE_URL_PROP, updatedUrl);\n+        jsonWriter.write(modMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzUxMw==", "bodyText": "If we have an initially HTTP cluster, and then one node comes up with HTTPS, then that will bring down the rest of the cluster, right? I don't think we can do this rolling, however.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508853513", "createdAt": "2020-10-20T21:33:29Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -263,4 +275,27 @@ public void close() {\n   public ExecutorService getCoreZkRegisterExecutorService() {\n     return coreZkRegister;\n   }\n+\n+  private void setGlobalUrlScheme(final ZkController zkCtrl) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String urlScheme = zkCtrl.getZkStateReader().getClusterProperty(ZkStateReader.URL_SCHEME, null);\n+    if (StringUtils.isNotEmpty(urlScheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      GlobalStateVars.singleton().setUrlScheme(urlScheme);\n+    } else {\n+      final String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        // it's OK to set the cluster prop to https b/c we're making the cluster more secure, not less\n+        // wouldn't do this for http though\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. Updating the cluster property to match.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjIxMg==", "bodyText": "I don't think we want to encourage further use of this pattern. Let's call it something more specific like UrlSchemeState", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508856212", "createdAt": "2020-10-20T21:38:59Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/34e2a4636aba850bd99d2daed4d66d872ffb8fa5", "committedDate": "2020-10-20T22:15:33Z", "message": "First pass at fixing code review issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2573d464143daf699b0633f6fe010d1c8ed12645", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/2573d464143daf699b0633f6fe010d1c8ed12645", "committedDate": "2020-10-20T22:45:57Z", "message": "Fix broken test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjEzMDY1", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-513213065", "createdAt": "2020-10-20T23:49:27Z", "commit": {"oid": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0OToyN1rOHlVHLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzo0OToyN1rOHlVHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNTI2MA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method ZkStateReader.getLeaderUrl(...) indirectly reads without synchronization from cloud.UrlScheme.INSTANCE.urlScheme. Potentially races with write in method ZkStateReader.forciblyRefreshAllClusterStateSlow().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508905260", "createdAt": "2020-10-20T23:49:27Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -798,7 +799,11 @@ public boolean isClosed() {\n   }\n \n   public String getLeaderUrl(String collection, String shard, int timeout) throws InterruptedException {\n-    ZkCoreNodeProps props = new ZkCoreNodeProps(getLeaderRetry(collection, shard, timeout));\n+    Replica replica = getLeaderRetry(collection, shard, timeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5da58b5cc6df98904faf31a2adda93445e0e310c", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/5da58b5cc6df98904faf31a2adda93445e0e310c", "committedDate": "2020-10-22T00:04:45Z", "message": "WIP: Store https scheme in liveNode registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/e7e32ef7c4542c7b375c9a1fa14e192320eeea8b", "committedDate": "2020-10-22T00:06:52Z", "message": "Fix imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "810523a23d66d27eae681203127fb070156c6665", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/810523a23d66d27eae681203127fb070156c6665", "committedDate": "2020-10-22T00:09:05Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzAxMjg2", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-514301286", "createdAt": "2020-10-22T01:38:24Z", "commit": {"oid": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozODoyNFrOHmNfrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozODoyNFrOHmNfrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyOTAzOQ==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r509829039", "createdAt": "2020-10-22T01:38:24Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -448,6 +447,11 @@ public boolean isClosed() {\n         return cc.isShutDown();\n       }});\n \n+    // setup the scheme before updating cluster state\n+    setGlobalUrlSchemeFromClusterProps(zkClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c13c182671746b9db4c55b23a717959f2cee416d", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/c13c182671746b9db4c55b23a717959f2cee416d", "committedDate": "2020-10-22T20:10:54Z", "message": "Store the scheme as data on the live node znode instead of changing the node name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cf0701a32e3bdb7b652f215427426968473ab76", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/9cf0701a32e3bdb7b652f215427426968473ab76", "committedDate": "2020-10-22T20:57:51Z", "message": "Fix precommit fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11592a4cc6897c3a51dc9e15fb2a79f50b5c5a61", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/11592a4cc6897c3a51dc9e15fb2a79f50b5c5a61", "committedDate": "2020-10-22T21:45:28Z", "message": "Revert unnecessary changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9920301e7aeaf1e7a821c6e488f5818bfd425bdc", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/9920301e7aeaf1e7a821c6e488f5818bfd425bdc", "committedDate": "2020-10-30T15:09:09Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dcec628122e0f2f34c3e7db7ca8dbeefca4cff8", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/3dcec628122e0f2f34c3e7db7ca8dbeefca4cff8", "committedDate": "2020-11-02T23:54:58Z", "message": "First pass at not storing the base_url but deriving it from node_name if possible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "583e6c22d7b123c18b8e3b67e047f2ffab7ddfcb", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/583e6c22d7b123c18b8e3b67e047f2ffab7ddfcb", "committedDate": "2020-11-02T23:59:02Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcde2ed0d668bfa97fb03f6ca88835de1e56a1d4", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/dcde2ed0d668bfa97fb03f6ca88835de1e56a1d4", "committedDate": "2020-11-03T00:01:33Z", "message": "call assumeWorkingMockito"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42801149bd331e3b5554456d7e8f318e219e72e7", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/42801149bd331e3b5554456d7e8f318e219e72e7", "committedDate": "2020-11-03T00:02:49Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f01f2ed45cf4fb2602992b722edf6940a759c609", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/f01f2ed45cf4fb2602992b722edf6940a759c609", "committedDate": "2020-11-03T18:52:03Z", "message": "Make urlScheme effectively immutable on the server-side"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "178696040d8cecc1681e30bfa63326c0ecc0341c", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/178696040d8cecc1681e30bfa63326c0ecc0341c", "committedDate": "2020-11-03T18:54:47Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d278d82c92383fdd74ad9aea429ff3e2581f4283", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/d278d82c92383fdd74ad9aea429ff3e2581f4283", "committedDate": "2020-11-03T18:59:01Z", "message": "Add comment for tricky area of urlScheme related logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/6b39af9e4b6c823d7a55d458efeca98ae4bee108", "committedDate": "2020-11-04T18:55:34Z", "message": "Update SSL migration test to perform a rolling restart"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNDEw", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711410", "createdAt": "2020-11-04T20:29:29Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOToyOVrOHtolCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOToyOVrOHtolCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjgwOA==", "bodyText": "NULL_DEREFERENCE:  object baseUrl last assigned on line 30 could be null and is dereferenced by call to getCoreUrl(...) at line 32.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612808", "createdAt": "2020-11-04T20:29:29Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -16,15 +16,20 @@\n  */\n package org.apache.solr.common.cloud;\n \n+import java.util.Objects;\n+\n public class ZkCoreNodeProps {\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    Objects.requireNonNull(nodeProps, \"nodeProps should not be null\");\n     this.nodeProps = nodeProps;\n   }\n   \n   public String getCoreUrl() {\n-    return getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));\n+    String baseUrl = nodeProps.getStr(ZkStateReader.BASE_URL_PROP);\n+    Objects.requireNonNull(baseUrl, \"No base_url in ZkNodeProps! \"+nodeProps.toString());\n+    return getCoreUrl(baseUrl, nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNDU5", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711459", "createdAt": "2020-11-04T20:29:32Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozMlrOHtolLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozMlrOHtolLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg0NA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) indirectly reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612844", "createdAt": "2020-11-04T20:29:32Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNDcy", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711472", "createdAt": "2020-11-04T20:29:34Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNFrOHtolMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNFrOHtolMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg1MA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612850", "createdAt": "2020-11-04T20:29:34Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNDkx", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711491", "createdAt": "2020-11-04T20:29:35Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNVrOHtolQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNVrOHtolQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg2Ng==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612866", "createdAt": "2020-11-04T20:29:35Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTA0", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711504", "createdAt": "2020-11-04T20:29:36Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNlrOHtolTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozNlrOHtolTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg3OA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getBaseUrlForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612878", "createdAt": "2020-11-04T20:29:36Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTEy", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711512", "createdAt": "2020-11-04T20:29:38Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOFrOHtolUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOFrOHtolUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg4Mw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlScheme() reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612883", "createdAt": "2020-11-04T20:29:38Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTMw", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711530", "createdAt": "2020-11-04T20:29:39Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOVrOHtolYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTozOVrOHtolYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg5OA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlSchemeForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612898", "createdAt": "2020-11-04T20:29:39Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTU2", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711556", "createdAt": "2020-11-04T20:29:40Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MFrOHtoldg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MFrOHtoldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkxOA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.isOnServer() reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612918", "createdAt": "2020-11-04T20:29:40Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTY1", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711565", "createdAt": "2020-11-04T20:29:41Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MVrOHtolfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MVrOHtolfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkyNw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.onChange(...) reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612927", "createdAt": "2020-11-04T20:29:41Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTcz", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711573", "createdAt": "2020-11-04T20:29:42Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MlrOHtoliQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0MlrOHtoliQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkzNw==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.liveNodes outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612937", "createdAt": "2020-11-04T20:29:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTg3", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711587", "createdAt": "2020-11-04T20:29:44Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NFrOHtolkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NFrOHtolkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk0NA==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.useLiveNodesUrlScheme outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612944", "createdAt": "2020-11-04T20:29:44Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzExNTk4", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523711598", "createdAt": "2020-11-04T20:29:45Z", "commit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NVrOHtolmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMDoyOTo0NVrOHtolmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk1Mg==", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.useLiveNodesUrlScheme() reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612952", "createdAt": "2020-11-04T20:29:45Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8436a396db768840376193ff401ec9c928de7962", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/8436a396db768840376193ff401ec9c928de7962", "committedDate": "2020-11-04T22:50:17Z", "message": "Restart leader last to test http connections during TLS upgrade"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODM0NjMw", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-523834630", "createdAt": "2020-11-05T00:34:02Z", "commit": {"oid": "8436a396db768840376193ff401ec9c928de7962"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDozNDowM1rOHtuqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDozNDowM1rOHtuqWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjQ3Mg==", "bodyText": "NULL_DEREFERENCE:  object returned by getBaseUrl() could be null and is dereferenced by call to getCoreUrl(...) at line 237.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517712472", "createdAt": "2020-11-05T00:34:03Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "diffHunk": "@@ -235,11 +234,11 @@ public String getName() {\n   }\n \n   public String getCoreUrl() {\n-    return ZkCoreNodeProps.getCoreUrl(getStr(ZkStateReader.BASE_URL_PROP), core);\n+    return ZkCoreNodeProps.getCoreUrl(getBaseUrl(), core);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8436a396db768840376193ff401ec9c928de7962"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad94b03fbb1a84107f4fbfdf9d7d6e37c6cdf1e8", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/ad94b03fbb1a84107f4fbfdf9d7d6e37c6cdf1e8", "committedDate": "2020-11-05T00:37:38Z", "message": "Clean-up node_name handling in OverseerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "377370b2cc19cbb8044a16b86d9e29ef9707c2b5", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/377370b2cc19cbb8044a16b86d9e29ef9707c2b5", "committedDate": "2020-11-05T15:03:02Z", "message": "check null issue found by muse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61e7122c34c7df694a5e452a0f3db0831e566575", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/61e7122c34c7df694a5e452a0f3db0831e566575", "committedDate": "2020-11-05T18:57:41Z", "message": "Supply base_url in ClusterState API response used by Admin UI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/fe7385b8af9b7b83bcc606efae495bdd1c03a3d0", "committedDate": "2020-11-05T19:15:42Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjU3NzEy", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-524657712", "createdAt": "2020-11-05T20:53:42Z", "commit": {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo1Mzo0MlrOHuWDrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo1Mzo0MlrOHuWDrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NzkzMg==", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController.getLeaderProps(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r518357932", "createdAt": "2020-11-05T20:53:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1401,8 +1420,7 @@ public ZkCoreNodeProps getLeaderProps(final String collection,\n         byte[] data = zkClient.getData(\n             ZkStateReader.getShardLeadersPath(collection, slice), null, null,\n             true);\n-        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(\n-            ZkNodeProps.load(data));\n+        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(ZkNodeProps.load(data));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "committedDate": "2020-11-05T20:55:06Z", "message": "Revert changes un-related to this PR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2OTI3NDM3", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-526927437", "createdAt": "2020-11-10T07:40:51Z", "commit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NjoyMVrOHwPwkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo0NzowMlrOHwPxuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTg4OQ==", "bodyText": "Should we instead mention that Solr doesn't support partial TLS enabled clusters?", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520351889", "createdAt": "2020-11-10T07:46:21Z", "author": {"login": "anshumg"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MjE4NQ==", "bodyText": "\ud83d\udc4d\ud83c\udffd", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520352185", "createdAt": "2020-11-10T07:47:02Z", "author": {"login": "anshumg"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2OTU1NzM0", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-526955734", "createdAt": "2020-11-10T08:23:50Z", "commit": {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8045135849e1da0e0945d76da33e7adbe8a82c2", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/b8045135849e1da0e0945d76da33e7adbe8a82c2", "committedDate": "2020-11-13T17:23:38Z", "message": "Remove feature to get urlScheme from live_nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eca9275e282e697edeffc28a63a22b6462c4f427", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/eca9275e282e697edeffc28a63a22b6462c4f427", "committedDate": "2020-11-13T17:30:19Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db58e20554a82cf5539f2dd08fa58ce12e03f267", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/db58e20554a82cf5539f2dd08fa58ce12e03f267", "committedDate": "2020-11-13T20:14:46Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwNDM1NDU2", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-530435456", "createdAt": "2020-11-13T21:45:21Z", "commit": {"oid": "db58e20554a82cf5539f2dd08fa58ce12e03f267"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMTo0NToyMVrOHzAkCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMTo0NToyMVrOHzAkCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0ODY1MA==", "bodyText": "NULL_DEREFERENCE:  object leaderUrl last assigned on line 348 could be null and is dereferenced at line 351.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r523248650", "createdAt": "2020-11-13T21:45:21Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java", "diffHunk": "@@ -344,13 +344,8 @@ final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedExce\n                                                                                             // though\n       try {\n         CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n-        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n-            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n-        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n-        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n-\n-        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n-\n+        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n+        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops);\n         String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n \n         boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db58e20554a82cf5539f2dd08fa58ce12e03f267"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be36c943f31364004a969c20d750db36427b13c0", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/be36c943f31364004a969c20d750db36427b13c0", "committedDate": "2020-11-13T22:24:09Z", "message": "Fix issue found by muse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "debe339768a6a53bd51960977f1fc171cfe028b7", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/debe339768a6a53bd51960977f1fc171cfe028b7", "committedDate": "2020-11-17T15:06:44Z", "message": "Update changes.txt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "committedDate": "2020-11-17T15:07:03Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAxODY4", "url": "https://github.com/apache/lucene-solr/pull/2010#pullrequestreview-533101868", "createdAt": "2020-11-18T04:48:44Z", "commit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo0ODo0NFrOH1cx0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNDo1MDozOVrOH1c5DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwODA4Mg==", "bodyText": "Java8 doesn't have URLEncoder.encode(String, Charset). Also, it'd through the exception on 8x.\nI like it this way, just saying that you might have to remember that when merging.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525808082", "createdAt": "2020-11-18T04:48:44Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -2131,12 +2128,7 @@ public LeaderElector getOverseerElector() {\n   static String generateNodeName(final String hostName,\n                                  final String hostPort,\n                                  final String hostContext) {\n-    try {\n-      return hostName + ':' + hostPort + '_' +\n-          URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), \"UTF-8\");\n-    } catch (UnsupportedEncodingException e) {\n-      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n-    }\n+    return hostName + ':' + hostPort + '_' + URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwOTkzMw==", "bodyText": "Can you please add a space around +.", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525809933", "createdAt": "2020-11-18T04:50:39Z", "author": {"login": "anshumg"}, "path": "solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java", "diffHunk": "@@ -414,6 +425,11 @@ private void waitForLeader(List<ClientThread> threads, int seq)\n \n   private int getLeaderThread() throws KeeperException, InterruptedException {\n     String leaderUrl = getLeaderUrl(\"collection1\", \"shard1\");\n+    // strip off the scheme\n+    final int at = leaderUrl.indexOf(\"://\");\n+    if (at != -1) {\n+      leaderUrl = leaderUrl.substring(at+3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f155c1cccde26a3aeacc4df5aa63430ec9738998", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/f155c1cccde26a3aeacc4df5aa63430ec9738998", "committedDate": "2020-11-30T17:31:23Z", "message": "Fix whitespacing around plus sign"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d09ef75847e03a42f673e218edae33d00a49541", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/7d09ef75847e03a42f673e218edae33d00a49541", "committedDate": "2020-11-30T17:31:29Z", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2776, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}