{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMjY2MDE2", "number": 1470, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoxMzozMFrOD4IftA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNDowOTozOFrOEImtDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTg2MDM2OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBSolrClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoxMzozMFrOGOyrGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwMjozOToxMVrOGPAl3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzQ4MQ==", "bodyText": "Why is this in LBSolrClient instead of LBHttp2SolrClient?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418163481", "createdAt": "2020-04-30T17:13:30Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBSolrClient.java", "diffHunk": "@@ -136,6 +137,91 @@ public boolean equals(Object obj) {\n     }\n   }\n \n+  protected static class ServerIterator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5MTUxNw==", "bodyText": "I do not see this class very relates to LBHttp2SolrClient only and most of the code in LBSolrClient.req() can be replaced by this class.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418391517", "createdAt": "2020-05-01T02:39:11Z", "author": {"login": "CaoManhDat"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBSolrClient.java", "diffHunk": "@@ -136,6 +137,91 @@ public boolean equals(Object obj) {\n     }\n   }\n \n+  protected static class ServerIterator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzQ4MQ=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTg3NjcxOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttp2SolrClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoxNzo1MVrOGOy1eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo0NzoyOFrOGPO_5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA==", "bodyText": "There is already an interface OnComplete in Http2SolrClient, can we either reuse that or maybe we can use CompletableFuture or something here? Have two similarly named interfaces is going to get confusing I think.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418166138", "createdAt": "2020-04-30T17:17:51Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttp2SolrClient.java", "diffHunk": "@@ -66,4 +80,132 @@ public LBHttp2SolrClient(Http2SolrClient httpClient, String... baseSolrUrls) {\n   protected SolrClient getClient(String baseUrl) {\n     return httpClient;\n   }\n+\n+  public interface OnComplete {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxNjc5MA==", "bodyText": "Hmm, so the to OnComplete different in the parameter of onSuccess one is\n\nNamedList\nanother is LBSolrClient.Rsp\nShould we making them as template then move it to util package of solrj?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418416790", "createdAt": "2020-05-01T04:56:23Z", "author": {"login": "CaoManhDat"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttp2SolrClient.java", "diffHunk": "@@ -66,4 +80,132 @@ public LBHttp2SolrClient(Http2SolrClient httpClient, String... baseSolrUrls) {\n   protected SolrClient getClient(String baseUrl) {\n     return httpClient;\n   }\n+\n+  public interface OnComplete {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyNzU1OQ==", "bodyText": "Yea, having a generic interface sounds good.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418627559", "createdAt": "2020-05-01T16:47:28Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttp2SolrClient.java", "diffHunk": "@@ -66,4 +80,132 @@ public LBHttp2SolrClient(Http2SolrClient httpClient, String... baseSolrUrls) {\n   protected SolrClient getClient(String baseUrl) {\n     return httpClient;\n   }\n+\n+  public interface OnComplete {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTkwNjI3OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzoyNTo1MFrOGOzIAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwMjo1MjowNFrOGPAwEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MDg4MA==", "bodyText": "How many requests are we planning on handling? LinkedList is not great for performance due to node allocation overhead.\nI also don't see us removing requests anywhere?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418170880", "createdAt": "2020-04-30T17:25:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -64,18 +62,23 @@\n    * by the RealtimeGet handler, since other types of replicas shouldn't respond to RTG requests\n    */\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n+  private static final ShardResponse END_QUEUE = new ShardResponse();\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private LinkedList<Cancellable> requests;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5NDEzMQ==", "bodyText": "I think most of the time, max size of the list will equals to number of shards, so I think it won't be very different here but I can change it back to ArrayList.\n\nI also don't see us removing requests anywhere?\n\nThat is right, we need to remove elements from this list on the corresponding result arrived.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418394131", "createdAt": "2020-05-01T02:52:04Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -64,18 +62,23 @@\n    * by the RealtimeGet handler, since other types of replicas shouldn't respond to RTG requests\n    */\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n+  private static final ShardResponse END_QUEUE = new ShardResponse();\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private LinkedList<Cancellable> requests;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MDg4MA=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTkyNDIyOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzozMDozM1rOGOzTFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwMzo0ODoyMVrOGPBYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MzcxNw==", "bodyText": "Do we need to reinsert the END_QUEUE element in case there are other threads?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418173717", "createdAt": "2020-04-30T17:30:33Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -243,12 +233,13 @@ public ShardResponse takeCompletedOrError() {\n   }\n \n   private ShardResponse take(boolean bailOnError) {\n+    try {\n+      while (pending.get() > 0) {\n+        ShardResponse rsp = responses.take();\n+        if (rsp == END_QUEUE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNDQ1NQ==", "bodyText": "So all usage of HttpShardHandler is single-thread. Submit tasks, takeResponse then cancelAll() if there are anyerror. Therefore even END_QUEUE is not needed here. I may add some comments to indicate that HttpShardHandler is not thread-safe.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418404455", "createdAt": "2020-05-01T03:48:21Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -243,12 +233,13 @@ public ShardResponse takeCompletedOrError() {\n   }\n \n   private ShardResponse take(boolean bailOnError) {\n+    try {\n+      while (pending.get() > 0) {\n+        ShardResponse rsp = responses.take();\n+        if (rsp == END_QUEUE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MzcxNw=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTkzNzQ4OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzozNDoxNVrOGOzbhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNDo1Njo1M1rOGPCI8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NTg3Nw==", "bodyText": "Might be worthwhile to create a singleton instance and reuse that, since we can give it a descriptive name like alreadyFailedRequest, assuming I understand the intent here.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418175877", "createdAt": "2020-04-30T17:34:15Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxNjg4MQ==", "bodyText": "+1", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418416881", "createdAt": "2020-05-01T04:56:53Z", "author": {"login": "CaoManhDat"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NTg3Nw=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTk0MDI1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzozNTowM1rOGOzdXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwMzoyMjozOFrOGPBGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NjM0OQ==", "bodyText": "Catching Throwable seems very broad to me, can we do something less aggressive here?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418176349", "createdAt": "2020-04-30T17:35:03Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};\n+    }\n     final ResponseParser parser = solrRequest.getResponseParser() == null\n         ? this.parser: solrRequest.getResponseParser();\n-\n-    if (onComplete != null) {\n-      // This async call only suitable for indexing since the response size is limited by 5MB\n-      req.onRequestQueued(asyncTracker.queuedListener)\n-          .onComplete(asyncTracker.completeListener).send(new BufferingResponseListener(5 * 1024 * 1024) {\n-\n-        @Override\n-        public void onComplete(Result result) {\n-          if (result.isFailed()) {\n-            onComplete.onFailure(result.getFailure());\n-            return;\n+    req.onRequestQueued(asyncTracker.queuedListener)\n+        .onComplete(asyncTracker.completeListener)\n+        .send(new InputStreamResponseListener() {\n+          @Override\n+          public void onHeaders(Response response) {\n+            super.onHeaders(response);\n+            InputStreamResponseListener listener = this;\n+            executor.execute(() -> {\n+              InputStream is = listener.getInputStream();\n+              assert ObjectReleaseTracker.track(is);\n+              try {\n+                NamedList<Object> body = processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+                onComplete.onSuccess(body);\n+              } catch (RemoteSolrException e) {\n+                if (SolrException.getRootCause(e) != CANCELLED_EXCEPTION) {\n+                  onComplete.onFailure(e);\n+                }\n+              } catch (SolrServerException e) {\n+                onComplete.onFailure(e);\n+              }\n+            });\n           }\n \n-          NamedList<Object> rsp;\n-          try {\n-            InputStream is = getContentAsInputStream();\n-            assert ObjectReleaseTracker.track(is);\n-            rsp = processErrorsAndResponse(result.getResponse(),\n-                parser, is, getEncoding(), isV2ApiRequest(solrRequest));\n-            onComplete.onSuccess(rsp);\n-          } catch (Exception e) {\n-            onComplete.onFailure(e);\n+          @Override\n+          public void onFailure(Response response, Throwable failure) {\n+            super.onFailure(response, failure);\n+            if (failure != CANCELLED_EXCEPTION) {\n+              onComplete.onFailure(createException(req, failure));\n+            }\n           }\n-        }\n-      });\n-      return null;\n-    } else {\n-      try {\n-        InputStreamResponseListener listener = new InputStreamResponseListener();\n-        req.send(listener);\n-        Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n-        InputStream is = listener.getInputStream();\n-        assert ObjectReleaseTracker.track(is);\n-        return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (TimeoutException e) {\n-        throw new SolrServerException(\n-            \"Timeout occured while waiting response from server at: \" + req.getURI(), e);\n-      } catch (ExecutionException e) {\n-        Throwable cause = e.getCause();\n-        if (cause instanceof ConnectException) {\n-          throw new SolrServerException(\"Server refused connection at: \" + req.getURI(), cause);\n-        }\n-        if (cause instanceof SolrServerException) {\n-          throw (SolrServerException) cause;\n-        } else if (cause instanceof IOException) {\n-          throw new SolrServerException(\n-              \"IOException occured when talking to server at: \" + getBaseURL(), cause);\n-        }\n-        throw new SolrServerException(cause.getMessage(), cause);\n+        });\n+    return () -> req.abort(CANCELLED_EXCEPTION);\n+  }\n+\n+  @Override\n+  public NamedList<Object> request(SolrRequest solrRequest, String collection) throws SolrServerException, IOException {\n+    Request req = makeRequest(solrRequest, collection);\n+    final ResponseParser parser = solrRequest.getResponseParser() == null\n+        ? this.parser: solrRequest.getResponseParser();\n+\n+    try {\n+      InputStreamResponseListener listener = new InputStreamResponseListener();\n+      req.send(listener);\n+      Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n+      InputStream is = listener.getInputStream();\n+      assert ObjectReleaseTracker.track(is);\n+      return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(e);\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Throwable e) {\n+      throw createException(req, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5OTc2NQ==", "bodyText": "Right, I think it is worth to seperate the exception handling logic of asyncReq() and req().", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418399765", "createdAt": "2020-05-01T03:22:38Z", "author": {"login": "CaoManhDat"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};\n+    }\n     final ResponseParser parser = solrRequest.getResponseParser() == null\n         ? this.parser: solrRequest.getResponseParser();\n-\n-    if (onComplete != null) {\n-      // This async call only suitable for indexing since the response size is limited by 5MB\n-      req.onRequestQueued(asyncTracker.queuedListener)\n-          .onComplete(asyncTracker.completeListener).send(new BufferingResponseListener(5 * 1024 * 1024) {\n-\n-        @Override\n-        public void onComplete(Result result) {\n-          if (result.isFailed()) {\n-            onComplete.onFailure(result.getFailure());\n-            return;\n+    req.onRequestQueued(asyncTracker.queuedListener)\n+        .onComplete(asyncTracker.completeListener)\n+        .send(new InputStreamResponseListener() {\n+          @Override\n+          public void onHeaders(Response response) {\n+            super.onHeaders(response);\n+            InputStreamResponseListener listener = this;\n+            executor.execute(() -> {\n+              InputStream is = listener.getInputStream();\n+              assert ObjectReleaseTracker.track(is);\n+              try {\n+                NamedList<Object> body = processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+                onComplete.onSuccess(body);\n+              } catch (RemoteSolrException e) {\n+                if (SolrException.getRootCause(e) != CANCELLED_EXCEPTION) {\n+                  onComplete.onFailure(e);\n+                }\n+              } catch (SolrServerException e) {\n+                onComplete.onFailure(e);\n+              }\n+            });\n           }\n \n-          NamedList<Object> rsp;\n-          try {\n-            InputStream is = getContentAsInputStream();\n-            assert ObjectReleaseTracker.track(is);\n-            rsp = processErrorsAndResponse(result.getResponse(),\n-                parser, is, getEncoding(), isV2ApiRequest(solrRequest));\n-            onComplete.onSuccess(rsp);\n-          } catch (Exception e) {\n-            onComplete.onFailure(e);\n+          @Override\n+          public void onFailure(Response response, Throwable failure) {\n+            super.onFailure(response, failure);\n+            if (failure != CANCELLED_EXCEPTION) {\n+              onComplete.onFailure(createException(req, failure));\n+            }\n           }\n-        }\n-      });\n-      return null;\n-    } else {\n-      try {\n-        InputStreamResponseListener listener = new InputStreamResponseListener();\n-        req.send(listener);\n-        Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n-        InputStream is = listener.getInputStream();\n-        assert ObjectReleaseTracker.track(is);\n-        return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (TimeoutException e) {\n-        throw new SolrServerException(\n-            \"Timeout occured while waiting response from server at: \" + req.getURI(), e);\n-      } catch (ExecutionException e) {\n-        Throwable cause = e.getCause();\n-        if (cause instanceof ConnectException) {\n-          throw new SolrServerException(\"Server refused connection at: \" + req.getURI(), cause);\n-        }\n-        if (cause instanceof SolrServerException) {\n-          throw (SolrServerException) cause;\n-        } else if (cause instanceof IOException) {\n-          throw new SolrServerException(\n-              \"IOException occured when talking to server at: \" + getBaseURL(), cause);\n-        }\n-        throw new SolrServerException(cause.getMessage(), cause);\n+        });\n+    return () -> req.abort(CANCELLED_EXCEPTION);\n+  }\n+\n+  @Override\n+  public NamedList<Object> request(SolrRequest solrRequest, String collection) throws SolrServerException, IOException {\n+    Request req = makeRequest(solrRequest, collection);\n+    final ResponseParser parser = solrRequest.getResponseParser() == null\n+        ? this.parser: solrRequest.getResponseParser();\n+\n+    try {\n+      InputStreamResponseListener listener = new InputStreamResponseListener();\n+      req.send(listener);\n+      Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n+      InputStream is = listener.getInputStream();\n+      assert ObjectReleaseTracker.track(is);\n+      return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(e);\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Throwable e) {\n+      throw createException(req, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NjM0OQ=="}, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTk0NDk3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzozNjoxNlrOGOzgLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzozNjoxNlrOGOzgLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NzA3MQ==", "bodyText": "This whole method seems problematic, but I can't immediately think of what the alternative should look like.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418177071", "createdAt": "2020-04-30T17:36:16Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};\n+    }\n     final ResponseParser parser = solrRequest.getResponseParser() == null\n         ? this.parser: solrRequest.getResponseParser();\n-\n-    if (onComplete != null) {\n-      // This async call only suitable for indexing since the response size is limited by 5MB\n-      req.onRequestQueued(asyncTracker.queuedListener)\n-          .onComplete(asyncTracker.completeListener).send(new BufferingResponseListener(5 * 1024 * 1024) {\n-\n-        @Override\n-        public void onComplete(Result result) {\n-          if (result.isFailed()) {\n-            onComplete.onFailure(result.getFailure());\n-            return;\n+    req.onRequestQueued(asyncTracker.queuedListener)\n+        .onComplete(asyncTracker.completeListener)\n+        .send(new InputStreamResponseListener() {\n+          @Override\n+          public void onHeaders(Response response) {\n+            super.onHeaders(response);\n+            InputStreamResponseListener listener = this;\n+            executor.execute(() -> {\n+              InputStream is = listener.getInputStream();\n+              assert ObjectReleaseTracker.track(is);\n+              try {\n+                NamedList<Object> body = processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+                onComplete.onSuccess(body);\n+              } catch (RemoteSolrException e) {\n+                if (SolrException.getRootCause(e) != CANCELLED_EXCEPTION) {\n+                  onComplete.onFailure(e);\n+                }\n+              } catch (SolrServerException e) {\n+                onComplete.onFailure(e);\n+              }\n+            });\n           }\n \n-          NamedList<Object> rsp;\n-          try {\n-            InputStream is = getContentAsInputStream();\n-            assert ObjectReleaseTracker.track(is);\n-            rsp = processErrorsAndResponse(result.getResponse(),\n-                parser, is, getEncoding(), isV2ApiRequest(solrRequest));\n-            onComplete.onSuccess(rsp);\n-          } catch (Exception e) {\n-            onComplete.onFailure(e);\n+          @Override\n+          public void onFailure(Response response, Throwable failure) {\n+            super.onFailure(response, failure);\n+            if (failure != CANCELLED_EXCEPTION) {\n+              onComplete.onFailure(createException(req, failure));\n+            }\n           }\n-        }\n-      });\n-      return null;\n-    } else {\n-      try {\n-        InputStreamResponseListener listener = new InputStreamResponseListener();\n-        req.send(listener);\n-        Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n-        InputStream is = listener.getInputStream();\n-        assert ObjectReleaseTracker.track(is);\n-        return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (TimeoutException e) {\n-        throw new SolrServerException(\n-            \"Timeout occured while waiting response from server at: \" + req.getURI(), e);\n-      } catch (ExecutionException e) {\n-        Throwable cause = e.getCause();\n-        if (cause instanceof ConnectException) {\n-          throw new SolrServerException(\"Server refused connection at: \" + req.getURI(), cause);\n-        }\n-        if (cause instanceof SolrServerException) {\n-          throw (SolrServerException) cause;\n-        } else if (cause instanceof IOException) {\n-          throw new SolrServerException(\n-              \"IOException occured when talking to server at: \" + getBaseURL(), cause);\n-        }\n-        throw new SolrServerException(cause.getMessage(), cause);\n+        });\n+    return () -> req.abort(CANCELLED_EXCEPTION);\n+  }\n+\n+  @Override\n+  public NamedList<Object> request(SolrRequest solrRequest, String collection) throws SolrServerException, IOException {\n+    Request req = makeRequest(solrRequest, collection);\n+    final ResponseParser parser = solrRequest.getResponseParser() == null\n+        ? this.parser: solrRequest.getResponseParser();\n+\n+    try {\n+      InputStreamResponseListener listener = new InputStreamResponseListener();\n+      req.send(listener);\n+      Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n+      InputStream is = listener.getInputStream();\n+      assert ObjectReleaseTracker.track(is);\n+      return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(e);\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Throwable e) {\n+      throw createException(req, e);\n+    }\n+  }\n+\n+  private SolrServerException createException(Request req, Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDg2NjE4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo0ODo1N1rOGPPCbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMzowNzowM1rOGPx0hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODIwNA==", "bodyText": "Use @SolrSingleThreaded", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418628204", "createdAt": "2020-05-01T16:48:57Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -54,6 +53,10 @@\n import org.apache.solr.util.tracing.GlobalTracer;\n import org.apache.solr.util.tracing.SolrRequestCarrier;\n \n+/**\n+ * Submit requests in async manner.\n+ * This class is not thread-safe so all methods should be called in a same thread.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ad19d9b6b7700b319fa56a384e38771319356d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5ODA4Nw==", "bodyText": "+1", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r419198087", "createdAt": "2020-05-04T03:07:03Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -54,6 +53,10 @@\n import org.apache.solr.util.tracing.GlobalTracer;\n import org.apache.solr.util.tracing.SolrRequestCarrier;\n \n+/**\n+ * Submit requests in async manner.\n+ * This class is not thread-safe so all methods should be called in a same thread.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODIwNA=="}, "originalCommit": {"oid": "c7ad19d9b6b7700b319fa56a384e38771319356d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDg2OTc0OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo1MDowNFrOGPPEhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMzowNzowMFrOGPx0eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODc0MA==", "bodyText": "And clear the map?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418628740", "createdAt": "2020-05-01T16:50:04Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -259,12 +261,10 @@ private ShardResponse take(boolean bailOnError) {\n \n   @Override\n   public void cancelAll() {\n-    for (Cancellable cancellable : requests) {\n+    for (Cancellable cancellable : responseCancellableMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ad19d9b6b7700b319fa56a384e38771319356d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5ODA3Mg==", "bodyText": "+1", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r419198072", "createdAt": "2020-05-04T03:07:00Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -259,12 +261,10 @@ private ShardResponse take(boolean bailOnError) {\n \n   @Override\n   public void cancelAll() {\n-    for (Cancellable cancellable : requests) {\n+    for (Cancellable cancellable : responseCancellableMap.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODc0MA=="}, "originalCommit": {"oid": "c7ad19d9b6b7700b319fa56a384e38771319356d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzM2MzI1OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzowMjo1OVrOGQ-tVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNjoyODozNVrOGS43Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzgxNA==", "bodyText": "Service unavailable error code seems reasonable to me here. Do you have something else you were debating to switch this out to?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r420457814", "createdAt": "2020-05-05T23:02:59Z", "author": {"login": "anshumg"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTEzOQ==", "bodyText": "I do not, just copied and pasted from the old code.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r422459139", "createdAt": "2020-05-09T06:28:35Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzgxNA=="}, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDU3OTMyOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/util/OnComplete.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNDowNzo1MFrOGoqq1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNDowMjoxNVrOGpS-Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTMxOQ==", "bodyText": "Perhaps rename to RequestLifecycleListener?", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295319", "createdAt": "2020-06-25T04:07:50Z", "author": {"login": "shalinmangar"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/util/OnComplete.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.util;\n+\n+/**\n+ * Listener for async requests\n+ */\n+public interface OnComplete<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTU5OA==", "bodyText": "changed, thanks!", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955598", "createdAt": "2020-06-26T04:02:15Z", "author": {"login": "CaoManhDat"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/util/OnComplete.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.util;\n+\n+/**\n+ * Listener for async requests\n+ */\n+public interface OnComplete<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTMxOQ=="}, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDU4MTExOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNDowOTowMlrOGoqr9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNDowMjozMVrOGpS-QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTYwNA==", "bodyText": "This needs to be volatile or AtomicLong because it is accessed from other threads that call onSuccess and onFailure", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295604", "createdAt": "2020-06-25T04:09:02Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when\n+      // all of the servers for a shard are down.\n+      SolrException exception = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n+      srsp.setException(exception);\n+      srsp.setResponseCode(exception.code());\n+      responses.add(srsp);\n+      return;\n+    }\n \n-      try {\n-        params.remove(CommonParams.WT); // use default (currently javabin)\n-        params.remove(CommonParams.VERSION);\n+    // all variables that set inside this listener must be at least volatile\n+    responseCancellableMap.put(srsp, this.lbClient.asyncReq(lbReq, new OnComplete<>() {\n+      long startTime = System.nanoTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTY0OQ==", "bodyText": "right, thank you Shalin.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955649", "createdAt": "2020-06-26T04:02:31Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when\n+      // all of the servers for a shard are down.\n+      SolrException exception = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n+      srsp.setException(exception);\n+      srsp.setResponseCode(exception.code());\n+      responses.add(srsp);\n+      return;\n+    }\n \n-      try {\n-        params.remove(CommonParams.WT); // use default (currently javabin)\n-        params.remove(CommonParams.VERSION);\n+    // all variables that set inside this listener must be at least volatile\n+    responseCancellableMap.put(srsp, this.lbClient.asyncReq(lbReq, new OnComplete<>() {\n+      long startTime = System.nanoTime();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTYwNA=="}, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDU4MTg5OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNDowOTozOFrOGoqscA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNDowMjo1NVrOGpS-jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTcyOA==", "bodyText": "It seems that this Http2SolrClient instance can be removed. It is being used in the request method but that method is not used anywhere anymore.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295728", "createdAt": "2020-06-25T04:09:38Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -66,16 +66,20 @@\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private Map<ShardResponse, Cancellable> responseCancellableMap;\n+  private BlockingQueue<ShardResponse> responses;\n+  private AtomicInteger pending;\n   private Map<String, List<String>> shardToURLs;\n   private Http2SolrClient httpClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTcyNw==", "bodyText": "right, I removed that in this commit 0a02baa.", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955727", "createdAt": "2020-06-26T04:02:55Z", "author": {"login": "CaoManhDat"}, "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -66,16 +66,20 @@\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private Map<ShardResponse, Cancellable> responseCancellableMap;\n+  private BlockingQueue<ShardResponse> responses;\n+  private AtomicInteger pending;\n   private Map<String, List<String>> shardToURLs;\n   private Http2SolrClient httpClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTcyOA=="}, "originalCommit": {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 808, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}