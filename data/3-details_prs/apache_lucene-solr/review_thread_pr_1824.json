{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NTYwMDUx", "number": 1824, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1ODowNVrOEf9PdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowMzowMlrOEf-ulg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTQ0NjkyOnYy", "diffSide": "LEFT", "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/DeflateWithPresetDictCompressionMode.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTo1ODowNVrOHMjPCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1MDozM1rOHMlEfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkyMjI0OA==", "bodyText": "Just a thought, really.\nIf it's a bug that can be probed for (and it can be - see Adrian's repro) then it could as well be a static initialization of a supplier of Deflater instances; if we probe for a buggy JVM, we return the wrapper. If we don't we return the Deflater. This way on non-affected JVMs nothing happens and if we do use the wrapper, we know the JVM is broken.", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482922248", "createdAt": "2020-09-03T11:58:05Z", "author": {"login": "dweiss"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/DeflateWithPresetDictCompressionMode.java", "diffHunk": "@@ -155,16 +155,15 @@ public Decompressor clone() {\n \n   private static class DeflateWithPresetDictCompressor extends Compressor {\n \n-    final byte[] dictBytes;\n-    final int blockLength;\n+    private final int dictLength, blockLength;\n     final Deflater compressor;\n     byte[] compressed;\n     boolean closed;\n \n     DeflateWithPresetDictCompressor(int level, int dictLength, int blockLength) {\n-      compressor = new Deflater(level, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7c3dcc76af3843534d3a360fd74a75e362b07db"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkyMzE4MQ==", "bodyText": "that's also my idea! I am working on probing at the moment. like 128 bytes of dict and 128 bytes of data. If result is correct the factory method i implemented uses the plain Deflater instead of the workaround class.", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482923181", "createdAt": "2020-09-03T11:59:44Z", "author": {"login": "uschindler"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/DeflateWithPresetDictCompressionMode.java", "diffHunk": "@@ -155,16 +155,15 @@ public Decompressor clone() {\n \n   private static class DeflateWithPresetDictCompressor extends Compressor {\n \n-    final byte[] dictBytes;\n-    final int blockLength;\n+    private final int dictLength, blockLength;\n     final Deflater compressor;\n     byte[] compressed;\n     boolean closed;\n \n     DeflateWithPresetDictCompressor(int level, int dictLength, int blockLength) {\n-      compressor = new Deflater(level, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkyMjI0OA=="}, "originalCommit": {"oid": "b7c3dcc76af3843534d3a360fd74a75e362b07db"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MjMxOA==", "bodyText": "I added detection in latest commit. Works with 8 bytes :-)", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482952318", "createdAt": "2020-09-03T12:50:33Z", "author": {"login": "uschindler"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/DeflateWithPresetDictCompressionMode.java", "diffHunk": "@@ -155,16 +155,15 @@ public Decompressor clone() {\n \n   private static class DeflateWithPresetDictCompressor extends Compressor {\n \n-    final byte[] dictBytes;\n-    final int blockLength;\n+    private final int dictLength, blockLength;\n     final Deflater compressor;\n     byte[] compressed;\n     boolean closed;\n \n     DeflateWithPresetDictCompressor(int level, int dictLength, int blockLength) {\n-      compressor = new Deflater(level, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkyMjI0OA=="}, "originalCommit": {"oid": "b7c3dcc76af3843534d3a360fd74a75e362b07db"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY4OTUwOnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowMjo0OFrOHMljGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNzowN1rOHMltjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDE1Mw==", "bodyText": "Did you only mean to use this for debugging?", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482960153", "createdAt": "2020-09-03T13:02:48Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.lucene.codecs.lucene87;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.zip.DataFormatException;\r\n+import java.util.zip.Deflater;\r\n+import java.util.zip.Inflater;\r\n+\r\n+/**\r\n+ * This class is a workaround for JDK bug\r\n+ * <a href=\"https://bugs.openjdk.java.net/browse/JDK-8252739\">JDK-8252739</a>.\r\n+ */\r\n+final class BugfixDeflater_JDK8252739 extends Deflater {\r\n+  \r\n+  private final byte[] dictBytesScratch;\r\n+\r\n+  private BugfixDeflater_JDK8252739(int level, boolean nowrap, int dictLength) {\r\n+    super(level, nowrap);\r\n+    this.dictBytesScratch = new byte[dictLength];\r\n+  }\r\n+  \r\n+  @Override\r\n+  public void setDictionary(byte[] dictBytes, int off, int len) {\r\n+    if (off > 0) {\r\n+      System.arraycopy(dictBytes, off, dictBytesScratch, 0, len);\r\n+      super.setDictionary(dictBytesScratch, 0, len);\r\n+    } else {\r\n+      super.setDictionary(dictBytes, off, len);\r\n+    }\r\n+  }\r\n+\r\n+  public static Deflater createDeflaterInstance(int level, boolean nowrap, int dictLength) {\r\n+    if (dictLength < 0) {\r\n+      throw new IllegalArgumentException(\"dictLength must be >= 0\");\r\n+    }\r\n+    if (IS_BUGGY_JDK) {\r\n+      return new BugfixDeflater_JDK8252739(level, nowrap, dictLength);\r\n+    } else {\r\n+      return new Deflater(level, nowrap);\r\n+    }\r\n+  }\r\n+  \r\n+  private static boolean detectBuggyJDK() {\r\n+    final byte[] testData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\r\n+    final byte[] compressed = new byte[32]; // way enough space\r\n+    final Deflater deflater = new Deflater(6, true);\r\n+    try {\r\n+      deflater.reset();\r\n+      deflater.setDictionary(testData, 4, 4);\r\n+      deflater.setInput(testData);\r\n+      deflater.finish();\r\n+      deflater.deflate(compressed, 0, compressed.length, Deflater.FULL_FLUSH);\r\n+    } finally {\r\n+      deflater.end();\r\n+    }\r\n+    \r\n+    final Inflater inflater = new Inflater(true);\r\n+    final byte[] restored = new byte[testData.length];\r\n+    try {\r\n+      inflater.reset();\r\n+      inflater.setDictionary(testData, 4, 4);\r\n+      inflater.setInput(compressed);\r\n+      final int restoredLength = inflater.inflate(restored);\r\n+      if (restoredLength != testData.length) {\r\n+        return true;\r\n+      }\r\n+    } catch (DataFormatException e) {\r\n+      return true;\r\n+    } finally {\r\n+      inflater.end();\r\n+    }\r\n+\r\n+    if (Arrays.equals(testData, restored) == false) {\r\n+      return true;\r\n+    }\r\n+    \r\n+    // all fine\r\n+    return false;\r\n+  }\r\n+  \r\n+  public static final boolean IS_BUGGY_JDK = detectBuggyJDK();\r\n+  \r\n+  static {\r\n+    System.err.println(\"JDK is buggy: \" + IS_BUGGY_JDK);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbcf6adcfd054567848e3d577234dd3576d25f4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MjgzMA==", "bodyText": "oops nevermind I just read your other comment", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482962830", "createdAt": "2020-09-03T13:07:07Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.lucene.codecs.lucene87;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.zip.DataFormatException;\r\n+import java.util.zip.Deflater;\r\n+import java.util.zip.Inflater;\r\n+\r\n+/**\r\n+ * This class is a workaround for JDK bug\r\n+ * <a href=\"https://bugs.openjdk.java.net/browse/JDK-8252739\">JDK-8252739</a>.\r\n+ */\r\n+final class BugfixDeflater_JDK8252739 extends Deflater {\r\n+  \r\n+  private final byte[] dictBytesScratch;\r\n+\r\n+  private BugfixDeflater_JDK8252739(int level, boolean nowrap, int dictLength) {\r\n+    super(level, nowrap);\r\n+    this.dictBytesScratch = new byte[dictLength];\r\n+  }\r\n+  \r\n+  @Override\r\n+  public void setDictionary(byte[] dictBytes, int off, int len) {\r\n+    if (off > 0) {\r\n+      System.arraycopy(dictBytes, off, dictBytesScratch, 0, len);\r\n+      super.setDictionary(dictBytesScratch, 0, len);\r\n+    } else {\r\n+      super.setDictionary(dictBytes, off, len);\r\n+    }\r\n+  }\r\n+\r\n+  public static Deflater createDeflaterInstance(int level, boolean nowrap, int dictLength) {\r\n+    if (dictLength < 0) {\r\n+      throw new IllegalArgumentException(\"dictLength must be >= 0\");\r\n+    }\r\n+    if (IS_BUGGY_JDK) {\r\n+      return new BugfixDeflater_JDK8252739(level, nowrap, dictLength);\r\n+    } else {\r\n+      return new Deflater(level, nowrap);\r\n+    }\r\n+  }\r\n+  \r\n+  private static boolean detectBuggyJDK() {\r\n+    final byte[] testData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\r\n+    final byte[] compressed = new byte[32]; // way enough space\r\n+    final Deflater deflater = new Deflater(6, true);\r\n+    try {\r\n+      deflater.reset();\r\n+      deflater.setDictionary(testData, 4, 4);\r\n+      deflater.setInput(testData);\r\n+      deflater.finish();\r\n+      deflater.deflate(compressed, 0, compressed.length, Deflater.FULL_FLUSH);\r\n+    } finally {\r\n+      deflater.end();\r\n+    }\r\n+    \r\n+    final Inflater inflater = new Inflater(true);\r\n+    final byte[] restored = new byte[testData.length];\r\n+    try {\r\n+      inflater.reset();\r\n+      inflater.setDictionary(testData, 4, 4);\r\n+      inflater.setInput(compressed);\r\n+      final int restoredLength = inflater.inflate(restored);\r\n+      if (restoredLength != testData.length) {\r\n+        return true;\r\n+      }\r\n+    } catch (DataFormatException e) {\r\n+      return true;\r\n+    } finally {\r\n+      inflater.end();\r\n+    }\r\n+\r\n+    if (Arrays.equals(testData, restored) == false) {\r\n+      return true;\r\n+    }\r\n+    \r\n+    // all fine\r\n+    return false;\r\n+  }\r\n+  \r\n+  public static final boolean IS_BUGGY_JDK = detectBuggyJDK();\r\n+  \r\n+  static {\r\n+    System.err.println(\"JDK is buggy: \" + IS_BUGGY_JDK);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDE1Mw=="}, "originalCommit": {"oid": "4fbcf6adcfd054567848e3d577234dd3576d25f4"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY5MDQ2OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowMzowMlrOHMljqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowNzoyOFrOHMluXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDI5Ng==", "bodyText": "If you confirmed that this fails on at least one buggy JVM, this detection code LGTM.", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482960296", "createdAt": "2020-09-03T13:03:02Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.lucene.codecs.lucene87;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.zip.DataFormatException;\r\n+import java.util.zip.Deflater;\r\n+import java.util.zip.Inflater;\r\n+\r\n+/**\r\n+ * This class is a workaround for JDK bug\r\n+ * <a href=\"https://bugs.openjdk.java.net/browse/JDK-8252739\">JDK-8252739</a>.\r\n+ */\r\n+final class BugfixDeflater_JDK8252739 extends Deflater {\r\n+  \r\n+  private final byte[] dictBytesScratch;\r\n+\r\n+  private BugfixDeflater_JDK8252739(int level, boolean nowrap, int dictLength) {\r\n+    super(level, nowrap);\r\n+    this.dictBytesScratch = new byte[dictLength];\r\n+  }\r\n+  \r\n+  @Override\r\n+  public void setDictionary(byte[] dictBytes, int off, int len) {\r\n+    if (off > 0) {\r\n+      System.arraycopy(dictBytes, off, dictBytesScratch, 0, len);\r\n+      super.setDictionary(dictBytesScratch, 0, len);\r\n+    } else {\r\n+      super.setDictionary(dictBytes, off, len);\r\n+    }\r\n+  }\r\n+\r\n+  public static Deflater createDeflaterInstance(int level, boolean nowrap, int dictLength) {\r\n+    if (dictLength < 0) {\r\n+      throw new IllegalArgumentException(\"dictLength must be >= 0\");\r\n+    }\r\n+    if (IS_BUGGY_JDK) {\r\n+      return new BugfixDeflater_JDK8252739(level, nowrap, dictLength);\r\n+    } else {\r\n+      return new Deflater(level, nowrap);\r\n+    }\r\n+  }\r\n+  \r\n+  private static boolean detectBuggyJDK() {\r\n+    final byte[] testData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\r\n+    final byte[] compressed = new byte[32]; // way enough space\r\n+    final Deflater deflater = new Deflater(6, true);\r\n+    try {\r\n+      deflater.reset();\r\n+      deflater.setDictionary(testData, 4, 4);\r\n+      deflater.setInput(testData);\r\n+      deflater.finish();\r\n+      deflater.deflate(compressed, 0, compressed.length, Deflater.FULL_FLUSH);\r\n+    } finally {\r\n+      deflater.end();\r\n+    }\r\n+    \r\n+    final Inflater inflater = new Inflater(true);\r\n+    final byte[] restored = new byte[testData.length];\r\n+    try {\r\n+      inflater.reset();\r\n+      inflater.setDictionary(testData, 4, 4);\r\n+      inflater.setInput(compressed);\r\n+      final int restoredLength = inflater.inflate(restored);\r\n+      if (restoredLength != testData.length) {\r\n+        return true;\r\n+      }\r\n+    } catch (DataFormatException e) {\r\n+      return true;\r\n+    } finally {\r\n+      inflater.end();\r\n+    }\r\n+\r\n+    if (Arrays.equals(testData, restored) == false) {\r\n+      return true;\r\n+    }\r\n+    \r\n+    // all fine\r\n+    return false;\r\n+  }\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbcf6adcfd054567848e3d577234dd3576d25f4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MzAzOA==", "bodyText": "likewise, nevermind", "url": "https://github.com/apache/lucene-solr/pull/1824#discussion_r482963038", "createdAt": "2020-09-03T13:07:28Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/codecs/lucene87/BugfixDeflater_JDK8252739.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.lucene.codecs.lucene87;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.zip.DataFormatException;\r\n+import java.util.zip.Deflater;\r\n+import java.util.zip.Inflater;\r\n+\r\n+/**\r\n+ * This class is a workaround for JDK bug\r\n+ * <a href=\"https://bugs.openjdk.java.net/browse/JDK-8252739\">JDK-8252739</a>.\r\n+ */\r\n+final class BugfixDeflater_JDK8252739 extends Deflater {\r\n+  \r\n+  private final byte[] dictBytesScratch;\r\n+\r\n+  private BugfixDeflater_JDK8252739(int level, boolean nowrap, int dictLength) {\r\n+    super(level, nowrap);\r\n+    this.dictBytesScratch = new byte[dictLength];\r\n+  }\r\n+  \r\n+  @Override\r\n+  public void setDictionary(byte[] dictBytes, int off, int len) {\r\n+    if (off > 0) {\r\n+      System.arraycopy(dictBytes, off, dictBytesScratch, 0, len);\r\n+      super.setDictionary(dictBytesScratch, 0, len);\r\n+    } else {\r\n+      super.setDictionary(dictBytes, off, len);\r\n+    }\r\n+  }\r\n+\r\n+  public static Deflater createDeflaterInstance(int level, boolean nowrap, int dictLength) {\r\n+    if (dictLength < 0) {\r\n+      throw new IllegalArgumentException(\"dictLength must be >= 0\");\r\n+    }\r\n+    if (IS_BUGGY_JDK) {\r\n+      return new BugfixDeflater_JDK8252739(level, nowrap, dictLength);\r\n+    } else {\r\n+      return new Deflater(level, nowrap);\r\n+    }\r\n+  }\r\n+  \r\n+  private static boolean detectBuggyJDK() {\r\n+    final byte[] testData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\r\n+    final byte[] compressed = new byte[32]; // way enough space\r\n+    final Deflater deflater = new Deflater(6, true);\r\n+    try {\r\n+      deflater.reset();\r\n+      deflater.setDictionary(testData, 4, 4);\r\n+      deflater.setInput(testData);\r\n+      deflater.finish();\r\n+      deflater.deflate(compressed, 0, compressed.length, Deflater.FULL_FLUSH);\r\n+    } finally {\r\n+      deflater.end();\r\n+    }\r\n+    \r\n+    final Inflater inflater = new Inflater(true);\r\n+    final byte[] restored = new byte[testData.length];\r\n+    try {\r\n+      inflater.reset();\r\n+      inflater.setDictionary(testData, 4, 4);\r\n+      inflater.setInput(compressed);\r\n+      final int restoredLength = inflater.inflate(restored);\r\n+      if (restoredLength != testData.length) {\r\n+        return true;\r\n+      }\r\n+    } catch (DataFormatException e) {\r\n+      return true;\r\n+    } finally {\r\n+      inflater.end();\r\n+    }\r\n+\r\n+    if (Arrays.equals(testData, restored) == false) {\r\n+      return true;\r\n+    }\r\n+    \r\n+    // all fine\r\n+    return false;\r\n+  }\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDI5Ng=="}, "originalCommit": {"oid": "4fbcf6adcfd054567848e3d577234dd3576d25f4"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1176, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}