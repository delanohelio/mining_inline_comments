{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NzQ1NTYy", "number": 1733, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOToxMjo0MlrOEXWLWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzo1Mjo0NVrOEz5qUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTE2MDU5OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOToxMjo0MlrOG_FrVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNjozNjowNVrOG_95_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwNjQ4NA==", "bodyText": "I think instead of the boxed Integer catIDInteger we should pass the int ordinal to .advanceExact(...)?  Not the cause of the NPE, just cleaner.", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r468806484", "createdAt": "2020-08-11T19:12:42Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -323,8 +323,10 @@ public FacetLabel getPath(int ordinal) throws IOException {\n       }\n     }\n     \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+    boolean found = MultiDocValues.getBinaryValues(indexReader, Consts.FULL).advanceExact(catIDInteger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ddd5c832fa4a57cc7cf8d620f2e3efe6459dc9f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwODkwNA==", "bodyText": "OK, I see one issue -- you are pulling a new BinaryDocValues, calling .advanceExact on it (good), but then pulling a new BinaryDocValues below and not calling .advanceExact on it.\nI think you must add a new local variable, e.g. BinaryDocValues values.  Pull it once (using the MultiDocValues.getBinaryValues sugar API).  Then call .advanceExact on that and assert it succeeded. Finally, use that same values instance (now that it has advanced to the right docId) to call .binaryValue().utf8ToString().\nI think that should fix the NPE?\nThis is misuse of the API for the default Lucene Codec for BinaryDocValues, since you were calling .binaryValue() before .advanceExact().  It is somewhat disappointing that the codec threw a confusing NPE and not a clearer (best effort) exception stating that you must first call .advanceExact.  Maybe we could improve the default Codec?  (Though, not if that would hurt performance of correct usage).  OK I see: the NPE is because of MultiDocValues.currentValues is null since .advanceExact was not yet called.  Maybe we could add an assert there, confirming .advanceExact was indeed called and had returned true?  It would have made debugging this easier, and should not hurt performance when assertions are disabled ...", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r468808904", "createdAt": "2020-08-11T19:17:07Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -323,8 +323,10 @@ public FacetLabel getPath(int ordinal) throws IOException {\n       }\n     }\n     \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+    boolean found = MultiDocValues.getBinaryValues(indexReader, Consts.FULL).advanceExact(catIDInteger);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwNjQ4NA=="}, "originalCommit": {"oid": "5ddd5c832fa4a57cc7cf8d620f2e3efe6459dc9f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxMjUyNw==", "bodyText": "One more idea: instead of using MultiDocValues sugar, I think we should use Lucene's ReaderUtil to quickly (binary search) determine which leaf holds this docId, then pull BinaryDocValues from that LeafReader?", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r468812527", "createdAt": "2020-08-11T19:24:07Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -323,8 +323,10 @@ public FacetLabel getPath(int ordinal) throws IOException {\n       }\n     }\n     \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+    boolean found = MultiDocValues.getBinaryValues(indexReader, Consts.FULL).advanceExact(catIDInteger);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwNjQ4NA=="}, "originalCommit": {"oid": "5ddd5c832fa4a57cc7cf8d620f2e3efe6459dc9f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcyNzc0Mw==", "bodyText": "Thank you for looking at it so closely (and helping in debugging).\nThe new PR has the following changes:\n\nUse ordinal  instead of catIDInteger (IntelliJ says that boxing is anyways not needed, perhaps we can remove?)\nUse the correct values instance that has advanced to the correct docId\nUse ReaderUtil to get to the leaf and then use LeafReader instead of using the higher level MultiDocValues call\n\nTEST:\nant test in the lucene-solr/lucene/facets directory (passes successfully)\nant precommit\nI've not added any new tests because this PR changes a low level implementation detail and the current tests already cover this\nThe next step is to run lucene benchmarks!", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r469727743", "createdAt": "2020-08-13T06:36:05Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -323,8 +323,10 @@ public FacetLabel getPath(int ordinal) throws IOException {\n       }\n     }\n     \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+    boolean found = MultiDocValues.getBinaryValues(indexReader, Consts.FULL).advanceExact(catIDInteger);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwNjQ4NA=="}, "originalCommit": {"oid": "5ddd5c832fa4a57cc7cf8d620f2e3efe6459dc9f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjczODkyOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowNjoyNVrOHANI0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTo0Mjo0OFrOHAa-pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NzI5Nw==", "bodyText": "Pre-existing: I don't like that we return null up above if the requested ordinal is out-of-bounds.  That's dangerous leniency and likely means the user is refreshing their main IndexReader and the TaxonomyReader in the wrong order.  It would be better to throw an exception here?  @gautamworah96 could you open a follow-on issue to fix that?  Thanks.", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r469977297", "createdAt": "2020-08-13T14:06:25Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -322,9 +324,14 @@ public FacetLabel getPath(int ordinal) throws IOException {\n         return res;\n       }\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7e345c0825969a1701ad465c14744880de6110"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwNDA3MA==", "bodyText": "Opened LUCENE-9460 for this", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r470204070", "createdAt": "2020-08-13T19:42:48Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -322,9 +324,14 @@ public FacetLabel getPath(int ordinal) throws IOException {\n         return res;\n       }\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NzI5Nw=="}, "originalCommit": {"oid": "4b7e345c0825969a1701ad465c14744880de6110"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjc0NjEwOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowODowNlrOHANNRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODoyODo1N1rOHAYVnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3ODQzOQ==", "bodyText": "Could you factor out the FacetsConfig.pathToString(...) part in a new local variable and re-use that?  We use it in (at least?) two places here.", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r469978439", "createdAt": "2020-08-13T14:08:06Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java", "diffHunk": "@@ -494,6 +496,7 @@ private int addCategoryDocument(FacetLabel categoryPath, int parent) throws IOEx\n \n     fullPathField.setStringValue(FacetsConfig.pathToString(categoryPath.components, categoryPath.length));\n     d.add(fullPathField);\n+    d.add(new BinaryDocValuesField(Consts.FULL, new BytesRef(FacetsConfig.pathToString(categoryPath.components, categoryPath.length))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7e345c0825969a1701ad465c14744880de6110"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDc5OQ==", "bodyText": "Yep, this could be cleaner. Extracted out in the next commit", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r470160799", "createdAt": "2020-08-13T18:28:57Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java", "diffHunk": "@@ -494,6 +496,7 @@ private int addCategoryDocument(FacetLabel categoryPath, int parent) throws IOEx\n \n     fullPathField.setStringValue(FacetsConfig.pathToString(categoryPath.components, categoryPath.length));\n     d.add(fullPathField);\n+    d.add(new BinaryDocValuesField(Consts.FULL, new BytesRef(FacetsConfig.pathToString(categoryPath.components, categoryPath.length))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3ODQzOQ=="}, "originalCommit": {"oid": "4b7e345c0825969a1701ad465c14744880de6110"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzA2NjEyOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNToxMjozMVrOHEGSxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMTo0MTo0MVrOHFSDBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTQ2Mg==", "bodyText": "Could you open a new issue to optimize this better in the future, to do bulk lookup of ordinal -> FacetLabel?  And then add a // TODO  pointing to that issue and describing the optimization?", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r474059462", "createdAt": "2020-08-20T15:12:31Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -322,9 +324,14 @@ public FacetLabel getPath(int ordinal) throws IOException {\n         return res;\n       }\n     }\n-    \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+\n+    int readerIndex = ReaderUtil.subIndex(ordinal, indexReader.leaves());\n+    LeafReader leafReader = indexReader.leaves().get(readerIndex).reader();\n+    BinaryDocValues values = leafReader.getBinaryDocValues(Consts.FULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "709c5ae3fda5eaab4a6827111835c4e8285f4cda"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1NjMyNQ==", "bodyText": "Could you give an example of what that bulk lookup function params would look like / some reference in the code where something of this sort is implemented?", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r474356325", "createdAt": "2020-08-21T01:23:05Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -322,9 +324,14 @@ public FacetLabel getPath(int ordinal) throws IOException {\n         return res;\n       }\n     }\n-    \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+\n+    int readerIndex = ReaderUtil.subIndex(ordinal, indexReader.leaves());\n+    LeafReader leafReader = indexReader.leaves().get(readerIndex).reader();\n+    BinaryDocValues values = leafReader.getBinaryDocValues(Consts.FULL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTQ2Mg=="}, "originalCommit": {"oid": "709c5ae3fda5eaab4a6827111835c4e8285f4cda"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMwMDYxNA==", "bodyText": "I created a new issue LUCENE 9476", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r475300614", "createdAt": "2020-08-24T01:41:41Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java", "diffHunk": "@@ -322,9 +324,14 @@ public FacetLabel getPath(int ordinal) throws IOException {\n         return res;\n       }\n     }\n-    \n-    Document doc = indexReader.document(ordinal);\n-    FacetLabel ret = new FacetLabel(FacetsConfig.stringToPath(doc.get(Consts.FULL)));\n+\n+    int readerIndex = ReaderUtil.subIndex(ordinal, indexReader.leaves());\n+    LeafReader leafReader = indexReader.leaves().get(readerIndex).reader();\n+    BinaryDocValues values = leafReader.getBinaryDocValues(Consts.FULL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTQ2Mg=="}, "originalCommit": {"oid": "709c5ae3fda5eaab4a6827111835c4e8285f4cda"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODU3NTEzOnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzo1MjozOFrOHraJjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODowODo1MlrOHra0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3OTI0Nw==", "bodyText": "Hmm, can you move this assert above the assertNotNull?", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r515279247", "createdAt": "2020-10-30T17:52:38Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy.directory;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.apache.lucene.facet.taxonomy.FacetLabel;\n+import org.apache.lucene.facet.taxonomy.TaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.lucene.util.TestUtil;\n+import org.junit.Ignore;\n+\n+/*\n+  Verify we can read previous versions' taxonomy indexes, do searches\n+  against them, and add documents to them.\n+*/\n+// See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n+public class TestBackwardsCompatibility extends LuceneTestCase {\n+\n+    // To generate backcompat indexes with the current default codec, run the following gradle command:\n+    //  gradlew test -Dtestcase=TestBackwardsCompatibility -Dtests.bwcdir=/path/to/store/indexes\n+    //           -Dtests.codec=default -Dtests.useSecurityManager=false\n+    // Also add testmethod with one of the index creation methods below, for example:\n+    //    -Dtestmethod=testCreateOldTaxonomy\n+    //\n+    // Zip up the generated indexes:\n+    //\n+    //    cd /path/to/store/indexes/index.cfs   ; zip index.<VERSION>-cfs.zip *\n+    //\n+    // Then move the zip file to your trunk checkout and use it in your test cases\n+\n+    public static final String oldTaxonomyIndexName = \"taxonomy.8.6.3-cfs\";\n+\n+    public void testCreateNewTaxonomy() throws IOException {\n+        createNewTaxonomyIndex(oldTaxonomyIndexName);\n+    }\n+\n+    // Opens up a pre-existing old taxonomy index and adds new BinaryDocValues based fields\n+    private void createNewTaxonomyIndex(String dirName) throws IOException {\n+        Path indexDir = createTempDir(oldTaxonomyIndexName);\n+        TestUtil.unzip(getDataInputStream(dirName + \".zip\"), indexDir);\n+        Directory dir = newFSDirectory(indexDir);\n+\n+        DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);\n+\n+        FacetLabel cp_b = new FacetLabel(\"b\");\n+        writer.addCategory(cp_b);\n+        writer.getInternalIndexWriter().forceMerge(1);\n+        writer.commit();\n+\n+        TaxonomyReader reader = new DirectoryTaxonomyReader(writer);\n+\n+        int ord1 = reader.getOrdinal(new FacetLabel(\"a\"));\n+        // Just asserting ord1 != TaxonomyReader.INVALID_ORDINAL is not enough to check compatibility\n+        assertNotNull(reader.getPath(ord1));\n+        assert ord1 != TaxonomyReader.INVALID_ORDINAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3b0de983d190e75947eed03b24064c305148ae4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MDI0Mw==", "bodyText": "Fixed", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r515290243", "createdAt": "2020-10-30T18:08:52Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy.directory;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.apache.lucene.facet.taxonomy.FacetLabel;\n+import org.apache.lucene.facet.taxonomy.TaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.lucene.util.TestUtil;\n+import org.junit.Ignore;\n+\n+/*\n+  Verify we can read previous versions' taxonomy indexes, do searches\n+  against them, and add documents to them.\n+*/\n+// See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n+public class TestBackwardsCompatibility extends LuceneTestCase {\n+\n+    // To generate backcompat indexes with the current default codec, run the following gradle command:\n+    //  gradlew test -Dtestcase=TestBackwardsCompatibility -Dtests.bwcdir=/path/to/store/indexes\n+    //           -Dtests.codec=default -Dtests.useSecurityManager=false\n+    // Also add testmethod with one of the index creation methods below, for example:\n+    //    -Dtestmethod=testCreateOldTaxonomy\n+    //\n+    // Zip up the generated indexes:\n+    //\n+    //    cd /path/to/store/indexes/index.cfs   ; zip index.<VERSION>-cfs.zip *\n+    //\n+    // Then move the zip file to your trunk checkout and use it in your test cases\n+\n+    public static final String oldTaxonomyIndexName = \"taxonomy.8.6.3-cfs\";\n+\n+    public void testCreateNewTaxonomy() throws IOException {\n+        createNewTaxonomyIndex(oldTaxonomyIndexName);\n+    }\n+\n+    // Opens up a pre-existing old taxonomy index and adds new BinaryDocValues based fields\n+    private void createNewTaxonomyIndex(String dirName) throws IOException {\n+        Path indexDir = createTempDir(oldTaxonomyIndexName);\n+        TestUtil.unzip(getDataInputStream(dirName + \".zip\"), indexDir);\n+        Directory dir = newFSDirectory(indexDir);\n+\n+        DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);\n+\n+        FacetLabel cp_b = new FacetLabel(\"b\");\n+        writer.addCategory(cp_b);\n+        writer.getInternalIndexWriter().forceMerge(1);\n+        writer.commit();\n+\n+        TaxonomyReader reader = new DirectoryTaxonomyReader(writer);\n+\n+        int ord1 = reader.getOrdinal(new FacetLabel(\"a\"));\n+        // Just asserting ord1 != TaxonomyReader.INVALID_ORDINAL is not enough to check compatibility\n+        assertNotNull(reader.getPath(ord1));\n+        assert ord1 != TaxonomyReader.INVALID_ORDINAL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3OTI0Nw=="}, "originalCommit": {"oid": "d3b0de983d190e75947eed03b24064c305148ae4"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODU3NTU1OnYy", "diffSide": "RIGHT", "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzo1Mjo0NVrOHraJ0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODowODoyMFrOHrazjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3OTMxNQ==", "bodyText": "This one too?", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r515279315", "createdAt": "2020-10-30T17:52:45Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy.directory;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.apache.lucene.facet.taxonomy.FacetLabel;\n+import org.apache.lucene.facet.taxonomy.TaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.lucene.util.TestUtil;\n+import org.junit.Ignore;\n+\n+/*\n+  Verify we can read previous versions' taxonomy indexes, do searches\n+  against them, and add documents to them.\n+*/\n+// See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n+public class TestBackwardsCompatibility extends LuceneTestCase {\n+\n+    // To generate backcompat indexes with the current default codec, run the following gradle command:\n+    //  gradlew test -Dtestcase=TestBackwardsCompatibility -Dtests.bwcdir=/path/to/store/indexes\n+    //           -Dtests.codec=default -Dtests.useSecurityManager=false\n+    // Also add testmethod with one of the index creation methods below, for example:\n+    //    -Dtestmethod=testCreateOldTaxonomy\n+    //\n+    // Zip up the generated indexes:\n+    //\n+    //    cd /path/to/store/indexes/index.cfs   ; zip index.<VERSION>-cfs.zip *\n+    //\n+    // Then move the zip file to your trunk checkout and use it in your test cases\n+\n+    public static final String oldTaxonomyIndexName = \"taxonomy.8.6.3-cfs\";\n+\n+    public void testCreateNewTaxonomy() throws IOException {\n+        createNewTaxonomyIndex(oldTaxonomyIndexName);\n+    }\n+\n+    // Opens up a pre-existing old taxonomy index and adds new BinaryDocValues based fields\n+    private void createNewTaxonomyIndex(String dirName) throws IOException {\n+        Path indexDir = createTempDir(oldTaxonomyIndexName);\n+        TestUtil.unzip(getDataInputStream(dirName + \".zip\"), indexDir);\n+        Directory dir = newFSDirectory(indexDir);\n+\n+        DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);\n+\n+        FacetLabel cp_b = new FacetLabel(\"b\");\n+        writer.addCategory(cp_b);\n+        writer.getInternalIndexWriter().forceMerge(1);\n+        writer.commit();\n+\n+        TaxonomyReader reader = new DirectoryTaxonomyReader(writer);\n+\n+        int ord1 = reader.getOrdinal(new FacetLabel(\"a\"));\n+        // Just asserting ord1 != TaxonomyReader.INVALID_ORDINAL is not enough to check compatibility\n+        assertNotNull(reader.getPath(ord1));\n+        assert ord1 != TaxonomyReader.INVALID_ORDINAL;\n+\n+        int ord2 = reader.getOrdinal(cp_b);\n+        assertNotNull(reader.getPath(ord2));\n+        assert ord2 != TaxonomyReader.INVALID_ORDINAL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3b0de983d190e75947eed03b24064c305148ae4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI4OTk5Ng==", "bodyText": "Fixed", "url": "https://github.com/apache/lucene-solr/pull/1733#discussion_r515289996", "createdAt": "2020-10-30T18:08:20Z", "author": {"login": "gautamworah96"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestBackwardsCompatibility.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy.directory;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.apache.lucene.facet.taxonomy.FacetLabel;\n+import org.apache.lucene.facet.taxonomy.TaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.lucene.util.TestUtil;\n+import org.junit.Ignore;\n+\n+/*\n+  Verify we can read previous versions' taxonomy indexes, do searches\n+  against them, and add documents to them.\n+*/\n+// See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n+public class TestBackwardsCompatibility extends LuceneTestCase {\n+\n+    // To generate backcompat indexes with the current default codec, run the following gradle command:\n+    //  gradlew test -Dtestcase=TestBackwardsCompatibility -Dtests.bwcdir=/path/to/store/indexes\n+    //           -Dtests.codec=default -Dtests.useSecurityManager=false\n+    // Also add testmethod with one of the index creation methods below, for example:\n+    //    -Dtestmethod=testCreateOldTaxonomy\n+    //\n+    // Zip up the generated indexes:\n+    //\n+    //    cd /path/to/store/indexes/index.cfs   ; zip index.<VERSION>-cfs.zip *\n+    //\n+    // Then move the zip file to your trunk checkout and use it in your test cases\n+\n+    public static final String oldTaxonomyIndexName = \"taxonomy.8.6.3-cfs\";\n+\n+    public void testCreateNewTaxonomy() throws IOException {\n+        createNewTaxonomyIndex(oldTaxonomyIndexName);\n+    }\n+\n+    // Opens up a pre-existing old taxonomy index and adds new BinaryDocValues based fields\n+    private void createNewTaxonomyIndex(String dirName) throws IOException {\n+        Path indexDir = createTempDir(oldTaxonomyIndexName);\n+        TestUtil.unzip(getDataInputStream(dirName + \".zip\"), indexDir);\n+        Directory dir = newFSDirectory(indexDir);\n+\n+        DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);\n+\n+        FacetLabel cp_b = new FacetLabel(\"b\");\n+        writer.addCategory(cp_b);\n+        writer.getInternalIndexWriter().forceMerge(1);\n+        writer.commit();\n+\n+        TaxonomyReader reader = new DirectoryTaxonomyReader(writer);\n+\n+        int ord1 = reader.getOrdinal(new FacetLabel(\"a\"));\n+        // Just asserting ord1 != TaxonomyReader.INVALID_ORDINAL is not enough to check compatibility\n+        assertNotNull(reader.getPath(ord1));\n+        assert ord1 != TaxonomyReader.INVALID_ORDINAL;\n+\n+        int ord2 = reader.getOrdinal(cp_b);\n+        assertNotNull(reader.getPath(ord2));\n+        assert ord2 != TaxonomyReader.INVALID_ORDINAL;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3OTMxNQ=="}, "originalCommit": {"oid": "d3b0de983d190e75947eed03b24064c305148ae4"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1283, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}