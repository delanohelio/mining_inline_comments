{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMDkyNTEy", "number": 1626, "title": "SOLR-14588: Implement Circuit Breakers", "bodyText": "This commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "createdAt": "2020-06-28T18:02:48Z", "url": "https://github.com/apache/lucene-solr/pull/1626", "merged": true, "mergeCommit": {"oid": "3f9cc227f159f1e0583dd5aad2ec7a8bd102415f"}, "closed": true, "closedAt": "2020-07-02T07:13:48Z", "author": {"login": "atris"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvwePmABqjM0OTA1NDg5MDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxBclhAFqTQ0MTg1MTU0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "718152e4e7dfbf1be579f78bdb4b424d292d0866", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/718152e4e7dfbf1be579f78bdb4b424d292d0866", "committedDate": "2020-06-28T18:00:52Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "committedDate": "2020-06-28T18:08:21Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODA0MjQ4", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-438804248", "createdAt": "2020-06-28T18:49:54Z", "commit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxODo0OTo1NFrOGp_d3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxOTo0MToyOFrOGp_ybw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NDYzNg==", "bodyText": "Minor nit, should be a new line between these.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446684636", "createdAt": "2020-06-28T18:49:54Z", "author": {"login": "ErickErickson"}, "path": "solr/CHANGES.txt", "diffHunk": "@@ -11,6 +11,7 @@ Consult the LUCENE_CHANGES.txt file for additional, low level, changes in this r\n New Features\n ---------------------\n * SOLR-14440: Introduce new Certificate Authentication Plugin to load Principal from certificate subject. (Mike Drob)\n+* SOLR-14588: Introduce Circuit Breaker Infrastructure and a JVM heap usage memory tracking circuit breaker implementation (Atri Sharma)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NDg0OQ==", "bodyText": "A little bit of guidance here would be helpful, maybe \"70-80% heap usage is typical\". Numbers are pulled out of thin air, just looking for a starting point for a newbie.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446684849", "createdAt": "2020-06-28T18:51:44Z", "author": {"login": "ErickErickson"}, "path": "solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/solrconfig.xml", "diffHunk": "@@ -123,6 +123,17 @@\n          The purpose is to enable easy caching of user/application level data.\n          The regenerator argument should be specified as an implementation\n          of solr.search.CacheRegenerator if autowarming is desired.  -->\n+\n+    <!-- Enable Circuit Breakers\n+  -->\n+    <useCircuitBreakers>false</useCircuitBreakers>\n+\n+    <!-- Memory Circuit Breaker Threshold In Percentage\n+\n+    Post this percentage usage of the heap, incoming queries will be rejected\n+      -->\n+    <memoryCircuitBreakerThreshold>100</memoryCircuitBreakerThreshold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NDg4OQ==", "bodyText": "Same as above.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446684889", "createdAt": "2020-06-28T18:52:03Z", "author": {"login": "ErickErickson"}, "path": "solr/contrib/prometheus-exporter/src/test-files/solr/collection1/conf/solrconfig.xml", "diffHunk": "@@ -83,6 +83,10 @@\n \n     <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n \n+    <useCircuitBreakers>false</useCircuitBreakers>\n+\n+    <memoryCircuitBreakerThreshold>100</memoryCircuitBreakerThreshold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTExNg==", "bodyText": "I always like to put in default values where the Java defaults wouldn't work, just in case \"somehow\" this isn't set in future. memoryCircuitBreakerThreshold defaults to 0 in this case, is that OK?\nAnd maybe name this memoryCircuitBreakerThresholdPct?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685116", "createdAt": "2020-06-28T18:54:50Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -522,6 +527,10 @@ public SolrRequestParsers getRequestParsers() {\n   public final int queryResultWindowSize;\n   public final int queryResultMaxDocsCached;\n   public final boolean enableLazyFieldLoading;\n+\n+  // Circuit Breaker Configuration\n+  public final boolean useCircuitBreakers;\n+  public final int memoryCircuitBreakerThreshold;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTU4OA==", "bodyText": "Does it really make sense to allow either of these values? 0 seems like it'd cause everything to break (haven't seen the rest of the code yet, maybe 0 is a special case). 100% seems too late. Do we have any good information about what reasonable upper and lower bounds are? And should we enforce them? Say 50%/90% as a straw-man proposal for discussion...", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685588", "createdAt": "2020-06-28T18:59:11Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng==", "bodyText": "Add what valid percentages are here, especially if we decide to enforce as above..\nThis should also echo the number entered and what the valid limits are, something like:\nmemoryCircuitBreakerThreshold was set to\" + memoryCircuitBreakerThreshold + \". Valid percentages must be between X% and Y%\"", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685886", "createdAt": "2020-06-28T19:02:03Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ==", "bodyText": "Why not just allocate a new HashMap here and avoid the null check below?\nHmmm, I suppose if there aren't any circuit breakers one could return null, NM.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446687849", "createdAt": "2020-06-28T19:20:39Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA==", "bodyText": "This seems like an awfully small file, perhaps put this in the abstract CircuitBreaker class? No big deal either way.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446688878", "createdAt": "2020-06-28T19:31:18Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+/**\n+ * Types of circuit breakers\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTMzMQ==", "bodyText": "Why is including the new circuitbreaker configs defaulting to false necessary? If they're left out, this should be a no-op, correct?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446689331", "createdAt": "2020-06-28T19:35:52Z", "author": {"login": "ErickErickson"}, "path": "solr/core/src/test-files/solr/collection1/conf/solrconfig-implicitproperties.xml", "diffHunk": "@@ -42,6 +42,8 @@\n     <enableLazyFieldLoading>true</enableLazyFieldLoading>\n     <queryResultWindowSize>20</queryResultWindowSize>\n     <queryResultMaxDocsCached>20</queryResultMaxDocsCached>\n+    <useCircuitBreakers>false</useCircuitBreakers>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTkwMw==", "bodyText": "I don't think there's any reason to include these in all these solrconfig files. I'd be sure they're include as comments at least in server/solr/configsets/_default and sample_techproducts_configs but not elsewhere. Except, of course, the one you use for testing this functionality.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446689903", "createdAt": "2020-06-28T19:41:28Z", "author": {"login": "ErickErickson"}, "path": "solr/example/example-DIH/solr/db/conf/solrconfig.xml", "diffHunk": "@@ -502,6 +502,16 @@\n      -->\n    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n \n+    <!-- Enable Circuit Breakers\n+  -->\n+    <useCircuitBreakers>false</useCircuitBreakers>\n+\n+    <!-- Memory Circuit Breaker Threshold In Percentage\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDU5MjA3", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-439059207", "createdAt": "2020-06-29T11:47:21Z", "commit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTo0NzoyMVrOGqNHvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMjozMzo0MFrOGqOvgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkwODM0OQ==", "bodyText": "This is probably not needed in configs that don't actually use it (when useCircuitBreakers=false)?\nAlso, to make it more future-proof, we could put these in a section - the expectation is that we will have at least one more (CPU breaker) and potentially other ones too, so instead of adding these new breakers as new elements at this level we could add them as a section (as sub-elements).", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446908349", "createdAt": "2020-06-29T11:47:21Z", "author": {"login": "sigram"}, "path": "solr/contrib/prometheus-exporter/src/test-files/solr/collection1/conf/solrconfig.xml", "diffHunk": "@@ -83,6 +83,10 @@\n \n     <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n \n+    <useCircuitBreakers>false</useCircuitBreakers>\n+\n+    <memoryCircuitBreakerThreshold>100</memoryCircuitBreakerThreshold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMDk1OQ==", "bodyText": "I think 0 also doesn't make much sense.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446910959", "createdAt": "2020-06-29T11:52:12Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcxNA==", "bodyText": "The following probably belongs to the SIP ... but the way I think about the common usage of this class for different code-paths is if breaker configs are labeled and correspond to different code-paths, eg.:\n\n\"query\" -> one config\n\"index\" -> another config\n\"foobar\" -> yet another config, used perhaps in my custom component\n\nCurrent implementation limits us to use the same config for potentially very different code paths.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446914714", "createdAt": "2020-06-29T11:59:07Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNTYzNw==", "bodyText": "OMG, what a name :) Maybe just checkTrippedBreakers ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446915637", "createdAt": "2020-06-29T12:00:43Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNjQ3MA==", "bodyText": "Maybe checkAnyBreakerTripped ? Because we don't actually check all breakers here.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446916470", "createdAt": "2020-06-29T12:02:11Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNzcwOA==", "bodyText": "Do we actually need SolrCore here, or just the breakers' config (currently in SolrConfig)?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446917708", "createdAt": "2020-06-29T12:04:17Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).printDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrCore solrCore) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxODc5Ng==", "bodyText": "It needs  tags to actually make a new paragraph.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446918796", "createdAt": "2020-06-29T12:06:18Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxOTgxOQ==", "bodyText": "This can be calculated once in the constructor - IIRC if SolrConfig is updated the core is reloaded anyway, which will construct the breaker once again.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446919819", "createdAt": "2020-06-29T12:08:00Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyMjEzOA==", "bodyText": "This comment is somewhat misleading ... if I correctly understand the intent :) MemoryUsageGaugeSet does provide the heap and the non-heap usages separately, so it's possible to get the value we want from it - but it incurs unnecessary cost and additional allocations, so we can do it cheaper by using MemoryMXBean directly.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446922138", "createdAt": "2020-06-29T12:12:08Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    long actualLimit = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+\n+    return actualLimit;\n+  }\n+\n+  /**\n+   * Calculate the live memory usage for the system. This method has package visibility\n+   * to allow using for testing\n+   * @return Memory usage in bytes\n+   */\n+  protected long calculateLiveMemoryUsage() {\n+    // NOTE: MemoryUsageGaugeSet provides memory usage statistics but we do not use them\n+    // here since MemoryUsageGaugeSet provides combination of heap and non heap usage and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTg2OQ==", "bodyText": "Maybe isEnabled ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446925869", "createdAt": "2020-06-29T12:18:39Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjA0Nw==", "bodyText": "Maybe isTripped ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926047", "createdAt": "2020-06-29T12:18:57Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjcxNw==", "bodyText": "This doesn't actually print anything, maybe name it getDebugInfo ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926717", "createdAt": "2020-06-29T12:20:08Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();\n+\n+  /**\n+   * Print debug useful info\n+   */\n+  public abstract String printDebugInfo();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyOTIwMA==", "bodyText": "I don't think this distinction merits a separate section - these are not actually different types of breakers, they are just different usage scenarios, and only one is currently implemented.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446929200", "createdAt": "2020-06-29T12:24:26Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMDIzNw==", "bodyText": "The doc should mention somewhere that this is currently the only scenario supported by default.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446930237", "createdAt": "2020-06-29T12:26:10Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:\n+\n+=== Admission Control Checks\n+\n+Circuit breakers that are checked at admission control (request handlers). These circuit breakers are typically attached to a set\n+of requests that check them before proceeding with the request. Example is JVM heap usage based circuit breaker (described below).\n+\n+For these type of circuit breakers, it is a good idea to register them with CircuitBreakerManager\n+(org.apache.solr.util.circuitbreaker.CircuitBreakerManager) to allow a holistic check at the required admission control point.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMDkwMg==", "bodyText": "The JVM arg is -Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446930902", "createdAt": "2020-06-29T12:27:12Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:\n+\n+=== Admission Control Checks\n+\n+Circuit breakers that are checked at admission control (request handlers). These circuit breakers are typically attached to a set\n+of requests that check them before proceeding with the request. Example is JVM heap usage based circuit breaker (described below).\n+\n+For these type of circuit breakers, it is a good idea to register them with CircuitBreakerManager\n+(org.apache.solr.util.circuitbreaker.CircuitBreakerManager) to allow a holistic check at the required admission control point.\n+\n+=== Custom Events/Code Paths Checks\n+\n+Circuit breakers that are needed only in special events or code paths.\n+\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMax). The main configuration for this circuit breaker is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMTI0MA==", "bodyText": "\"the JVM\" -> \"the breaker\".", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446931240", "createdAt": "2020-06-29T12:27:43Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:\n+\n+=== Admission Control Checks\n+\n+Circuit breakers that are checked at admission control (request handlers). These circuit breakers are typically attached to a set\n+of requests that check them before proceeding with the request. Example is JVM heap usage based circuit breaker (described below).\n+\n+For these type of circuit breakers, it is a good idea to register them with CircuitBreakerManager\n+(org.apache.solr.util.circuitbreaker.CircuitBreakerManager) to allow a holistic check at the required admission control point.\n+\n+=== Custom Events/Code Paths Checks\n+\n+Circuit breakers that are needed only in special events or code paths.\n+\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMax). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the JVM will trip.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMTQ1Nw==", "bodyText": "-Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446931457", "createdAt": "2020-06-29T12:28:04Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:\n+\n+=== Admission Control Checks\n+\n+Circuit breakers that are checked at admission control (request handlers). These circuit breakers are typically attached to a set\n+of requests that check them before proceeding with the request. Example is JVM heap usage based circuit breaker (described below).\n+\n+For these type of circuit breakers, it is a good idea to register them with CircuitBreakerManager\n+(org.apache.solr.util.circuitbreaker.CircuitBreakerManager) to allow a holistic check at the required admission control point.\n+\n+=== Custom Events/Code Paths Checks\n+\n+Circuit breakers that are needed only in special events or code paths.\n+\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMax). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the JVM will trip.\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerThreshold>75</memoryCircuitBreakerThreshold>\n+----\n+\n+Consider the following example:\n+\n+JVM has been allocated a maximum heap of 5GB (-XMax) and memoryCircuitBreakerThreshold is set to 75. In this scenario, the heap usage", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzMjU0MA==", "bodyText": "\"Live state\" in SolrCloud terminology is a loaded term ... perhaps it's better to simply use the \"current heap usage\".", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446932540", "createdAt": "2020-06-29T12:29:49Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Types Of Circuit Breakers\n+Circuit breakers can be of two types:\n+\n+=== Admission Control Checks\n+\n+Circuit breakers that are checked at admission control (request handlers). These circuit breakers are typically attached to a set\n+of requests that check them before proceeding with the request. Example is JVM heap usage based circuit breaker (described below).\n+\n+For these type of circuit breakers, it is a good idea to register them with CircuitBreakerManager\n+(org.apache.solr.util.circuitbreaker.CircuitBreakerManager) to allow a holistic check at the required admission control point.\n+\n+=== Custom Events/Code Paths Checks\n+\n+Circuit breakers that are needed only in special events or code paths.\n+\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMax). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the JVM will trip.\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerThreshold>75</memoryCircuitBreakerThreshold>\n+----\n+\n+Consider the following example:\n+\n+JVM has been allocated a maximum heap of 5GB (-XMax) and memoryCircuitBreakerThreshold is set to 75. In this scenario, the heap usage\n+at which the circuit breaker will trip is 3.75GB.\n+\n+Note that this circuit breaker is checked for each incoming search request and considers the live state of the node i.e every search", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDY4Ng==", "bodyText": "Erhm .. \"a comprehensive way\" it is not, but it is certainly \"a way\" :) I would also argue that it doesn't increase predictability of request execution because it introduces a new failure mode that clients have to handle - rather it's a way to ensure the service-level guarantees for requests that are accepted for execution.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446934686", "createdAt": "2020-06-29T12:33:17Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/index.adoc", "diffHunk": "@@ -121,6 +122,8 @@ The *<<getting-started.adoc#getting-started,Getting Started>>* section guides yo\n *<<solrcloud.adoc#solrcloud,SolrCloud>>*: This section describes SolrCloud, which provides comprehensive distributed capabilities.\n \n *<<legacy-scaling-and-distribution.adoc#legacy-scaling-and-distribution,Legacy Scaling and Distribution>>*: This section tells you how to grow a Solr distribution by dividing a large index into sections called shards, which are then distributed across multiple servers, or by replicating a single index across multiple services.\n+\n+*<<circuit-breakers.adoc#circuit-breakers,Circuit Breakers>>*: This section talks about circuit breakers, a comprehensive way of allowing a higher stability of Solr nodes and predictability of request execution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDkxNQ==", "bodyText": "-Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446934915", "createdAt": "2020-06-29T12:33:40Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/query-settings-in-solrconfig.adoc", "diffHunk": "@@ -170,6 +170,26 @@ This parameter sets the maximum number of documents to cache for any entry in th\n <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n ----\n \n+=== useCircuitBreakers\n+\n+Global control flag for enabling circuit breakers\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>true</useCircuitBreakers>\n+----\n+\n+=== memoryCircuitBreakerThreshold\n+\n+Memory threshold in percentage for JVM heap usage defined in percentage of maximum heap allocated\n+\n+to the JVM (-XMax).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "committedDate": "2020-06-28T18:08:21Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "committedDate": "2020-06-29T19:06:28Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "committedDate": "2020-06-29T19:06:28Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "d9f7624131475761b466c92603abcd9846e62bad", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d9f7624131475761b466c92603abcd9846e62bad", "committedDate": "2020-06-29T19:11:17Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9f7624131475761b466c92603abcd9846e62bad", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d9f7624131475761b466c92603abcd9846e62bad", "committedDate": "2020-06-29T19:11:17Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}, "afterCommit": {"oid": "61ca4c0bd71f5cc35b515308e1757292965f90ff", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/61ca4c0bd71f5cc35b515308e1757292965f90ff", "committedDate": "2020-06-29T19:19:03Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1994e8b6a35e827209c2d769cdc14df6729b87d2", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/1994e8b6a35e827209c2d769cdc14df6729b87d2", "committedDate": "2020-06-30T07:38:50Z", "message": "Update test parameter"}, "afterCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/b5582fa759c575623b37c911d7f4485bef7ac940", "committedDate": "2020-06-30T07:57:03Z", "message": "Update test parameter"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9435f85732b4729b8db820f1252eb901ecbab43f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/9435f85732b4729b8db820f1252eb901ecbab43f", "committedDate": "2020-06-30T11:00:05Z", "message": "More Updates"}, "afterCommit": {"oid": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e8c53bd42247904060bb5ee4903ccf46c4057c49", "committedDate": "2020-06-30T11:11:03Z", "message": "More Updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5ODkwNTAz", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-439890503", "createdAt": "2020-06-30T10:39:14Z", "commit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDozOToxNVrOGq2fYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMTowNzo0MVrOGq3YlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjE0Nw==", "bodyText": "There's a typo in this method name - \"checked\" -> \"check\".\nIn general, could we use shorter method names rather than these very long ones? We already know what the component does, we know that it manages CircuitBreakers - IMHO there's no need whatsoever to remind users in every method name that they deal with CircuitBreakers. :)\nI propose getTripped, checkAnyTripped, toErrorMessage and so on, avoiding repetition where it's obvious what we're dealing with.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586147", "createdAt": "2020-06-30T10:39:15Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ=="}, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjM1NA==", "bodyText": "checkAnyTripped ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586354", "createdAt": "2020-06-30T10:39:39Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NzMyMw==", "bodyText": "This is an awkward name - maybe toErrorString or toErrorMessage ?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447587323", "createdAt": "2020-06-30T10:41:26Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODAwNg==", "bodyText": "New-lines or other separator characters would make this message more readable, now we're getting a single very long line.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588006", "createdAt": "2020-06-30T10:42:48Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODUzNg==", "bodyText": "If circuit breakers are not enabled in SolrConfig is there still any point to register any of them?\nAlso, I propose to rename this method to just build - we don't have any way yet to build a non-default manager anyway. The javadoc already says it builds a default configuration.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588536", "createdAt": "2020-06-30T10:43:45Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrConfig solrConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MDIxMA==", "bodyText": "I think Erick suggested (and I agree) that this enum should be simply declared in CircuitBreaker class, as CircuitBreaker.CircuitBreakerType or just CircuitBreaker.Type. This doesn't affect compilation but helps to reduce the number of trivial class files. This is also a pattern that is used frequently in Solr in other places.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447590210", "createdAt": "2020-06-30T10:46:46Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+/**\n+ * Types of circuit breakers\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA=="}, "originalCommit": {"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MjM2NQ==", "bodyText": "upto -> up to\nhandle the same -> handle this error", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447592365", "createdAt": "2020-06-30T10:50:41Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,65 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MjczMA==", "bodyText": "-Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447592730", "createdAt": "2020-06-30T10:51:23Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,65 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMx). The main configuration for this circuit breaker is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5Mjg2Mg==", "bodyText": "-Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447592862", "createdAt": "2020-06-30T10:51:40Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,65 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMx). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the breaker will trip.\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerThreshold>75</memoryCircuitBreakerThreshold>\n+----\n+\n+Consider the following example:\n+\n+JVM has been allocated a maximum heap of 5GB (-XMx) and memoryCircuitBreakerThreshold is set to 75. In this scenario, the heap usage", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzE1Nw==", "bodyText": "i.e -> , i.e.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447593157", "createdAt": "2020-06-30T10:52:17Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,65 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMx). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the breaker will trip.\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerThreshold>75</memoryCircuitBreakerThreshold>\n+----\n+\n+Consider the following example:\n+\n+JVM has been allocated a maximum heap of 5GB (-XMx) and memoryCircuitBreakerThreshold is set to 75. In this scenario, the heap usage\n+at which the circuit breaker will trip is 3.75GB.\n+\n+Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node i.e every search", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5Mzk1Nw==", "bodyText": "practise -> practice", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447593957", "createdAt": "2020-06-30T10:53:42Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/circuit-breakers.adoc", "diffHunk": "@@ -0,0 +1,65 @@\n+= Circuit Breakers\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+Solr's circuit breaker infrastructure allows prevention of actions that can cause a node to go beyond its capacity or to go down. The\n+premise of circuit breakers is to ensure a higher quality of service and only accept request loads that are serviceable in the current\n+resource configuration.\n+\n+== When To Use Circuit Breakers\n+Circuit breakers should be used when the user wishes to trade request throughput for a higher Solr stability. If circuit breakers\n+are enabled, requests may be rejected under the condition of high node duress with an appropriate HTTP error code (typically 503).\n+\n+It is upto the client to handle the same and potentially build a retrial logic as this should ideally be a transient situation.\n+\n+== Circuit Breaker Configurations\n+The following flag controls the global activation/deactivation of circuit breakers. If this flag is disabled, all circuit breakers\n+will be disabled globally. Per circuit breaker configurations are specified in their respective sections later.\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>false</useCircuitBreakers>\n+----\n+\n+== Currently Supported Circuit Breakers\n+\n+=== JVM Heap Usage Based Circuit Breaker\n+This circuit breaker tracks JVM heap memory usage and rejects incoming search requests with a 503 error code if the heap usage\n+exceeds a configured percentage of maximum heap allocated to the JVM (-XMx). The main configuration for this circuit breaker is\n+controlling the threshold percentage at which the breaker will trip.\n+\n+[source,xml]\n+----\n+<memoryCircuitBreakerThreshold>75</memoryCircuitBreakerThreshold>\n+----\n+\n+Consider the following example:\n+\n+JVM has been allocated a maximum heap of 5GB (-XMx) and memoryCircuitBreakerThreshold is set to 75. In this scenario, the heap usage\n+at which the circuit breaker will trip is 3.75GB.\n+\n+Note that this circuit breaker is checked for each incoming search request and considers the current heap usage of the node i.e every search\n+request will get the live heap usage and compare it against the set memory threshold. The check does not impact performance,\n+but any performance regressions that are suspected to be caused by this feature should be reported to the dev list.\n+\n+\n+== Performance Considerations\n+It is worth noting that while JVM circuit breaker does not add any noticeable overhead per query, having too many\n+circuit breakers checked for a single request can cause a performance overhead.\n+\n+In addition, it is a good practise to exponentially back off while retrying requests on a busy node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NDM4Mw==", "bodyText": "Add full stop.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447594383", "createdAt": "2020-06-30T10:54:33Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/query-settings-in-solrconfig.adoc", "diffHunk": "@@ -170,6 +170,26 @@ This parameter sets the maximum number of documents to cache for any entry in th\n <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n ----\n \n+=== useCircuitBreakers\n+\n+Global control flag for enabling circuit breakers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NDUwMg==", "bodyText": "-Xmx", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447594502", "createdAt": "2020-06-30T10:54:47Z", "author": {"login": "sigram"}, "path": "solr/solr-ref-guide/src/query-settings-in-solrconfig.adoc", "diffHunk": "@@ -170,6 +170,26 @@ This parameter sets the maximum number of documents to cache for any entry in th\n <queryResultMaxDocsCached>200</queryResultMaxDocsCached>\n ----\n \n+=== useCircuitBreakers\n+\n+Global control flag for enabling circuit breakers\n+\n+[source,xml]\n+----\n+<useCircuitBreakers>true</useCircuitBreakers>\n+----\n+\n+=== memoryCircuitBreakerThreshold\n+\n+Memory threshold in percentage for JVM heap usage defined in percentage of maximum heap allocated\n+to the JVM (-XMx). Ideally, this value should be in the range of 75-80% of maximum heap allocated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NzY3Mw==", "bodyText": "These can be final too (it doesn't matter at runtime but it makes the intent clear).", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447597673", "createdAt": "2020-06-30T11:01:06Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTc0MQ==", "bodyText": "This javadoc is confusing - why not simply say \"Check if this breaker is tripped\"? It's not the request that trips the breaker, it's the underlying condition that does this.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599741", "createdAt": "2020-06-30T11:05:23Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTkxMA==", "bodyText": "Get useful debug info.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599910", "createdAt": "2020-06-30T11:05:46Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Print debug useful info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDQ4OQ==", "bodyText": "We can drop CircuitBreaker from the method name - we already know what we're going to register.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600489", "createdAt": "2020-06-30T11:07:01Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDc4OQ==", "bodyText": "Drop CircuitBreakers?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600789", "createdAt": "2020-06-30T11:07:41Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6e91bda0bc63d587d84bedc8b3f54f8a875cd1f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e6e91bda0bc63d587d84bedc8b3f54f8a875cd1f", "committedDate": "2020-06-30T15:15:07Z", "message": "Renamings"}, "afterCommit": {"oid": "80b5ce7495c720c927c883411b76326cf009409d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/80b5ce7495c720c927c883411b76326cf009409d", "committedDate": "2020-06-30T15:27:33Z", "message": "Renamings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80b5ce7495c720c927c883411b76326cf009409d", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/80b5ce7495c720c927c883411b76326cf009409d", "committedDate": "2020-06-30T15:27:33Z", "message": "Renamings"}, "afterCommit": {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/4225317e4da65a5f6ae49d5f6ecac47db274444f", "committedDate": "2020-06-30T15:35:25Z", "message": "Renamings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTU4MjIz", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-440158223", "createdAt": "2020-06-30T15:53:27Z", "commit": {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MzoyOFrOGrDGtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1NjowNFrOGrDOKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjgyMg==", "bodyText": "Add full-stops at the end of sentences and a <p> between paragraphs, otherwise the lines will run into each other.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447792822", "createdAt": "2020-06-30T15:53:28Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzI0NA==", "bodyText": "Full-stop? ;)", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447793244", "createdAt": "2020-06-30T15:54:04Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDczMA==", "bodyText": "Hmm, if we're warning about this then maybe we should give some details about what's wrong, i.e. which value was unexpected.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447794730", "createdAt": "2020-06-30T15:56:04Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {\n+      log.warn(\"MemoryCircuitBreaker's monitored values not set correctly\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f"}, "originalPosition": 89}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4eea5e29c95e3d36ac1f717e9599db5b183d527", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/c4eea5e29c95e3d36ac1f717e9599db5b183d527", "committedDate": "2020-06-30T17:25:37Z", "message": "Moar Stuff"}, "afterCommit": {"oid": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "committedDate": "2020-06-30T17:31:08Z", "message": "Moar Stuff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "committedDate": "2020-06-30T17:31:08Z", "message": "Moar Stuff"}, "afterCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/69594b7c28658a702b5bf2462e568290bec05e61", "committedDate": "2020-06-30T17:45:05Z", "message": "Moar Stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzY4Njk4", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-440768698", "createdAt": "2020-07-01T11:04:40Z", "commit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwOTg5NDUx", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-440989451", "createdAt": "2020-07-01T15:43:20Z", "commit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0MzoyMVrOGrrbBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjozMjo0N1rOGrtPIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MzM4MQ==", "bodyText": "I don't think 100 is a safe default here, since later we check that the value is between 50-95.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448453381", "createdAt": "2020-07-01T15:43:21Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,11 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NTU3Nw==", "bodyText": "This is a little scary that we sometimes return null here? I think I would prefer an implementation of CBM that knows it is turned off so we don't accidentally get an NPE somewhere else.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448455577", "createdAt": "2020-07-01T15:46:44Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/SolrCore.java", "diffHunk": "@@ -1164,6 +1168,16 @@ private SolrCoreMetricManager initCoreMetricManager(SolrConfig config) {\n     return coreMetricManager;\n   }\n \n+  private CircuitBreakerManager initCircuitBreakerManager() {\n+    if (solrConfig.useCircuitBreakers) {\n+      CircuitBreakerManager circuitBreakerManager = CircuitBreakerManager.build(solrConfig);\n+\n+      return circuitBreakerManager;\n+    }\n+\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1Nzg5MA==", "bodyText": "This is unused? Maybe delete it for now and add it back when somebody comes up with an implementation?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448457890", "createdAt": "2020-07-01T15:50:27Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {\n+    MEMORY,\n+    CPU", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1ODM4MA==", "bodyText": "Does this need a \"CUSTOM\" type or something else for folks who will be implementing their own?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448458380", "createdAt": "2020-07-01T15:51:14Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTAzNw==", "bodyText": "circuitBreakerMap.values()", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459037", "createdAt": "2020-07-01T15:52:22Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTcwNg==", "bodyText": "This doesn't seem right... I can only have one circuit breaker of each type? I can imagine having multiple breakers that all work in conjunction - limit QPS to X, and limit QPM to Y, for example.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459706", "createdAt": "2020-07-01T15:53:30Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTg2MA==", "bodyText": "Is this needed?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459860", "createdAt": "2020-07-01T15:53:46Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDI3Mw==", "bodyText": "do multiple append calls instead of string concat.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460273", "createdAt": "2020-07-01T15:54:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip.\n+   *\n+   * @param circuitBreakerMap Input list for circuit breakers.\n+   * @return Constructed error message.\n+   */\n+  public static String toErrorMessage(Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreaker.CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo() + \"\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDY1MQ==", "bodyText": "This method is never used?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460651", "createdAt": "2020-07-01T15:54:58Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MTE4NQ==", "bodyText": "This is unused?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448461185", "createdAt": "2020-07-01T15:55:48Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ==", "bodyText": "Should we store these to local values so that we don't have to call an extra .get() on the concurrent structure? Probably doesn't make a difference.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462009", "createdAt": "2020-07-01T15:57:09Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjMxNA==", "bodyText": "Why are we comparing a long to a floating point?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462314", "createdAt": "2020-07-01T15:57:38Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ4MzEwNg==", "bodyText": "What is this testing? Is this just resetting the circuitbreakermanager? Should be in a Before/After blocks?", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448483106", "createdAt": "2020-07-01T16:32:47Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTEyOTk3", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-441112997", "createdAt": "2020-07-01T18:42:38Z", "commit": {"oid": "3dbfc0b02afb925d7abd3da00a309cf8c723a1e2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo0MjozOFrOGrxWVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODo0NDozM1rOGrxZ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MDQ4NQ==", "bodyText": "this solution has an extra unboxing.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448550485", "createdAt": "2020-07-01T18:42:38Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ=="}, "originalCommit": {"oid": "69594b7c28658a702b5bf2462e568290bec05e61"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MTQwMg==", "bodyText": "This appends to the list, doesn't do any clearing. By the last test you'll have three of the same circuit breakers running.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448551402", "createdAt": "2020-07-01T18:44:33Z", "author": {"login": "madrob"}, "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  @After\n+  public void after() {\n+    CircuitBreaker circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(circuitBreaker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbfc0b02afb925d7abd3da00a309cf8c723a1e2"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTI2NDQ4", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-441126448", "createdAt": "2020-07-01T19:04:15Z", "commit": {"oid": "3dbfc0b02afb925d7abd3da00a309cf8c723a1e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzcyODcx", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-441372871", "createdAt": "2020-07-02T06:06:03Z", "commit": {"oid": "4f11e07381173b775946f136b7cf79852dcaf5d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413b4b98172d453cfc9bdc78c2802d7879031983", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/413b4b98172d453cfc9bdc78c2802d7879031983", "committedDate": "2020-07-02T06:54:50Z", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "committedDate": "2020-07-02T06:54:50Z", "message": "Update test parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64448f0a8b068712e584d898073e3d912dcfe1ec", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/64448f0a8b068712e584d898073e3d912dcfe1ec", "committedDate": "2020-07-02T06:54:50Z", "message": "More Updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "committedDate": "2020-07-02T06:54:50Z", "message": "Renamings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2a19278643409558709d582638e20c4832d78e1", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/e2a19278643409558709d582638e20c4832d78e1", "committedDate": "2020-07-02T06:54:50Z", "message": "Updated per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fa18af58be636fce922a68c9de0ea2cbfe198b9", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/3fa18af58be636fce922a68c9de0ea2cbfe198b9", "committedDate": "2020-07-02T06:54:50Z", "message": "Add remaining formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de529ed55a44941f5448fd5c30733645add0acd7", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/de529ed55a44941f5448fd5c30733645add0acd7", "committedDate": "2020-07-02T06:54:50Z", "message": "Moar Stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64722f96b1ba5890763a467eacb6acb1ffd94328", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/64722f96b1ba5890763a467eacb6acb1ffd94328", "committedDate": "2020-07-02T06:54:50Z", "message": "More comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1045e161ae9e2d0aeb68aea517cce883dbaf231a", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/1045e161ae9e2d0aeb68aea517cce883dbaf231a", "committedDate": "2020-07-02T06:54:50Z", "message": "Brain Fart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5099095fe532ad46db8c01029ef42fb8d6113010", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/5099095fe532ad46db8c01029ef42fb8d6113010", "committedDate": "2020-07-02T06:54:50Z", "message": "Fix precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "committedDate": "2020-07-02T06:54:50Z", "message": "Updating per comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f11e07381173b775946f136b7cf79852dcaf5d0", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/4f11e07381173b775946f136b7cf79852dcaf5d0", "committedDate": "2020-07-02T06:02:52Z", "message": "Updating per comments"}, "afterCommit": {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "author": {"user": {"login": "atris", "name": "Atri Sharma"}}, "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "committedDate": "2020-07-02T06:54:50Z", "message": "Updating per comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODUxNTQ0", "url": "https://github.com/apache/lucene-solr/pull/1626#pullrequestreview-441851544", "createdAt": "2020-07-02T16:29:29Z", "commit": {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOTozMFrOGsVEnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoyOTozMFrOGsVEnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTc3Mw==", "bodyText": "FYI @ctargett  I'm not sure if this page deserves its own page or should be a part of another... and if it is its own page as Atris did then where the logical placement is.  Any way; I just want to bring this to your attention.", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r449135773", "createdAt": "2020-07-02T16:29:30Z", "author": {"login": "dsmiley"}, "path": "solr/solr-ref-guide/src/index.adoc", "diffHunk": "@@ -10,6 +10,7 @@\n     streaming-expressions, \\\n     solrcloud, \\\n     legacy-scaling-and-distribution, \\\n+    circuit-breakers, \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2442, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}