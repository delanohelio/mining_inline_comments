{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzExNzYx", "number": 1467, "title": "LUCENE-9350: Don't hold references to large automata on FuzzyQuery", "bodyText": "LUCENE-9068 moved fuzzy automata construction into FuzzyQuery itself.  However,\nthis has the nasty side-effect of blowing up query caches that expect queries to be\nfairly small.  This commit restores the previous behaviour of caching the large automata\non an AttributeSource shared between segments, while making the construction a\nbit clearer by factoring it out into a package-private FuzzyAutomatonBuilder.", "createdAt": "2020-04-29T13:24:56Z", "url": "https://github.com/apache/lucene-solr/pull/1467", "merged": true, "mergeCommit": {"oid": "c6d4aeab3f9c7df028fdd77f9fb5c8c30e839482"}, "closed": true, "closedAt": "2020-05-07T10:28:55Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccYUS1gH2gAyNDEwNzExNzYxOmY2Nzc3N2ZjZjY2YjIxYjRmMjcyYWViMGMxMzMyZTliYTFlZDBkYzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceUZr3AFqTQwNTgwNjc0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0", "committedDate": "2020-04-29T13:15:51Z", "message": "Cache automata on attributesource again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNzcyMTI4", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-402772128", "createdAt": "2020-04-29T15:17:11Z", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToxNzoxMlrOGOD68A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToxNzoxMlrOGOD68A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM5NzQ4OA==", "bodyText": "Why not implement these like they are done on 8x?  I suspect introspection tools like \"luke\" / Solr analysis page may choke if this isn't done right.", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417397488", "createdAt": "2020-04-29T15:17:12Z", "author": {"login": "dsmiley"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -364,4 +325,60 @@ public BytesRef term() throws IOException {\n     }\n   }\n \n+  /**\n+   * Used for sharing automata between segments\n+   *\n+   * Levenshtein automata are large and expensive to build; we don't want to build\n+   * them directly on the query because this can blow up caches that use queries\n+   * as keys; we also don't want to rebuild them for every segment.  This attribute\n+   * allows the FuzzyTermsEnum to build the automata once for its first segment\n+   * and then share them for subsequent segment calls.\n+   */\n+  private interface AutomatonAttribute extends Attribute {\n+    CompiledAutomaton[] getAutomata();\n+    int getTermLength();\n+    void init(Supplier<FuzzyAutomatonBuilder> builder);\n+  }\n+\n+  private static class AutomatonAttributeImpl extends AttributeImpl implements AutomatonAttribute {\n+\n+    private CompiledAutomaton[] automata;\n+    private int termLength;\n+\n+    @Override\n+    public CompiledAutomaton[] getAutomata() {\n+      return automata;\n+    }\n+\n+    @Override\n+    public int getTermLength() {\n+      return termLength;\n+    }\n+\n+    @Override\n+    public void init(Supplier<FuzzyAutomatonBuilder> supplier) {\n+      if (automata != null) {\n+        return;\n+      }\n+      FuzzyAutomatonBuilder builder = supplier.get();\n+      this.termLength = builder.getTermLength();\n+      this.automata = builder.buildAutomatonSet();\n+    }\n+\n+    @Override\n+    public void clear() {\n+      this.automata = null;\n+    }\n+\n+    @Override\n+    public void reflectWith(AttributeReflector reflector) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODI2NDE5", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-402826419", "createdAt": "2020-04-29T16:15:54Z", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxNTo1NFrOGOGiOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxNTo1NFrOGOGiOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0MDMxMg==", "bodyText": "nitpick: compare the term first, as it is most likely to return false for different fuzzy", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417440312", "createdAt": "2020-04-29T16:15:54Z", "author": {"login": "dsmiley"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -237,22 +216,9 @@ public boolean equals(Object obj) {\n     if (getClass() != obj.getClass())\n       return false;\n     FuzzyQuery other = (FuzzyQuery) obj;\n-    // Note that we don't need to compare termLength or automata because they\n-    // are entirely determined by the other fields\n-    if (maxEdits != other.maxEdits)\n-      return false;\n-    if (prefixLength != other.prefixLength)\n-      return false;\n-    if (maxExpansions != other.maxExpansions)\n-      return false;\n-    if (transpositions != other.transpositions)\n-      return false;\n-    if (term == null) {\n-      if (other.term != null)\n-        return false;\n-    } else if (!term.equals(other.term))\n-      return false;\n-    return true;\n+    return Objects.equals(maxEdits, other.maxEdits) && Objects.equals(prefixLength, other.prefixLength)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDk1MTcy", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-403095172", "createdAt": "2020-04-29T22:52:33Z", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo1MjozM1rOGOT23Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMzowMTo0OFrOGOUDkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1ODU4OQ==", "bodyText": "Is there a school of thought that we want to compare most likely to differ objects first, competing with the school that advocates comparing primitive types first because they are faster?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417658589", "createdAt": "2020-04-29T22:52:33Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -237,22 +216,9 @@ public boolean equals(Object obj) {\n     if (getClass() != obj.getClass())\n       return false;\n     FuzzyQuery other = (FuzzyQuery) obj;\n-    // Note that we don't need to compare termLength or automata because they\n-    // are entirely determined by the other fields\n-    if (maxEdits != other.maxEdits)\n-      return false;\n-    if (prefixLength != other.prefixLength)\n-      return false;\n-    if (maxExpansions != other.maxExpansions)\n-      return false;\n-    if (transpositions != other.transpositions)\n-      return false;\n-    if (term == null) {\n-      if (other.term != null)\n-        return false;\n-    } else if (!term.equals(other.term))\n-      return false;\n-    return true;\n+    return Objects.equals(maxEdits, other.maxEdits) && Objects.equals(prefixLength, other.prefixLength)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0MDMxMg=="}, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTg0MQ==", "bodyText": "I'm confused about the difference between when we would want the full automaton set and when we want the max edit automaton. When is one useful but not the other? Is this a simple optimization to skip building the relatively inexpensive (exponentially less expensive, even) fewer edit automata?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r417661841", "createdAt": "2020-04-29T23:01:48Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyAutomatonBuilder.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.util.UnicodeUtil;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+import org.apache.lucene.util.automaton.LevenshteinAutomata;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+\n+/**\n+ * Builds a set of CompiledAutomaton for fuzzy matching on a given term,\n+ * with specified maximum edit distance, fixed prefix and whether or not\n+ * to allow transpositions.\n+ */\n+class FuzzyAutomatonBuilder {\n+\n+  private final String term;\n+  private final int maxEdits;\n+  private final LevenshteinAutomata levBuilder;\n+  private final String prefix;\n+  private final int termLength;\n+\n+  FuzzyAutomatonBuilder(String term, int maxEdits, int prefixLength, boolean transpositions) {\n+    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n+      throw new IllegalArgumentException(\"max edits must be 0..\" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE + \", inclusive; got: \" + maxEdits);\n+    }\n+    if (prefixLength < 0) {\n+      throw new IllegalArgumentException(\"prefixLength cannot be less than 0\");\n+    }\n+    this.term = term;\n+    this.maxEdits = maxEdits;\n+    int[] codePoints = stringToUTF32(term);\n+    this.termLength = codePoints.length;\n+    prefixLength = Math.min(prefixLength, codePoints.length);\n+    int[] suffix = new int[codePoints.length - prefixLength];\n+    System.arraycopy(codePoints, prefixLength, suffix, 0, suffix.length);\n+    this.levBuilder = new LevenshteinAutomata(suffix, Character.MAX_CODE_POINT, transpositions);\n+    this.prefix = UnicodeUtil.newString(codePoints, 0, prefixLength);\n+  }\n+\n+  CompiledAutomaton[] buildAutomatonSet() {\n+    CompiledAutomaton[] compiled = new CompiledAutomaton[maxEdits + 1];\n+    for (int i = 0; i <= maxEdits; i++) {\n+      try {\n+        compiled[i] = new CompiledAutomaton(levBuilder.toAutomaton(i, prefix), true, false);\n+      }\n+      catch (TooComplexToDeterminizeException e) {\n+        throw new FuzzyTermsEnum.FuzzyTermsException(term, e);\n+      }\n+    }\n+    return compiled;\n+  }\n+\n+  CompiledAutomaton buildMaxEditAutomaton() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjU0NTcx", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-403654571", "createdAt": "2020-04-30T15:53:09Z", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo1MzowOVrOGOvoVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo1MzowOVrOGOvoVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzYyMQ==", "bodyText": "Does this still build the automata each time?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418113621", "createdAt": "2020-04-30T15:53:09Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -183,7 +162,7 @@ public void visit(QueryVisitor visitor) {\n       if (maxEdits == 0 || prefixLength >= term.text().length()) {\n         visitor.consumeTerms(this, term);\n       } else {\n-        automata[automata.length - 1].visit(visitor, this, field);\n+        visitor.consumeTermsMatching(this, term.field(), () -> getAutomata().runAutomaton);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjY0NTI1", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-403664525", "createdAt": "2020-04-30T16:04:27Z", "commit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjowNDoyN1rOGOwGZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjoxMzo1N1rOGOwfBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTMxNw==", "bodyText": "The java doc on this suggest that we need to be using an AttributeFactory, but that might be overkill here?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418121317", "createdAt": "2020-04-30T16:04:27Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMTQ0OA==", "bodyText": "why not getAttribute? If we're sharing this across segments, then I think we want to reuse the same one each time, right?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418121448", "createdAt": "2020-04-30T16:04:40Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java", "diffHunk": "@@ -88,43 +89,44 @@\n    * @throws IOException if there is a low-level IO error\n    */\n   public FuzzyTermsEnum(Terms terms, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, term, stringToUTF32(term.text()), maxEdits, prefixLength, transpositions);\n-  }\n-\n-  private FuzzyTermsEnum(Terms terms, Term term, int[] codePoints, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n-    this(terms, new AttributeSource(), term, codePoints.length, maxEdits,\n-        buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits));\n+    this(terms, new AttributeSource(), term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n   }\n \n   /**\n    * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n    * length <code>prefixLength</code> with <code>term</code> and which have at most {@code maxEdits} edits.\n    * <p>\n-   * After calling the constructor the enumeration is already pointing to the first \n-   * valid term if such a term exists. \n-   * \n+   * After calling the constructor the enumeration is already pointing to the first\n+   * valid term if such a term exists.\n+   *\n    * @param terms Delivers terms.\n-   * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}\n-   *              that contains information about competitive boosts during rewrite\n+   * @param atts An AttributeSource used to share automata between segments\n    * @param term Pattern term.\n    * @param maxEdits Maximum edit distance.\n-   * @param automata An array of levenshtein automata to match against terms,\n-   *                 see {@link #buildAutomata(String, int[], int, boolean, int)}\n+   * @param prefixLength the length of the required common prefix\n+   * @param transpositions whether transpositions should count as a single edit\n    * @throws IOException if there is a low-level IO error\n    */\n-  public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int termLength,\n-      final int maxEdits, CompiledAutomaton[] automata) throws IOException {\n+  FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, int maxEdits, int prefixLength, boolean transpositions) throws IOException {\n+    this(terms, atts, term, () -> new FuzzyAutomatonBuilder(term.text(), maxEdits, prefixLength, transpositions));\n+  }\n+\n+  private FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, Supplier<FuzzyAutomatonBuilder> automatonBuilder) throws IOException {\n \n-    this.maxEdits = maxEdits;\n     this.terms = terms;\n-    this.term = term;\n     this.atts = atts;\n-    this.termLength = termLength;\n+    this.term = term;\n \n     this.maxBoostAtt = atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n     this.boostAtt = atts.addAttribute(BoostAttribute.class);\n \n-    this.automata = automata;\n+    atts.addAttributeImpl(new AutomatonAttributeImpl());\n+    AutomatonAttribute aa = atts.addAttribute(AutomatonAttribute.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNzYyMA==", "bodyText": "do we need to update the java docs on multi term query to reflect that fuzzy query also uses the attribute source now as well?", "url": "https://github.com/apache/lucene-solr/pull/1467#discussion_r418127620", "createdAt": "2020-04-30T16:13:57Z", "author": {"login": "madrob"}, "path": "lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java", "diffHunk": "@@ -193,7 +172,7 @@ protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOExc\n     if (maxEdits == 0 || prefixLength >= term.text().length()) {  // can only match if it's exact\n       return new SingleTermsEnum(terms.iterator(), term.bytes());\n     }\n-    return new FuzzyTermsEnum(terms, atts, getTerm(), termLength, maxEdits, automata);\n+    return new FuzzyTermsEnum(terms, atts, getTerm(), maxEdits, prefixLength, transpositions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f67777fcf66b21b4f272aeb0c1332e9ba1ed0dc0"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87dc3ff792fe28c77887aff09851f1158c046c01", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/87dc3ff792fe28c77887aff09851f1158c046c01", "committedDate": "2020-05-05T10:44:11Z", "message": "Merge remote-tracking branch 'origin/master' into fuzzyquery/automata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93dba2da331a43c8d1bcdfb99a773ff432a6d909", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/apache/lucene-solr/commit/93dba2da331a43c8d1bcdfb99a773ff432a6d909", "committedDate": "2020-05-05T10:48:07Z", "message": "Update javadoc on MTQ.getTermsEnum()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1ODA2NzQ3", "url": "https://github.com/apache/lucene-solr/pull/1467#pullrequestreview-405806747", "createdAt": "2020-05-05T13:49:58Z", "commit": {"oid": "93dba2da331a43c8d1bcdfb99a773ff432a6d909"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2136, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}