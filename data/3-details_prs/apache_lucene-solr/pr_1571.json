{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMjY4NjY3", "number": 1571, "title": "SOLR-14560: Interleaving for Learning To Rank", "bodyText": "Description\nInterleaving is an approach to Online Search Quality evaluation that can be very useful for Learning To Rank models:\nhttps://sease.io/2020/05/online-testing-for-learning-to-rank-interleaving.html\nScope of this issue is to introduce the ability to the LTR query parser of accepting multiple models (2 to start with).\nIf one model is passed, normal reranking happens.\nIf two models are passed, reranking happens for both models and the final reranked list is the interleaved sequence of results coming from the two models lists.\nAs a first step it is going to be implemented through:\nTeamDraft Interleaving with two models in input.\nIn the future, we can expand the functionality adding the interleaving algorithm as a parameter.\nSolution\nChange of core LTR classed and addition of a new rescorer\nTests\nDone\nChecklist\nPlease review the following and check all that apply:\n\n[X ] I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n[X ] I have created a Jira issue and added the issue ID to my pull request title.\n[X ] I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ant precommit and the appropriate test suite.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-06-11T18:49:28Z", "url": "https://github.com/apache/lucene-solr/pull/1571", "merged": true, "mergeCommit": {"oid": "af0455ac8366d6dba941f2b2674ed2a8245c76f9"}, "closed": true, "closedAt": "2020-11-18T18:15:24Z", "author": {"login": "alessandrobenedetti"}, "timelineItems": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqOr-IAH2gAyNDMzMjY4NjY3OjVjZGI0YjQyMmU3OWVkOTJkNjJhNGI5ZjM5OGUwZDM2M2VjMGE3NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddxcpwgH2gAyNDMzMjY4NjY3OjU4MGViM2JmMDQyMGFkNzZlZGI4ODQ0MmQ3MjVlNDMxYThhM2MxNDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5cdb4b422e79ed92d62a4b9f398e0d363ec0a771", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/5cdb4b422e79ed92d62a4b9f398e0d363ec0a771", "committedDate": "2020-06-11T13:57:36Z", "message": "Test Green"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79c91a44b6f4f852bf237f7e9c59eb953ce82164", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/79c91a44b6f4f852bf237f7e9c59eb953ce82164", "committedDate": "2020-06-11T15:19:59Z", "message": "Interleaving skeleton"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc5478b34a634da8b7a88440d0b52d44117687f6", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/bc5478b34a634da8b7a88440d0b52d44117687f6", "committedDate": "2020-06-11T18:44:35Z", "message": "[SOLR-14560]Interleaving skeleton"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba67b9f9b3ea6cac62b3db7721b2bfb5b006d434", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/ba67b9f9b3ea6cac62b3db7721b2bfb5b006d434", "committedDate": "2020-06-11T18:45:43Z", "message": "[SOLR-14560]Interleaving skeleton"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4c24add3069b9119bb778b22ae14bcf394371c5", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/b4c24add3069b9119bb778b22ae14bcf394371c5", "committedDate": "2020-06-12T00:09:21Z", "message": "[SOLR-14560]Next step to pass the interleaving sequence to the transformer?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1863adbc30014892f475e0610934258bc7f22f0b", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/1863adbc30014892f475e0610934258bc7f22f0b", "committedDate": "2020-06-18T20:32:49Z", "message": "[SOLR-14560]Full draft complete + initial tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "095c201e24e7e0164e48c6447ac5b41e8c7705d0", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/095c201e24e7e0164e48c6447ac5b41e8c7705d0", "committedDate": "2020-07-21T22:28:57Z", "message": "[SOLR-14560] first approach in interleaving + original ranking + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e44ea907dca2fe11c679a30b1e764809a213369", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/3e44ea907dca2fe11c679a30b1e764809a213369", "committedDate": "2020-07-22T14:47:22Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/SOLR-14560"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79722402210371b8ff2422e945ba1b8f8eb29c15", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/79722402210371b8ff2422e945ba1b8f8eb29c15", "committedDate": "2020-07-22T17:09:03Z", "message": "[SOLR-14560] original ranking supported + tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NzI1NzI0", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-457725724", "createdAt": "2020-07-29T17:12:55Z", "commit": {"oid": "79722402210371b8ff2422e945ba1b8f8eb29c15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMjo1NVrOG5CIIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMjo1NVrOG5CIIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njg2NA==", "bodyText": "The model name originalRanking is being given a special meaning here. I wonder if perhaps the differences between models could be transferred to the parameter names somehow (e.g. a new original_model parameter name alongside the existing model parameter name)? Then users could choose any model name they like, including for \"original ranking\" purposes.\n#1705 proposes to factor out a LTRQParserPlugin.newLTRScoringQuery method (but I haven't yet explored fully w.r.t. how that might connect up here w.r.t. additional parameter names).\nWhat do you think?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r462456864", "createdAt": "2020-07-29T17:12:55Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/search/LTRQParserPlugin.java", "diffHunk": "@@ -146,93 +149,114 @@ public LTRQParser(String qstr, SolrParams localParams, SolrParams params,\n     @Override\n     public Query parse() throws SyntaxError {\n       // ReRanking Model\n-      final String modelName = localParams.get(LTRQParserPlugin.MODEL);\n-      if ((modelName == null) || modelName.isEmpty()) {\n+      final String[] modelNames = localParams.getParams(LTRQParserPlugin.MODEL);\n+      if ((modelNames == null) || modelNames.length==0 || modelNames[0].isEmpty()) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n             \"Must provide model in the request\");\n       }\n-\n-      final LTRScoringModel ltrScoringModel = mr.getModel(modelName);\n-      if (ltrScoringModel == null) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-            \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelName);\n-      }\n-\n-      final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n-      final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n-      final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      // Check if features are requested and if the model feature store and feature-transform feature store are the same\n-      final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures:false;\n-      if (threadManager != null) {\n-        threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n-      }\n-      final LTRScoringQuery scoringQuery = new LTRScoringQuery(ltrScoringModel,\n-          extractEFIParams(localParams),\n-          featuresRequestedFromSameStore, threadManager);\n-\n-      // Enable the feature vector caching if we are extracting features, and the features\n-      // we requested are the same ones we are reranking with\n-      if (featuresRequestedFromSameStore) {\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+     \n+      LTRScoringQuery[] rerankingQueries = new LTRScoringQuery[modelNames.length];\n+      for (int i = 0; i < modelNames.length; i++) {\n+        final LTRScoringQuery rerankingQuery;\n+        if (!ORIGINAL_RANKING.equals(modelNames[i])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79722402210371b8ff2422e945ba1b8f8eb29c15"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0c1b335e5912e7310db74a692cecfda6c8e207a", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/d0c1b335e5912e7310db74a692cecfda6c8e207a", "committedDate": "2020-09-28T20:03:56Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/SOLR-14560"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "921d7ef5ccf07b9af916410909d39fd61754908e", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/921d7ef5ccf07b9af916410909d39fd61754908e", "committedDate": "2020-09-28T20:49:50Z", "message": "[SOLR-14560] original ranking supported as separate param + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6446710cab4a3c1a5b66ac02901f8866ab9ea6bb", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/6446710cab4a3c1a5b66ac02901f8866ab9ea6bb", "committedDate": "2020-09-28T21:26:17Z", "message": "[SOLR-14560] documentation in the official LTR page"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTM0Njk4", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-497934698", "createdAt": "2020-09-28T22:10:06Z", "commit": {"oid": "921d7ef5ccf07b9af916410909d39fd61754908e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMDowN1rOHZRkbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMDowN1rOHZRkbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NDMwMw==", "bodyText": "NULL_DEREFERENCE:  object scorer last assigned on line 172 could be null and is dereferenced by call to scoreSingleHit(...) at line 189.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r496264303", "createdAt": "2020-09-28T22:10:07Z", "author": {"login": "sonatype-lift"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java", "diffHunk": "@@ -166,64 +186,77 @@ public void scoreFeatures(IndexSearcher indexSearcher, TopDocs firstPassTopDocs,\n         docBase = readerContext.docBase;\n         scorer = modelWeight.scorer(readerContext);\n       }\n-      // Scorer for a LTRScoringQuery.ModelWeight should never be null since we always have to\n-      // call score\n-      // even if no feature scorers match, since a model might use that info to\n-      // return a\n-      // non-zero score. Same applies for the case of advancing a LTRScoringQuery.ModelWeight.ModelScorer\n-      // past the target\n-      // doc since the model algorithm still needs to compute a potentially\n-      // non-zero score from blank features.\n-      assert (scorer != null);\n-      final int targetDoc = docID - docBase;\n-      scorer.docID();\n-      scorer.iterator().advance(targetDoc);\n-\n-      scorer.getDocInfo().setOriginalDocScore(hit.score);\n-      hit.score = scorer.score();\n-      if (hitUpto < topN) {\n-        reranked[hitUpto] = hit;\n-        // if the heap is not full, maybe I want to log the features for this\n-        // document\n+      scoreSingleHit(indexSearcher, topN, modelWeight, docBase, hitUpto, hit, docID, scoringQuery, scorer, reranked);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921d7ef5ccf07b9af916410909d39fd61754908e"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTM0NzIw", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-497934720", "createdAt": "2020-09-28T22:10:10Z", "commit": {"oid": "921d7ef5ccf07b9af916410909d39fd61754908e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMDoxMFrOHZRkhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMDoxMFrOHZRkhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NDMyNQ==", "bodyText": "PREDICTABLE_RANDOM:  This random generator (java.util.Random) is predictable (details)", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r496264325", "createdAt": "2020-09-28T22:10:10Z", "author": {"login": "sonatype-lift"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+public class TeamDraftInterleaving implements Interleaving{\n+  public static Random RANDOM;\n+\n+  static {\n+    // We try to make things reproducible in the context of our tests by initializing the random instance\n+    // based on the current seed\n+    String seed = System.getProperty(\"tests.seed\");\n+    if (seed == null) {\n+      RANDOM = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "921d7ef5ccf07b9af916410909d39fd61754908e"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e05cf4fd564ec71de56337401f1ece3f4a0fa16c", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/e05cf4fd564ec71de56337401f1ece3f4a0fa16c", "committedDate": "2020-10-07T11:31:02Z", "message": "[SOLR-14560] revert originalRanking parametrization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/7f35b8f8f0f330852fb7eda4589c3d2e3a58342c", "committedDate": "2020-10-07T11:46:14Z", "message": "[SOLR-14560] original ranking renamed to be in line with Apache Solr standards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTc5MzA0", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-523579304", "createdAt": "2020-11-04T17:24:44Z", "commit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyNDo0NFrOHtiRKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzo0OTowNlrOHtjK-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwOTQxNw==", "bodyText": "1/n Instead of having a static isOriginalRanking(LTRScoringQuery rerankingQuery) utility method here we could have a OriginalRankingLTRScoringQuery extends LTRScoringQuery class and replace LTRQParserPlugin.isOriginalRanking(query) calls with query instanceof OriginalRankingLTRScoringQuery expressions.\ncpoerschke@6204ead explores that.\nIn isolation the change appears to be somewhat stylistic only but it would later  (2/n and 4/n) allow for other possibilities too.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517509417", "createdAt": "2020-11-04T17:24:44Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/search/LTRQParserPlugin.java", "diffHunk": "@@ -146,93 +149,114 @@ public LTRQParser(String qstr, SolrParams localParams, SolrParams params,\n     @Override\n     public Query parse() throws SyntaxError {\n       // ReRanking Model\n-      final String modelName = localParams.get(LTRQParserPlugin.MODEL);\n-      if ((modelName == null) || modelName.isEmpty()) {\n+      final String[] modelNames = localParams.getParams(LTRQParserPlugin.MODEL);\n+      if ((modelNames == null) || modelNames.length==0 || modelNames[0].isEmpty()) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n             \"Must provide model in the request\");\n       }\n-\n-      final LTRScoringModel ltrScoringModel = mr.getModel(modelName);\n-      if (ltrScoringModel == null) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-            \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelName);\n-      }\n-\n-      final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n-      final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n-      final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      // Check if features are requested and if the model feature store and feature-transform feature store are the same\n-      final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures:false;\n-      if (threadManager != null) {\n-        threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n-      }\n-      final LTRScoringQuery scoringQuery = new LTRScoringQuery(ltrScoringModel,\n-          extractEFIParams(localParams),\n-          featuresRequestedFromSameStore, threadManager);\n-\n-      // Enable the feature vector caching if we are extracting features, and the features\n-      // we requested are the same ones we are reranking with\n-      if (featuresRequestedFromSameStore) {\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+     \n+      LTRScoringQuery[] rerankingQueries = new LTRScoringQuery[modelNames.length];\n+      for (int i = 0; i < modelNames.length; i++) {\n+        final LTRScoringQuery rerankingQuery;\n+        if (!ORIGINAL_RANKING.equals(modelNames[i])) {\n+          final LTRScoringModel ltrScoringModel = mr.getModel(modelNames[i]);\n+          if (ltrScoringModel == null) {\n+            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+                \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelNames[i]);\n+          }\n+          final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n+          final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n+          final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);        // Check if features are requested and if the model feature store and feature-transform feature store are the same\n+          final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures : false;\n+          if (threadManager != null) {\n+            threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n+          }\n+          rerankingQuery = new LTRScoringQuery(ltrScoringModel,\n+              extractEFIParams(localParams),\n+              featuresRequestedFromSameStore, threadManager);\n+\n+          // Enable the feature vector caching if we are extracting features, and the features\n+          // we requested are the same ones we are reranking with\n+          if (featuresRequestedFromSameStore) {\n+            rerankingQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+          }\n+        }else{\n+          rerankingQuery = new LTRScoringQuery(null);\n+        }\n+\n+        // External features\n+        rerankingQuery.setRequest(req);\n+        rerankingQueries[i] = rerankingQuery;\n       }\n-      SolrQueryRequestContextUtils.setScoringQuery(req, scoringQuery);\n \n+      SolrQueryRequestContextUtils.setScoringQuery(req, rerankingQueries);\n       int reRankDocs = localParams.getInt(RERANK_DOCS, DEFAULT_RERANK_DOCS);\n       if (reRankDocs <= 0) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-          \"Must rerank at least 1 document\");\n+            \"Must rerank at least 1 document\");\n+      }\n+      if (rerankingQueries.length == 1) {\n+        return new LTRQuery(rerankingQueries[0], reRankDocs);\n+      } else {\n+        return new LTRQuery(rerankingQueries, reRankDocs);\n       }\n-\n-      // External features\n-      scoringQuery.setRequest(req);\n-\n-      return new LTRQuery(scoringQuery, reRankDocs);\n     }\n   }\n+  \n+  public static boolean isOriginalRanking(LTRScoringQuery rerankingQuery){\n+    return rerankingQuery.getScoringModel() == null;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxMTIyNw==", "bodyText": "2/n cpoerschke@be20b3a explores making LTRQParserPlugin.ORIGINAL_RANKING private. A stylistic thing to some extent though it would in future also make it easier to pass in their own alternative to the special \"_OriginalRanking_\" value as a parameter.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517511227", "createdAt": "2020-11-04T17:27:36Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRInterleavingTransformerFactory.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.ltr.response.transform;\n+\n+import java.io.IOException;\n+import org.apache.solr.common.SolrDocument;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.common.util.NamedList;\n+import org.apache.solr.ltr.LTRScoringQuery;\n+import org.apache.solr.ltr.SolrQueryRequestContextUtils;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.ResultContext;\n+import org.apache.solr.response.transform.DocTransformer;\n+import org.apache.solr.response.transform.TransformerFactory;\n+import org.apache.solr.util.SolrPluginUtils;\n+\n+import static org.apache.solr.ltr.search.LTRQParserPlugin.ORIGINAL_RANKING;\n+import static org.apache.solr.ltr.search.LTRQParserPlugin.isOriginalRanking;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxMzE0OQ==", "bodyText": "3/n getScoringQuery already is renamed to getScoringQueries to reflect the changed signature, how about renaming setScoringQuery to setScoringQueries also?  cpoerschke@2579aee does that plus SCORING_QUERY to SCORING_QUERIES too.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517513149", "createdAt": "2020-11-04T17:30:49Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/SolrQueryRequestContextUtils.java", "diffHunk": "@@ -47,12 +47,12 @@ public static FeatureLogger getFeatureLogger(SolrQueryRequest req) {\n \n   /** scoring query accessors **/\n \n-  public static void setScoringQuery(SolrQueryRequest req, LTRScoringQuery scoringQuery) {\n-    req.getContext().put(SCORING_QUERY, scoringQuery);\n+  public static void setScoringQuery(SolrQueryRequest req, LTRScoringQuery[] scoringQueries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNDkwMA==", "bodyText": "4.1/n The addition of a new member here which is only sometimes applicable got me wondering about possibly having LTRInterleavingScoringQuery extends LTRScoringQuery inheritance.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517514900", "createdAt": "2020-11-04T17:33:50Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRScoringQuery.java", "diffHunk": "@@ -73,6 +74,8 @@\n   final private Map<String,String[]> efi;\n   // Original solr query used to fetch matching documents\n   private Query originalQuery;\n+  // Model was picked for this Docs\n+  private Set<Integer> pickedInterleavingDocIds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNjQ3NQ==", "bodyText": "4.2/n The differentation of behaviour here based on which constructor variant was called got me wondering about possibly having LTRInterleavingQuery extends LTRQuery inheritance.\ncpoerschke@ff2cfe7 explores factoring out of LTRInterleaving[Scoring]Query classes.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517516475", "createdAt": "2020-11-04T17:36:25Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/search/LTRQParserPlugin.java", "diffHunk": "@@ -146,93 +149,114 @@ public LTRQParser(String qstr, SolrParams localParams, SolrParams params,\n     @Override\n     public Query parse() throws SyntaxError {\n       // ReRanking Model\n-      final String modelName = localParams.get(LTRQParserPlugin.MODEL);\n-      if ((modelName == null) || modelName.isEmpty()) {\n+      final String[] modelNames = localParams.getParams(LTRQParserPlugin.MODEL);\n+      if ((modelNames == null) || modelNames.length==0 || modelNames[0].isEmpty()) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n             \"Must provide model in the request\");\n       }\n-\n-      final LTRScoringModel ltrScoringModel = mr.getModel(modelName);\n-      if (ltrScoringModel == null) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-            \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelName);\n-      }\n-\n-      final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n-      final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n-      final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      // Check if features are requested and if the model feature store and feature-transform feature store are the same\n-      final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures:false;\n-      if (threadManager != null) {\n-        threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n-      }\n-      final LTRScoringQuery scoringQuery = new LTRScoringQuery(ltrScoringModel,\n-          extractEFIParams(localParams),\n-          featuresRequestedFromSameStore, threadManager);\n-\n-      // Enable the feature vector caching if we are extracting features, and the features\n-      // we requested are the same ones we are reranking with\n-      if (featuresRequestedFromSameStore) {\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+     \n+      LTRScoringQuery[] rerankingQueries = new LTRScoringQuery[modelNames.length];\n+      for (int i = 0; i < modelNames.length; i++) {\n+        final LTRScoringQuery rerankingQuery;\n+        if (!ORIGINAL_RANKING.equals(modelNames[i])) {\n+          final LTRScoringModel ltrScoringModel = mr.getModel(modelNames[i]);\n+          if (ltrScoringModel == null) {\n+            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+                \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelNames[i]);\n+          }\n+          final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n+          final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n+          final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);        // Check if features are requested and if the model feature store and feature-transform feature store are the same\n+          final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures : false;\n+          if (threadManager != null) {\n+            threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n+          }\n+          rerankingQuery = new LTRScoringQuery(ltrScoringModel,\n+              extractEFIParams(localParams),\n+              featuresRequestedFromSameStore, threadManager);\n+\n+          // Enable the feature vector caching if we are extracting features, and the features\n+          // we requested are the same ones we are reranking with\n+          if (featuresRequestedFromSameStore) {\n+            rerankingQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+          }\n+        }else{\n+          rerankingQuery = new LTRScoringQuery(null);\n+        }\n+\n+        // External features\n+        rerankingQuery.setRequest(req);\n+        rerankingQueries[i] = rerankingQuery;\n       }\n-      SolrQueryRequestContextUtils.setScoringQuery(req, scoringQuery);\n \n+      SolrQueryRequestContextUtils.setScoringQuery(req, rerankingQueries);\n       int reRankDocs = localParams.getInt(RERANK_DOCS, DEFAULT_RERANK_DOCS);\n       if (reRankDocs <= 0) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-          \"Must rerank at least 1 document\");\n+            \"Must rerank at least 1 document\");\n+      }\n+      if (rerankingQueries.length == 1) {\n+        return new LTRQuery(rerankingQueries[0], reRankDocs);\n+      } else {\n+        return new LTRQuery(rerankingQueries, reRankDocs);\n       }\n-\n-      // External features\n-      scoringQuery.setRequest(req);\n-\n-      return new LTRQuery(scoringQuery, reRankDocs);\n     }\n   }\n+  \n+  public static boolean isOriginalRanking(LTRScoringQuery rerankingQuery){\n+    return rerankingQuery.getScoringModel() == null;\n+  }\n \n   /**\n    * A learning to rank Query, will incapsulate a learning to rank model, and delegate to it the rescoring\n    * of the documents.\n    **/\n   public class LTRQuery extends AbstractReRankQuery {\n-    private final LTRScoringQuery scoringQuery;\n+    private final LTRScoringQuery[] rerankingQueries;\n \n-    public LTRQuery(LTRScoringQuery scoringQuery, int reRankDocs) {\n-      super(defaultQuery, reRankDocs, new LTRRescorer(scoringQuery));\n-      this.scoringQuery = scoringQuery;\n+    public LTRQuery(LTRScoringQuery[] rerankingQueries, int rerankDocs) {\n+      super(defaultQuery, rerankDocs, new LTRInterleavingRescorer(rerankingQueries));\n+      this.rerankingQueries = rerankingQueries;\n+    }\n+\n+    public LTRQuery(LTRScoringQuery rerankingQuery, int rerankDocs) {\n+      super(defaultQuery, rerankDocs, new LTRRescorer(rerankingQuery));\n+      this.rerankingQueries = new LTRScoringQuery[]{rerankingQuery};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMTMzOQ==", "bodyText": "5/n When doing the 4/n stuff a question occurred to me here: rerankingQueries[0] and modelWeights[0] are the initial values. If the query is changed to rerankingQueries[1] then should the weight also be changed to modelWeights[1]? (Open question, haven't analysed it further yet nor tried it out.)", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517521339", "createdAt": "2020-11-04T17:44:17Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -271,17 +287,23 @@ public void transform(SolrDocument doc, int docid)\n \n     private void implTransform(SolrDocument doc, int docid, Float score)\n         throws IOException {\n-      Object fv = featureLogger.getFeatureVector(docid, scoringQuery, searcher);\n-      if (fv == null) { // FV for this document was not in the cache\n-        fv = featureLogger.makeFeatureVector(\n-            LTRRescorer.extractFeaturesInfo(\n-                modelWeight,\n-                docid,\n-                (docsWereNotReranked ? score : null),\n-                leafContexts));\n+      LTRScoringQuery rerankingQuery = rerankingQueries[0];\n+      LTRScoringQuery.ModelWeight rerankingModelWeight = modelWeights[0];\n+      if (rerankingQueries.length > 1 && rerankingQueries[1].getPickedInterleavingDocIds().contains(docid)) {\n+        rerankingQuery = rerankingQueries[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyNDIxNw==", "bodyText": "6/n Also as part of 4/n noticed that here this if-then-set likely need not be inside the for-loop? The loop runs only once or twice so efficiency wise no concerns but from code reading perspective it not being inside the loop would be clearer.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517524217", "createdAt": "2020-11-04T17:49:06Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/search/LTRQParserPlugin.java", "diffHunk": "@@ -146,93 +149,114 @@ public LTRQParser(String qstr, SolrParams localParams, SolrParams params,\n     @Override\n     public Query parse() throws SyntaxError {\n       // ReRanking Model\n-      final String modelName = localParams.get(LTRQParserPlugin.MODEL);\n-      if ((modelName == null) || modelName.isEmpty()) {\n+      final String[] modelNames = localParams.getParams(LTRQParserPlugin.MODEL);\n+      if ((modelNames == null) || modelNames.length==0 || modelNames[0].isEmpty()) {\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n             \"Must provide model in the request\");\n       }\n-\n-      final LTRScoringModel ltrScoringModel = mr.getModel(modelName);\n-      if (ltrScoringModel == null) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-            \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelName);\n-      }\n-\n-      final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n-      final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n-      final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      // Check if features are requested and if the model feature store and feature-transform feature store are the same\n-      final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures:false;\n-      if (threadManager != null) {\n-        threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n-      }\n-      final LTRScoringQuery scoringQuery = new LTRScoringQuery(ltrScoringModel,\n-          extractEFIParams(localParams),\n-          featuresRequestedFromSameStore, threadManager);\n-\n-      // Enable the feature vector caching if we are extracting features, and the features\n-      // we requested are the same ones we are reranking with\n-      if (featuresRequestedFromSameStore) {\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+     \n+      LTRScoringQuery[] rerankingQueries = new LTRScoringQuery[modelNames.length];\n+      for (int i = 0; i < modelNames.length; i++) {\n+        final LTRScoringQuery rerankingQuery;\n+        if (!ORIGINAL_RANKING.equals(modelNames[i])) {\n+          final LTRScoringModel ltrScoringModel = mr.getModel(modelNames[i]);\n+          if (ltrScoringModel == null) {\n+            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+                \"cannot find \" + LTRQParserPlugin.MODEL + \" \" + modelNames[i]);\n+          }\n+          final String modelFeatureStoreName = ltrScoringModel.getFeatureStoreName();\n+          final boolean extractFeatures = SolrQueryRequestContextUtils.isExtractingFeatures(req);\n+          final String fvStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);        // Check if features are requested and if the model feature store and feature-transform feature store are the same\n+          final boolean featuresRequestedFromSameStore = (modelFeatureStoreName.equals(fvStoreName) || fvStoreName == null) ? extractFeatures : false;\n+          if (threadManager != null) {\n+            threadManager.setExecutor(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MDQ4NTk1", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-524048595", "createdAt": "2020-11-05T09:00:25Z", "commit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwOTowMDoyNVrOHt5clw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwOTowNjo0OVrOHt5r1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg4OTE3NQ==", "bodyText": "7/n minor comments:\n\ntechnically not just modelNames[0] but all the model names could be isEmpty checked\nthreadManager.setExecutor (already mentioned in 6/n) need not be inside the loop, likewise extractFeatures and fvStoreName and extractEFIParams(localParams) could move out.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517889175", "createdAt": "2020-11-05T09:00:25Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/search/LTRQParserPlugin.java", "diffHunk": "@@ -146,93 +149,114 @@ public LTRQParser(String qstr, SolrParams localParams, SolrParams params,\n     @Override\n     public Query parse() throws SyntaxError {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg5MzA3OA==", "bodyText": "8/n suggestions:\n\nclass level javadocs re: the interleaving algorithm\ncomments or javadocs re: any assumptions e.g.\n\nmust rerankedA.length and rerankedB.length match?\ncan rerankedA and rerankedB contain the same docs?\ncan rerankedA contain the same doc more than once?\ncan rerankedB contain the same doc more than once?\n\n\nconsider guarding against array-index-out-of-bounds exceptions (even if they shouldn't happen if all assumptions are met)\n\nindexA = updateIndex(interleavedResults,indexA,rerankedA);\nif (indexA < rerankedA.length) {\n  interleavedResults.add(rerankedA[indexA]);\n  teamA.add(rerankedA[indexA].doc);\n  indexA++;\n}", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517893078", "createdAt": "2020-11-05T09:06:49Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+public class TeamDraftInterleaving implements Interleaving{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MTQxOTEz", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-524141913", "createdAt": "2020-11-05T10:52:38Z", "commit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMDo1MjozOFrOHt9y_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMDo1MjozOFrOHt9y_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk2MDQ0Nw==", "bodyText": "9/n observation and suggestions:\n\nvery elegant factoring out of methods for use by LTRInterleavingRescorer\nthe rerank method already takes a searcher and so it could determine its own leaves from that\nthis.scoringQuery being passed to the scoreSingleHit method as an argument (rather than it using the this.scoringQuery directly) is very subtle. it is of course present as an argument because LTRInterleavingRescorer will passing rerankingQueries[i] for that argument. the subtlety could be removed by making scoreSingleHit a static method.\n\ncpoerschke@16512db", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r517960447", "createdAt": "2020-11-05T10:52:38Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java", "diffHunk": "@@ -166,64 +186,77 @@ public void scoreFeatures(IndexSearcher indexSearcher, TopDocs firstPassTopDocs,\n         docBase = readerContext.docBase;\n         scorer = modelWeight.scorer(readerContext);\n       }\n-      // Scorer for a LTRScoringQuery.ModelWeight should never be null since we always have to\n-      // call score\n-      // even if no feature scorers match, since a model might use that info to\n-      // return a\n-      // non-zero score. Same applies for the case of advancing a LTRScoringQuery.ModelWeight.ModelScorer\n-      // past the target\n-      // doc since the model algorithm still needs to compute a potentially\n-      // non-zero score from blank features.\n-      assert (scorer != null);\n-      final int targetDoc = docID - docBase;\n-      scorer.docID();\n-      scorer.iterator().advance(targetDoc);\n-\n-      scorer.getDocInfo().setOriginalDocScore(hit.score);\n-      hit.score = scorer.score();\n-      if (hitUpto < topN) {\n-        reranked[hitUpto] = hit;\n-        // if the heap is not full, maybe I want to log the features for this\n-        // document\n+      scoreSingleHit(indexSearcher, topN, modelWeight, docBase, hitUpto, hit, docID, scoringQuery, scorer, reranked);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MjM5NjU2", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-524239656", "createdAt": "2020-11-05T13:06:01Z", "commit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzowNjowMVrOHuCYEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzowNjowMVrOHuCYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNTQ3NQ==", "bodyText": "10/n suggestions:\n\ncalculate originalRankingIndex in the constructor\nuse originalRankingIndex to minimise \"rerankingQueries[i] is not original ranking\" checks\nuse originalRankingIndex to remove the \"original ranking query is always the last query\" assumption\nthe 'rerank' method already takes a searcher and so it could determine its own leaves from that\n\ncpoerschke@002c31c", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518035475", "createdAt": "2020-11-05T13:06:01Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRInterleavingRescorer.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.ltr;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.ScoreDoc;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.TopDocs;\n+import org.apache.solr.ltr.interleaving.Interleaving;\n+import org.apache.solr.ltr.interleaving.InterleavingResult;\n+import org.apache.solr.ltr.interleaving.TeamDraftInterleaving;\n+\n+import static org.apache.solr.ltr.search.LTRQParserPlugin.isOriginalRanking;\n+\n+/**\n+ * Implements the rescoring logic. The top documents returned by solr with their\n+ * original scores, will be processed by a {@link LTRScoringQuery} that will assign a\n+ * new score to each document. The top documents will be resorted based on the\n+ * new score.\n+ * */\n+public class LTRInterleavingRescorer extends LTRRescorer {\n+  \n+  LTRScoringQuery[] rerankingQueries;\n+  Interleaving interleavingAlgorithm = new TeamDraftInterleaving();\n+  \n+  public LTRInterleavingRescorer(LTRScoringQuery[] rerankingQueries) {\n+    this.rerankingQueries = rerankingQueries;\n+  }\n+\n+  /**\n+   * rescores the documents:\n+   *\n+   * @param searcher\n+   *          current IndexSearcher\n+   * @param firstPassTopDocs\n+   *          documents to rerank;\n+   * @param topN\n+   *          documents to return;\n+   */\n+  @Override\n+  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n+      int topN) throws IOException {\n+    if ((topN == 0) || (firstPassTopDocs.scoreDocs.length == 0)) {\n+      return firstPassTopDocs;\n+    }\n+    \n+    int originalRankingIndex = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae0b0953d6980fb355f9c8030b4e2c095fb5afea", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/ae0b0953d6980fb355f9c8030b4e2c095fb5afea", "committedDate": "2020-11-05T15:30:00Z", "message": "replace static LTRQParserPlugin.isOriginalRanking method with instanceof OriginalRankingLTRScoringQuery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0fd5142e1acc227a1a25ebbce4cc8a07d4fc554", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/e0fd5142e1acc227a1a25ebbce4cc8a07d4fc554", "committedDate": "2020-11-05T15:35:48Z", "message": "make LTRQParserPlugin.ORIGINAL_RANKING private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/ab66139921ea61c15dc2884de80dff6d41a7e5aa", "committedDate": "2020-11-05T15:38:22Z", "message": "SolrQueryRequestContextUtils: setScoreQuery-->setScoringQueries rename (to match signature and getter name)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDAxNDMx", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-524401431", "createdAt": "2020-11-05T15:49:37Z", "commit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0OTozN1rOHuJwPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1NDoxNFrOHuJ-Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NjM0OA==", "bodyText": "11.1/n If we go with 4/n then LTRQParserPlugin.LTRQParser could pass a Interleaving interleavingAlgorithm argument to the LTRInterleavingQuery constructor which could pass it to the LTRInterleavingRescorer constructor. For now TeamDraftInterleaving would be the only supported algorithm but in future other algorithms could then easily be added e.g. based on an additional ltr parameter. What do you think? An easy change to make now or something better left for later?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518156348", "createdAt": "2020-11-05T15:49:37Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRInterleavingRescorer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.ltr;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.ScoreDoc;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.TopDocs;\n+import org.apache.solr.ltr.interleaving.Interleaving;\n+import org.apache.solr.ltr.interleaving.InterleavingResult;\n+import org.apache.solr.ltr.interleaving.TeamDraftInterleaving;\n+\n+/**\n+ * Implements the rescoring logic. The top documents returned by solr with their\n+ * original scores, will be processed by a {@link LTRScoringQuery} that will assign a\n+ * new score to each document. The top documents will be resorted based on the\n+ * new score.\n+ * */\n+public class LTRInterleavingRescorer extends LTRRescorer {\n+  \n+  LTRScoringQuery[] rerankingQueries;\n+  Interleaving interleavingAlgorithm = new TeamDraftInterleaving();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1OTg5MQ==", "bodyText": "11.2/n LTRQParserPlugin.LTRQParser also has access to the SolrQueryRequest and its SolrCore object. For some reason I thought that within that some 'official' source of random-ness might be available which could be passed to a TeamDraftInterleaving(Random) constructor. And I imagined that our test harnesses would use seeds to make tests reproducible w.r.t. that 'official' source of random-ness. There however doesn't appear to be such a source of non-test official random-ness? System.getProperty(\"tests.seed\"); being used/available to non-test code seems potentially tricky.\n@dweiss would you perhaps have any insights around non-test sources of randomness?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518159891", "createdAt": "2020-11-05T15:54:14Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+public class TeamDraftInterleaving implements Interleaving{\n+  public static Random RANDOM;\n+\n+  static {\n+    // We try to make things reproducible in the context of our tests by initializing the random instance\n+    // based on the current seed\n+    String seed = System.getProperty(\"tests.seed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDgzMTQ2", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-524483146", "createdAt": "2020-11-05T17:12:59Z", "commit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxMjo1OVrOHuNgGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNzoxNjowNlrOHuNoFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxNzc1NQ==", "bodyText": "12/n observations/thoughts/questions:\nMost tricky to articulate, hence left until last.\nPrior to interleaving the existing logic is that if feature vectors are requested and there is no model (or the model is for a different feature store) then a logging model is created.\nSo now then if we have two models:\n\nif both models are for the requested feature store then that's great and each document would have been picked by one of the models and so we use the feature vector already previously calculated by whatever model had picked the document.\nif neither model is for the requested feature store then we need to create a logging model, is one logging model sufficient or do we need two? intuitively to me one would seem to be sufficient but that's based on partial analysis only so far.\nif one of the two models (modelA) is for the requested feature store then for the documents picked by modelA we can use the feature vector already previously calculated by modelA. what about documents picked by modelB? it could be that modelA actually has the feature vector for that document but that modelB simply managed to pick the document first. or if modelA does not have the feature vector then we could calculate it for modelA. would a logging model help in this scenario? intuitively to me it would seem that calculating the missing feature vector via modelA or via the logging model would both be equally efficient and hence no logging model would be needed but again that's only based on partial analysis so far.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518217755", "createdAt": "2020-11-05T17:12:59Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -210,50 +216,59 @@ public void setContext(ResultContext context) {\n       }\n       \n       // Setup LTRScoringQuery\n-      scoringQuery = SolrQueryRequestContextUtils.getScoringQuery(req);\n-      docsWereNotReranked = (scoringQuery == null);\n-      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      if (docsWereNotReranked || (featureStoreName != null && (!featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {\n-        // if store is set in the transformer we should overwrite the logger\n-\n-        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n-\n-        final FeatureStore store = fr.getFeatureStore(featureStoreName);\n-        featureStoreName = store.getName(); // if featureStoreName was null before this gets actual name\n-\n-        try {\n-          final LoggingModel lm = new LoggingModel(loggingModelName,\n-              featureStoreName, store.getFeatures());\n-\n-          scoringQuery = new LTRScoringQuery(lm,\n-              LTRQParserPlugin.extractEFIParams(localparams),\n-              true,\n-              threadManager); // request feature weights to be created for all features\n-\n-        }catch (final Exception e) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"retrieving the feature store \"+featureStoreName, e);\n-        }\n-      }\n+      rerankingQueries = SolrQueryRequestContextUtils.getScoringQueries(req);\n \n-      if (scoringQuery.getOriginalQuery() == null) {\n-        scoringQuery.setOriginalQuery(context.getQuery());\n+      docsWereNotReranked = (rerankingQueries == null || rerankingQueries.length == 0);\n+      if (docsWereNotReranked) {\n+        rerankingQueries = new LTRScoringQuery[]{null};\n       }\n-      if (scoringQuery.getFeatureLogger() == null){\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n-      }\n-      scoringQuery.setRequest(req);\n-\n-      featureLogger = scoringQuery.getFeatureLogger();\n+      modelWeights = new LTRScoringQuery.ModelWeight[rerankingQueries.length];\n+      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n+      for (int i = 0; i < rerankingQueries.length; i++) {\n+        LTRScoringQuery scoringQuery = rerankingQueries[i];\n+        if ((scoringQuery == null || !(scoringQuery instanceof OriginalRankingLTRScoringQuery)) && (docsWereNotReranked || (featureStoreName != null && !featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxOTc5OA==", "bodyText": "13/n minor: interleaveOriginalRanking=true --> model=_OriginalRanking_ assuming we're going with that special value", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518219798", "createdAt": "2020-11-05T17:16:06Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -247,6 +254,81 @@ The output XML will include feature values as a comma-separated list, resembling\n   }}\n ----\n \n+=== Running a Rerank Query Interleaving Two Models\n+\n+To rerank the results of a query, interleaving two models (myModelA, myModelB) add the `rq` parameter to your search, passing two models in input, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score\n+\n+To obtain the model that interleaving picked for a search result, computed during reranking, add `[interleaving]` to the `fl` parameter, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score,[interleaving]\n+\n+The output XML will include the model picked for each search result, resembling the output shown here:\n+\n+[source,json]\n+----\n+{\n+  \"responseHeader\":{\n+    \"status\":0,\n+    \"QTime\":0,\n+    \"params\":{\n+      \"q\":\"test\",\n+      \"fl\":\"id,score,[interleaving]\",\n+      \"rq\":\"{!ltr model=myModelA model=myModelB reRankDocs=100}\"}},\n+  \"response\":{\"numFound\":2,\"start\":0,\"maxScore\":1.0005897,\"docs\":[\n+      {\n+        \"id\":\"GB18030TEST\",\n+        \"score\":1.0005897,\n+        \"[interleaving]\":\"myModelB\"},\n+      {\n+        \"id\":\"UTF8TEST\",\n+        \"score\":0.79656565,\n+        \"[interleaving]\":\"myModelA\"}]\n+  }}\n+----\n+\n+=== Running a Rerank Query Interleaving a model with the original ranking\n+When approaching Search Quality Evaluation with interleaving it may be useful to compare a model with the original ranking. \n+To rerank the results of a query, interleaving a model with the original ranking, add the `rq` parameter to your search, with a model in input and activating the original ranking interleaving, for example:\n+\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModel interleaveOriginalRanking=true reRankDocs=100}&fl=id,score", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ad2b7731031e102f2b7465831aacee98d4b5270", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/2ad2b7731031e102f2b7465831aacee98d4b5270", "committedDate": "2020-11-05T18:23:27Z", "message": "LTRRescorer suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3de9587429c9a23c29fdd0538e34ee49c90e46d8", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/3de9587429c9a23c29fdd0538e34ee49c90e46d8", "committedDate": "2020-11-05T19:09:31Z", "message": "[SOLR-14560] original ranking renamed to be in line with Apache Solr standards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bb42f07ae79bb83c436ee3d3766aa27b8426773", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/6bb42f07ae79bb83c436ee3d3766aa27b8426773", "committedDate": "2020-11-06T09:35:59Z", "message": "refactor out LTRInterleaving[Scoring]Query classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ba44e372222679cb1ef802263ab522476b8719a", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/9ba44e372222679cb1ef802263ab522476b8719a", "committedDate": "2020-11-06T10:41:50Z", "message": "[SOLR-14560] review comments + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec33eeb9043a64160cf80099a41d1a2a1aa68b1b", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/ec33eeb9043a64160cf80099a41d1a2a1aa68b1b", "committedDate": "2020-11-06T10:42:33Z", "message": "LTRInterleavingRescorer suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MDk5Mzgy", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-525099382", "createdAt": "2020-11-06T12:15:32Z", "commit": {"oid": "9ba44e372222679cb1ef802263ab522476b8719a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjoxNTozMlrOHurzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjoxNTozMlrOHurzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNDI4NQ==", "bodyText": "NULL_DEREFERENCE:  object rerankingQuery last assigned on line 106 could be null and is dereferenced at line 117.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r518714285", "createdAt": "2020-11-06T12:15:32Z", "author": {"login": "sonatype-lift"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRInterleavingTransformerFactory.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.ltr.response.transform;\n+\n+import java.io.IOException;\n+import org.apache.solr.common.SolrDocument;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.common.util.NamedList;\n+import org.apache.solr.ltr.LTRInterleavingScoringQuery;\n+import org.apache.solr.ltr.LTRScoringQuery;\n+import org.apache.solr.ltr.SolrQueryRequestContextUtils;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.ResultContext;\n+import org.apache.solr.response.transform.DocTransformer;\n+import org.apache.solr.response.transform.TransformerFactory;\n+import org.apache.solr.util.SolrPluginUtils;\n+\n+public class LTRInterleavingTransformerFactory extends TransformerFactory {\n+  \n+  @Override\n+  @SuppressWarnings({\"unchecked\"})\n+  public void init(@SuppressWarnings(\"rawtypes\") NamedList args) {\n+    super.init(args);\n+    SolrPluginUtils.invokeSetters(this, args);\n+  }\n+\n+  @Override\n+  public DocTransformer create(String name, SolrParams localparams,\n+      SolrQueryRequest req) {\n+    return new InterleavingTransformer(name, req);\n+  }\n+  \n+  class InterleavingTransformer extends DocTransformer {\n+\n+    final private String name;\n+    final private SolrQueryRequest req;\n+    \n+    private LTRScoringQuery[] rerankingQueries;\n+\n+    /**\n+     * @param name\n+     *          Name of the field to be added in a document representing the\n+     *          model picked by the interleaving process\n+     */\n+    public InterleavingTransformer(String name,\n+        SolrQueryRequest req) {\n+      this.name = name;\n+      this.req = req;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public void setContext(ResultContext context) {\n+      super.setContext(context);\n+      if (context == null) {\n+        return;\n+      }\n+      if (context.getRequest() == null) {\n+        return;\n+      }\n+      rerankingQueries = SolrQueryRequestContextUtils.getScoringQueries(req);\n+      for (int i = 0; i < rerankingQueries.length; i++) {\n+        LTRScoringQuery scoringQuery = rerankingQueries[i];\n+\n+        if (scoringQuery.getOriginalQuery() == null) {\n+          scoringQuery.setOriginalQuery(context.getQuery());\n+        }\n+        if (scoringQuery.getFeatureLogger() == null) {\n+          scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n+        }\n+        scoringQuery.setRequest(req);\n+      }\n+    }\n+\n+    @Override\n+    public void transform(SolrDocument doc, int docid, float score)\n+        throws IOException {\n+      implTransform(doc, docid);\n+    }\n+\n+    @Override\n+    public void transform(SolrDocument doc, int docid)\n+        throws IOException {\n+      implTransform(doc, docid);\n+    }\n+\n+    private void implTransform(SolrDocument doc, int docid) {\n+      LTRScoringQuery rerankingQuery = null;\n+      if (rerankingQueries.length == 1) {\n+        rerankingQuery = rerankingQueries[0];\n+      } else {\n+        for (LTRScoringQuery query : rerankingQueries) {\n+          if (((LTRInterleavingScoringQuery)query).getPickedInterleavingDocIds().contains(docid)) {\n+            rerankingQuery = query;\n+            break;\n+          }\n+        }\n+      }\n+      doc.addField(name, rerankingQuery.getScoringModelName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ba44e372222679cb1ef802263ab522476b8719a"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9010c271ac2e07692047d7e4571b4472ac1f98f5", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/9010c271ac2e07692047d7e4571b4472ac1f98f5", "committedDate": "2020-11-06T12:17:41Z", "message": "[SOLR-14560] addition of easy extendibility for Interleaving Algorithm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a8f42a6a3b3a8afda7aecc53c50d3608df8a6fe", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/0a8f42a6a3b3a8afda7aecc53c50d3608df8a6fe", "committedDate": "2020-11-06T12:59:26Z", "message": "[SOLR-14560] extraction of LTRQuery + package move + transformer semplification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/c4f87f7030218df9d7a2af0fdc3e089e68a6db07", "committedDate": "2020-11-06T14:22:28Z", "message": "[SOLR-14560] minor doc refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cc797f9206321055acb1a85d525f779de5bf36f", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/9cc797f9206321055acb1a85d525f779de5bf36f", "committedDate": "2020-11-09T12:11:21Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/SOLR-14560"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDAzOTQ0", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-526403944", "createdAt": "2020-11-09T16:00:51Z", "commit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjowMDo1MlrOHv1p9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjozNzowM1rOHv3QCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyNDIxNA==", "bodyText": "Ah, precedent and existing use already, good to know, thanks for sharing!", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519924214", "createdAt": "2020-11-09T16:00:52Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+public class TeamDraftInterleaving implements Interleaving{\n+  public static Random RANDOM;\n+\n+  static {\n+    // We try to make things reproducible in the context of our tests by initializing the random instance\n+    // based on the current seed\n+    String seed = System.getProperty(\"tests.seed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1OTg5MQ=="}, "originalCommit": {"oid": "ab66139921ea61c15dc2884de80dff6d41a7e5aa"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjMyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To rerank the results of a query, interleaving a model with the original ranking, add the `rq` parameter to your search, with a model in input and activating the original ranking interleaving, for example:\n          \n          \n            \n            To rerank the results of a query, interleaving a model with the original ranking, add the `rq` parameter to your search, passing the special inbuilt `_OriginalRanking_` model identifier as one model and your comparison model as the other model, for example:", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519932322", "createdAt": "2020-11-09T16:12:08Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -247,6 +254,81 @@ The output XML will include feature values as a comma-separated list, resembling\n   }}\n ----\n \n+=== Running a Rerank Query Interleaving Two Models\n+\n+To rerank the results of a query, interleaving two models (myModelA, myModelB) add the `rq` parameter to your search, passing two models in input, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score\n+\n+To obtain the model that interleaving picked for a search result, computed during reranking, add `[interleaving]` to the `fl` parameter, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score,[interleaving]\n+\n+The output XML will include the model picked for each search result, resembling the output shown here:\n+\n+[source,json]\n+----\n+{\n+  \"responseHeader\":{\n+    \"status\":0,\n+    \"QTime\":0,\n+    \"params\":{\n+      \"q\":\"test\",\n+      \"fl\":\"id,score,[interleaving]\",\n+      \"rq\":\"{!ltr model=myModelA model=myModelB reRankDocs=100}\"}},\n+  \"response\":{\"numFound\":2,\"start\":0,\"maxScore\":1.0005897,\"docs\":[\n+      {\n+        \"id\":\"GB18030TEST\",\n+        \"score\":1.0005897,\n+        \"[interleaving]\":\"myModelB\"},\n+      {\n+        \"id\":\"UTF8TEST\",\n+        \"score\":0.79656565,\n+        \"[interleaving]\":\"myModelA\"}]\n+  }}\n+----\n+\n+=== Running a Rerank Query Interleaving a model with the original ranking\n+When approaching Search Quality Evaluation with interleaving it may be useful to compare a model with the original ranking. \n+To rerank the results of a query, interleaving a model with the original ranking, add the `rq` parameter to your search, with a model in input and activating the original ranking interleaving, for example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNTA2NA==", "bodyText": "subjective: might model=_OriginalRanking_ model=myModel be more intuitive i.e. the 'from' baseline model on the left and the 'to' alternative model on the right? (i recall that the code had an \"original ranking last\" assumption before but if that's gone there's a possibility here to swap the order)", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519935064", "createdAt": "2020-11-09T16:15:59Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -247,6 +254,81 @@ The output XML will include feature values as a comma-separated list, resembling\n   }}\n ----\n \n+=== Running a Rerank Query Interleaving Two Models\n+\n+To rerank the results of a query, interleaving two models (myModelA, myModelB) add the `rq` parameter to your search, passing two models in input, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score\n+\n+To obtain the model that interleaving picked for a search result, computed during reranking, add `[interleaving]` to the `fl` parameter, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score,[interleaving]\n+\n+The output XML will include the model picked for each search result, resembling the output shown here:\n+\n+[source,json]\n+----\n+{\n+  \"responseHeader\":{\n+    \"status\":0,\n+    \"QTime\":0,\n+    \"params\":{\n+      \"q\":\"test\",\n+      \"fl\":\"id,score,[interleaving]\",\n+      \"rq\":\"{!ltr model=myModelA model=myModelB reRankDocs=100}\"}},\n+  \"response\":{\"numFound\":2,\"start\":0,\"maxScore\":1.0005897,\"docs\":[\n+      {\n+        \"id\":\"GB18030TEST\",\n+        \"score\":1.0005897,\n+        \"[interleaving]\":\"myModelB\"},\n+      {\n+        \"id\":\"UTF8TEST\",\n+        \"score\":0.79656565,\n+        \"[interleaving]\":\"myModelA\"}]\n+  }}\n+----\n+\n+=== Running a Rerank Query Interleaving a model with the original ranking\n+When approaching Search Quality Evaluation with interleaving it may be useful to compare a model with the original ranking. \n+To rerank the results of a query, interleaving a model with the original ranking, add the `rq` parameter to your search, with a model in input and activating the original ranking interleaving, for example:\n+\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModel model=_OriginalRanking_ reRankDocs=100}&fl=id,score", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0NDQ2Mg==", "bodyText": "question: if myModelA had [ doc1, doc2, doc3 ] document order and myModelB had [ doc1, doc3, doc2 ] document order i.e. there was agreement between the models re: the first document, will [interleaving] return (1) randomly myModelA or myModelB depending on how the picking actually happened or will it return (2) something else e.g. myModelA,myModelB (if myModelA actually picked and myModelB agreed) or myModelB,myModelA (if myModelB actually picked and myModelA agreed) or will it return (3) neither since in a way neither of them picked the document since they both agreed on it?\nanswer-ish: from recalling the implementation the answer is (1) i think though from a user's perspective perhaps it might be nice here to clarify here somehow around that? a subtle aspect being (if i understand things right) that [features] and [interleaving] could both be requested in the fl and whilst myModelA and myModelB might have agreed that doc1 should be the first document they might have used very different features to arrived at that conclusion and their score value could also differ.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519944462", "createdAt": "2020-11-09T16:28:44Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -247,6 +254,81 @@ The output XML will include feature values as a comma-separated list, resembling\n   }}\n ----\n \n+=== Running a Rerank Query Interleaving Two Models\n+\n+To rerank the results of a query, interleaving two models (myModelA, myModelB) add the `rq` parameter to your search, passing two models in input, for example:\n+\n+[source,text]\n+http://localhost:8983/solr/techproducts/query?q=test&rq={!ltr model=myModelA model=myModelB reRankDocs=100}&fl=id,score\n+\n+To obtain the model that interleaving picked for a search result, computed during reranking, add `[interleaving]` to the `fl` parameter, for example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0NTYyOQ==", "bodyText": "minor/subjective: could shorten since there's no parameters\n<transformer name=\"interleaving\" class=\"org.apache.solr.ltr.response.transform.LTRInterleavingTransformerFactory\"/>", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519945629", "createdAt": "2020-11-09T16:30:19Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -418,6 +500,14 @@ Learning-To-Rank is a contrib module and therefore its plugins must be configure\n </transformer>\n ----\n \n+* Declaration of the `[interleaving]` transformer.\n++\n+[source,xml]\n+----\n+<transformer name=\"interleaving\" class=\"org.apache.solr.ltr.response.transform.LTRInterleavingTransformerFactory\">\n+</transformer>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1MDM0NQ==", "bodyText": "We've got \"... Contributions for further models, features and normalizers are welcome. ...\" above, any thoughts on adding \"interleaving algorithms\" to that list?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519950345", "createdAt": "2020-11-09T16:37:03Z", "author": {"login": "cpoerschke"}, "path": "solr/solr-ref-guide/src/learning-to-rank.adoc", "diffHunk": "@@ -779,3 +869,7 @@ The feature store and the model store are both <<managed-resources.adoc#managed-\n * \"Learning to Rank in Solr\" presentation at Lucene/Solr Revolution 2015 in Austin:\n ** Slides: http://www.slideshare.net/lucidworks/learning-to-rank-in-solr-presented-by-michael-nilsson-diego-ceccarelli-bloomberg-lp\n ** Video: https://www.youtube.com/watch?v=M7BKwJoh96s\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDU0NDk3", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-526454497", "createdAt": "2020-11-09T16:51:10Z", "commit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo1MToxMFrOHv4BXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxNToxNVrOHv5IUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2Mjk3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Here the authors implement a method similar to the way in which captains select their players in team-matches.\n          \n          \n            \n             * Team Draft Interleaving implements a method similar to the way in which captains select their players in team-matches.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519962972", "createdAt": "2020-11-09T16:51:10Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+/**\n+ * Interleaving was introduced the first time by Joachims in [1, 2].\n+ * Team Draft Interleaving is among the most successful and used interleaving approaches[3].\n+ * Here the authors implement a method similar to the way in which captains select their players in team-matches.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NzMxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * It has also proved to overcome an issue of the previous implemented approach, Balanced interleaving, in determining the winning model[4].\n          \n          \n            \n             * \"Team draft interleaving\" has also proved to overcome an issue of the \"Balanced interleaving\" approach, in determining the winning model[4].\n          \n      \n    \n    \n  \n\nSuggest to avoid the \"previous implemented approach\" wording since it could be misinterpreted to mean that Solr previously had a BalancedInterleaving class.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519967315", "createdAt": "2020-11-09T16:55:42Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+/**\n+ * Interleaving was introduced the first time by Joachims in [1, 2].\n+ * Team Draft Interleaving is among the most successful and used interleaving approaches[3].\n+ * Here the authors implement a method similar to the way in which captains select their players in team-matches.\n+ * Team Draft Interleaving produces a fair distribution of ranking models\u2019 elements in the final interleaved list.\n+ * It has also proved to overcome an issue of the previous implemented approach, Balanced interleaving, in determining the winning model[4].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MzkxNA==", "bodyText": "Wondering re: interleaved.contains(elementToCheck) vs. interleaved.contains(elementToCheck).doc here. I note that the new ScoreDoc.equals method considers doc and shardIndex but not score which makes sense in the context here but for ScoreDoc alone is perhaps less obvious. The interleavingPicks use doc only (i.e. not doc+shardIndex). I haven't fully thought it through but intuitively if doc+shardIndex is required here then would it not also be required for the interleaving picks to avoid a strange edge case when potentially modelA picks \"doc 1 from shard 1\" and modelB picks \"doc 1 from shard 2\"?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519973914", "createdAt": "2020-11-09T17:04:59Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+/**\n+ * Interleaving was introduced the first time by Joachims in [1, 2].\n+ * Team Draft Interleaving is among the most successful and used interleaving approaches[3].\n+ * Here the authors implement a method similar to the way in which captains select their players in team-matches.\n+ * Team Draft Interleaving produces a fair distribution of ranking models\u2019 elements in the final interleaved list.\n+ * It has also proved to overcome an issue of the previous implemented approach, Balanced interleaving, in determining the winning model[4].\n+ * <p>\n+ * [1] T. Joachims. Optimizing search engines using clickthrough data. KDD (2002)\n+ * [2] T.Joachims.Evaluatingretrievalperformanceusingclickthroughdata.InJ.Franke, G. Nakhaeizadeh, and I. Renz, editors,\n+ * Text Mining, pages 79\u201396. Physica/Springer (2003)\n+ * [3] F. Radlinski, M. Kurup, and T. Joachims. How does clickthrough data reflect re-\n+ * trieval quality? In CIKM, pages 43\u201352. ACM Press (2008)\n+ * [4] O. Chapelle, T. Joachims, F. Radlinski, and Y. Yue.\n+ * Large-scale validation and analysis of interleaved search evaluation. ACM TOIS, 30(1):1\u201341, Feb. (2012)\n+ */\n+public class TeamDraftInterleaving implements Interleaving{\n+  public static Random RANDOM;\n+\n+  static {\n+    // We try to make things reproducible in the context of our tests by initializing the random instance\n+    // based on the current seed\n+    String seed = System.getProperty(\"tests.seed\");\n+    if (seed == null) {\n+      RANDOM = new Random();\n+    } else {\n+      RANDOM = new Random(seed.hashCode());\n+    }\n+  }\n+\n+  /**\n+   * Team Draft Interleaving considers two ranking models: modelA and modelB.\n+   * For a given query, each model returns its ranked list of documents La = (a1,a2,...) and Lb = (b1, b2, ...).\n+   * The algorithm creates a unique ranked list I = (i1, i2, ...).\n+   * This list is created by interleaving elements from the two lists la and lb as described by Chapelle et al.[1].\n+   * Each element Ij is labelled TeamA if it is selected from La and TeamB if it is selected from Lb.\n+   * <p>\n+   * [1] O. Chapelle, T. Joachims, F. Radlinski, and Y. Yue.\n+   * Large-scale validation and analysis of interleaved search evaluation. ACM TOIS, 30(1):1\u201341, Feb. (2012)\n+   * <p>\n+   * Assumptions:\n+   * - rerankedA and rerankedB has the same length.\n+   * They contains the same search results, ranked differently by two ranking models\n+   * - each reranked list can not contain the same search result more than once.\n+   *\n+   * @param rerankedA a ranked list of search results produced by a ranking model A\n+   * @param rerankedB a ranked list of search results produced by a ranking model B\n+   * @return the interleaved ranking list\n+   */\n+  public InterleavingResult interleave(ScoreDoc[] rerankedA, ScoreDoc[] rerankedB) {\n+    LinkedHashSet<ScoreDoc> interleavedResults = new LinkedHashSet<>();\n+    ScoreDoc[] interleavedResultArray = new ScoreDoc[rerankedA.length];\n+    ArrayList<Set<Integer>> interleavingPicks = new ArrayList<>(2);\n+    Set<Integer> teamA = new HashSet<>();\n+    Set<Integer> teamB = new HashSet<>();\n+    int topN = rerankedA.length;\n+    int indexA = 0, indexB = 0;\n+\n+    while (interleavedResults.size() < topN && indexA < rerankedA.length && indexB < rerankedB.length) {\n+      if(teamA.size()<teamB.size() || (teamA.size()==teamB.size() && !RANDOM.nextBoolean())){\n+        indexA = updateIndex(interleavedResults,indexA,rerankedA);\n+        interleavedResults.add(rerankedA[indexA]);\n+        teamA.add(rerankedA[indexA].doc);\n+        indexA++;\n+      } else{\n+        indexB = updateIndex(interleavedResults,indexB,rerankedB);\n+        interleavedResults.add(rerankedB[indexB]);\n+        teamB.add(rerankedB[indexB].doc);\n+        indexB++;\n+      }\n+    }\n+    interleavingPicks.add(teamA);\n+    interleavingPicks.add(teamB);\n+    interleavedResultArray = interleavedResults.toArray(interleavedResultArray);\n+\n+    return new InterleavingResult(interleavedResultArray,interleavingPicks);\n+  }\n+\n+  private int updateIndex(LinkedHashSet<ScoreDoc> interleaved, int index, ScoreDoc[] reranked) {\n+    boolean foundElementToAdd = false;\n+    while (index < reranked.length && !foundElementToAdd) {\n+      ScoreDoc elementToCheck = reranked[index];\n+      if (interleaved.contains(elementToCheck)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4f87f7030218df9d7a2af0fdc3e089e68a6db07"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4MTEzNg==", "bodyText": "Very nice java docs and comments, thanks!\n\n... I think we should raise the exception ...\n\nYes, you're right, an exception that will lead to a bug being identified and fixed rather than silent failure or (confusing for the user) \"array out of bounds exception\" would be better.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r519981136", "createdAt": "2020-11-09T17:15:15Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+\n+public class TeamDraftInterleaving implements Interleaving{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg5MzA3OA=="}, "originalCommit": {"oid": "7f35b8f8f0f330852fb7eda4589c3d2e3a58342c"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beb8f84f6915e1f9a3c5406bc76feb20d1864763", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/beb8f84f6915e1f9a3c5406bc76feb20d1864763", "committedDate": "2020-11-09T18:38:07Z", "message": "[SOLR-14560] loggerModel + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f87b710e4714e5e6b5229a3312659f68c2bdb1f", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/6f87b710e4714e5e6b5229a3312659f68c2bdb1f", "committedDate": "2020-11-09T19:11:37Z", "message": "Update solr/solr-ref-guide/src/learning-to-rank.adoc\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86bf4e26720879cf3a87a75cf557ecbbb8cd28d4", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/86bf4e26720879cf3a87a75cf557ecbbb8cd28d4", "committedDate": "2020-11-09T19:13:39Z", "message": "Update solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12e33a132fb40f598a60a2c9c8c58d232badc4a8", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/12e33a132fb40f598a60a2c9c8c58d232badc4a8", "committedDate": "2020-11-09T19:14:07Z", "message": "Update solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/TeamDraftInterleaving.java\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4a1a5cfbc77f4669f7a123db2f0ec812a13c837", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/c4a1a5cfbc77f4669f7a123db2f0ec812a13c837", "committedDate": "2020-11-10T11:54:14Z", "message": "[SOLR-14560] loggerModel refactr to improve readability + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c49430d4ca52c3710e3ed471d4139481de797d9", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/8c49430d4ca52c3710e3ed471d4139481de797d9", "committedDate": "2020-11-10T12:07:44Z", "message": "[SOLR-14560] minor doc change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4189b9dd115bfc9a29c2f00d4c057716135c207b", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/4189b9dd115bfc9a29c2f00d4c057716135c207b", "committedDate": "2020-11-10T12:21:50Z", "message": "[SOLR-14560] doc changes + package refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf5df48d47260eb89e694c68da8e55d4f0ed57e", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/7bf5df48d47260eb89e694c68da8e55d4f0ed57e", "committedDate": "2020-11-10T12:23:09Z", "message": "[SOLR-14560] package refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MjIyODM2", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-527222836", "createdAt": "2020-11-10T13:54:27Z", "commit": {"oid": "4189b9dd115bfc9a29c2f00d4c057716135c207b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzo1NDoyN1rOHwdmGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzo1NDoyN1rOHwdmGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU3ODU4Ng==", "bodyText": "PREDICTABLE_RANDOM:  This random generator (java.util.Random) is predictable (details)", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r520578586", "createdAt": "2020-11-10T13:54:27Z", "author": {"login": "sonatype-lift"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/interleaving/algorithms/TeamDraftInterleaving.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.ltr.interleaving.algorithms;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.ScoreDoc;\n+import org.apache.solr.ltr.interleaving.Interleaving;\n+import org.apache.solr.ltr.interleaving.InterleavingResult;\n+\n+/**\n+ * Interleaving was introduced the first time by Joachims in [1, 2].\n+ * Team Draft Interleaving is among the most successful and used interleaving approaches[3].\n+ * Team Draft Interleaving implements a method similar to the way in which captains select their players in team-matches.\n+ * Team Draft Interleaving produces a fair distribution of ranking models\u2019 elements in the final interleaved list.\n+ * \"Team draft interleaving\" has also proved to overcome an issue of the \"Balanced interleaving\" approach, in determining the winning model[4].\n+ * <p>\n+ * [1] T. Joachims. Optimizing search engines using clickthrough data. KDD (2002)\n+ * [2] T.Joachims.Evaluatingretrievalperformanceusingclickthroughdata.InJ.Franke, G. Nakhaeizadeh, and I. Renz, editors,\n+ * Text Mining, pages 79\u201396. Physica/Springer (2003)\n+ * [3] F. Radlinski, M. Kurup, and T. Joachims. How does clickthrough data reflect re-\n+ * trieval quality? In CIKM, pages 43\u201352. ACM Press (2008)\n+ * [4] O. Chapelle, T. Joachims, F. Radlinski, and Y. Yue.\n+ * Large-scale validation and analysis of interleaved search evaluation. ACM TOIS, 30(1):1\u201341, Feb. (2012)\n+ */\n+public class TeamDraftInterleaving implements Interleaving {\n+  public static Random RANDOM;\n+\n+  static {\n+    // We try to make things reproducible in the context of our tests by initializing the random instance\n+    // based on the current seed\n+    String seed = System.getProperty(\"tests.seed\");\n+    if (seed == null) {\n+      RANDOM = new Random();\n+    } else {\n+      RANDOM = new Random(seed.hashCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4189b9dd115bfc9a29c2f00d4c057716135c207b"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/7521f728079ff2980a0d78980448680f08bf911f", "committedDate": "2020-11-10T17:48:55Z", "message": "[SOLR-14560] scoreDoc equals rollback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTY1NDA4", "url": "https://github.com/apache/lucene-solr/pull/1571#pullrequestreview-529565408", "createdAt": "2020-11-12T22:50:32Z", "commit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMjo1MDozMlrOHyR0GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyMToyOVrOHySuEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4MjcxMg==", "bodyText": "LTRFeatureLoggerTransformerFactory.1 - loggingModel is a member of of the transformer factory here.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522482712", "createdAt": "2020-11-12T22:50:32Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -79,6 +81,7 @@\n   private char csvFeatureSeparator = CSVFeatureLogger.DEFAULT_FEATURE_SEPARATOR;\n \n   private LTRThreadModule threadManager = null;\n+  private LoggingModel loggingModel = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4NjgzOA==", "bodyText": "LTRFeatureLoggerTransformerFactory.2 - loggingModel being a member of the transformer factory gives it SolrCore lifetime/scope but here it's initialised based on per-request parameters. If multiple threads use the same transformer factory object concurrently then they might trampled upon each other. cpoerschke@4912dac proposes to not have the logging model as a member of the transformer factory.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522486838", "createdAt": "2020-11-12T22:56:10Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -208,55 +216,116 @@ public void setContext(ResultContext context) {\n       if (threadManager != null) {\n         threadManager.setExecutor(context.getRequest().getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n       }\n-      \n-      // Setup LTRScoringQuery\n-      scoringQuery = SolrQueryRequestContextUtils.getScoringQuery(req);\n-      docsWereNotReranked = (scoringQuery == null);\n-      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      if (docsWereNotReranked || (featureStoreName != null && (!featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {\n-        // if store is set in the transformer we should overwrite the logger\n \n-        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n+      LTRScoringQuery[] rerankingQueriesFromContext = SolrQueryRequestContextUtils.getScoringQueries(req);\n+      docsWereNotReranked = (rerankingQueriesFromContext == null || rerankingQueriesFromContext.length == 0);\n+      String transformerFeatureStore = SolrQueryRequestContextUtils.getFvStoreName(req);\n+      Map<String, String[]> transformerExternalFeatureInfo = LTRQParserPlugin.extractEFIParams(localparams);\n \n-        final FeatureStore store = fr.getFeatureStore(featureStoreName);\n-        featureStoreName = store.getName(); // if featureStoreName was null before this gets actual name\n-\n-        try {\n-          final LoggingModel lm = new LoggingModel(loggingModelName,\n-              featureStoreName, store.getFeatures());\n+      initLoggingModel(transformerFeatureStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4OTUyMw==", "bodyText": "LTRFeatureLoggerTransformerFactory.3 - I noted that threadManager here is an existing member of the transformer factory and it is initialised as part of request processing. Since there's no locking or anything there could be a chance that multiple threads concurrently call threadManager.setExecutor() but the argument to the set call is not specific to the request i.e. all requests would set the same thing (whereas for the logging model different requests could supply a different feature store name via the fl=[feature store=...] parameter).", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522489523", "createdAt": "2020-11-12T23:00:22Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -208,55 +216,116 @@ public void setContext(ResultContext context) {\n       if (threadManager != null) {\n         threadManager.setExecutor(context.getRequest().getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDY5OQ==", "bodyText": "LTRFeatureLoggerTransformerFactory.4 - Very nice overview of the different code paths here. cpoerschke@3a61287 suggests some tweaks to the implementation, I will annotate comments re: my thinking behind those suggestions. Let me know what you think?", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522490699", "createdAt": "2020-11-12T23:03:23Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -208,55 +216,116 @@ public void setContext(ResultContext context) {\n       if (threadManager != null) {\n         threadManager.setExecutor(context.getRequest().getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n       }\n-      \n-      // Setup LTRScoringQuery\n-      scoringQuery = SolrQueryRequestContextUtils.getScoringQuery(req);\n-      docsWereNotReranked = (scoringQuery == null);\n-      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      if (docsWereNotReranked || (featureStoreName != null && (!featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {\n-        // if store is set in the transformer we should overwrite the logger\n \n-        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n+      LTRScoringQuery[] rerankingQueriesFromContext = SolrQueryRequestContextUtils.getScoringQueries(req);\n+      docsWereNotReranked = (rerankingQueriesFromContext == null || rerankingQueriesFromContext.length == 0);\n+      String transformerFeatureStore = SolrQueryRequestContextUtils.getFvStoreName(req);\n+      Map<String, String[]> transformerExternalFeatureInfo = LTRQParserPlugin.extractEFIParams(localparams);\n \n-        final FeatureStore store = fr.getFeatureStore(featureStoreName);\n-        featureStoreName = store.getName(); // if featureStoreName was null before this gets actual name\n-\n-        try {\n-          final LoggingModel lm = new LoggingModel(loggingModelName,\n-              featureStoreName, store.getFeatures());\n+      initLoggingModel(transformerFeatureStore);\n+      setupRerankingQueriesForLogging(rerankingQueriesFromContext, transformerFeatureStore, transformerExternalFeatureInfo);\n+      setupRerankingWeightsForLogging(context);\n+    }\n+    \n+    private boolean isModelMatchingFeatureStore(String featureStoreName, LTRScoringModel model) {\n+      return model != null && featureStoreName.equals(model.getFeatureStoreName());\n+    }\n \n-          scoringQuery = new LTRScoringQuery(lm,\n-              LTRQParserPlugin.extractEFIParams(localparams),\n-              true,\n-              threadManager); // request feature weights to be created for all features\n+    /**\n+     * The loggingModel is an empty model that is just used to extract the features\n+     * and log them\n+     * @param transformerFeatureStore the explicit transformer feature store\n+     */\n+    private void initLoggingModel(String transformerFeatureStore) {\n+      if (transformerFeatureStore == null || !isModelMatchingFeatureStore(transformerFeatureStore, loggingModel)) {\n+        // if store is set in the transformer we should overwrite the logger\n+        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n \n-        }catch (final Exception e) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"retrieving the feature store \"+featureStoreName, e);\n-        }\n-      }\n+        final FeatureStore store = fr.getFeatureStore(transformerFeatureStore);\n+        transformerFeatureStore = store.getName(); // if featureStoreName was null before this gets actual name\n \n-      if (scoringQuery.getOriginalQuery() == null) {\n-        scoringQuery.setOriginalQuery(context.getQuery());\n+        loggingModel = new LoggingModel(loggingModelName,\n+            transformerFeatureStore, store.getFeatures());\n       }\n-      if (scoringQuery.getFeatureLogger() == null){\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n-      }\n-      scoringQuery.setRequest(req);\n-\n-      featureLogger = scoringQuery.getFeatureLogger();\n+    }\n \n-      try {\n-        modelWeight = scoringQuery.createWeight(searcher, ScoreMode.COMPLETE, 1f);\n-      } catch (final IOException e) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n+    /**\n+     * When preparing the reranking queries for logging features various scenarios apply:\n+     * \n+     * No Reranking \n+     * There is the need of a logger model from the default feature store/ the explicit feature store passed\n+     * to extract the feature vector\n+     * \n+     * Re Ranking\n+     * 1) If no explicit feature store is passed, the models for each reranking query can be safely re-used\n+     * the feature vector can be fetched from the feature vector cache.\n+     * 2) If an explicit feature store is passed, and no reranking query uses a model from that featureStore,\n+     * There is the need of a logger model to extract the feature vector\n+     * 3) If an explicit feature store is passed, and there is a reranking query that uses a model from that featureStore,\n+     * It can be re-used\n+     * \n+     * @param rerankingQueriesFromContext reranking queries\n+     * @param transformerFeatureStore explicit feature store for the transformer\n+     * @param transformerExternalFeatureInfo explicit efi for the transformer\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MjQwNA==", "bodyText": "LTRFeatureLoggerTransformerFactory.5 - the rerankingQuery here could be an OriginalRankingLTRScoringQuery object which inherently has no feature store. The implementation here works because it relies on rerankingQuery.getScoringModel() returning null for OriginalRankingLTRScoringQuery objects and because isModelMatchingFeatureStore checks model null-ness. This is very subtle and it could be made more explicit for code clarity.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522492404", "createdAt": "2020-11-12T23:07:47Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -208,55 +216,116 @@ public void setContext(ResultContext context) {\n       if (threadManager != null) {\n         threadManager.setExecutor(context.getRequest().getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n       }\n-      \n-      // Setup LTRScoringQuery\n-      scoringQuery = SolrQueryRequestContextUtils.getScoringQuery(req);\n-      docsWereNotReranked = (scoringQuery == null);\n-      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      if (docsWereNotReranked || (featureStoreName != null && (!featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {\n-        // if store is set in the transformer we should overwrite the logger\n \n-        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n+      LTRScoringQuery[] rerankingQueriesFromContext = SolrQueryRequestContextUtils.getScoringQueries(req);\n+      docsWereNotReranked = (rerankingQueriesFromContext == null || rerankingQueriesFromContext.length == 0);\n+      String transformerFeatureStore = SolrQueryRequestContextUtils.getFvStoreName(req);\n+      Map<String, String[]> transformerExternalFeatureInfo = LTRQParserPlugin.extractEFIParams(localparams);\n \n-        final FeatureStore store = fr.getFeatureStore(featureStoreName);\n-        featureStoreName = store.getName(); // if featureStoreName was null before this gets actual name\n-\n-        try {\n-          final LoggingModel lm = new LoggingModel(loggingModelName,\n-              featureStoreName, store.getFeatures());\n+      initLoggingModel(transformerFeatureStore);\n+      setupRerankingQueriesForLogging(rerankingQueriesFromContext, transformerFeatureStore, transformerExternalFeatureInfo);\n+      setupRerankingWeightsForLogging(context);\n+    }\n+    \n+    private boolean isModelMatchingFeatureStore(String featureStoreName, LTRScoringModel model) {\n+      return model != null && featureStoreName.equals(model.getFeatureStoreName());\n+    }\n \n-          scoringQuery = new LTRScoringQuery(lm,\n-              LTRQParserPlugin.extractEFIParams(localparams),\n-              true,\n-              threadManager); // request feature weights to be created for all features\n+    /**\n+     * The loggingModel is an empty model that is just used to extract the features\n+     * and log them\n+     * @param transformerFeatureStore the explicit transformer feature store\n+     */\n+    private void initLoggingModel(String transformerFeatureStore) {\n+      if (transformerFeatureStore == null || !isModelMatchingFeatureStore(transformerFeatureStore, loggingModel)) {\n+        // if store is set in the transformer we should overwrite the logger\n+        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n \n-        }catch (final Exception e) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"retrieving the feature store \"+featureStoreName, e);\n-        }\n-      }\n+        final FeatureStore store = fr.getFeatureStore(transformerFeatureStore);\n+        transformerFeatureStore = store.getName(); // if featureStoreName was null before this gets actual name\n \n-      if (scoringQuery.getOriginalQuery() == null) {\n-        scoringQuery.setOriginalQuery(context.getQuery());\n+        loggingModel = new LoggingModel(loggingModelName,\n+            transformerFeatureStore, store.getFeatures());\n       }\n-      if (scoringQuery.getFeatureLogger() == null){\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n-      }\n-      scoringQuery.setRequest(req);\n-\n-      featureLogger = scoringQuery.getFeatureLogger();\n+    }\n \n-      try {\n-        modelWeight = scoringQuery.createWeight(searcher, ScoreMode.COMPLETE, 1f);\n-      } catch (final IOException e) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n+    /**\n+     * When preparing the reranking queries for logging features various scenarios apply:\n+     * \n+     * No Reranking \n+     * There is the need of a logger model from the default feature store/ the explicit feature store passed\n+     * to extract the feature vector\n+     * \n+     * Re Ranking\n+     * 1) If no explicit feature store is passed, the models for each reranking query can be safely re-used\n+     * the feature vector can be fetched from the feature vector cache.\n+     * 2) If an explicit feature store is passed, and no reranking query uses a model from that featureStore,\n+     * There is the need of a logger model to extract the feature vector\n+     * 3) If an explicit feature store is passed, and there is a reranking query that uses a model from that featureStore,\n+     * It can be re-used\n+     * \n+     * @param rerankingQueriesFromContext reranking queries\n+     * @param transformerFeatureStore explicit feature store for the transformer\n+     * @param transformerExternalFeatureInfo explicit efi for the transformer\n+     */\n+    private void setupRerankingQueriesForLogging(LTRScoringQuery[] rerankingQueriesFromContext, String transformerFeatureStore, Map<String, String[]> transformerExternalFeatureInfo) {\n+      if (docsWereNotReranked) { //no reranking query\n+        LTRScoringQuery loggingQuery = new LTRScoringQuery(loggingModel,\n+            transformerExternalFeatureInfo,\n+            true,\n+            threadManager);\n+        rerankingQueries = new LTRScoringQuery[]{loggingQuery};\n+      } else {\n+        rerankingQueries = new LTRScoringQuery[rerankingQueriesFromContext.length];\n+        System.arraycopy(rerankingQueriesFromContext, 0, rerankingQueries, 0, rerankingQueriesFromContext.length);\n+\n+        if (transformerFeatureStore != null) {// explicit feature store for the transformer\n+          LTRScoringModel matchingRerankingModel = null;\n+          for (LTRScoringQuery rerankingQuery : rerankingQueries) {\n+            if (isModelMatchingFeatureStore(transformerFeatureStore, rerankingQuery.getScoringModel())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MzQxNw==", "bodyText": "LTRFeatureLoggerTransformerFactory.6 - the reranking queries from the context were copied and now they are being modified. The \"why copy-and-modify instead construct-a-new-one?\" question may arise for code readers.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522493417", "createdAt": "2020-11-12T23:10:25Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -208,55 +216,116 @@ public void setContext(ResultContext context) {\n       if (threadManager != null) {\n         threadManager.setExecutor(context.getRequest().getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n       }\n-      \n-      // Setup LTRScoringQuery\n-      scoringQuery = SolrQueryRequestContextUtils.getScoringQuery(req);\n-      docsWereNotReranked = (scoringQuery == null);\n-      String featureStoreName = SolrQueryRequestContextUtils.getFvStoreName(req);\n-      if (docsWereNotReranked || (featureStoreName != null && (!featureStoreName.equals(scoringQuery.getScoringModel().getFeatureStoreName())))) {\n-        // if store is set in the transformer we should overwrite the logger\n \n-        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n+      LTRScoringQuery[] rerankingQueriesFromContext = SolrQueryRequestContextUtils.getScoringQueries(req);\n+      docsWereNotReranked = (rerankingQueriesFromContext == null || rerankingQueriesFromContext.length == 0);\n+      String transformerFeatureStore = SolrQueryRequestContextUtils.getFvStoreName(req);\n+      Map<String, String[]> transformerExternalFeatureInfo = LTRQParserPlugin.extractEFIParams(localparams);\n \n-        final FeatureStore store = fr.getFeatureStore(featureStoreName);\n-        featureStoreName = store.getName(); // if featureStoreName was null before this gets actual name\n-\n-        try {\n-          final LoggingModel lm = new LoggingModel(loggingModelName,\n-              featureStoreName, store.getFeatures());\n+      initLoggingModel(transformerFeatureStore);\n+      setupRerankingQueriesForLogging(rerankingQueriesFromContext, transformerFeatureStore, transformerExternalFeatureInfo);\n+      setupRerankingWeightsForLogging(context);\n+    }\n+    \n+    private boolean isModelMatchingFeatureStore(String featureStoreName, LTRScoringModel model) {\n+      return model != null && featureStoreName.equals(model.getFeatureStoreName());\n+    }\n \n-          scoringQuery = new LTRScoringQuery(lm,\n-              LTRQParserPlugin.extractEFIParams(localparams),\n-              true,\n-              threadManager); // request feature weights to be created for all features\n+    /**\n+     * The loggingModel is an empty model that is just used to extract the features\n+     * and log them\n+     * @param transformerFeatureStore the explicit transformer feature store\n+     */\n+    private void initLoggingModel(String transformerFeatureStore) {\n+      if (transformerFeatureStore == null || !isModelMatchingFeatureStore(transformerFeatureStore, loggingModel)) {\n+        // if store is set in the transformer we should overwrite the logger\n+        final ManagedFeatureStore fr = ManagedFeatureStore.getManagedFeatureStore(req.getCore());\n \n-        }catch (final Exception e) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"retrieving the feature store \"+featureStoreName, e);\n-        }\n-      }\n+        final FeatureStore store = fr.getFeatureStore(transformerFeatureStore);\n+        transformerFeatureStore = store.getName(); // if featureStoreName was null before this gets actual name\n \n-      if (scoringQuery.getOriginalQuery() == null) {\n-        scoringQuery.setOriginalQuery(context.getQuery());\n+        loggingModel = new LoggingModel(loggingModelName,\n+            transformerFeatureStore, store.getFeatures());\n       }\n-      if (scoringQuery.getFeatureLogger() == null){\n-        scoringQuery.setFeatureLogger( SolrQueryRequestContextUtils.getFeatureLogger(req) );\n-      }\n-      scoringQuery.setRequest(req);\n-\n-      featureLogger = scoringQuery.getFeatureLogger();\n+    }\n \n-      try {\n-        modelWeight = scoringQuery.createWeight(searcher, ScoreMode.COMPLETE, 1f);\n-      } catch (final IOException e) {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.getMessage(), e);\n+    /**\n+     * When preparing the reranking queries for logging features various scenarios apply:\n+     * \n+     * No Reranking \n+     * There is the need of a logger model from the default feature store/ the explicit feature store passed\n+     * to extract the feature vector\n+     * \n+     * Re Ranking\n+     * 1) If no explicit feature store is passed, the models for each reranking query can be safely re-used\n+     * the feature vector can be fetched from the feature vector cache.\n+     * 2) If an explicit feature store is passed, and no reranking query uses a model from that featureStore,\n+     * There is the need of a logger model to extract the feature vector\n+     * 3) If an explicit feature store is passed, and there is a reranking query that uses a model from that featureStore,\n+     * It can be re-used\n+     * \n+     * @param rerankingQueriesFromContext reranking queries\n+     * @param transformerFeatureStore explicit feature store for the transformer\n+     * @param transformerExternalFeatureInfo explicit efi for the transformer\n+     */\n+    private void setupRerankingQueriesForLogging(LTRScoringQuery[] rerankingQueriesFromContext, String transformerFeatureStore, Map<String, String[]> transformerExternalFeatureInfo) {\n+      if (docsWereNotReranked) { //no reranking query\n+        LTRScoringQuery loggingQuery = new LTRScoringQuery(loggingModel,\n+            transformerExternalFeatureInfo,\n+            true,\n+            threadManager);\n+        rerankingQueries = new LTRScoringQuery[]{loggingQuery};\n+      } else {\n+        rerankingQueries = new LTRScoringQuery[rerankingQueriesFromContext.length];\n+        System.arraycopy(rerankingQueriesFromContext, 0, rerankingQueries, 0, rerankingQueriesFromContext.length);\n+\n+        if (transformerFeatureStore != null) {// explicit feature store for the transformer\n+          LTRScoringModel matchingRerankingModel = null;\n+          for (LTRScoringQuery rerankingQuery : rerankingQueries) {\n+            if (isModelMatchingFeatureStore(transformerFeatureStore, rerankingQuery.getScoringModel())) {\n+              matchingRerankingModel = rerankingQuery.getScoringModel();\n+            }\n+          }\n+          if (matchingRerankingModel != null) {//one of the LTR query model can be re-used\n+            for (LTRScoringQuery rerankingQuery : rerankingQueries) {\n+              rerankingQuery.setLtrScoringModel(matchingRerankingModel);\n+            }\n+          } else {\n+            for (LTRScoringQuery rerankingQuery : rerankingQueries) {\n+              rerankingQuery.setLtrScoringModel(loggingModel);\n+              rerankingQuery.setExtractAllFeatures(true);\n+              rerankingQuery.setEfi(transformerExternalFeatureInfo);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NTk4MA==", "bodyText": "LTRFeatureLoggerTransformerFactory.7 - here now the reranking queries that were copied from the context (and modified) are being used. It's very subtle but questions that may arise for code readers are (a) whether or not the copy happened before or after the picked interleaving doc ids were set, and/or (b) if the copy is shallow so that the query from the context and the query in the transformer share the same underlying picked ids object, and/or (c) if any shared underlying picked ids object remains shared when 'set' is called on it. cpoerschke@3a61287 proposes to introduce (alongside the rerankingQueries array) a rerankingQueriesFromContext array which is used only for the \"picked doc id\" check which would avoid the \"was it copied before or after the picked ids were set\" questions. An extra implementation subtlety is as follows: get-picked-interleaving-doc-ids applies only to interleaving queries and because of that the \"copy-and-modify\" approach was required for rerankingQueries before but if the already existing queries from the context can be used for the picked-or-not check then the rerankingQueries can follow a \"construct-a-new-one\" approach instead with the constructed queries all being of the same LTRScoringQuery base class type.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522495980", "createdAt": "2020-11-12T23:17:13Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/response/transform/LTRFeatureLoggerTransformerFactory.java", "diffHunk": "@@ -271,17 +340,24 @@ public void transform(SolrDocument doc, int docid)\n \n     private void implTransform(SolrDocument doc, int docid, Float score)\n         throws IOException {\n-      Object fv = featureLogger.getFeatureVector(docid, scoringQuery, searcher);\n-      if (fv == null) { // FV for this document was not in the cache\n-        fv = featureLogger.makeFeatureVector(\n-            LTRRescorer.extractFeaturesInfo(\n-                modelWeight,\n-                docid,\n-                (docsWereNotReranked ? score : null),\n-                leafContexts));\n+      LTRScoringQuery rerankingQuery = rerankingQueries[0];\n+      LTRScoringQuery.ModelWeight rerankingModelWeight = modelWeights[0];\n+      if (rerankingQueries.length > 1 && ((LTRInterleavingScoringQuery)rerankingQueries[1]).getPickedInterleavingDocIds().contains(docid)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzU1Mw==", "bodyText": "LTRFeatureLoggerTransformerFactory.8 - with a rerankedQueriesFromContext + rerankedQueries approach in the feature logger transformer the setters here would not be needed.", "url": "https://github.com/apache/lucene-solr/pull/1571#discussion_r522497553", "createdAt": "2020-11-12T23:21:29Z", "author": {"login": "cpoerschke"}, "path": "solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRScoringQuery.java", "diffHunk": "@@ -102,6 +102,26 @@ public LTRScoringModel getScoringModel() {\n     return ltrScoringModel;\n   }\n \n+  public void setLtrScoringModel(LTRScoringModel ltrScoringModel) {\n+    this.ltrScoringModel = ltrScoringModel;\n+  }\n+\n+  public void setLtrThreadMgr(LTRThreadModule ltrThreadMgr) {\n+    this.ltrThreadMgr = ltrThreadMgr;\n+  }\n+\n+  public void setExtractAllFeatures(boolean extractAllFeatures) {\n+    this.extractAllFeatures = extractAllFeatures;\n+  }\n+\n+  public void setEfi(Map<String, String[]> efi) {\n+    this.efi = efi;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7521f728079ff2980a0d78980448680f08bf911f"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "806cdf1ee2175560eab3c594c67bcad1ba0d6bd7", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/806cdf1ee2175560eab3c594c67bcad1ba0d6bd7", "committedDate": "2020-11-13T16:45:08Z", "message": "document 'results are all from the same shard' assumption (which is not the same as 'collection is single sharded')"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73707928315de480b1e4b6340e54e326b594695a", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/73707928315de480b1e4b6340e54e326b594695a", "committedDate": "2020-11-13T16:52:55Z", "message": "fix TestLTRQParserPlugin.ltrModelIdMissingTest failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae47c1391ecc923a2e0f7dd30e2696f74f81a687", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/ae47c1391ecc923a2e0f7dd30e2696f74f81a687", "committedDate": "2020-11-13T16:56:31Z", "message": "ensure 'one or two models' incl. TestLTRQParserPlugin.interleavingLtrTooManyModelsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18441185cb404190a9e2a83769671db939e13a1b", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/18441185cb404190a9e2a83769671db939e13a1b", "committedDate": "2020-11-13T16:57:15Z", "message": "LTRQParserPlugin: call extractEFIParams outside the loop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8a89a07bd57d93d913706285cda1a2eb8405614", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/d8a89a07bd57d93d913706285cda1a2eb8405614", "committedDate": "2020-11-13T17:03:58Z", "message": "miscellaneous"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93cae3ef5a420e887f6d81507e2e9e1b10ea53bb", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/93cae3ef5a420e887f6d81507e2e9e1b10ea53bb", "committedDate": "2020-11-13T17:06:03Z", "message": "test w.r.t. original ranking not always last"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53cf120ca432d0bb6f6a00a5b2df6cb0a5c4b64", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/b53cf120ca432d0bb6f6a00a5b2df6cb0a5c4b64", "committedDate": "2020-11-13T17:11:11Z", "message": "LTRInterleavingRescorer: remove original-ranking is last assumption"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b2d41a20886547683977242ccfbc36309c886af", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/0b2d41a20886547683977242ccfbc36309c886af", "committedDate": "2020-11-13T17:12:50Z", "message": "avoid LTRFeatureLoggerTransformerFactory.loggingModel addition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cca012ec25643117606921e990c3e31a9c444c34", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/cca012ec25643117606921e990c3e31a9c444c34", "committedDate": "2020-11-13T17:19:21Z", "message": "avoid four new LTRScoringQuery setters, clarify rerankingQueriesFromContext/rerankingQueriesInTransformer interaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80c16cf141cdc0b8923c49897e2e9496a4b6f5d5", "author": {"user": {"login": "cpoerschke", "name": "Christine Poerschke"}}, "url": "https://github.com/apache/lucene-solr/commit/80c16cf141cdc0b8923c49897e2e9496a4b6f5d5", "committedDate": "2020-11-13T17:24:48Z", "message": "reduce localparams.get(FV_STORE) calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4def6a7e3475ad190dd5673613dff84e2847b5f8", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/4def6a7e3475ad190dd5673613dff84e2847b5f8", "committedDate": "2020-11-13T18:00:13Z", "message": "[SOLR-14560] minor javadoc fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14eccb7ad04b4f2d3fc9d152f73cb26a9c8c4177", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/14eccb7ad04b4f2d3fc9d152f73cb26a9c8c4177", "committedDate": "2020-11-18T16:42:42Z", "message": "[SOLR-14560] removal unnecessary TO DO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "327cb08ad67f86d2b29e0076ae18b6eb6e011d75", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/327cb08ad67f86d2b29e0076ae18b6eb6e011d75", "committedDate": "2020-11-18T16:54:12Z", "message": "[SOLR-14560] changes new feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "580eb3bf0420ad76edb88442d725e431a8a3c141", "author": {"user": {"login": "alessandrobenedetti", "name": "Alessandro Benedetti"}}, "url": "https://github.com/apache/lucene-solr/commit/580eb3bf0420ad76edb88442d725e431a8a3c141", "committedDate": "2020-11-18T17:17:41Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/SOLR-14560"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2609, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}