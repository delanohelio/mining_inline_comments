{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODAyMzA0", "number": 1620, "title": "SOLR-14590 : Add support for Lucene's FeatureField in Solr", "bodyText": "This implements the \"Approach 2\"  suggested by Varun here: #1616 (comment)", "createdAt": "2020-06-26T21:54:05Z", "url": "https://github.com/apache/lucene-solr/pull/1620", "merged": true, "mergeCommit": {"oid": "6eb7bc3b7bd6dea2a104448e921f7234973f0197"}, "closed": true, "closedAt": "2020-06-30T18:15:36Z", "author": {"login": "tflobbe"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvKk90gFqTQzODYxODkwNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwZf6kABqjM0OTg5ODE1NjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjE4OTA0", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-438618904", "createdAt": "2020-06-26T21:59:57Z", "commit": {"oid": "e5319c73a554bdb249e1f896b7d711b7fa635217"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMTo1OTo1N1rOGpv38w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMTo1OTo1N1rOGpv38w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQyOTE3MQ==", "bodyText": "I think so? Essentially this is an exists query right?\nWe can be safe and not support this for now?\nThinking aloud on another option - What if we rewrite ( like how you have it right now ) when the value is * and throw an exception otherwise?", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446429171", "createdAt": "2020-06-26T21:59:57Z", "author": {"login": "vthacker"}, "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+public class RankField extends FieldType {\n+  \n+  public static final String INTERNAL_RANK_FIELD_NAME = \"_internal_rank_field\";\n+\n+  @Override\n+  public Type getUninversionType(SchemaField sf) {\n+    throw null;\n+  }\n+\n+  @Override\n+  public void write(TextResponseWriter writer, String name, IndexableField f) throws IOException {\n+  }\n+  \n+  @Override\n+  protected void init(IndexSchema schema, Map<String,String> args) {\n+    super.init(schema, args);\n+    if (schema.getFieldOrNull(INTERNAL_RANK_FIELD_NAME) != null) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"A field named \\\"\" + INTERNAL_RANK_FIELD_NAME + \"\\\" can't be defined in the schema\");\n+    }\n+    for (int prop:new int[] {STORED, DOC_VALUES, OMIT_TF_POSITIONS, SORT_MISSING_FIRST, SORT_MISSING_LAST}) {\n+      if ((trueProperties & prop) != 0) {\n+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Property \\\"\" + getPropertyName(prop) + \"\\\" can't be set to true in RankFields\");\n+      }\n+    }\n+    for (int prop:new int[] {UNINVERTIBLE, INDEXED, MULTIVALUED}) {\n+      if ((falseProperties & prop) != 0) {\n+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Property \\\"\" + getPropertyName(prop) + \"\\\" can't be set to false in RankFields\");\n+      }\n+    }\n+    properties &= ~(UNINVERTIBLE | STORED | DOC_VALUES);\n+    \n+  }\n+\n+  @Override\n+  protected IndexableField createField(String name, String val, IndexableFieldType type) {\n+    if (val == null || val.isEmpty()) {\n+      return null;\n+    }\n+    float featureValue;\n+    try {\n+      featureValue = Float.parseFloat(val);\n+    } catch (NumberFormatException nfe) {\n+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error while creating field '\" + name + \"' from value '\" + val + \"'. Expecting float.\", nfe);\n+    }\n+    return new FeatureField(INTERNAL_RANK_FIELD_NAME, name, featureValue);\n+  }\n+\n+  @Override\n+  public Query getFieldQuery(QParser parser, SchemaField field, String externalVal) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5319c73a554bdb249e1f896b7d711b7fa635217"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Njc0ODM5", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-438674839", "createdAt": "2020-06-27T05:41:11Z", "commit": {"oid": "54e30df0e512da5b51b143fbd0a89df2eb741c05"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNTo0MToxMVrOGpzf3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNTo0NDoxN1rOGpzgkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODU0MA==", "bodyText": "should end with a final underscore as well like our other internal fields", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446488540", "createdAt": "2020-06-27T05:41:11Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.search.RankQParserPlugin;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+/**\n+ * <p>\n+ * {@code RankField}s can be used to store scoring factors to improve document ranking. They should be used\n+ * in combination with {@link RankQParserPlugin}. To use:\n+ * </p>\n+ * <p>\n+ * Define the {@code RankField} {@code fieldType} in your schema:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;fieldType name=\"rank\" class=\"solr.RankField\" /&gt;\n+ * </pre>\n+ * <p>\n+ * Add fields to the schema, i.e.:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;field name=\"rank_1\" type=\"rank\" /&gt;\n+ * </pre>\n+ * \n+ * Query using the {@link RankQParserPlugin}, for example\n+ * <pre class=\"prettyprint\">\n+ * http://localhost:8983/solr/techproducts?q=memory _query_:{!rank f='rank_1', function='log' scalingFactor='1.2'}\n+ * </pre>\n+ * \n+ * @see RankQParserPlugin\n+ * @lucene.experimental\n+ * @since 8.6\n+ */\n+public class RankField extends FieldType {\n+  \n+  /*\n+   * While the user can create multiple RankFields, internally we use a single Lucene field,\n+   * and we map the Solr field name to the \"feature\" in Lucene's FeatureField. This is mainly\n+   * to simplify the user experience.\n+   */\n+  public static final String INTERNAL_RANK_FIELD_NAME = \"_internal_rank_field\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54e30df0e512da5b51b143fbd0a89df2eb741c05"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODcyMQ==", "bodyText": "might simply _rank_ be fine?  The \"internal\" aspect is implied by the leading/trailing underscore, and I don't think any field needs to have \"field\" in its name ;-)", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446488721", "createdAt": "2020-06-27T05:44:17Z", "author": {"login": "dsmiley"}, "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.search.RankQParserPlugin;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+/**\n+ * <p>\n+ * {@code RankField}s can be used to store scoring factors to improve document ranking. They should be used\n+ * in combination with {@link RankQParserPlugin}. To use:\n+ * </p>\n+ * <p>\n+ * Define the {@code RankField} {@code fieldType} in your schema:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;fieldType name=\"rank\" class=\"solr.RankField\" /&gt;\n+ * </pre>\n+ * <p>\n+ * Add fields to the schema, i.e.:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;field name=\"rank_1\" type=\"rank\" /&gt;\n+ * </pre>\n+ * \n+ * Query using the {@link RankQParserPlugin}, for example\n+ * <pre class=\"prettyprint\">\n+ * http://localhost:8983/solr/techproducts?q=memory _query_:{!rank f='rank_1', function='log' scalingFactor='1.2'}\n+ * </pre>\n+ * \n+ * @see RankQParserPlugin\n+ * @lucene.experimental\n+ * @since 8.6\n+ */\n+public class RankField extends FieldType {\n+  \n+  /*\n+   * While the user can create multiple RankFields, internally we use a single Lucene field,\n+   * and we map the Solr field name to the \"feature\" in Lucene's FeatureField. This is mainly\n+   * to simplify the user experience.\n+   */\n+  public static final String INTERNAL_RANK_FIELD_NAME = \"_internal_rank_field\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODU0MA=="}, "originalCommit": {"oid": "54e30df0e512da5b51b143fbd0a89df2eb741c05"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjcwNjgz", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-439670683", "createdAt": "2020-06-30T05:00:08Z", "commit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowMDowOFrOGqrwTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowMDowOFrOGqrwTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMDI1Mw==", "bodyText": "small nit: something like document_length_boost might be a better example to help a user realize how they can leverage this feature?", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447410253", "createdAt": "2020-06-30T05:00:08Z", "author": {"login": "vthacker"}, "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.search.RankQParserPlugin;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+/**\n+ * <p>\n+ * {@code RankField}s can be used to store scoring factors to improve document ranking. They should be used\n+ * in combination with {@link RankQParserPlugin}. To use:\n+ * </p>\n+ * <p>\n+ * Define the {@code RankField} {@code fieldType} in your schema:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;fieldType name=\"rank\" class=\"solr.RankField\" /&gt;\n+ * </pre>\n+ * <p>\n+ * Add fields to the schema, i.e.:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;field name=\"rank_1\" type=\"rank\" /&gt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjczMDA0", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-439673004", "createdAt": "2020-06-30T05:07:20Z", "commit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowNzoyMFrOGqr4Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowNzoyMFrOGqr4Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMjI1NA==", "bodyText": "\ud83d\udc4d All parsers in https://lucene.apache.org/solr/guide/8_5/other-parsers.html that expect a field use f as the key", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447412254", "createdAt": "2020-06-30T05:07:20Z", "author": {"login": "vthacker"}, "path": "solr/core/src/java/org/apache/solr/search/RankQParserPlugin.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.search;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.search.Query;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.schema.RankField;\n+import org.apache.solr.schema.SchemaField;\n+/**\n+ * {@code RankQParserPlugin} can be used to introduce document-depending scoring factors to ranking.\n+ * While this {@code QParser} delivers a (subset of) functionality already available via {@link FunctionQParser},\n+ * the benefit is that {@code RankQParserPlugin} can be used in combination with the {@code minExactCount} to\n+ * use BlockMax-WAND algorithm (skip non-competitive documents) to provide faster responses. \n+ * \n+ *  @see RankField\n+ * \n+ * @lucene.experimental\n+ * @since 8.6\n+ */\n+public class RankQParserPlugin extends QParserPlugin {\n+  \n+  public static final String NAME = \"rank\";\n+  public static final String FIELD = \"f\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjgwNjkz", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-439680693", "createdAt": "2020-06-30T05:30:09Z", "commit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTozMDowOVrOGqsRmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTozMDowOVrOGqsRmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxODc3Nw==", "bodyText": "I manually checked the 'score' from these two runs to ensure that the score was changing! Would it make sense to add this as a test?\nString rsp = h.query(req(\"q\", \"foo\",\n        \"defType\", \"dismax\",\n        \"qf\", \"str_field^10\",\n        \"fl\", \"*,score\"\n    ));\n\n    rsp = h.query(req(\"q\", \"foo\",\n        \"defType\", \"dismax\",\n        \"qf\", \"str_field^10\",\n        \"fl\", \"*,score\",\n        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n    ));", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447418777", "createdAt": "2020-06-30T05:30:09Z", "author": {"login": "vthacker"}, "path": "solr/core/src/test/org/apache/solr/schema/RankFieldTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+\n+public class RankFieldTest extends SolrTestCaseJ4 {\n+  \n+  private static final String RANK_1 = \"rank_1\";\n+  private static final String RANK_2 = \"rank_2\";\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    initCore(\"solrconfig-minimal.xml\",\"schema-rank-fields.xml\");\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    clearIndex();\n+    assertU(commit());\n+    super.setUp();\n+  }\n+  \n+  public void testInternalFieldName() {\n+    assertEquals(\"RankField.INTERNAL_RANK_FIELD_NAME changed in an incompatible way\",\n+        \"_rank_\", RankField.INTERNAL_RANK_FIELD_NAME);\n+  }\n+\n+  public void testBasic() {\n+    assertNotNull(h.getCore().getLatestSchema().getFieldOrNull(RANK_1));\n+    assertEquals(RankField.class, h.getCore().getLatestSchema().getField(RANK_1).getType().getClass());\n+  }\n+  \n+  public void testBadFormat() {\n+    ignoreException(\"Expecting float\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"foo\"\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"1.2.3\"\n+        ));\n+    \n+    unIgnoreException(\"Expecting float\");\n+    \n+    ignoreException(\"must be finite\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.POSITIVE_INFINITY)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NEGATIVE_INFINITY)\n+        ));\n+    \n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NaN)\n+        ));\n+    \n+    unIgnoreException(\"must be finite\");\n+    \n+    ignoreException(\"must be a positive\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-0.0f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-1f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(0.0f)\n+        ));\n+    unIgnoreException(\"must be a positive\");\n+  }\n+  \n+  public void testAddRandom() {\n+    for (int i = 0 ; i < random().nextInt(TEST_NIGHTLY ? 10000 : 100); i++) {\n+      assertU(adoc(\n+          \"id\", String.valueOf(i),\n+          RANK_1, Float.toString(random().nextFloat())\n+          ));\n+    }\n+    assertU(commit());\n+  }\n+  \n+  public void testSkipEmpty() {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"\"\n+        ));\n+  }\n+  \n+  public void testBasicAdd() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testBasicAdd\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testBasicAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the feature made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testMultipleRankFields() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testMultiValueAdd\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testMultiValueAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the features made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_2.getBytes(StandardCharsets.UTF_8))));\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testSortFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testSortFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't sort on rank field\", req(\n+        \"q\", \"id:testSortFails\",\n+        \"sort\", RANK_1 + \" desc\"), 400);\n+  }\n+  \n+  @Ignore(\"We currently don't fail these kinds of requests with other field types\")\n+  public void testFacetFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testFacetFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't facet on rank field\", req(\n+        \"q\", \"id:testFacetFails\",\n+        \"facet\", \"true\",\n+        \"facet.field\", RANK_1), 400);\n+  }\n+  \n+  public void testTermQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testTermQuery\",\n+        RANK_1, \"1\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"testTermQuery2\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", RANK_1 + \":*\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_1 + \":[* TO *]\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_2 + \":*\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"q\", RANK_2 + \":[* TO *]\"), \"//*[@numFound='1']\");\n+    \n+    assertQEx(\"Term queries not supported\", req(\"q\", RANK_1 + \":1\"), 400);\n+    assertQEx(\"Range queries not supported\", req(\"q\", RANK_1 + \":[1 TO 10]\"), 400);\n+  }\n+  \n+  \n+  public void testResponseQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testResponseQuery\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    // Ignore requests to retrieve rank\n+    assertQ(req(\"q\", RANK_1 + \":*\",\n+        \"fl\", \"id,\" + RANK_1),\n+        \"//*[@numFound='1']\",\n+        \"count(//result/doc[1]/str)=1\");\n+  }\n+  \n+  public void testRankQParserQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"2\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"2\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjgxOTU2", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-439681956", "createdAt": "2020-06-30T05:33:56Z", "commit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTozMzo1NlrOGqsWMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTozMzo1NlrOGqsWMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxOTk1Mg==", "bodyText": "If I add \"fl\", \"*,score,rank_1,rank_2\", we won't retrieve the value back. I think it's fine not to throw an error or anything right?", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447419952", "createdAt": "2020-06-30T05:33:56Z", "author": {"login": "vthacker"}, "path": "solr/core/src/test/org/apache/solr/schema/RankFieldTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+\n+public class RankFieldTest extends SolrTestCaseJ4 {\n+  \n+  private static final String RANK_1 = \"rank_1\";\n+  private static final String RANK_2 = \"rank_2\";\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    initCore(\"solrconfig-minimal.xml\",\"schema-rank-fields.xml\");\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    clearIndex();\n+    assertU(commit());\n+    super.setUp();\n+  }\n+  \n+  public void testInternalFieldName() {\n+    assertEquals(\"RankField.INTERNAL_RANK_FIELD_NAME changed in an incompatible way\",\n+        \"_rank_\", RankField.INTERNAL_RANK_FIELD_NAME);\n+  }\n+\n+  public void testBasic() {\n+    assertNotNull(h.getCore().getLatestSchema().getFieldOrNull(RANK_1));\n+    assertEquals(RankField.class, h.getCore().getLatestSchema().getField(RANK_1).getType().getClass());\n+  }\n+  \n+  public void testBadFormat() {\n+    ignoreException(\"Expecting float\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"foo\"\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"1.2.3\"\n+        ));\n+    \n+    unIgnoreException(\"Expecting float\");\n+    \n+    ignoreException(\"must be finite\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.POSITIVE_INFINITY)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NEGATIVE_INFINITY)\n+        ));\n+    \n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NaN)\n+        ));\n+    \n+    unIgnoreException(\"must be finite\");\n+    \n+    ignoreException(\"must be a positive\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-0.0f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-1f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(0.0f)\n+        ));\n+    unIgnoreException(\"must be a positive\");\n+  }\n+  \n+  public void testAddRandom() {\n+    for (int i = 0 ; i < random().nextInt(TEST_NIGHTLY ? 10000 : 100); i++) {\n+      assertU(adoc(\n+          \"id\", String.valueOf(i),\n+          RANK_1, Float.toString(random().nextFloat())\n+          ));\n+    }\n+    assertU(commit());\n+  }\n+  \n+  public void testSkipEmpty() {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"\"\n+        ));\n+  }\n+  \n+  public void testBasicAdd() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testBasicAdd\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testBasicAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the feature made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testMultipleRankFields() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testMultiValueAdd\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testMultiValueAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the features made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_2.getBytes(StandardCharsets.UTF_8))));\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testSortFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testSortFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't sort on rank field\", req(\n+        \"q\", \"id:testSortFails\",\n+        \"sort\", RANK_1 + \" desc\"), 400);\n+  }\n+  \n+  @Ignore(\"We currently don't fail these kinds of requests with other field types\")\n+  public void testFacetFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testFacetFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't facet on rank field\", req(\n+        \"q\", \"id:testFacetFails\",\n+        \"facet\", \"true\",\n+        \"facet.field\", RANK_1), 400);\n+  }\n+  \n+  public void testTermQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testTermQuery\",\n+        RANK_1, \"1\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"testTermQuery2\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", RANK_1 + \":*\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_1 + \":[* TO *]\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_2 + \":*\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"q\", RANK_2 + \":[* TO *]\"), \"//*[@numFound='1']\");\n+    \n+    assertQEx(\"Term queries not supported\", req(\"q\", RANK_1 + \":1\"), 400);\n+    assertQEx(\"Range queries not supported\", req(\"q\", RANK_1 + \":[1 TO 10]\"), 400);\n+  }\n+  \n+  \n+  public void testResponseQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testResponseQuery\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    // Ignore requests to retrieve rank\n+    assertQ(req(\"q\", RANK_1 + \":*\",\n+        \"fl\", \"id,\" + RANK_1),\n+        \"//*[@numFound='1']\",\n+        \"count(//result/doc[1]/str)=1\");\n+  }\n+  \n+  public void testRankQParserQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"2\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"2\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjgyNTMx", "url": "https://github.com/apache/lucene-solr/pull/1620#pullrequestreview-439682531", "createdAt": "2020-06-30T05:35:30Z", "commit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c8410b027881dc69a35efc1792cd56ce6aab822", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/4c8410b027881dc69a35efc1792cd56ce6aab822", "committedDate": "2020-06-29T17:27:24Z", "message": "Rename internal field name"}, "afterCommit": {"oid": "517b43e7ef8242557cab09b235252f2121eb97aa", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/517b43e7ef8242557cab09b235252f2121eb97aa", "committedDate": "2020-06-30T17:22:29Z", "message": "Add CHANGES entry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "517b43e7ef8242557cab09b235252f2121eb97aa", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/517b43e7ef8242557cab09b235252f2121eb97aa", "committedDate": "2020-06-30T17:22:29Z", "message": "Add CHANGES entry"}, "afterCommit": {"oid": "b95f1a274a81f96d018158e9339a02a2205ebbd1", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/b95f1a274a81f96d018158e9339a02a2205ebbd1", "committedDate": "2020-06-30T17:37:31Z", "message": "Add CHANGES entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ca1481f186dd2cff2bb3985373453fa2d8d2a9e", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/8ca1481f186dd2cff2bb3985373453fa2d8d2a9e", "committedDate": "2020-06-30T17:56:42Z", "message": "Add RankQParserPlugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38a31e02bb7dd7b51d7355f3ba1fd96c6af3886b", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/38a31e02bb7dd7b51d7355f3ba1fd96c6af3886b", "committedDate": "2020-06-30T17:56:42Z", "message": "Move the Function enum to the QPArser Plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5697759e47f3b001d943fd3055a5b62b29830a9", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/f5697759e47f3b001d943fd3055a5b62b29830a9", "committedDate": "2020-06-30T17:56:42Z", "message": "Add RankField"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cab07cdd682430b03554e1168e07af014d388e9", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/8cab07cdd682430b03554e1168e07af014d388e9", "committedDate": "2020-06-30T17:56:42Z", "message": "Cleaned up tabs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64f9e6c03fd35dee3205d13228a64ddd066fa21d", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/64f9e6c03fd35dee3205d13228a64ddd066fa21d", "committedDate": "2020-06-30T17:56:42Z", "message": "Validate Rank Query is on Rank Field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "340c6c41811f60754ad4aa1096396e83e5552ecd", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/340c6c41811f60754ad4aa1096396e83e5552ecd", "committedDate": "2020-06-30T17:56:43Z", "message": "Use a single Lucene field internally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3bf0869d7d38663205b0240b1e3943c0d95f964", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/e3bf0869d7d38663205b0240b1e3943c0d95f964", "committedDate": "2020-06-30T17:56:43Z", "message": "Some more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4863b6a2569fe45665ae69811f478223216a56e", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/b4863b6a2569fe45665ae69811f478223216a56e", "committedDate": "2020-06-30T17:56:43Z", "message": "Add support for existence query"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8699fb420f22559299f093e6846f76da9c6cdb0", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/f8699fb420f22559299f093e6846f76da9c6cdb0", "committedDate": "2020-06-30T17:56:43Z", "message": "Add retrieve field test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb472ffdc25beabef4ffa8c293248e451442bf0e", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/cb472ffdc25beabef4ffa8c293248e451442bf0e", "committedDate": "2020-06-30T17:56:43Z", "message": "Add class javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1138f91e439a3cf27df90c14331e4d825ab11df5", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/1138f91e439a3cf27df90c14331e4d825ab11df5", "committedDate": "2020-06-30T17:56:43Z", "message": "Add rank field type to default schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01fa910f05185d50102bc5d4c0166e178f7bf2a5", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/01fa910f05185d50102bc5d4c0166e178f7bf2a5", "committedDate": "2020-06-30T17:56:43Z", "message": "Fix failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06571c63d041a6942a1c2de4198c1a900592e5f5", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/06571c63d041a6942a1c2de4198c1a900592e5f5", "committedDate": "2020-06-30T17:56:43Z", "message": "Rename internal field name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96aa9fcf024397dccd9609818775964a5e5acca9", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/96aa9fcf024397dccd9609818775964a5e5acca9", "committedDate": "2020-06-30T17:56:43Z", "message": "Addressed PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2898e16ae2d35fb1a13c1550fff673fef5340c3e", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/2898e16ae2d35fb1a13c1550fff673fef5340c3e", "committedDate": "2020-06-30T17:56:43Z", "message": "Add CHANGES entry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b95f1a274a81f96d018158e9339a02a2205ebbd1", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/b95f1a274a81f96d018158e9339a02a2205ebbd1", "committedDate": "2020-06-30T17:37:31Z", "message": "Add CHANGES entry"}, "afterCommit": {"oid": "2898e16ae2d35fb1a13c1550fff673fef5340c3e", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/2898e16ae2d35fb1a13c1550fff673fef5340c3e", "committedDate": "2020-06-30T17:56:43Z", "message": "Add CHANGES entry"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2430, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}