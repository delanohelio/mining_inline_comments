{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5Nzc5NzU2", "number": 1528, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyODo1NFrOD99feg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoxMjo1MVrOD_TOzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk3MjEwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyODo1NFrOGXxadw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzoyNTo0MVrOGX2Bsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDAyMw==", "bodyText": "Can we be more rigorous on the test here?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427580023", "createdAt": "2020-05-19T20:28:54Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +493,40 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (data.length < 5) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1NTYwMg==", "bodyText": "updated.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427655602", "createdAt": "2020-05-19T23:25:41Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +493,40 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (data.length < 5) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDAyMw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk3NTEwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDoyOTo1MFrOGXxcbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo0OToyNlrOGaphvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDUyNw==", "bodyText": "What are the conditions where this happens? log-and-throw is usually an anti-pattern.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427580527", "createdAt": "2020-05-19T20:29:50Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +493,40 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (data.length < 5) {\n+        // less than 5 chars is empty (it's likely just \"{}\"). This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);\n+      } else {\n+        // /clusterstate.json not empty: refuse to start but do not automatically delete. A bit of a pain but user shouldn't\n+        // have older collections at this stage anyway.\n+        String message = ZkStateReader.UNSUPPORTED_CLUSTER_STATE + \" no longer supported starting with Solr 9. \"\n+            + \"It is present and not empty. Cannot start Solr. Please first migrate collections to stateFormat=2 using an \"\n+            + \"older version of Solr or if you don't care about the data then delete the file from \"\n+            + \"Zookeeper using a command line tool, for example: bin/solr zk rm /clusterstate.json -z host:port\";\n+        log.error(message);\n+        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, message);\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNzI3Ng==", "bodyText": "Converting checked to unchecked exception. copied from init() further down that deals with the same problem on access to ZK.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427627276", "createdAt": "2020-05-19T22:04:48Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +493,40 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (data.length < 5) {\n+        // less than 5 chars is empty (it's likely just \"{}\"). This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);\n+      } else {\n+        // /clusterstate.json not empty: refuse to start but do not automatically delete. A bit of a pain but user shouldn't\n+        // have older collections at this stage anyway.\n+        String message = ZkStateReader.UNSUPPORTED_CLUSTER_STATE + \" no longer supported starting with Solr 9. \"\n+            + \"It is present and not empty. Cannot start Solr. Please first migrate collections to stateFormat=2 using an \"\n+            + \"older version of Solr or if you don't care about the data then delete the file from \"\n+            + \"Zookeeper using a command line tool, for example: bin/solr zk rm /clusterstate.json -z host:port\";\n+        log.error(message);\n+        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, message);\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDUyNw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NjU0MA==", "bodyText": "Makes sense. If we throw anything here it will still propagate up to SolrDispatchFilter where it will be logged, so we don't need to double up on that here. We should probably clean that up in the other places where it happens, but that's out of scope for this PR.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r430596540", "createdAt": "2020-05-26T17:49:26Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +493,40 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (data.length < 5) {\n+        // less than 5 chars is empty (it's likely just \"{}\"). This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);\n+      } else {\n+        // /clusterstate.json not empty: refuse to start but do not automatically delete. A bit of a pain but user shouldn't\n+        // have older collections at this stage anyway.\n+        String message = ZkStateReader.UNSUPPORTED_CLUSTER_STATE + \" no longer supported starting with Solr 9. \"\n+            + \"It is present and not empty. Cannot start Solr. Please first migrate collections to stateFormat=2 using an \"\n+            + \"older version of Solr or if you don't care about the data then delete the file from \"\n+            + \"Zookeeper using a command line tool, for example: bin/solr zk rm /clusterstate.json -z host:port\";\n+        log.error(message);\n+        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, message);\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDUyNw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk4MDYwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozMTozOFrOGXxgFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjoyODoxNlrOGX02zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTQ2Mw==", "bodyText": "s/clusterstate/state?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427581463", "createdAt": "2020-05-19T20:31:38Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "diffHunk": "@@ -236,21 +235,19 @@ public void call(ClusterState clusterState, ZkNodeProps message, NamedList resul\n         }\n \n         String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n-        //in the new mode, create the replica in clusterstate prior to creating the core.\n+        //create the replica in clusterstate (i.e. ZK) prior to creating the core.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNTc2Ng==", "bodyText": "\"clusterstate\" is used all over (including in the docs) to refer in general to the state of the cluster or collection stored in ZK.\nWill replace with state.json here.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427625766", "createdAt": "2020-05-19T22:01:07Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "diffHunk": "@@ -236,21 +235,19 @@ public void call(ClusterState clusterState, ZkNodeProps message, NamedList resul\n         }\n \n         String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n-        //in the new mode, create the replica in clusterstate prior to creating the core.\n+        //create the replica in clusterstate (i.e. ZK) prior to creating the core.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTQ2Mw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNzI0MA==", "bodyText": "I think we still can use 'clusterstate' as a generic term? When I read it in a sentence like this I do not read it as the file clusterstate.json, but as the cluster state. Perhaps we could consistenly write it as \"cluster state\" instead?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427627240", "createdAt": "2020-05-19T22:04:41Z", "author": {"login": "janhoy"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "diffHunk": "@@ -236,21 +235,19 @@ public void call(ClusterState clusterState, ZkNodeProps message, NamedList resul\n         }\n \n         String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n-        //in the new mode, create the replica in clusterstate prior to creating the core.\n+        //create the replica in clusterstate (i.e. ZK) prior to creating the core.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTQ2Mw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzNjQzMA==", "bodyText": "Agreed, we should rename in many places. Although here state.json is appropriate since that's what happens.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427636430", "createdAt": "2020-05-19T22:28:16Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "diffHunk": "@@ -236,21 +235,19 @@ public void call(ClusterState clusterState, ZkNodeProps message, NamedList resul\n         }\n \n         String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n-        //in the new mode, create the replica in clusterstate prior to creating the core.\n+        //create the replica in clusterstate (i.e. ZK) prior to creating the core.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTQ2Mw=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mjk4MTcyOnYy", "diffSide": "LEFT", "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDozMjowM1rOGXxg0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzoyNjo0M1rOGX2DIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTY0OA==", "bodyText": "Yay!", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427581648", "createdAt": "2020-05-19T20:32:03Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "diffHunk": "@@ -468,36 +467,6 @@ void checkResults(String label, NamedList<Object> results, boolean failureIsFata\n     }\n   }\n \n-\n-  //TODO should we not remove in the next release ?\n-  private void migrateStateFormat(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1NTk3MA==", "bodyText": "Had to remove 1,660 lines and add 568 to get rid of that comment :)", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r427655970", "createdAt": "2020-05-19T23:26:43Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "diffHunk": "@@ -468,36 +467,6 @@ void checkResults(String label, NamedList<Object> results, boolean failureIsFata\n     }\n   }\n \n-\n-  //TODO should we not remove in the next release ?\n-  private void migrateStateFormat(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MTY0OA=="}, "originalCommit": {"oid": "14f7db461bc9d8663717cedd7ae08408a4a0b696"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njg1NTM3OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzoxODowM1rOGZ3D3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNjozMjoyMlrOGaF2jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc2OTY5Mw==", "bodyText": "I was thinking of the rolling upgrade scenario - if someone upgrades from 8.x to 9.0 one node at a time. Then the first node upgraded will delete /clusterstate.json. Will that cause any kind of failures or exceptions in the remaining nodes, if they have a watch on the znode or something?\nA way to mitigate it could be to let only the Overseer do the delete, and tell people to upgrade overseer last?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429769693", "createdAt": "2020-05-25T07:18:03Z", "author": {"login": "janhoy"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +494,41 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (Arrays.equals(\"{}\".getBytes(StandardCharsets.UTF_8), data)) {\n+        // Empty json. This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMTcwMA==", "bodyText": "I don't think that's an issue: if /clusterstate.json is non empty, no node running 9.0 will start.\nIf /clusterstate.json exists and is empty, the first starting node on 9.0 will delete it as it starts.\n8.x nodes that might start afterwards (who knows) will I believe recreate the file (that will be deleted again when a 9.0 node starts).", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429811700", "createdAt": "2020-05-25T08:45:15Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +494,41 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (Arrays.equals(\"{}\".getBytes(StandardCharsets.UTF_8), data)) {\n+        // Empty json. This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc2OTY5Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyOTM1Nw==", "bodyText": "Running 8.x nodes might get a callback since they have a watch. Have not checked the callback handling code, but if the code don't handle DELETE operation then either nothing happens or an exception is thrown...", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429829357", "createdAt": "2020-05-25T09:19:44Z", "author": {"login": "janhoy"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +494,41 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (Arrays.equals(\"{}\".getBytes(StandardCharsets.UTF_8), data)) {\n+        // Empty json. This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc2OTY5Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAxMjA0Ng==", "bodyText": "Looking at pre PR master branch.\nThe watcher on /clusterstate.json is an instance of LegacyClusterStateWatcher (subclass of ZkStateReader).\nThe watcher processing is done in refreshAndWatch() that calls ZkStateReader.refreshLegacyClusterState() and does some exception handling.\nEven though refreshAndWatch() handles KeeperException.NoNodeException by throwing a SolrException SERVICE_UNAVAILABLE, this never happens: refreshLegacyClusterState() catches that exception, a comment says \"Ignore missing legacy clusterstate.json.\" and the catch builds what would be an empty clusterstate.\nWe should be fine.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r430012046", "createdAt": "2020-05-25T16:32:22Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -491,6 +494,41 @@ public boolean isClosed() {\n     assert ObjectReleaseTracker.track(this);\n   }\n \n+  /**\n+   * <p>Verifies if /clusterstate.json exists in Zookeepeer, and if it does and is not empty, refuses to start and outputs\n+   * a helpful message regarding collection migration.</p>\n+   *\n+   * <p>If /clusterstate.json exists and is empty, it is removed.</p>\n+   */\n+  private void checkNoOldClusterstate(final SolrZkClient zkClient) throws InterruptedException {\n+    try {\n+      if (!zkClient.exists(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, true)) {\n+        return;\n+      }\n+\n+      final byte[] data = zkClient.getData(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, null, null, true);\n+\n+      if (Arrays.equals(\"{}\".getBytes(StandardCharsets.UTF_8), data)) {\n+        // Empty json. This log will only occur once.\n+        log.warn(\"{} no longer supported starting with Solr 9. Found empty file on Zookeeper, deleting it.\", ZkStateReader.UNSUPPORTED_CLUSTER_STATE);\n+        zkClient.delete(ZkStateReader.UNSUPPORTED_CLUSTER_STATE, -1, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc2OTY5Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njg4Njk1OnYy", "diffSide": "LEFT", "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzoyOToxOFrOGZ3Xeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo0NTo1OVrOGZ5pYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NDcxNA==", "bodyText": "What happens if someone backs up a 8.5 collection with stateFormat=1 and then tries to restore in 9.0? Not very likely since that collection was probably created pre-7.0 and it would not load in 9.0 anyway. But should we simply throw an exception here if STATE_FORMAT is 1?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429774714", "createdAt": "2020-05-25T07:29:18Z", "author": {"login": "janhoy"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java", "diffHunk": "@@ -160,9 +159,6 @@ public void call(ClusterState state, ZkNodeProps message, NamedList results) thr\n       Map<String, Object> propMap = new HashMap<>();\n       propMap.put(Overseer.QUEUE_OPERATION, CREATE.toString());\n       propMap.put(\"fromApi\", \"true\"); // mostly true.  Prevents autoCreated=true in the collection state.\n-      if (properties.get(STATE_FORMAT) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMjA2Nw==", "bodyText": "Good point. Will update.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429812067", "createdAt": "2020-05-25T08:45:59Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java", "diffHunk": "@@ -160,9 +159,6 @@ public void call(ClusterState state, ZkNodeProps message, NamedList results) thr\n       Map<String, Object> propMap = new HashMap<>();\n       propMap.put(Overseer.QUEUE_OPERATION, CREATE.toString());\n       propMap.put(\"fromApi\", \"true\"); // mostly true.  Prevents autoCreated=true in the collection state.\n-      if (properties.get(STATE_FORMAT) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NDcxNA=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njg4OTY2OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzozMDoxOFrOGZ3ZOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo0ODo1MVrOGZ5vKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NTE2Mw==", "bodyText": "???", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429775163", "createdAt": "2020-05-25T07:30:18Z", "author": {"login": "janhoy"}, "path": "solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.java", "diffHunk": "@@ -790,6 +790,33 @@ public void simRemoveReplica(String nodeId, String collection, String coreNodeNa\n   }\n \n   /**\n+<<<<<<< HEAD\n+=======\n+   * Save clusterstate.json to {@link DistribStateManager}.\n+   * @return saved state\n+   */\n+  private ClusterState saveClusterState(ClusterState state) throws IOException {\n+    ensureNotClosed();\n+\n+    // TODO: this method is emptied of its content in order to compile. We're not saving the cluster state that has to be saved collection per collection in separate state.json files.\n+    // TODO: DO NOT CHECK THIS IN. Check with AB how to update sim to stateFormat 2\n+\n+//    byte[] data = Utils.toJSON(state);\n+//    try {\n+//      VersionedData oldData = stateManager.getData(ZkStateReader.CLUSTER_STATE);\n+//      int version = oldData != null ? oldData.getVersion() : 0;\n+//      assert clusterStateVersion == version : \"local clusterStateVersion out of sync\";\n+//      stateManager.setData(ZkStateReader.CLUSTER_STATE, data, version);\n+//      log.debug(\"** saved cluster state version {}\", version);\n+//      clusterStateVersion++;\n+//    } catch (Exception e) {\n+//      throw new IOException(e);\n+//    }\n+    return state;\n+  }\n+\n+  /**\n+>>>>>>> SOLR-12823: remove /clusterstate.json", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxMzU0Ng==", "bodyText": "Ouch.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429813546", "createdAt": "2020-05-25T08:48:51Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.java", "diffHunk": "@@ -790,6 +790,33 @@ public void simRemoveReplica(String nodeId, String collection, String coreNodeNa\n   }\n \n   /**\n+<<<<<<< HEAD\n+=======\n+   * Save clusterstate.json to {@link DistribStateManager}.\n+   * @return saved state\n+   */\n+  private ClusterState saveClusterState(ClusterState state) throws IOException {\n+    ensureNotClosed();\n+\n+    // TODO: this method is emptied of its content in order to compile. We're not saving the cluster state that has to be saved collection per collection in separate state.json files.\n+    // TODO: DO NOT CHECK THIS IN. Check with AB how to update sim to stateFormat 2\n+\n+//    byte[] data = Utils.toJSON(state);\n+//    try {\n+//      VersionedData oldData = stateManager.getData(ZkStateReader.CLUSTER_STATE);\n+//      int version = oldData != null ? oldData.getVersion() : 0;\n+//      assert clusterStateVersion == version : \"local clusterStateVersion out of sync\";\n+//      stateManager.setData(ZkStateReader.CLUSTER_STATE, data, version);\n+//      log.debug(\"** saved cluster state version {}\", version);\n+//      clusterStateVersion++;\n+//    } catch (Exception e) {\n+//      throw new IOException(e);\n+//    }\n+    return state;\n+  }\n+\n+  /**\n+>>>>>>> SOLR-12823: remove /clusterstate.json", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NTE2Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njk0MjMzOnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo0Nzo1M1rOGZ35eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo0Nzo1M1rOGZ35eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4MzQxNg==", "bodyText": "We should have plenty of coverage elsewhere, so +1 to remove this test?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429783416", "createdAt": "2020-05-25T07:47:53Z", "author": {"login": "janhoy"}, "path": "solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java", "diffHunk": "@@ -43,8 +44,12 @@\n   public static void beforeClass() {\n \n   }\n-  \n+\n   @Test\n+  @Ignore\n+  // This test doesn't work (anymore) following https://issues.apache.org/jira/browse/SOLR-12823", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njk2NzM1OnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/OverseerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwNzo1NTo0OVrOGZ4I9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOToyMjowMVrOGZ6xWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4NzM4Mg==", "bodyText": "Did you consider alernatives to creating a new method with same signature and 95% same code? If duplication is necessary perhaps give the new method a more descriptive name?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429787382", "createdAt": "2020-05-25T07:55:49Z", "author": {"login": "janhoy"}, "path": "solr/core/src/test/org/apache/solr/cloud/OverseerTest.java", "diffHunk": "@@ -181,16 +180,21 @@ public void close() {\n       zkStateReader.close();\n     }\n \n+    /**\n+     * Create a collection.\n+     * Note there's a similar but slightly different {@link OverseerTest#createCollection(String, int)}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNTczOQ==", "bodyText": "I hesitated. There are a few variations in how collections are created. I don't know if these variations are in purpose or end up doing the same thing and are there for historical reasons, and I tried to keep tests as identical to the way they were before as possible. IIRC the method was created where previously the code was just duplicated around, so there's some progress :), but I didn't want to change the logic of any test beyond what was strictly necessary.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429815739", "createdAt": "2020-05-25T08:53:03Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/OverseerTest.java", "diffHunk": "@@ -181,16 +180,21 @@ public void close() {\n       zkStateReader.close();\n     }\n \n+    /**\n+     * Create a collection.\n+     * Note there's a similar but slightly different {@link OverseerTest#createCollection(String, int)}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4NzM4Mg=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzMDQ5MQ==", "bodyText": "Ok. If/when the big Overseer / Curator rewrite happens, then I guess it will be cleaned up then...", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429830491", "createdAt": "2020-05-25T09:22:01Z", "author": {"login": "janhoy"}, "path": "solr/core/src/test/org/apache/solr/cloud/OverseerTest.java", "diffHunk": "@@ -181,16 +180,21 @@ public void close() {\n       zkStateReader.close();\n     }\n \n+    /**\n+     * Create a collection.\n+     * Note there's a similar but slightly different {@link OverseerTest#createCollection(String, int)}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4NzM4Mg=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Njk5MDEwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/test/org/apache/solr/cloud/TestZkChroot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODowMzoxM1rOGZ4W-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1NTowMVrOGZ57dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MDk3MQ==", "bodyText": "Perhaps MiniSolrCloud should have a .withChroot option which can be asserted somewhere? What about deleting this test and create a separate followup JIRA \"Add zk chroot test\" which can be fixed as a followup?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429790971", "createdAt": "2020-05-25T08:03:13Z", "author": {"login": "janhoy"}, "path": "solr/core/src/test/org/apache/solr/cloud/TestZkChroot.java", "diffHunk": "@@ -27,8 +27,10 @@\n import org.apache.solr.core.CoreContainer;\n import org.junit.After;\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n+// TODO: this class tries to test Zookeeper using Solr abstractions, but ZK implies the code is running in cloud mode. It doesn't work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNjY5NA==", "bodyText": "I agree (on the followup option).\nI tried to see if there's a way to do the chroot on the mini cluster or elsewhere but nothing obvious came after an hour or two of hacking, that's why I suggest to leave it for later.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429816694", "createdAt": "2020-05-25T08:55:01Z", "author": {"login": "murblanc"}, "path": "solr/core/src/test/org/apache/solr/cloud/TestZkChroot.java", "diffHunk": "@@ -27,8 +27,10 @@\n import org.apache.solr.core.CoreContainer;\n import org.junit.After;\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n+// TODO: this class tries to test Zookeeper using Solr abstractions, but ZK implies the code is running in cloud mode. It doesn't work.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MDk3MQ=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzAwOTkyOnYy", "diffSide": "LEFT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpClusterStateProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODowOTozMlrOGZ4i1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1NTo0OFrOGZ59Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NDAwNw==", "bodyText": "Remember to close SOLR-11877 after this", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429794007", "createdAt": "2020-05-25T08:09:32Z", "author": {"login": "janhoy"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpClusterStateProvider.java", "diffHunk": "@@ -138,8 +138,7 @@ private ClusterState fetchClusterState(SolrClient client, String collection, Map\n     Set<String> liveNodes = new HashSet((List<String>)(cluster.get(\"live_nodes\")));\n     this.liveNodes = liveNodes;\n     liveNodesTimestamp = System.nanoTime();\n-    //TODO SOLR-11877 we don't know the znode path; CLUSTER_STATE is probably wrong leading to bad stateFormat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNzEzMA==", "bodyText": "Yes, it's mentioned in the PR description.", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429817130", "createdAt": "2020-05-25T08:55:48Z", "author": {"login": "murblanc"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpClusterStateProvider.java", "diffHunk": "@@ -138,8 +138,7 @@ private ClusterState fetchClusterState(SolrClient client, String collection, Map\n     Set<String> liveNodes = new HashSet((List<String>)(cluster.get(\"live_nodes\")));\n     this.liveNodes = liveNodes;\n     liveNodesTimestamp = System.nanoTime();\n-    //TODO SOLR-11877 we don't know the znode path; CLUSTER_STATE is probably wrong leading to bad stateFormat", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NDAwNw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzAxOTY1OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoxMjo1MVrOGZ4o6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNjozNToyOVrOGaF6Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NTU2Mw==", "bodyText": "Would createFromMap be a more descriptive name?", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429795563", "createdAt": "2020-05-25T08:12:51Z", "author": {"login": "janhoy"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "diffHunk": "@@ -210,47 +200,42 @@ public boolean liveNodesContain(String name) {\n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n-    sb.append(\"znodeVersion: \").append(znodeVersion);\n-    sb.append(\"\\n\");\n     sb.append(\"live nodes:\").append(liveNodes);\n     sb.append(\"\\n\");\n     sb.append(\"collections:\").append(collectionStates);\n     return sb.toString();\n   }\n \n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes) {\n-    return load(version, bytes, liveNodes, ZkStateReader.CLUSTER_STATE);\n-  }\n   /**\n-   * Create ClusterState from json string that is typically stored in zookeeper.\n+   * Create a ClusterState from Json.\n    * \n-   * @param version zk version of the clusterstate.json file (bytes)\n-   * @param bytes clusterstate.json as a byte array\n+   * @param bytes a byte array of a Json representation of a mapping from collection name to the Json representation of a\n+   *              {@link DocCollection} as written by {@link #write(JSONWriter)}. It can represent\n+   *              one or more collections.\n    * @param liveNodes list of live nodes\n    * @return the ClusterState\n    */\n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes, String znode) {\n-    // System.out.println(\"######## ClusterState.load:\" + (bytes==null ? null : new String(bytes)));\n+  public static ClusterState createFromJson(int version, byte[] bytes, Set<String> liveNodes) {\n     if (bytes == null || bytes.length == 0) {\n-      return new ClusterState(version, liveNodes, Collections.<String, DocCollection>emptyMap());\n+      return new ClusterState(liveNodes, Collections.<String, DocCollection>emptyMap());\n     }\n     Map<String, Object> stateMap = (Map<String, Object>) Utils.fromJSON(bytes);\n-    return load(version, stateMap, liveNodes, znode);\n+    return createFromData(version, stateMap, liveNodes);\n   }\n \n-  public static ClusterState load(Integer version, Map<String, Object> stateMap, Set<String> liveNodes, String znode) {\n+  public static ClusterState createFromData(int version, Map<String, Object> stateMap, Set<String> liveNodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNzcyNQ==", "bodyText": "As you wish, let me know and I'll change it as I rework the other comments.\ncreateFromIntMapAndSet :)", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429817725", "createdAt": "2020-05-25T08:56:57Z", "author": {"login": "murblanc"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "diffHunk": "@@ -210,47 +200,42 @@ public boolean liveNodesContain(String name) {\n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n-    sb.append(\"znodeVersion: \").append(znodeVersion);\n-    sb.append(\"\\n\");\n     sb.append(\"live nodes:\").append(liveNodes);\n     sb.append(\"\\n\");\n     sb.append(\"collections:\").append(collectionStates);\n     return sb.toString();\n   }\n \n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes) {\n-    return load(version, bytes, liveNodes, ZkStateReader.CLUSTER_STATE);\n-  }\n   /**\n-   * Create ClusterState from json string that is typically stored in zookeeper.\n+   * Create a ClusterState from Json.\n    * \n-   * @param version zk version of the clusterstate.json file (bytes)\n-   * @param bytes clusterstate.json as a byte array\n+   * @param bytes a byte array of a Json representation of a mapping from collection name to the Json representation of a\n+   *              {@link DocCollection} as written by {@link #write(JSONWriter)}. It can represent\n+   *              one or more collections.\n    * @param liveNodes list of live nodes\n    * @return the ClusterState\n    */\n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes, String znode) {\n-    // System.out.println(\"######## ClusterState.load:\" + (bytes==null ? null : new String(bytes)));\n+  public static ClusterState createFromJson(int version, byte[] bytes, Set<String> liveNodes) {\n     if (bytes == null || bytes.length == 0) {\n-      return new ClusterState(version, liveNodes, Collections.<String, DocCollection>emptyMap());\n+      return new ClusterState(liveNodes, Collections.<String, DocCollection>emptyMap());\n     }\n     Map<String, Object> stateMap = (Map<String, Object>) Utils.fromJSON(bytes);\n-    return load(version, stateMap, liveNodes, znode);\n+    return createFromData(version, stateMap, liveNodes);\n   }\n \n-  public static ClusterState load(Integer version, Map<String, Object> stateMap, Set<String> liveNodes, String znode) {\n+  public static ClusterState createFromData(int version, Map<String, Object> stateMap, Set<String> liveNodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NTU2Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzMTE3MQ==", "bodyText": "I don't have strong feeelings, just that 'data' could be anything :)", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r429831171", "createdAt": "2020-05-25T09:23:22Z", "author": {"login": "janhoy"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "diffHunk": "@@ -210,47 +200,42 @@ public boolean liveNodesContain(String name) {\n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n-    sb.append(\"znodeVersion: \").append(znodeVersion);\n-    sb.append(\"\\n\");\n     sb.append(\"live nodes:\").append(liveNodes);\n     sb.append(\"\\n\");\n     sb.append(\"collections:\").append(collectionStates);\n     return sb.toString();\n   }\n \n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes) {\n-    return load(version, bytes, liveNodes, ZkStateReader.CLUSTER_STATE);\n-  }\n   /**\n-   * Create ClusterState from json string that is typically stored in zookeeper.\n+   * Create a ClusterState from Json.\n    * \n-   * @param version zk version of the clusterstate.json file (bytes)\n-   * @param bytes clusterstate.json as a byte array\n+   * @param bytes a byte array of a Json representation of a mapping from collection name to the Json representation of a\n+   *              {@link DocCollection} as written by {@link #write(JSONWriter)}. It can represent\n+   *              one or more collections.\n    * @param liveNodes list of live nodes\n    * @return the ClusterState\n    */\n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes, String znode) {\n-    // System.out.println(\"######## ClusterState.load:\" + (bytes==null ? null : new String(bytes)));\n+  public static ClusterState createFromJson(int version, byte[] bytes, Set<String> liveNodes) {\n     if (bytes == null || bytes.length == 0) {\n-      return new ClusterState(version, liveNodes, Collections.<String, DocCollection>emptyMap());\n+      return new ClusterState(liveNodes, Collections.<String, DocCollection>emptyMap());\n     }\n     Map<String, Object> stateMap = (Map<String, Object>) Utils.fromJSON(bytes);\n-    return load(version, stateMap, liveNodes, znode);\n+    return createFromData(version, stateMap, liveNodes);\n   }\n \n-  public static ClusterState load(Integer version, Map<String, Object> stateMap, Set<String> liveNodes, String znode) {\n+  public static ClusterState createFromData(int version, Map<String, Object> stateMap, Set<String> liveNodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NTU2Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAxMjkzMA==", "bodyText": "createFromCollectionMap", "url": "https://github.com/apache/lucene-solr/pull/1528#discussion_r430012930", "createdAt": "2020-05-25T16:35:29Z", "author": {"login": "murblanc"}, "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "diffHunk": "@@ -210,47 +200,42 @@ public boolean liveNodesContain(String name) {\n   @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n-    sb.append(\"znodeVersion: \").append(znodeVersion);\n-    sb.append(\"\\n\");\n     sb.append(\"live nodes:\").append(liveNodes);\n     sb.append(\"\\n\");\n     sb.append(\"collections:\").append(collectionStates);\n     return sb.toString();\n   }\n \n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes) {\n-    return load(version, bytes, liveNodes, ZkStateReader.CLUSTER_STATE);\n-  }\n   /**\n-   * Create ClusterState from json string that is typically stored in zookeeper.\n+   * Create a ClusterState from Json.\n    * \n-   * @param version zk version of the clusterstate.json file (bytes)\n-   * @param bytes clusterstate.json as a byte array\n+   * @param bytes a byte array of a Json representation of a mapping from collection name to the Json representation of a\n+   *              {@link DocCollection} as written by {@link #write(JSONWriter)}. It can represent\n+   *              one or more collections.\n    * @param liveNodes list of live nodes\n    * @return the ClusterState\n    */\n-  public static ClusterState load(Integer version, byte[] bytes, Set<String> liveNodes, String znode) {\n-    // System.out.println(\"######## ClusterState.load:\" + (bytes==null ? null : new String(bytes)));\n+  public static ClusterState createFromJson(int version, byte[] bytes, Set<String> liveNodes) {\n     if (bytes == null || bytes.length == 0) {\n-      return new ClusterState(version, liveNodes, Collections.<String, DocCollection>emptyMap());\n+      return new ClusterState(liveNodes, Collections.<String, DocCollection>emptyMap());\n     }\n     Map<String, Object> stateMap = (Map<String, Object>) Utils.fromJSON(bytes);\n-    return load(version, stateMap, liveNodes, znode);\n+    return createFromData(version, stateMap, liveNodes);\n   }\n \n-  public static ClusterState load(Integer version, Map<String, Object> stateMap, Set<String> liveNodes, String znode) {\n+  public static ClusterState createFromData(int version, Map<String, Object> stateMap, Set<String> liveNodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5NTU2Mw=="}, "originalCommit": {"oid": "c5d47bbfdd8f867a8c1006ad3b90a53c4b74844b"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1422, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}