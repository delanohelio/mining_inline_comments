{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODIwNDgx", "number": 2132, "title": "SOLR-15036: auto- select / rollup / sort / plist over facet expression when using a collection alias with multiple collections", "bodyText": "Description\nSee full description and background info in https://issues.apache.org/jira/browse/SOLR-15036\nSolution\nThis PR adds support for automatically wrapping a facet stream with a sort(select(hashRollup(plist(facet(col1, ...), facet(col2, ...))))) expression to allow parallelizing metrics computation across multiple collections concurrently. This auto-wrapping only applies if the collection parameter to the facet stream points to an alias with multiple collections.\nYou might ask why should we bother but I'd counter that this is a simple improvement that helps make aliases work better for analytics applications. In other words, what's the point of providing aliases that abstract querying many collections if client applications have to be aware of the backing collections and create a plist to get better performance? In general, Solr should aim to hide details of the underlying collections for an alias as much as possible.\nThe intended use for this feature is in large clusters where you have many collections with many shards behind the alias. The bulk of the auto-plist logic is implemented in the ParallelMetricsRollup interface; currently only FacetStream implements ParallelMetricsRollup but other stream sources could make use of this in the future.\nThe parallelization approach works nicely for count, sum, min, max, and avg metrics. All other metrics cannot be safely rolled up and thus cannot be parallelized with a plist; rolling up over multiple avg metrics requires a new weighted sum metric, also introduced in this PR.\nThe auto-plist approach applies automatically but can be disabled by passing a tiered=false parameter to the facet expression or globally by setting the solr.facet.stream.tiered=false system property. The reason behind the tiered parameter name is:\n\nthe plist sets up a middle tier of aggregator nodes, one per aliased collection. This happens because of how the facet expression works, which is to setup a CloudSolrClient and push the facet call to the collection\n(from Joel B.)\n\nTests\nIntroduced a new unit test to verify the auto-plist rollup works properly with a single dimension as well as multiple dimensions, where the latter ensures the sorting logic of the final stream is correct. More importantly, I tested this approach in a large cluster with 10's of collections (~50), each with many shards (~100) and the performance was quite impressive, around 5-6x faster than just executing a facet expression without plist. This is also more scalable as it doesn't put a large spike in concurrent shard requests on a single node (top-level controller / coordinator), so can support more concurrent facet stream requests as the load is distributed better between client and cluster.\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ./gradlew check.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-12-09T00:50:02Z", "url": "https://github.com/apache/lucene-solr/pull/2132", "merged": true, "mergeCommit": {"oid": "6711eb7571727552aad3ace53c52c9a8fe07dc40"}, "closed": true, "closedAt": "2021-01-11T17:34:28Z", "author": {"login": "thelabdude"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkT2l2AH2gAyNTM0ODIwNDgxOmMzNWEyMDU2NzJlZTRiZDhmYThiZGI4NzZhZDg5NTkwZTRkZDQxNmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvJgivAH2gAyNTM0ODIwNDgxOjBkN2YwZDNjOTQxNGI3NjU0N2M4Mjc2OWM0ZWNiN2FjYjUwZTIzZmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c35a205672ee4bd8fa8bdb876ad89590e4dd416a", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/c35a205672ee4bd8fa8bdb876ad89590e4dd416a", "committedDate": "2020-12-09T00:46:20Z", "message": "SOLR-15036: auto- select / rollup / sort / plist over facet expression when using a collection alias with multiple collections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0762024f03fa32ab08b9192596332b92e6dbd50c", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/0762024f03fa32ab08b9192596332b92e6dbd50c", "committedDate": "2020-12-09T17:42:49Z", "message": "Fix precommit problems"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2556070a5d624c5b30e7cc0ebbfa933bba216572", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/2556070a5d624c5b30e7cc0ebbfa933bba216572", "committedDate": "2020-12-14T23:26:31Z", "message": "Try to generalize the parallel metrics rollup logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73c2a6a6a2c1f1ac946b7d65893f9646d98c953e", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/73c2a6a6a2c1f1ac946b7d65893f9646d98c953e", "committedDate": "2020-12-14T23:28:39Z", "message": "Fix format call"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/b0a3261cbc0a1ae490e4de43cbb1530584374ab7", "committedDate": "2020-12-14T23:31:50Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMDI2MTc5", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-552026179", "createdAt": "2020-12-15T01:01:42Z", "commit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMTo0MlrOIFz8DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMTowMTo0MlrOIFz8DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk2NDc0OQ==", "bodyText": "NULL_DEREFERENCE:  object returned by FacetStream.cloudSolrClient.getClusterStateProvider() could be null and is dereferenced at line 562.", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r542964749", "createdAt": "2020-12-15T01:01:42Z", "author": {"login": "sonatype-lift"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -545,6 +557,18 @@ public void open() throws IOException {\n       cloudSolrClient = new Builder(hosts, Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000).build();\n     }\n \n+    if (params.getBool(\"plist\", true)) {\n+      params.remove(\"plist\");\n+      final List<String> resolved = cloudSolrClient.getClusterStateProvider().resolveAlias(collection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNTc2Njg1", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-552576685", "createdAt": "2020-12-15T15:26:50Z", "commit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNjo1MFrOIGRKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTozMzo0NFrOIGRgnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MzQ4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for(int i=0; i<sorts.length; i++) {\n          \n          \n            \n                for (int i = 0; i < sorts.length; i++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543443487", "createdAt": "2020-12-15T15:26:50Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0Mzk3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n          \n          \n            \n                if (s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543443975", "createdAt": "2020-12-15T15:27:20Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NDM2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n          \n          \n            \n                } else if (s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543444367", "createdAt": "2020-12-15T15:27:44Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n+      order = \"asc\";\n+      fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n+    } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NTE0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad sort caluse '%s'.\",s));\n          \n          \n            \n                  throw new IOException(String.format(Locale.ROOT, \"invalid expression - bad sort caluse '%s'.\", s));", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543445146", "createdAt": "2020-12-15T15:28:43Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -351,25 +361,26 @@ public String getCollection() {\n \n     FieldComparator[] comps = new FieldComparator[sorts.length];\n     for(int i=0; i<sorts.length; i++) {\n-      String s = sorts[i];\n+      comps[i] = parseSortClause(sorts[i]);\n+    }\n \n-      String fieldName = null;\n-      String order = null;\n+    return comps;\n+  }\n \n-      if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n-        order = \"asc\";\n-        fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n-      } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n-        order = \"desc\";\n-        fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n-      } else {\n-        throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad bucketSort '%s'.\",bucketSortString));\n-      }\n-            \n-      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n+  private FieldComparator parseSortClause(final String s) throws IOException {\n+    String fieldName = null;\n+    String order = null;\n+    if(s.endsWith(\"asc\") || s.endsWith(\"ASC\")) {\n+      order = \"asc\";\n+      fieldName = s.substring(0, s.length()-3).trim().replace(\" \", \"\");\n+    } else if(s.endsWith(\"desc\") || s.endsWith(\"DESC\")) {\n+      order = \"desc\";\n+      fieldName = s.substring(0, s.length()-4).trim().replace(\" \", \"\");\n+    } else {\n+      throw new IOException(String.format(Locale.ROOT,\"invalid expression - bad sort caluse '%s'.\",s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NjA1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int c=0; c < parallelStreams.length; c++) {\n          \n          \n            \n                for (int c = 0; c < parallelStreams.length; c++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543446054", "createdAt": "2020-12-15T15:29:45Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -842,10 +874,73 @@ public int getCost() {\n \n   @Override\n   public StreamComparator getStreamSort() {\n-    if(bucketSorts.length > 1) {\n-      return new MultipleFieldComparator(bucketSorts);\n+    return (bucketSorts.length > 1) ? new MultipleFieldComparator(bucketSorts) : bucketSorts[0];\n+  }\n+\n+  @Override\n+  public TupleStream[] parallelize(List<String> partitions) throws IOException {\n+    TupleStream[] parallelStreams = new TupleStream[partitions.size()];\n+\n+    // prefer a different node for each collection if possible as we don't want the same remote node\n+    // being the coordinator if possible, otherwise, our plist isn't distributing the load as well\n+    final Set<String> preferredNodes = new HashSet<>(Math.max((int) (parallelStreams.length/.75f) + 1, 16));\n+\n+    for (int c=0; c < parallelStreams.length; c++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NjkwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int m=0; m < rollup.length; m++) {\n          \n          \n            \n                for (int m = 0; m < rollup.length; m++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543446902", "createdAt": "2020-12-15T15:30:51Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.solr.client.solrj.io.comp.StreamComparator;\n+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.Metric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.WeightedSumMetric;\n+\n+/**\n+ * Indicates the underlying stream source supports parallelizing metrics computation across collections\n+ * using a rollup of metrics from each collection.\n+ */\n+public interface ParallelMetricsRollup {\n+  TupleStream[] parallelize(List<String> partitions) throws IOException;\n+  StreamComparator getParallelListSortOrder() throws IOException;\n+  RollupStream getRollupStream(SortStream sortStream, Metric[] rollupMetrics) throws IOException;\n+  Map<String,String> getRollupSelectFields(Metric[] rollupMetrics);\n+\n+  default Optional<TupleStream> openParallelStream(StreamContext context, List<String> partitions, Metric[] metrics) throws IOException {\n+    Optional<Metric[]> maybeRollupMetrics = getRollupMetrics(metrics);\n+    if (maybeRollupMetrics.isEmpty())\n+      return Optional.empty(); // some metric is incompatible with doing a rollup over the plist results\n+\n+    TupleStream[] parallelStreams = parallelize(partitions);\n+\n+    // the tuples from each plist need to be sorted using the same order to do a rollup\n+    Metric[] rollupMetrics = maybeRollupMetrics.get();\n+    StreamComparator comparator = getParallelListSortOrder();\n+    SortStream sortStream = new SortStream(new ParallelListStream(parallelStreams), comparator);\n+    RollupStream rollup = getRollupStream(sortStream, rollupMetrics);\n+    SelectStream select = new SelectStream(rollup, getRollupSelectFields(rollupMetrics));\n+    select.setStreamContext(context);\n+    select.open();\n+\n+    return Optional.of(select);\n+  }\n+\n+  default Optional<Metric[]> getRollupMetrics(Metric[] metrics) {\n+    Metric[] rollup = new Metric[metrics.length];\n+    CountMetric count = null;\n+    for (int m=0; m < rollup.length; m++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NzM0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      for (int n=m+1; n < metrics.length; n++) {\n          \n          \n            \n                      for (int n = m+1; n < metrics.length; n++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543447340", "createdAt": "2020-12-15T15:31:25Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelMetricsRollup.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.solr.client.solrj.io.comp.StreamComparator;\n+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.Metric;\n+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;\n+import org.apache.solr.client.solrj.io.stream.metrics.WeightedSumMetric;\n+\n+/**\n+ * Indicates the underlying stream source supports parallelizing metrics computation across collections\n+ * using a rollup of metrics from each collection.\n+ */\n+public interface ParallelMetricsRollup {\n+  TupleStream[] parallelize(List<String> partitions) throws IOException;\n+  StreamComparator getParallelListSortOrder() throws IOException;\n+  RollupStream getRollupStream(SortStream sortStream, Metric[] rollupMetrics) throws IOException;\n+  Map<String,String> getRollupSelectFields(Metric[] rollupMetrics);\n+\n+  default Optional<TupleStream> openParallelStream(StreamContext context, List<String> partitions, Metric[] metrics) throws IOException {\n+    Optional<Metric[]> maybeRollupMetrics = getRollupMetrics(metrics);\n+    if (maybeRollupMetrics.isEmpty())\n+      return Optional.empty(); // some metric is incompatible with doing a rollup over the plist results\n+\n+    TupleStream[] parallelStreams = parallelize(partitions);\n+\n+    // the tuples from each plist need to be sorted using the same order to do a rollup\n+    Metric[] rollupMetrics = maybeRollupMetrics.get();\n+    StreamComparator comparator = getParallelListSortOrder();\n+    SortStream sortStream = new SortStream(new ParallelListStream(parallelStreams), comparator);\n+    RollupStream rollup = getRollupStream(sortStream, rollupMetrics);\n+    SelectStream select = new SelectStream(rollup, getRollupSelectFields(rollupMetrics));\n+    select.setStreamContext(context);\n+    select.open();\n+\n+    return Optional.of(select);\n+  }\n+\n+  default Optional<Metric[]> getRollupMetrics(Metric[] metrics) {\n+    Metric[] rollup = new Metric[metrics.length];\n+    CountMetric count = null;\n+    for (int m=0; m < rollup.length; m++) {\n+      Metric nextRollup;\n+      Metric next = metrics[m];\n+      if (next instanceof SumMetric) {\n+        // sum of sums\n+        nextRollup = new SumMetric(next.getIdentifier());\n+      } else if (next instanceof MinMetric) {\n+        // min of mins\n+        nextRollup = new MinMetric(next.getIdentifier());\n+      } else if (next instanceof MaxMetric) {\n+        // max of max\n+        nextRollup = new MaxMetric(next.getIdentifier());\n+      } else if (next instanceof CountMetric) {\n+        // sum of counts\n+        nextRollup = new SumMetric(next.getIdentifier());\n+        count = (CountMetric)next;\n+      } else if (next instanceof MeanMetric) {\n+        // WeightedSumMetric must have a count to compute the weighted avg. rollup from ...\n+        // if the user is not requesting count, then we can't parallelize\n+        if (count == null) {\n+          // just look past the current position\n+          for (int n=m+1; n < metrics.length; n++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0Nzc1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(o instanceof Long) {\n          \n          \n            \n                } else if (o instanceof Long) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543447750", "createdAt": "2020-12-15T15:31:52Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java", "diffHunk": "@@ -86,7 +86,7 @@ public void update(Tuple tuple) {\n       if(l > longMax) {\n         longMax = l;\n       }\n-    } else {\n+    } else if(o instanceof Long) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0ODA5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if(o instanceof Long) {\n          \n          \n            \n                } else if (o instanceof Long) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543448098", "createdAt": "2020-12-15T15:32:17Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java", "diffHunk": "@@ -87,7 +87,7 @@ public void update(Tuple tuple) {\n       if(l < longMin) {\n         longMin = l;\n       }\n-    } else {\n+    } else if(o instanceof Long) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0ODczNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543448735", "createdAt": "2020-12-15T15:33:04Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/WeightedSumMetric.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.client.solrj.io.stream.metrics;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.solr.client.solrj.io.Tuple;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n+\n+public class WeightedSumMetric extends Metric {\n+\n+  public static final String FUNC = \"wsum\";\n+\n+  private static final class Part {\n+    private final double value;\n+    private final long count;\n+\n+    Part(long count, double value) {\n+      this.count = count;\n+      this.value = value;\n+    }\n+\n+    double weighted(final long total) {\n+      return ((double) count / total) * value;\n+    }\n+  }\n+\n+  private String valueCol;\n+  private String countCol;\n+  private List<Part> parts;\n+\n+  public WeightedSumMetric(String valueCol, String countCol) {\n+    init(valueCol, countCol, false);\n+  }\n+\n+  public WeightedSumMetric(String valueCol, String countCol, boolean outputLong) {\n+    init(valueCol, countCol, outputLong);\n+  }\n+\n+  public WeightedSumMetric(StreamExpression expression, StreamFactory factory) throws IOException {\n+    // grab all parameters out\n+    String functionName = expression.getFunctionName();\n+    if (!FUNC.equals(functionName)) {\n+      throw new IOException(\"Expected '\" + FUNC + \"' function but found \" + functionName);\n+    }\n+    String valueCol = factory.getValueOperand(expression, 0);\n+    String countCol = factory.getValueOperand(expression, 1);\n+    String outputLong = factory.getValueOperand(expression, 2);\n+\n+    // validate expression contains only what we want.\n+    if (null == valueCol) {\n+      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expected %s(valueCol,countCol)\", expression, FUNC));\n+    }\n+\n+    boolean ol = false;\n+    if (outputLong != null) {\n+      ol = Boolean.parseBoolean(outputLong);\n+    }\n+\n+    init(valueCol, countCol, ol);\n+  }\n+\n+  private void init(String valueCol, String countCol, boolean outputLong) {\n+    this.valueCol = valueCol;\n+    this.countCol = countCol != null ? countCol : \"count(*)\";\n+    this.outputLong = outputLong;\n+    setFunctionName(FUNC);\n+    setIdentifier(FUNC, \"(\", valueCol, \", \" + countCol + \")\");\n+  }\n+\n+  public void update(Tuple tuple) {\n+    Object c = tuple.get(countCol);\n+    Object o = tuple.get(valueCol);\n+    if (c instanceof Number && o instanceof Number) {\n+      if (parts == null) {\n+        parts = new LinkedList<>();\n+      }\n+      Number count = (Number) c;\n+      Number value = (Number) o;\n+      parts.add(new Part(count.longValue(), value.doubleValue()));\n+    }\n+  }\n+\n+  public Metric newInstance() {\n+    return new WeightedSumMetric(valueCol, countCol, outputLong);\n+  }\n+\n+  public String[] getColumns() {\n+    return new String[]{valueCol, countCol};\n+  }\n+\n+  public Number getValue() {\n+    long total = sumCounts();\n+    double wavg = 0d;\n+    for (Part next : parts) {\n+      wavg += next.weighted(total);\n+    }\n+    return outputLong ? Math.round(wavg) : wavg;\n+  }\n+\n+  private long sumCounts() {\n+    long total = 0L;\n+    for (Part next : parts) {\n+      total += next.count;\n+    }\n+    return total;\n+  }\n+\n+  @Override\n+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {\n+    return new StreamExpression(getFunctionName()).withParameter(valueCol).withParameter(countCol).withParameter(Boolean.toString(outputLong));\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0OTI0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i=0; i < dists.length; i++) {\n          \n          \n            \n                for (int i = 0; i < dists.length; i++) {", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r543449247", "createdAt": "2020-12-15T15:33:44Z", "author": {"login": "jbampton"}, "path": "solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/ParallelFacetStreamOverAliasTest.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.io.stream;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.util.Precision;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.io.SolrClientCache;\n+import org.apache.solr.client.solrj.io.Tuple;\n+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.request.UpdateRequest;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.handler.SolrDefaultStreamFactory;\n+import org.apache.solr.util.LogLevel;\n+import org.apache.solr.util.RTimer;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * objective of this test suite is to test scalability of Streaming expressions for large deployments,\n+ * for example where there are many collections with high sharding and each collection has millions of documents\n+ */\n+@SolrTestCaseJ4.SuppressSSL\n+@LuceneTestCase.SuppressCodecs({\"Lucene3x\", \"Lucene40\", \"Lucene41\", \"Lucene42\", \"Lucene45\"})\n+@LogLevel(\"org.apache.solr.client.solrj.io.stream=INFO;org.apache.solr.common.cloud.ZkStateReader=WARN;org.apache.solr.metrics=WARN;org.apache.solr.core.SolrCore=WARN;org.apache.solr.cloud=WARN;org.apache.solr.update=WARN;org.apache.solr.rest=ERROR;org.apache.solr.servlet.HttpSolrCall=WARN;org.apache.solr=WARN;org.apache.solr.client.solrj.impl=INFO\")\n+public class ParallelFacetStreamOverAliasTest extends SolrCloudTestCase {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private static final String ALIAS_NAME = \"SOME_ALIAS_WITH_MANY_COLLS\";\n+\n+  private static final String id = \"id\";\n+  private static final int NUM_COLLECTIONS = 2;\n+  private static final int NUM_DOCS_PER_COLLECTION = 40;\n+  private static final int NUM_SHARDS_PER_COLLECTION = 4;\n+  private static final int CARD = 10;\n+\n+  private static List<String> listOfCollections;\n+  private static final RandomGenerator rand = new JDKRandomGenerator(5150);\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    final RTimer timer = new RTimer();\n+    configureCluster(NUM_COLLECTIONS).withMetrics(false)\n+        .addConfig(\"conf\", getFile(\"solrj\").toPath().resolve(\"solr\").resolve(\"configsets\").resolve(\"streaming\").resolve(\"conf\"))\n+        .configure();\n+    cleanup();\n+    setupCollectionsAndAlias();\n+\n+    if (log.isInfoEnabled())\n+      log.info(\"Took {}ms to setup cluster with {} collections\", timer.getTime(), NUM_COLLECTIONS);\n+  }\n+\n+  /**\n+   * setup the testbed with necessary collections, documents, and alias\n+   */\n+  public static void setupCollectionsAndAlias() throws Exception {\n+\n+    final NormalDistribution[] dists = new NormalDistribution[CARD];\n+    for (int i=0; i < dists.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a3261cbc0a1ae490e4de43cbb1530584374ab7"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfb70cb8048ea136e8f1f3835e2b5a836c956bb8", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/dfb70cb8048ea136e8f1f3835e2b5a836c956bb8", "committedDate": "2020-12-16T22:18:46Z", "message": "Drill expr wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c5034038a4bb51b76eb1e45afd32afa3c7e127", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/87c5034038a4bb51b76eb1e45afd32afa3c7e127", "committedDate": "2020-12-16T22:18:59Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d5ba27571b50059856ef181c28434d9d95465be", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/5d5ba27571b50059856ef181c28434d9d95465be", "committedDate": "2020-12-16T22:42:44Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4afe16c778844c1e2d8c71a15b3a022e283bb1a", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/f4afe16c778844c1e2d8c71a15b3a022e283bb1a", "committedDate": "2021-01-06T14:57:37Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2f8d69ef0024f589bb65229199bcf28781c71e9", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/c2f8d69ef0024f589bb65229199bcf28781c71e9", "committedDate": "2021-01-07T18:57:08Z", "message": "WIP: some code clean-up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7b7fd3a3448fc95cbc5564152a269b7ad6c7602", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/e7b7fd3a3448fc95cbc5564152a269b7ad6c7602", "committedDate": "2021-01-07T18:57:55Z", "message": "restore original version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e07d0abe670de9149ae74b56fb80dbcdae90c5a1", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/e07d0abe670de9149ae74b56fb80dbcdae90c5a1", "committedDate": "2021-01-07T18:58:14Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc7dc2d681a284d4277d38c16c740a581da28ae9", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/fc7dc2d681a284d4277d38c16c740a581da28ae9", "committedDate": "2021-01-07T19:26:56Z", "message": "Add Javadoc for ParallelMetricsRollup and fix-up check issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "978787f8b0893f2fccf2bb96b0e993b4fa0b379e", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/978787f8b0893f2fccf2bb96b0e993b4fa0b379e", "committedDate": "2021-01-08T00:04:42Z", "message": "No need to expose the rollup sort comparator in the ParallelMetricsRollup interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97d0218640cd29839ed33d46ac9e4fa0cb03edce", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/97d0218640cd29839ed33d46ac9e4fa0cb03edce", "committedDate": "2021-01-08T00:35:50Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83bae9c8cd681001fee303b34ed61bb746caba3e", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/83bae9c8cd681001fee303b34ed61bb746caba3e", "committedDate": "2021-01-08T16:07:58Z", "message": "Add unit test for WeightedSumMetric"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDAyMjgw", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-564402280", "createdAt": "2021-01-08T16:34:11Z", "commit": {"oid": "83bae9c8cd681001fee303b34ed61bb746caba3e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNDoxMVrOIQYr3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNDoxMVrOIQYr3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1MjU3Mg==", "bodyText": "This refactor makes use of the enhancement provided by SOLR-14987 to reuse HttpSolrClients per host vs. one per replica", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554052572", "createdAt": "2021-01-08T16:34:11Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DrillStream.java", "diffHunk": "@@ -252,29 +253,27 @@ public void setStreamContext(StreamContext streamContext) {\n   }\n \n   protected void constructStreams() throws IOException {\n-\n     try {\n-\n       Object pushStream = ((Expressible) tupleStream).toExpression(streamFactory);\n-\n-      List<String> shardUrls = getShards(this.zkHost, this.collection, this.streamContext);\n-\n-      for(int w=0; w<shardUrls.size(); w++) {\n-        ModifiableSolrParams paramsLoc = new ModifiableSolrParams();\n-        paramsLoc.set(DISTRIB,\"false\"); // We are the aggregator.\n-        paramsLoc.set(\"expr\", pushStream.toString());\n-        paramsLoc.set(\"qt\",\"/export\");\n-        paramsLoc.set(\"fl\", fl);\n-        paramsLoc.set(\"sort\", sort);\n-        paramsLoc.set(\"q\", q);\n-        String url = shardUrls.get(w);\n-        SolrStream solrStream = new SolrStream(url, paramsLoc);\n+      final ModifiableSolrParams paramsLoc = new ModifiableSolrParams();\n+      paramsLoc.set(DISTRIB,\"false\"); // We are the aggregator.\n+      paramsLoc.set(\"expr\", pushStream.toString());\n+      paramsLoc.set(\"qt\",\"/export\");\n+      paramsLoc.set(\"fl\", fl);\n+      paramsLoc.set(\"sort\", sort);\n+      paramsLoc.set(\"q\", q);\n+      getReplicas(this.zkHost, this.collection, this.streamContext, paramsLoc).forEach(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83bae9c8cd681001fee303b34ed61bb746caba3e"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/e3df84cb6929c89fec8d37350d256b4b30868d57", "committedDate": "2021-01-08T16:34:47Z", "message": "Remove unused log"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDA0NTEz", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-564404513", "createdAt": "2021-01-08T16:37:09Z", "commit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNzowOVrOIQYygg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozNzowOVrOIQYygg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NDI3NA==", "bodyText": "This source file did not adhere to the community code format so I reformatted it. It's bad practice in general, but since my PR was getting dinged for format issues, I chose to fix globally in this file vs. piecemeal.", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554054274", "createdAt": "2021-01-08T16:37:09Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -20,15 +20,19 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDA1MjYz", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-564405263", "createdAt": "2021-01-08T16:38:08Z", "commit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozODowOVrOIQY0mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozODowOVrOIQY0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NDgxMA==", "bodyText": "this is the main hook to see if the auto-plist approach should apply to this facet expression", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554054810", "createdAt": "2021-01-08T16:38:09Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -537,14 +555,29 @@ public void setStreamContext(StreamContext context) {\n   }\n \n   public void open() throws IOException {\n-    if(cache != null) {\n+    if (cache != null) {\n       cloudSolrClient = cache.getCloudSolrClient(zkHost);\n     } else {\n       final List<String> hosts = new ArrayList<>();\n       hosts.add(zkHost);\n       cloudSolrClient = new Builder(hosts, Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000).build();\n     }\n \n+    // Parallelize the facet expression across multiple collections for an alias using plist if possible\n+    if (params.getBool(\"plist\", defaultPlistEnabled)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 619}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDA2MDE5", "url": "https://github.com/apache/lucene-solr/pull/2132#pullrequestreview-564406019", "createdAt": "2021-01-08T16:39:08Z", "commit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozOTowOFrOIQY2wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNjozOTowOFrOIQY2wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA1NTM2MA==", "bodyText": "Implementation of the ParallelMetricsRollup interface starts here ...", "url": "https://github.com/apache/lucene-solr/pull/2132#discussion_r554055360", "createdAt": "2021-01-08T16:39:08Z", "author": {"login": "thelabdude"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FacetStream.java", "diffHunk": "@@ -842,10 +881,99 @@ public int getCost() {\n \n   @Override\n   public StreamComparator getStreamSort() {\n-    if(bucketSorts.length > 1) {\n-      return new MultipleFieldComparator(bucketSorts);\n+    return (bucketSorts.length > 1) ? new MultipleFieldComparator(bucketSorts) : bucketSorts[0];\n+  }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3df84cb6929c89fec8d37350d256b4b30868d57"}, "originalPosition": 921}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a678e4d72c1f2d50443c0f9781fdbebcde87a00d", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/a678e4d72c1f2d50443c0f9781fdbebcde87a00d", "committedDate": "2021-01-08T16:42:33Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d463af9d4afe82e238940a9a8748109e5ee8ec8", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/2d463af9d4afe82e238940a9a8748109e5ee8ec8", "committedDate": "2021-01-08T17:01:28Z", "message": "Update changes.txt and add ref guide doc for plist option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8057236df3866b5f9283e516f16e01df030b747", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/c8057236df3866b5f9283e516f16e01df030b747", "committedDate": "2021-01-08T21:15:03Z", "message": "Switch to using tiered for opt-in/out and revert reformatting changes to FacetStream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5ca8770d8e38d4d42619ac17786d9b194c6d321", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/e5ca8770d8e38d4d42619ac17786d9b194c6d321", "committedDate": "2021-01-08T22:07:12Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee22336f516e8724d33702f121d28639dfe19eaf", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/ee22336f516e8724d33702f121d28639dfe19eaf", "committedDate": "2021-01-09T18:31:15Z", "message": "Add unit test for facet with multi-dimensions to verify sorting logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "531962b587506b071df726cf189fabd51321b1dd", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/531962b587506b071df726cf189fabd51321b1dd", "committedDate": "2021-01-09T18:52:23Z", "message": "Refactor test to remove duplication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d822b3721b67adbb0e02e25a56d0e146563287", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/06d822b3721b67adbb0e02e25a56d0e146563287", "committedDate": "2021-01-09T18:52:32Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21d6844895c621a5875f29ce04ca0f182c7d68fc", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/21d6844895c621a5875f29ce04ca0f182c7d68fc", "committedDate": "2021-01-11T15:09:22Z", "message": "Merge remote-tracking branch 'asf/master' into SOLR-15036"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "223fbcddd23ee2c40ebe69ec86c876a7720a1b7e", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/223fbcddd23ee2c40ebe69ec86c876a7720a1b7e", "committedDate": "2021-01-11T15:43:19Z", "message": "use bucket sort order for rollup if it includes all bucket fields and skip the final re-sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53a51553f9ba5c875e045979e832bd4d03b09d7f", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/53a51553f9ba5c875e045979e832bd4d03b09d7f", "committedDate": "2021-01-11T16:12:55Z", "message": "check resort needed before using the stream sort for the rollup sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d7f0d3c9414b76547c82769c4ecb7acb50e23fe", "author": {"user": {"login": "thelabdude", "name": "Timothy Potter"}}, "url": "https://github.com/apache/lucene-solr/commit/0d7f0d3c9414b76547c82769c4ecb7acb50e23fe", "committedDate": "2021-01-11T16:56:22Z", "message": "Switch to using a HashRollupStream vs. Rollup with sort"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2422, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}