{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MDc2MDQ5", "number": 1754, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjowNjowNFrOEYwfhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjoxMTo0NFrOEYwgqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzk1NzgzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjowNjowNFrOHBO3UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNToxMToxNlrOHBs6OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDE2MQ==", "bodyText": "There's a lot of complexity in this line, can we make it an if/else without wrapping and unwrapping an Optional? We are already doing a check on streamContext != null 6 lines up.", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471054161", "createdAt": "2020-08-16T02:06:04Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);\n+      final SolrClientCache localSolrClientCache;\n+      if (solrClientCache == null) {\n+        solrClientCache = localSolrClientCache = new SolrClientCache();\n+      } else {\n+        localSolrClientCache = null;\n+      }\n+      CloudSolrClient cloudSolrClient = solrClientCache.getCloudSolrClient(zkHost);\n       ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n       ClusterState clusterState = zkStateReader.getClusterState();\n       Slice[] slices = CloudSolrStream.getSlices(collection, zkStateReader, true);\n       Set<String> liveNodes = clusterState.getLiveNodes();\n \n \n-      ModifiableSolrParams solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      final ModifiableSolrParams solrParams;\n+      if (streamContext != null) {\n+        solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      } else {\n+        solrParams = new ModifiableSolrParams();\n+      }\n       solrParams.add(requestParams);\n \n       RequestReplicaListTransformerGenerator requestReplicaListTransformerGenerator =\n-          Optional.ofNullable(streamContext.getRequestReplicaListTransformerGenerator()).orElseGet(RequestReplicaListTransformerGenerator::new);\n+          Optional.ofNullable(streamContext != null ? streamContext.getRequestReplicaListTransformerGenerator() : null).orElseGet(RequestReplicaListTransformerGenerator::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3MDIzNw==", "bodyText": "Good question. I just tried to fold the logic into the streamContext != null above but then the unit tests failed and (rightly so) identified that streamContext.getRequestReplicaListTransformerGenerator() can return null. We could still remove use of the Optional of course but it would require an additional if (requestReplicaListTransformerGenerator == null) block then. Thought?", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471370237", "createdAt": "2020-08-17T09:56:15Z", "author": {"login": "cpoerschke"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);\n+      final SolrClientCache localSolrClientCache;\n+      if (solrClientCache == null) {\n+        solrClientCache = localSolrClientCache = new SolrClientCache();\n+      } else {\n+        localSolrClientCache = null;\n+      }\n+      CloudSolrClient cloudSolrClient = solrClientCache.getCloudSolrClient(zkHost);\n       ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n       ClusterState clusterState = zkStateReader.getClusterState();\n       Slice[] slices = CloudSolrStream.getSlices(collection, zkStateReader, true);\n       Set<String> liveNodes = clusterState.getLiveNodes();\n \n \n-      ModifiableSolrParams solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      final ModifiableSolrParams solrParams;\n+      if (streamContext != null) {\n+        solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      } else {\n+        solrParams = new ModifiableSolrParams();\n+      }\n       solrParams.add(requestParams);\n \n       RequestReplicaListTransformerGenerator requestReplicaListTransformerGenerator =\n-          Optional.ofNullable(streamContext.getRequestReplicaListTransformerGenerator()).orElseGet(RequestReplicaListTransformerGenerator::new);\n+          Optional.ofNullable(streamContext != null ? streamContext.getRequestReplicaListTransformerGenerator() : null).orElseGet(RequestReplicaListTransformerGenerator::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDE2MQ=="}, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0NjQyNQ==", "bodyText": "Yea, I think an extra null check is going to be more clear than the use of Optional here.", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471546425", "createdAt": "2020-08-17T15:11:16Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);\n+      final SolrClientCache localSolrClientCache;\n+      if (solrClientCache == null) {\n+        solrClientCache = localSolrClientCache = new SolrClientCache();\n+      } else {\n+        localSolrClientCache = null;\n+      }\n+      CloudSolrClient cloudSolrClient = solrClientCache.getCloudSolrClient(zkHost);\n       ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n       ClusterState clusterState = zkStateReader.getClusterState();\n       Slice[] slices = CloudSolrStream.getSlices(collection, zkStateReader, true);\n       Set<String> liveNodes = clusterState.getLiveNodes();\n \n \n-      ModifiableSolrParams solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      final ModifiableSolrParams solrParams;\n+      if (streamContext != null) {\n+        solrParams = new ModifiableSolrParams(streamContext.getRequestParams());\n+      } else {\n+        solrParams = new ModifiableSolrParams();\n+      }\n       solrParams.add(requestParams);\n \n       RequestReplicaListTransformerGenerator requestReplicaListTransformerGenerator =\n-          Optional.ofNullable(streamContext.getRequestReplicaListTransformerGenerator()).orElseGet(RequestReplicaListTransformerGenerator::new);\n+          Optional.ofNullable(streamContext != null ? streamContext.getRequestReplicaListTransformerGenerator() : null).orElseGet(RequestReplicaListTransformerGenerator::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDE2MQ=="}, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzk1ODEwOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjowNjozNlrOHBO3cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0OTo1N1rOHBh8Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDE5Mw==", "bodyText": "This is clever, add a comment that we're saving localCache because we need to close it later. :)", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471054193", "createdAt": "2020-08-16T02:06:36Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);\n+      final SolrClientCache localSolrClientCache;\n+      if (solrClientCache == null) {\n+        solrClientCache = localSolrClientCache = new SolrClientCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NjcwNw==", "bodyText": "Good idea, will do.", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471366707", "createdAt": "2020-08-17T09:49:57Z", "author": {"login": "cpoerschke"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);\n+      final SolrClientCache localSolrClientCache;\n+      if (solrClientCache == null) {\n+        solrClientCache = localSolrClientCache = new SolrClientCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDE5Mw=="}, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzk2MDM3OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjoxMTowMVrOHBO4dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNToxMjowMVrOHBs8MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDQ1NQ==", "bodyText": "I think this ternary folds into the conditional that we have:\n      SolrClientCache scc, lscc;\n      if (streamContext != null) {\n        scc = streamContext.getSolrClientCache();\n      } else {\n        scc = lscc = new SolrClientCache();\n      }", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471054455", "createdAt": "2020-08-16T02:11:01Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NjM1MA==", "bodyText": "It's possible for streamContext.getSolrClientCache() to return null and in that case combining the ternary and the conditional would give a different result. Would it help to have a comment re: that subtlety perhaps?", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471366350", "createdAt": "2020-08-17T09:49:17Z", "author": {"login": "cpoerschke"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDQ1NQ=="}, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0NjkyOA==", "bodyText": "Yea, add a comment. I definitely missed that subtlety.", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471546928", "createdAt": "2020-08-17T15:12:01Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TupleStream.java", "diffHunk": "@@ -141,19 +141,30 @@ public UUID getStreamNodeId(){\n       shards = shardsMap.get(collection);\n     } else {\n       //SolrCloud Sharding\n-      CloudSolrClient cloudSolrClient =\n-          Optional.ofNullable(streamContext.getSolrClientCache()).orElseGet(SolrClientCache::new).getCloudSolrClient(zkHost);\n+      SolrClientCache solrClientCache = (streamContext != null ? streamContext.getSolrClientCache() : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDQ1NQ=="}, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzk2MDc0OnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjoxMTo0NFrOHBO4oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwMjoxMTo0NFrOHBO4oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NDQ5Nw==", "bodyText": "I really like how simple this test is.", "url": "https://github.com/apache/lucene-solr/pull/1754#discussion_r471054497", "createdAt": "2020-08-16T02:11:44Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java", "diffHunk": "@@ -2716,4 +2716,11 @@ private ParallelStream parallelStream(TupleStream stream, FieldComparator compar\n     return pstream;\n   }\n \n+  public void testCloudSolrStreamWithoutStreamContext() throws Exception {\n+    SolrParams sParams = StreamingTest.mapParams(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", \"id asc\");\n+    try (CloudSolrStream stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams)) {\n+      stream.open();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8b57df49a555d80166675c87c1669d8697c059"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1299, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}