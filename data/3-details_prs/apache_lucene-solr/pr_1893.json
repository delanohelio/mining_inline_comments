{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NjAyODMw", "number": 1893, "title": "LUCENE-9444 Utility class to get facet labels from taxonomy for a fac\u2026", "bodyText": "\u2026et field. This is useful if a facet field is requested in the list of return fields for each hit.\n\nDescription\nThis pull request adds a convenience class that allows an application to get facet labels for a facet field without knowing the internals of faceting implementation.\nSolution\nSimple class with APIs to get facet labels for a facet field and (optionally) a facet dimension\nTests\nTests were added to demonstrate expected API usage and ensure correctness of implementation\nChecklist\nPlease review the following and check all that apply:\n\n I have reviewed the guidelines for How to Contribute and my code conforms to the standards described there to the best of my ability.\n I have created a Jira issue and added the issue ID to my pull request title.\n I have given Solr maintainers access to contribute to my PR branch. (optional but recommended)\n I have developed this patch against the master branch.\n I have run ./gradlew check.\n I have added tests for my changes.\n I have added documentation for the Ref Guide (for Solr changes only).", "createdAt": "2020-09-19T01:31:15Z", "url": "https://github.com/apache/lucene-solr/pull/1893", "merged": true, "mergeCommit": {"oid": "24aadc220ba9578f581637b9fd0e7e973d46426c"}, "closed": true, "closedAt": "2020-09-28T14:55:38Z", "author": {"login": "goankur"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKPwOsAH2gAyNDg5NjAyODMwOmJmOGVhZjk4OTAxY2JlODNmMjMwNjdiZWE5MGRmYjJmMzEwMjYwM2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMfKOSgH2gAyNDg5NjAyODMwOmUzYzk5MmM0YmFlNmY5OGQ2NWQ4ZjQyZWY3NTJhNTgzYmQxZThmNGQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/bf8eaf98901cbe83f23067bea90dfb2f3102603a", "committedDate": "2020-09-19T01:17:44Z", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODU3MTUy", "url": "https://github.com/apache/lucene-solr/pull/1893#pullrequestreview-493857152", "createdAt": "2020-09-22T21:23:10Z", "commit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyMzoxMFrOHWM43g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTozNTozNFrOHWNOuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MTg4Ng==", "bodyText": "Hmm let's upgrade this to a real if not an assert (that requires that assertions are enabled), and change to throw IllegalArgumentException?  In general if it is a problem that a user could legitimately trip up on, it should be a real if, as long as performance impact of such micro-policing is acceptable (which should be the case here).", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493041886", "createdAt": "2020-09-22T21:23:10Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MjI1MQ==", "bodyText": "This one is a good usage of assert because this should only be violated if there is a bug in this code or our default Codec, etc.  No accidental abuse by users could cause this.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042251", "createdAt": "2020-09-22T21:23:59Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mjg2MQ==", "bodyText": "Can we add a Note here, that the returned FacetLabel are not necessarily in the same order in which they were indexed?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493042861", "createdAt": "2020-09-22T21:25:23Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzAxNw==", "bodyText": "Add same Note here as above comment?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043017", "createdAt": "2020-09-22T21:25:44Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MzI4MA==", "bodyText": "Can we upgrade this to a real if?  Caller might legitimately pass in a non-existing facetDimension?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493043280", "createdAt": "2020-09-22T21:26:21Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NTk1MA==", "bodyText": "Ahh, be careful here!  Lucene's test-framework sometimes randomly runs without assertions enabled, to help us catch bugs where we accidentally create code relying on assertions (it has happened, do not ask who).\nSo when tests run with assertions disabled then this test would false-fail?  But, if we upgrade to real if that would also fix this.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493045950", "createdAt": "2020-09-22T21:32:13Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {\n+    Directory dir = newDirectory();\n+    Directory taxoDir = newDirectory();\n+\n+    // Writes facet ords to a separate directory from the main index:\n+    DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir, IndexWriterConfig.OpenMode.CREATE);\n+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n+\n+    FacetsConfig config = new FacetsConfig();\n+    config.setHierarchical(\"Publish Date\", true);\n+\n+    for (Document doc : prepareDocuments()) {\n+      writer.addDocument(config.build(taxoWriter, doc));\n+    }\n+\n+    // NRT open\n+    IndexSearcher searcher = newSearcher(writer.getReader());\n+    // NRT open\n+    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);\n+\n+    FacetsCollector fc = new FacetsCollector();\n+    searcher.search(new MatchAllDocsQuery(), fc);\n+\n+    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n+\n+    // Check labels for all dimensions\n+    List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());\n+    assertTrue(facetLabels.size() == 10);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Author\".equals(l.components[0]))\n+        .map(l -> l.components[1]).collect(Collectors.toSet())\n+        .equals(Set.of(\"Bob\", \"Lisa\", \"Susan\", \"Frank\", \"Tom\")));\n+\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    // Check labels for specific dimension\n+    facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), \"Publish Date\");\n+    assertTrue(facetLabels.size() == 5);\n+    assertTrue(facetLabels.stream()\n+        .filter(l -> \"Publish Date\".equals(l.components[0]))\n+        .map(l -> String.join(\"/\", l.components[1], l.components[2], l.components[3]))\n+        .collect(Collectors.toSet())\n+        .equals(Set.of(\"2010/10/15\", \"2010/10/20\", \"2012/1/1\", \"2012/1/7\", \"1999/5/5\")));\n+\n+    try {\n+      facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), null, true);\n+      fail(\"Assertion error was not thrown for using docIds supplied in decreasing order\");\n+    } catch (AssertionError ae) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ==", "bodyText": "Hmm when we switch to BinaryDocValues for this lookup, we could fix this class to persistently hold a single BinaryDocValues, and improve performance for caller that need to look up multiple ordinals, which is the common case.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047095", "createdAt": "2020-09-22T21:34:48Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzQ4MA==", "bodyText": "Could we make a small change to an existing randomized test, maybe TestTaxonomyFacetCounts.testRandom, to use this API to randomly retrieve N facet labels?  (So we exercise the class beyond the simplish testBasic ... maybe we uncover a rare bug, somewhere).", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r493047480", "createdAt": "2020-09-22T21:35:34Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.facet.FacetField;\n+import org.apache.lucene.facet.FacetTestCase;\n+import org.apache.lucene.facet.FacetsCollector;\n+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;\n+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.IOUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class TestTaxonomyLabels extends FacetTestCase {\n+\n+  private List<Document> prepareDocuments() {\n+    List<Document> docs = new ArrayList<>();\n+\n+    Document doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Bob\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Lisa\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Tom\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Susan\"));\n+    doc.add(new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\"));\n+    docs.add(doc);\n+\n+    doc = new Document();\n+    doc.add(new FacetField(\"Author\", \"Frank\"));\n+    doc.add(new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\"));\n+    docs.add(doc);\n+\n+    return docs;\n+  }\n+\n+  private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {\n+    DocIdSetIterator disi = m.bits.iterator();\n+    List<Integer> docIds = new ArrayList<>();\n+    while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n+      docIds.add(disi.docID());\n+    }\n+\n+    if (decreasingDocIds == true) {\n+      Collections.reverse(docIds);\n+    }\n+    return docIds;\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, null, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,\n+                                             List<MatchingDocs> matchingDocs,\n+                                             String dimension) throws IOException {\n+    return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);\n+  }\n+\n+  private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,\n+                                             boolean decreasingDocIds) throws IOException {\n+    List<FacetLabel> facetLabels = new ArrayList<>();\n+\n+    for (MatchingDocs m : matchingDocs) {\n+      TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n+      List<Integer> docIds = allDocIds(m, decreasingDocIds);\n+      FacetLabel facetLabel;\n+      for (Integer docId : docIds) {\n+        while (true) {\n+          if (dimension != null) {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);\n+          } else {\n+            facetLabel = facetLabelReader.nextFacetLabel(docId);\n+          }\n+\n+          if (facetLabel == null) {\n+            break;\n+          }\n+          facetLabels.add(facetLabel);\n+        }\n+      }\n+    }\n+\n+    return facetLabels;\n+  }\n+\n+\n+  public void testBasic() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/75ff251ebac9034c93edbb43dcf5d8dd0f1058ae", "committedDate": "2020-09-23T04:23:23Z", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/71222c288a83e4a05d0be6020f6903ad340d959d", "committedDate": "2020-09-23T17:19:13Z", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc3Njc5", "url": "https://github.com/apache/lucene-solr/pull/1893#pullrequestreview-495677679", "createdAt": "2020-09-24T15:11:04Z", "commit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxMTowNFrOHXfsYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToyNDoxMlrOHXgSLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5ODU2MA==", "bodyText": "Thank you for adding this utility method so tests can easily use the new utility class!\nCan we rename this to getAllTaxonomyFacetLabels, and add javadoc explaining that the outer list is one entry per matched hit, and the inner list is one entry per FacetLabel belonging to that hit?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494398560", "createdAt": "2020-09-24T15:11:04Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java", "diffHunk": "@@ -56,6 +60,28 @@ public Facets getTaxonomyFacetCounts(TaxonomyReader taxoReader, FacetsConfig con\n     return facets;\n   }\n \n+  public List<List<FacetLabel>> getTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, FacetsCollector fc) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMDUxNQ==", "bodyText": "Hmm why are these null checks necessary?  Are we really seeing null in the argument?  Oh, I guess this legitimately happens when the hit had no facets?  Maybe add a comment?  Hmm, actually, looking at how actual and expected are populated, neither of them seems to add null?  One of them filters out empty list but the other does not?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494400515", "createdAt": "2020-09-24T15:13:48Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {\n+      if (o1 == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMjUwMQ==", "bodyText": "I'm confused why we are sorting the top list?  Isn't the top list in order of the hits?  And we want to confirm, for a given docId hit, that expected and actual labels match?\nOK, I think I understand: this test does not index anything allowing you to track which original doc mapped to which FacetLabel, so then you cannot know, per segment, which docs ended up where :)\nGiven that, I think it's OK to do the top-level sort of all List<FacetLabel> across all hits.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494402501", "createdAt": "2020-09-24T15:16:24Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -726,6 +743,39 @@ public void testRandom() throws Exception {\n     IOUtils.close(tw, searcher.getIndexReader(), tr, indexDir, taxoDir);\n   }\n \n+  private static List<List<FacetLabel>> sortedFacetLabels(List<List<FacetLabel>> allfacetLabels) {\n+    for (List<FacetLabel> facetLabels : allfacetLabels) {\n+      Collections.sort(facetLabels);\n+    }\n+\n+    Collections.sort(allfacetLabels, (o1, o2) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA==", "bodyText": "Hmm I think expectedLabels filters out empty List<FacetLabel> but actualLabels does not, so this might false trip?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r494408238", "createdAt": "2020-09-24T15:24:12Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2600be2694de92f7eb881a7f4e65de77f2175e8d", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/2600be2694de92f7eb881a7f4e65de77f2175e8d", "committedDate": "2020-09-25T00:21:04Z", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2ODcwNDY5", "url": "https://github.com/apache/lucene-solr/pull/1893#pullrequestreview-496870469", "createdAt": "2020-09-25T21:21:23Z", "commit": {"oid": "2600be2694de92f7eb881a7f4e65de77f2175e8d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMToyMToyM1rOHYTDvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMToyMjozNFrOHYTF1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDEyNw==", "bodyText": "Yeah, or we could bulk map all ord -> FacetLabel as soon as caller goes to the next docId, and then iterate them one by one with this API.\nAnyway, we don't need to solve that here.", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240127", "createdAt": "2020-09-25T21:21:23Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.facet.taxonomy;\n+\n+import org.apache.lucene.facet.FacetsConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.IntsRef;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;\n+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;\n+\n+/**\n+ * Utility class to easily retrieve previously indexed facet labels, allowing you to skip also adding stored fields for these values,\n+ * reducing your index size.\n+ *\n+ * @lucene.experimental\n+ **/\n+public class TaxonomyFacetLabels {\n+\n+  /**\n+   * Index field name provided to the constructor\n+   */\n+  private final String indexFieldName;\n+\n+  /**\n+   * {@code TaxonomyReader} provided to the constructor\n+   */\n+  private final TaxonomyReader taxoReader;\n+\n+  /**\n+   * {@code FacetsConfig} provided to the constructor\n+   */\n+  private final FacetsConfig config;\n+\n+  /**\n+   * {@code OrdinalsReader} to decode ordinals previously indexed into the {@code BinaryDocValues} facet field\n+   */\n+  private final OrdinalsReader ordsReader;\n+\n+  /**\n+   * Sole constructor.  Do not close the provided {@link TaxonomyReader} while still using this instance!\n+   */\n+  public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {\n+    this.taxoReader = taxoReader;\n+    this.config = config;\n+    this.indexFieldName = indexFieldName;\n+    this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);\n+  }\n+\n+  /**\n+   * Create and return an instance of {@link FacetLabelReader} to retrieve facet labels for\n+   * multiple documents and (optionally) for a specific dimension.  You must create this per-segment,\n+   * and then step through all hits, in order, for that segment.\n+   *\n+   * <p><b>NOTE</b>: This class is not thread-safe, so you must use a new instance of this\n+   * class for each thread.</p>\n+   *\n+   * @param readerContext LeafReaderContext used to access the {@code BinaryDocValues} facet field\n+   * @return an instance of {@link FacetLabelReader}\n+   * @throws IOException when a low-level IO issue occurs\n+   */\n+  public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {\n+    return new FacetLabelReader(ordsReader, readerContext);\n+  }\n+\n+  /**\n+   * Utility class to retrieve facet labels for multiple documents.\n+   *\n+   * @lucene.experimental\n+   */\n+  public class FacetLabelReader {\n+    private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;\n+    private final IntsRef decodedOrds = new IntsRef();\n+    private int currentDocId = -1;\n+    private int currentPos = -1;\n+\n+    // Lazily set when nextFacetLabel(int docId, String facetDimension) is first called\n+    private int[] parents;\n+\n+    /**\n+     * Sole constructor.\n+     */\n+    public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {\n+      ordinalsSegmentReader = ordsReader.getReader(readerContext);\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n+     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n+     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n+     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n+     * new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * @param docId input docId provided in monotonic (non-decreasing) order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException when a low-level IO issue occurs\n+     */\n+    public FacetLabel nextFacetLabel(int docId) throws IOException {\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentDocId = docId;\n+        currentPos = decodedOrds.offset;\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      if (currentPos == endPos) {\n+        // no more FacetLabels\n+        return null;\n+      }\n+\n+      int ord = decodedOrds.ints[currentPos++];\n+      return taxoReader.getPath(ord);\n+    }\n+\n+    private boolean isDescendant(int ord, int ancestorOrd) {\n+      while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {\n+        if (parents[ord] == ancestorOrd) {\n+          return true;\n+        }\n+        ord = parents[ord];\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * Retrieves the next {@link FacetLabel} for the specified {@code docId} under the requested {@code facetDimension},\n+     * or {@code null} if there are no more. This method has state: if the provided {@code docId} is the same as the\n+     * previous invocation, it returns the next {@link FacetLabel} for that document.  Otherwise, it advances to\n+     * the new {@code docId} and provides the first {@link FacetLabel} for that document, or {@code null} if that document\n+     * has no indexed facets.  Each new {@code docId} must be in strictly monotonic (increasing) order.\n+     *\n+     * <p><b>NOTE</b>: this method loads the {@code int[] parents} array from the taxonomy index</p>\n+     *\n+     * @param docId input docId provided in non-decreasing order\n+     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n+     * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal\n+     */\n+    public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {\n+      final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));\n+      assert parentOrd != INVALID_ORDINAL : \"Category ordinal not found for facet dimension: \" + facetDimension;\n+\n+      if (currentDocId != docId) {\n+        assert docId > currentDocId: \"docs out of order!  currentDocId=\" + currentDocId + \" docId=\" + docId;\n+        ordinalsSegmentReader.get(docId, decodedOrds);\n+        currentPos = decodedOrds.offset;\n+        currentDocId = docId;\n+      }\n+\n+      if (parents == null) {\n+        parents = taxoReader.getParallelTaxonomyArrays().parents();\n+      }\n+\n+      int endPos = decodedOrds.offset + decodedOrds.length;\n+      assert currentPos <= endPos;\n+\n+      for (; currentPos < endPos; ) {\n+        int ord = decodedOrds.ints[currentPos++];\n+        if (isDescendant(ord, parentOrd) == true) {\n+          return taxoReader.getPath(ord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NzA5NQ=="}, "originalCommit": {"oid": "bf8eaf98901cbe83f23067bea90dfb2f3102603a"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0MDY2MQ==", "bodyText": "Hmm I don't like filtering out \"no facet fields\" case from FacetTestCase.getAllTaxonomyFacetLabels() -- that means callers cannot safely map hits to the List<FacetLabel>?\nCould we instead keep the empty lists in both expected and actual?", "url": "https://github.com/apache/lucene-solr/pull/1893#discussion_r495240661", "createdAt": "2020-09-25T21:22:34Z", "author": {"login": "mikemccand"}, "path": "lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetCounts.java", "diffHunk": "@@ -711,6 +723,11 @@ public void testRandom() throws Exception {\n         }\n       }\n \n+      // Test facet labels for each matching test doc\n+      List<List<FacetLabel>> actualLabels = getTaxonomyFacetLabels(tr, config, fc);\n+      assertEquals(expectedLabels.size(), actualLabels.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODIzOA=="}, "originalCommit": {"oid": "71222c288a83e4a05d0be6020f6903ad340d959d"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3c992c4bae6f98d65d8f42ef752a583bd1e8f4d", "author": {"user": null}, "url": "https://github.com/apache/lucene-solr/commit/e3c992c4bae6f98d65d8f42ef752a583bd1e8f4d", "committedDate": "2020-09-26T00:22:33Z", "message": "LUCENE-9444 Utility class to get facet labels from taxonomy for a facet field. This is useful if a facet field is requested in the list of return fields for each hit."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2286, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}