{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTQ4NDUz", "number": 1561, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMzo1OVrOEEwTQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozODo0NVrOEEyHIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDIxMTIzOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/OverseerMessageHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMzo1OVrOGikx5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxMzo1OVrOGikx5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNzM2NQ==", "bodyText": "This javadoc includes a sentence fragment, can we complete the thought while we're improving documentation in this area?", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438907365", "createdAt": "2020-06-11T16:13:59Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerMessageHandler.java", "diffHunk": "@@ -50,7 +50,7 @@\n   /**Try to provide an exclusive lock for this particular task\n    * return null if locking is not possible. If locking is not necessary", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDIxNDg2OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/LockTree.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxNDo1OFrOGik0Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxNDo1OFrOGik0Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkwNzk3NQ==", "bodyText": "I don't understand what this comment means.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438907975", "createdAt": "2020-06-11T16:14:58Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/LockTree.java", "diffHunk": "@@ -89,22 +98,29 @@ public Lock lock(CollectionParams.CollectionAction action, List<String> path) {\n       this.level = level;\n     }\n \n-    void markBusy(List<String> path, int depth) {\n-      if (path.size() == depth) {\n+    /**\n+     * Marks busy the SessionNode corresponding to lockLevel (node names coming from <code>path</code>).\n+     * @param path size is at least <code>lockLevel.getHeight()</code>, to capture which node should be marked busy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDMxMDY3OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MDoxOVrOGilxlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODowNTo0NVrOGipAKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMzY3MA==", "bodyText": "This reference to runningTasks isn't synchronized. Is that an issue?", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438923670", "createdAt": "2020-06-11T16:40:19Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;\n-  // This map may contain tasks which are read from work queue but could not\n-  // be executed because they are blocked or the execution queue is full\n-  // This is an optimization to ensure that we do not read the same tasks\n-  // again and again from ZK.\n+\n+  /**\n+   * This map may contain tasks which are read from work queue but could not\n+   * be executed because they are blocked or the execution queue is full\n+   * This is an optimization to ensure that we do not read the same tasks\n+   * again and again from ZK.\n+   */\n   final private Map<String, QueueEvent> blockedTasks = Collections.synchronizedMap(new LinkedHashMap<>());\n-  final private Predicate<String> excludedTasks = new Predicate<String>() {\n+\n+  /**\n+   * Predicate used to filter out tasks from the Zookeeper queue that should not be returned for processing.\n+   */\n+  final private Predicate<String> excludedTasks = new Predicate<>() {\n     @Override\n     public boolean test(String s) {\n       return runningTasks.contains(s) || blockedTasks.containsKey(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NjU1Mg==", "bodyText": "Yes it is. Can likely change this one into a ConcurrentHashMap.newKeySet() as well.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438976552", "createdAt": "2020-06-11T18:05:45Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;\n-  // This map may contain tasks which are read from work queue but could not\n-  // be executed because they are blocked or the execution queue is full\n-  // This is an optimization to ensure that we do not read the same tasks\n-  // again and again from ZK.\n+\n+  /**\n+   * This map may contain tasks which are read from work queue but could not\n+   * be executed because they are blocked or the execution queue is full\n+   * This is an optimization to ensure that we do not read the same tasks\n+   * again and again from ZK.\n+   */\n   final private Map<String, QueueEvent> blockedTasks = Collections.synchronizedMap(new LinkedHashMap<>());\n-  final private Predicate<String> excludedTasks = new Predicate<String>() {\n+\n+  /**\n+   * Predicate used to filter out tasks from the Zookeeper queue that should not be returned for processing.\n+   */\n+  final private Predicate<String> excludedTasks = new Predicate<>() {\n     @Override\n     public boolean test(String s) {\n       return runningTasks.contains(s) || blockedTasks.containsKey(s);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMzY3MA=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDMyMjMzOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MzozMlrOGil45A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxODowMjozOFrOGio4_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNTU0MA==", "bodyText": "Since there is so much synchronized access to this, should it be a ConcurrentHashMap.newKeySet();", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438925540", "createdAt": "2020-06-11T16:43:32Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NDcxOQ==", "bodyText": "Yes, will change that.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438974719", "createdAt": "2020-06-11T18:02:38Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNTU0MA=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDMyNDM0OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0NDowNlrOGil6NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOTowOTozOVrOGirCXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNTg3Nw==", "bodyText": "Similar here, can this be a ConcurrentHashMap instead of a synchronized map?", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438925877", "createdAt": "2020-06-11T16:44:06Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;\n-  // This map may contain tasks which are read from work queue but could not\n-  // be executed because they are blocked or the execution queue is full\n-  // This is an optimization to ensure that we do not read the same tasks\n-  // again and again from ZK.\n+\n+  /**\n+   * This map may contain tasks which are read from work queue but could not\n+   * be executed because they are blocked or the execution queue is full\n+   * This is an optimization to ensure that we do not read the same tasks\n+   * again and again from ZK.\n+   */\n   final private Map<String, QueueEvent> blockedTasks = Collections.synchronizedMap(new LinkedHashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3MDY4Ng==", "bodyText": "We'd need a concurrent linked hash map because we need iteration order == insert order...", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438970686", "createdAt": "2020-06-11T17:55:57Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;\n-  // This map may contain tasks which are read from work queue but could not\n-  // be executed because they are blocked or the execution queue is full\n-  // This is an optimization to ensure that we do not read the same tasks\n-  // again and again from ZK.\n+\n+  /**\n+   * This map may contain tasks which are read from work queue but could not\n+   * be executed because they are blocked or the execution queue is full\n+   * This is an optimization to ensure that we do not read the same tasks\n+   * again and again from ZK.\n+   */\n   final private Map<String, QueueEvent> blockedTasks = Collections.synchronizedMap(new LinkedHashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNTg3Nw=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwOTg4NQ==", "bodyText": "We need a map for the predicate to check presence of an id (map keys also used for logs, but if it was the only use we could work around).", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r439009885", "createdAt": "2020-06-11T19:09:39Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -95,16 +95,25 @@\n \n   private volatile Stats stats;\n \n-  // Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n-  // It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n-  // deleted from the work-queue as that is a batched operation.\n+  /**\n+   * Set of tasks that have been picked up for processing but not cleaned up from zk work-queue.\n+   * It may contain tasks that have completed execution, have been entered into the completed/failed map in zk but not\n+   * deleted from the work-queue as that is a batched operation.\n+   */\n   final private Set<String> runningZKTasks;\n-  // This map may contain tasks which are read from work queue but could not\n-  // be executed because they are blocked or the execution queue is full\n-  // This is an optimization to ensure that we do not read the same tasks\n-  // again and again from ZK.\n+\n+  /**\n+   * This map may contain tasks which are read from work queue but could not\n+   * be executed because they are blocked or the execution queue is full\n+   * This is an optimization to ensure that we do not read the same tasks\n+   * again and again from ZK.\n+   */\n   final private Map<String, QueueEvent> blockedTasks = Collections.synchronizedMap(new LinkedHashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNTg3Nw=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDUwMTU0OnYy", "diffSide": "LEFT", "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozNjo0NFrOGintmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzo1MTozN1rOGioavg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTQxNg==", "bodyText": "This is the only usage of clear in the code, can we remove that method completely? Is this safe to not call clear?", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438955416", "createdAt": "2020-06-11T17:36:44Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "diffHunk": "@@ -867,26 +866,25 @@ public String getTaskKey(ZkNodeProps message) {\n   }\n \n \n+  // -1 is not a possible batchSessionId so -1 will force initialization of lockSession\n   private long sessionId = -1;\n   private LockTree.Session lockSession;\n \n   @Override\n-  public Lock lockTask(ZkNodeProps message, OverseerTaskProcessor.TaskBatch taskBatch) {\n-    if (lockSession == null || sessionId != taskBatch.getId()) {\n+  public Lock lockTask(ZkNodeProps message, long batchSessionId) {\n+    if (sessionId != batchSessionId) {\n       //this is always called in the same thread.\n       //Each batch is supposed to have a new taskBatch\n       //So if taskBatch changes we must create a new Session\n-      // also check if the running tasks are empty. If yes, clear lockTree\n-      // this will ensure that locks are not 'leaked'\n-      if(taskBatch.getRunningTasks() == 0) lockTree.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2Njk3NA==", "bodyText": "I hope (and think) it is... A lock can leak if an executor thread dies in a place where it shouldn't be dying (just before the try with the lock released in the finally.\nClearing all locks is not a solution IMO. If we do end up with lock leaks we should address those in a more elegant way (fix the leak).", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438966974", "createdAt": "2020-06-11T17:51:37Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java", "diffHunk": "@@ -867,26 +866,25 @@ public String getTaskKey(ZkNodeProps message) {\n   }\n \n \n+  // -1 is not a possible batchSessionId so -1 will force initialization of lockSession\n   private long sessionId = -1;\n   private LockTree.Session lockSession;\n \n   @Override\n-  public Lock lockTask(ZkNodeProps message, OverseerTaskProcessor.TaskBatch taskBatch) {\n-    if (lockSession == null || sessionId != taskBatch.getId()) {\n+  public Lock lockTask(ZkNodeProps message, long batchSessionId) {\n+    if (sessionId != batchSessionId) {\n       //this is always called in the same thread.\n       //Each batch is supposed to have a new taskBatch\n       //So if taskBatch changes we must create a new Session\n-      // also check if the running tasks are empty. If yes, clear lockTree\n-      // this will ensure that locks are not 'leaked'\n-      if(taskBatch.getRunningTasks() == 0) lockTree.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTQxNg=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDUwNDYzOnYy", "diffSide": "RIGHT", "path": "solr/solrj/src/java/org/apache/solr/common/params/CollectionParams.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozNzo0N1rOGinvqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOTowNTozMFrOGiq6lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTk0Ng==", "bodyText": "I don't think it makes sense to reorder them here.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438955946", "createdAt": "2020-06-11T17:37:47Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/params/CollectionParams.java", "diffHunk": "@@ -42,31 +42,30 @@\n \n \n   enum LockLevel {\n-    CLUSTER(0),\n-    COLLECTION(1),\n-    SHARD(2),\n-    REPLICA(3),\n-    NONE(10);\n-\n-    public final int level;\n-\n-    LockLevel(int i) {\n-      this.level = i;\n+    NONE(10, null),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NzM4Nw==", "bodyText": "Compiler complained of forward reference when I didn't.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438967387", "createdAt": "2020-06-11T17:52:07Z", "author": {"login": "murblanc"}, "path": "solr/solrj/src/java/org/apache/solr/common/params/CollectionParams.java", "diffHunk": "@@ -42,31 +42,30 @@\n \n \n   enum LockLevel {\n-    CLUSTER(0),\n-    COLLECTION(1),\n-    SHARD(2),\n-    REPLICA(3),\n-    NONE(10);\n-\n-    public final int level;\n-\n-    LockLevel(int i) {\n-      this.level = i;\n+    NONE(10, null),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTk0Ng=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwNzg5Mg==", "bodyText": "Didn't consider that; yea, that's a good reason for reordering.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r439007892", "createdAt": "2020-06-11T19:05:30Z", "author": {"login": "madrob"}, "path": "solr/solrj/src/java/org/apache/solr/common/params/CollectionParams.java", "diffHunk": "@@ -42,31 +42,30 @@\n \n \n   enum LockLevel {\n-    CLUSTER(0),\n-    COLLECTION(1),\n-    SHARD(2),\n-    REPLICA(3),\n-    NONE(10);\n-\n-    public final int level;\n-\n-    LockLevel(int i) {\n-      this.level = i;\n+    NONE(10, null),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTk0Ng=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDUwNzg3OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozODo0NVrOGinx5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxMDoxOVrOGirDqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NjUxNg==", "bodyText": "Why do we no longer need to check against the upper limit of BLOCKED_TASKS?", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438956516", "createdAt": "2020-06-11T17:38:45Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -253,20 +277,22 @@ public void run() {\n             continue;\n           }\n \n-          blockedTasks.clear(); // clear it now; may get refilled below.\n+          // clear the blocked tasks, may get refilled below. Given blockedTasks can only get entries from heads and heads\n+          // has at most MAX_BLOCKED_TASKS tasks, blockedTasks will never exceed MAX_BLOCKED_TASKS entries.\n+          // Note blockedTasks can't be cleared too early as it is used in the excludedTasks Predicate above.\n+          blockedTasks.clear();\n+\n+          // Trigger the creation of a new Session used for locking when/if a lock is later acquired on the OverseerCollectionMessageHandler\n+          batchSessionId++;\n \n-          taskBatch.batchId++;\n           boolean tooManyTasks = false;\n           for (QueueEvent head : heads) {\n             if (!tooManyTasks) {\n-              synchronized (runningTasks) {\n                 tooManyTasks = runningTasksSize() >= MAX_PARALLEL_TASKS;\n-              }\n             }\n             if (tooManyTasks) {\n               // Too many tasks are running, just shove the rest into the \"blocked\" queue.\n-              if(blockedTasks.size() < MAX_BLOCKED_TASKS)\n-                blockedTasks.put(head.getId(), head);\n+              blockedTasks.put(head.getId(), head);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NTA4OQ==", "bodyText": "Commented line 280 above.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r438965089", "createdAt": "2020-06-11T17:49:30Z", "author": {"login": "murblanc"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -253,20 +277,22 @@ public void run() {\n             continue;\n           }\n \n-          blockedTasks.clear(); // clear it now; may get refilled below.\n+          // clear the blocked tasks, may get refilled below. Given blockedTasks can only get entries from heads and heads\n+          // has at most MAX_BLOCKED_TASKS tasks, blockedTasks will never exceed MAX_BLOCKED_TASKS entries.\n+          // Note blockedTasks can't be cleared too early as it is used in the excludedTasks Predicate above.\n+          blockedTasks.clear();\n+\n+          // Trigger the creation of a new Session used for locking when/if a lock is later acquired on the OverseerCollectionMessageHandler\n+          batchSessionId++;\n \n-          taskBatch.batchId++;\n           boolean tooManyTasks = false;\n           for (QueueEvent head : heads) {\n             if (!tooManyTasks) {\n-              synchronized (runningTasks) {\n                 tooManyTasks = runningTasksSize() >= MAX_PARALLEL_TASKS;\n-              }\n             }\n             if (tooManyTasks) {\n               // Too many tasks are running, just shove the rest into the \"blocked\" queue.\n-              if(blockedTasks.size() < MAX_BLOCKED_TASKS)\n-                blockedTasks.put(head.getId(), head);\n+              blockedTasks.put(head.getId(), head);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NjUxNg=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxMDIxNw==", "bodyText": "Ah, ok, I saw that but then missed the connection by the time I got to this method.", "url": "https://github.com/apache/lucene-solr/pull/1561#discussion_r439010217", "createdAt": "2020-06-11T19:10:19Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.java", "diffHunk": "@@ -253,20 +277,22 @@ public void run() {\n             continue;\n           }\n \n-          blockedTasks.clear(); // clear it now; may get refilled below.\n+          // clear the blocked tasks, may get refilled below. Given blockedTasks can only get entries from heads and heads\n+          // has at most MAX_BLOCKED_TASKS tasks, blockedTasks will never exceed MAX_BLOCKED_TASKS entries.\n+          // Note blockedTasks can't be cleared too early as it is used in the excludedTasks Predicate above.\n+          blockedTasks.clear();\n+\n+          // Trigger the creation of a new Session used for locking when/if a lock is later acquired on the OverseerCollectionMessageHandler\n+          batchSessionId++;\n \n-          taskBatch.batchId++;\n           boolean tooManyTasks = false;\n           for (QueueEvent head : heads) {\n             if (!tooManyTasks) {\n-              synchronized (runningTasks) {\n                 tooManyTasks = runningTasksSize() >= MAX_PARALLEL_TASKS;\n-              }\n             }\n             if (tooManyTasks) {\n               // Too many tasks are running, just shove the rest into the \"blocked\" queue.\n-              if(blockedTasks.size() < MAX_BLOCKED_TASKS)\n-                blockedTasks.put(head.getId(), head);\n+              blockedTasks.put(head.getId(), head);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NjUxNg=="}, "originalCommit": {"oid": "0946eca60887308bbc2b186512659cc66c935d07"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1456, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}