{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzEzNTcx", "number": 1567, "title": "LUCENE-9402: Let MultiCollector handle minCompetitiveScore", "bodyText": "Here is an idea to make MultiCollector be able to handle minCompetitiveScore. Looking at this comment in the code:\n            // Ignore calls to setMinCompetitiveScore so that if we wrap two\n            // collectors and one of them wants to skip low-scoring hits, then\n            // the other collector still sees all hits. We could try to reconcile\n            // min scores and take the maximum min score across collectors, but\n            // this is very unlikely to be helpful in practice.\n\nThis implementation tries to make it so that all collectors can see all the hits and only allow skipping if all collectors set a min competitive score. The value passed to the inner scorer is the minimum among all collectors (instead of the maximum as the comment suggests).", "createdAt": "2020-06-10T21:30:11Z", "url": "https://github.com/apache/lucene-solr/pull/1567", "merged": true, "mergeCommit": {"oid": "4db1e3895fec7cd50b0ad266af5db0757bb5780a"}, "closed": true, "closedAt": "2020-06-18T17:19:49Z", "author": {"login": "tflobbe"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqAmHYAFqTQyODQ0Mzc5Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcshoUDgBqjM0NTkyMTk3ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDQzNzkz", "url": "https://github.com/apache/lucene-solr/pull/1567#pullrequestreview-428443793", "createdAt": "2020-06-10T21:32:32Z", "commit": {"oid": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMjozMlrOGiHDTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMjozMlrOGiHDTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMDMwMQ==", "bodyText": "I should fix this comment", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438420301", "createdAt": "2020-06-10T21:32:32Z", "author": {"login": "tflobbe"}, "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -143,32 +143,43 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n     private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n       this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];\n     }\n \n     @Override\n     public void setScorer(Scorable scorer) throws IOException {\n       if (cacheScores) {\n         scorer = new ScoreCachingWrappingScorer(scorer);\n       }\n-      scorer = new FilterScorable(scorer) {\n-        @Override\n-        public void setMinCompetitiveScore(float minScore) {\n-          // Ignore calls to setMinCompetitiveScore so that if we wrap two\n-          // collectors and one of them wants to skip low-scoring hits, then\n-          // the other collector still sees all hits. We could try to reconcile\n-          // min scores and take the maximum min score across collectors, but\n-          // this is very unlikely to be helpful in practice.\n+      if (skipNonCompetitiveScores) {\n+        for (int i = 0; i < numCollectors; ++i) {\n+          final LeafCollector c = collectors[i];\n+          c.setScorer(new MinCompetitiveScoreAwareScorable(scorer,  i,  minScores));\n         }\n+      } else {\n+        scorer = new FilterScorable(scorer) {\n+          @Override\n+          public void setMinCompetitiveScore(float minScore) throws IOException {\n+            // Ignore calls to setMinCompetitiveScore so that if we wrap two\n+            // collectors and one of them wants to skip low-scoring hits, then\n+            // the other collector still sees all hits. We could try to reconcile\n+            // min scores and take the maximum min score across collectors, but\n+            // this is very unlikely to be helpful in practice.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NjMxMjU3", "url": "https://github.com/apache/lucene-solr/pull/1567#pullrequestreview-428631257", "createdAt": "2020-06-11T06:41:55Z", "commit": {"oid": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjo0MTo1NlrOGiQa4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjo0NzoyNVrOGiQi5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3Mzc5NQ==", "bodyText": "Let's make the array null when skipNonCompetitiveScores is false?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];\n          \n          \n            \n                  this.minScores = this.skipNonCompetitiveScores ? new float[ this.numCollectors] : null;", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438573795", "createdAt": "2020-06-11T06:41:56Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -143,32 +143,43 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n     private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n       this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3NTg0NA==", "bodyText": "no need to commit, the follow-up call to getReader() creates a NRT segment anyway", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438575844", "createdAt": "2020-06-11T06:47:25Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/MultiCollectorTest.java", "diffHunk": "@@ -163,4 +163,64 @@ public void testCacheScoresIfNecessary() throws IOException {\n     reader.close();\n     dir.close();\n   }\n+  \n+  public void testScorerWrappingForTopScores() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    iw.commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzMyMDgz", "url": "https://github.com/apache/lucene-solr/pull/1567#pullrequestreview-430732083", "createdAt": "2020-06-15T15:03:36Z", "commit": {"oid": "e880e1b4a19ec0fba063459bda86cafb193dc514"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTowMzozNlrOGj2Qfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTowMzozNlrOGj2Qfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0MjMwMw==", "bodyText": "I don't think that this assertion is right, the collector could be null if the collector already threw a CollectionTerminatedException? (we don't disallow calling setCollector after collection started)", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r440242303", "createdAt": "2020-06-15T15:03:36Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -134,69 +134,110 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n       case 1:\n         return leafCollectors.get(0);\n       default:\n-        return new MultiLeafCollector(leafCollectors, cacheScores);\n+        return new MultiLeafCollector(leafCollectors, cacheScores, scoreMode() == ScoreMode.TOP_SCORES);\n     }\n   }\n \n   private static class MultiLeafCollector implements LeafCollector {\n \n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n-    private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n-      this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = this.skipNonCompetitiveScores ? new float[this.collectors.length] : null;\n     }\n \n     @Override\n     public void setScorer(Scorable scorer) throws IOException {\n       if (cacheScores) {\n         scorer = new ScoreCachingWrappingScorer(scorer);\n       }\n-      scorer = new FilterScorable(scorer) {\n-        @Override\n-        public void setMinCompetitiveScore(float minScore) {\n-          // Ignore calls to setMinCompetitiveScore so that if we wrap two\n-          // collectors and one of them wants to skip low-scoring hits, then\n-          // the other collector still sees all hits. We could try to reconcile\n-          // min scores and take the maximum min score across collectors, but\n-          // this is very unlikely to be helpful in practice.\n+      if (skipNonCompetitiveScores) {\n+        for (int i = 0; i < collectors.length; ++i) {\n+          final LeafCollector c = collectors[i];\n+          assert c != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e880e1b4a19ec0fba063459bda86cafb193dc514"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjEyMTM5", "url": "https://github.com/apache/lucene-solr/pull/1567#pullrequestreview-431212139", "createdAt": "2020-06-16T07:01:54Z", "commit": {"oid": "8f0292e0a7581a322d347b478c3b8198ba8cbc63"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowMTo1NFrOGkNzoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowMTo1NFrOGkNzoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyODEyOQ==", "bodyText": "maybe create a new variant of this test that calls setScorer again after this collect call?", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r440628129", "createdAt": "2020-06-16T07:01:54Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/test/org/apache/lucene/search/MultiCollectorTest.java", "diffHunk": "@@ -163,4 +163,115 @@ public void testCacheScoresIfNecessary() throws IOException {\n     reader.close();\n     dir.close();\n   }\n+  \n+  public void testScorerWrappingForTopScores() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    DirectoryReader reader = iw.getReader();\n+    iw.close();\n+    final LeafReaderContext ctx = reader.leaves().get(0);\n+    Collector c1 = collector(ScoreMode.TOP_SCORES, MultiCollector.MinCompetitiveScoreAwareScorable.class);\n+    Collector c2 = collector(ScoreMode.TOP_SCORES, MultiCollector.MinCompetitiveScoreAwareScorable.class);\n+    MultiCollector.wrap(c1, c2).getLeafCollector(ctx).setScorer(new ScoreAndDoc());\n+    \n+    c1 = collector(ScoreMode.TOP_SCORES, ScoreCachingWrappingScorer.class);\n+    c2 = collector(ScoreMode.COMPLETE, ScoreCachingWrappingScorer.class);\n+    MultiCollector.wrap(c1, c2).getLeafCollector(ctx).setScorer(new ScoreAndDoc());\n+    \n+    reader.close();\n+    dir.close();\n+  }\n+  \n+  public void testMinCompetitiveScore() throws IOException {\n+    float[] currentMinScores = new float[3];\n+    float[] minCompetitiveScore = new float[1];\n+    Scorable scorer = new Scorable() {\n+      \n+      @Override\n+      public float score() throws IOException {\n+        return 0;\n+      }\n+      \n+      @Override\n+      public int docID() {\n+        return 0;\n+      }\n+      \n+      @Override\n+      public void setMinCompetitiveScore(float minScore) throws IOException {\n+        minCompetitiveScore[0] = minScore;\n+      }\n+    };\n+    Scorable s0 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 0, currentMinScores);\n+    Scorable s1 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 1, currentMinScores);\n+    Scorable s2 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 2, currentMinScores);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s0.setMinCompetitiveScore(0.5f);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s1.setMinCompetitiveScore(0.8f);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(0.3f);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(0.1f);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s1.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(0.5f, minCompetitiveScore[0], 0);\n+    s0.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(Float.MAX_VALUE, minCompetitiveScore[0], 0);\n+  }\n+  \n+  public void testCollectionTermination() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    DirectoryReader reader = iw.getReader();\n+    iw.close();\n+    final LeafReaderContext ctx = reader.leaves().get(0);\n+    DummyCollector c1 = new DummyCollector() {\n+      @Override\n+      public void collect(int doc) throws IOException {\n+        if (doc == 1) {\n+          throw new CollectionTerminatedException();\n+        }\n+        super.collect(doc);\n+      }\n+      \n+    };\n+    \n+    DummyCollector c2 = new DummyCollector() {\n+      @Override\n+      public void collect(int doc) throws IOException {\n+        if (doc == 2) {\n+          throw new CollectionTerminatedException();\n+        }\n+        super.collect(doc);\n+      }\n+      \n+    };\n+\n+    Collector mc = MultiCollector.wrap(c1, c2);\n+    LeafCollector lc = mc.getLeafCollector(ctx);\n+    lc.setScorer(new ScoreAndDoc());\n+    lc.collect(0); // OK\n+    assertTrue(\"c1's collect should be called\", c1.collectCalled);\n+    assertTrue(\"c2's collect should be called\", c2.collectCalled);\n+    c1.collectCalled = false;\n+    c2.collectCalled = false;\n+    lc.collect(1); // OK, but c1 should terminate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0292e0a7581a322d347b478c3b8198ba8cbc63"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTc4NDc1", "url": "https://github.com/apache/lucene-solr/pull/1567#pullrequestreview-432978475", "createdAt": "2020-06-18T06:35:05Z", "commit": {"oid": "045d9c123ee13d6418419a4e8d553e56ff432f7d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44cdbab1fa1227658a789b6ce42145e9bd5e8bd0", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/44cdbab1fa1227658a789b6ce42145e9bd5e8bd0", "committedDate": "2020-06-18T17:01:38Z", "message": "Let MultiCollector handle minCompetitiveScore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eaf5d5dd8aa6e5eb8a33cf063ebabfe47cb2ca6", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/9eaf5d5dd8aa6e5eb8a33cf063ebabfe47cb2ca6", "committedDate": "2020-06-18T17:01:38Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d91ea09d199d03e0284819d8da9b4d6a2e82265", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/7d91ea09d199d03e0284819d8da9b4d6a2e82265", "committedDate": "2020-06-18T17:01:38Z", "message": "Add null checks in setScorer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee2683d30c34e10dda644ab39935a75e7a960fbc", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/ee2683d30c34e10dda644ab39935a75e7a960fbc", "committedDate": "2020-06-18T17:01:38Z", "message": "Add setScorer tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46f50ce15f754a4ca14941037096fad188e33fd", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/e46f50ce15f754a4ca14941037096fad188e33fd", "committedDate": "2020-06-18T17:09:24Z", "message": "Add CHANGES entry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "045d9c123ee13d6418419a4e8d553e56ff432f7d", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/045d9c123ee13d6418419a4e8d553e56ff432f7d", "committedDate": "2020-06-17T23:38:16Z", "message": "Add setScorer tests"}, "afterCommit": {"oid": "e46f50ce15f754a4ca14941037096fad188e33fd", "author": {"user": {"login": "tflobbe", "name": "Tomas Fernandez Lobbe"}}, "url": "https://github.com/apache/lucene-solr/commit/e46f50ce15f754a4ca14941037096fad188e33fd", "committedDate": "2020-06-18T17:09:24Z", "message": "Add CHANGES entry"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2601, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}