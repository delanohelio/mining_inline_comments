{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MDk2OTQ3", "number": 1948, "title": "LUCENE-9536: Optimize OrdinalMap when one segment contains all distinct values.", "bodyText": "For doc values that are not too high cardinality, it is common for some large\nsegments to contain all distinct values. In this case, we can check if the first\nsegment ords map perfectly to global ords, and if so store the global ord deltas\nand first segment indices as LongValues.ZEROES\nto save some space.", "createdAt": "2020-10-05T20:24:47Z", "url": "https://github.com/apache/lucene-solr/pull/1948", "merged": true, "mergeCommit": {"oid": "8f004f7a38947176eecf9056087311f39d7504d6"}, "closed": true, "closedAt": "2020-11-02T15:40:17Z", "author": {"login": "jtibshirani"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPoPgFAH2gAyNDk4MDk2OTQ3OjRmMjJjYmFiMDNkMTlmMmM4MjZkNmQ1OTE1ZDg2Y2VhMjk1N2Q2Y2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXokYXAFqTUyMDc3ODEyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/apache/lucene-solr/commit/4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "committedDate": "2020-10-05T18:39:14Z", "message": "LUCENE-9536: Optimize OrdinalMap when one segment contains all distinct values.\n\nFor doc values that are not too high cardinality, it is common for some large\nsegments to contain all distinct values. In this case, we can check if the first\nsegment ords map perfectly to global ords, and if so store the global ord deltas\nand first segment indices as `LongValues.ZEROES`\nto save some space."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTE0NzQx", "url": "https://github.com/apache/lucene-solr/pull/1948#pullrequestreview-507114741", "createdAt": "2020-10-13T06:48:16Z", "commit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjo0ODoxNlrOHgXqFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjo1MDo0MFrOHgXudg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNDA4NQ==", "bodyText": "We could ignore it completely from ramBytesUsed, since this singleton is allocated anyway, regardless of whether the optimization uses it.", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r503704085", "createdAt": "2020-10-13T06:48:16Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.\n+    if (ordDeltaBits.length > 0 && ordDeltaBits[0] == 0L && ordDeltas[0].size() == this.valueCount) {\n+      this.firstSegments = LongValues.ZEROES;\n+      this.globalOrdDeltas = LongValues.ZEROES;\n+      ramBytesUsed += RamUsageEstimator.shallowSizeOf(LongValues.ZEROES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNTIwNg==", "bodyText": "could be do something like if (firstSegments != LongValues.ZEROES) { resources.add(Accountables.namedAccountable(\"first segments\", firstSegments)); }?", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r503705206", "createdAt": "2020-10-13T06:50:40Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -359,10 +375,9 @@ public long ramBytesUsed() {\n   @Override\n   public Collection<Accountable> getChildResources() {\n     List<Accountable> resources = new ArrayList<>();\n-    resources.add(Accountables.namedAccountable(\"global ord deltas\", globalOrdDeltas));\n-    resources.add(Accountables.namedAccountable(\"first segments\", firstSegments));\n     resources.add(Accountables.namedAccountable(\"segment map\", segmentMap));\n-    // TODO: would be nice to return actual child segment deltas too, but the optimizations are confusing\n+    // TODO: would be nice to return the ordinal and segment maps too, but it's not straightforward\n+    //  because of optimizations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NTkwNjY1", "url": "https://github.com/apache/lucene-solr/pull/1948#pullrequestreview-508590665", "createdAt": "2020-10-14T17:50:58Z", "commit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzo1MDo1OFrOHhebsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzo1MToyMFrOHhecjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw==", "bodyText": "Hmm why only the first segment?  Couldn't it be the 3rd segment, in addition, that matches the global ords?\nEdit: ahh OK I understand now -- this opto is indeed specific to the first segment, so we can store this.firstSegments as all 0s.  Good!\nDo we (somewhere, couldn't find it here) pre-sort all segments by the cardinality descending?  Then we could know all segments that meet this optimization are at the start of the segments list, and possibly building the ordinal map is faster (not sure).  But then we would need to un-sort in the end to return the final OrdinalMap.  But it might enable this opto to apply more often, except, I think we would then need an additional dereference on lookup, hmm.\nDoes our PackedLongValues.monotonicBuilder already optimize for the case where it is all 0s, for the case where another segment (not the first) has all the global values as well?", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504863667", "createdAt": "2020-10-14T17:50:58Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.\n+    if (ordDeltaBits.length > 0 && ordDeltaBits[0] == 0L && ordDeltas[0].size() == this.valueCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2Mzg4Nw==", "bodyText": "Insert possessive quote (first segment's)?", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504863887", "createdAt": "2020-10-14T17:51:20Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55ac801915f0ff0f0b2dd11794af630d83d70c98", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/apache/lucene-solr/commit/55ac801915f0ff0f0b2dd11794af630d83d70c98", "committedDate": "2020-10-15T18:35:27Z", "message": "Omit static singleton from RAM estimate."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9d7b9433c7ee31d0ec9013bb760a7d571ae083b", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/apache/lucene-solr/commit/e9d7b9433c7ee31d0ec9013bb760a7d571ae083b", "committedDate": "2020-10-15T18:55:10Z", "message": "Clarify comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0330e3af31c286af1a553d6169248dfec7a0b98", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/apache/lucene-solr/commit/a0330e3af31c286af1a553d6169248dfec7a0b98", "committedDate": "2020-10-15T21:29:00Z", "message": "Add test that covers the optomization."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzc4MTI0", "url": "https://github.com/apache/lucene-solr/pull/1948#pullrequestreview-520778124", "createdAt": "2020-10-30T15:25:52Z", "commit": {"oid": "a0330e3af31c286af1a553d6169248dfec7a0b98"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNToyNTo1MlrOHrUFLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTozMToxNVrOHrUWZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3OTgyMA==", "bodyText": "Aha!  Sorry, I was indeed confused ;)\nThis is to enable \"retrieve BytesRef for this global ordinal\" use-case, right?  For that, we first pick a segment to use (the first one also containing that BytesRef), then map to its segment-local ordinal, then retrieve the BytesRef for that using the existing doc values API for that segment.\nWe do not (need to, nor) expose an API today to \"retrieve segment N's ordinal corresponding to global ordinal M\".  Only the reverse direction (segment N's ordinal M maps to global ordinal O).\nI think I understand now!", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515179820", "createdAt": "2020-10-30T15:25:52Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.\n+    if (ordDeltaBits.length > 0 && ordDeltaBits[0] == 0L && ordDeltas[0].size() == this.valueCount) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}, "originalCommit": {"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4NDIyOA==", "bodyText": "Does (would) https://issues.apache.org/jira/browse/LUCENE-9564 enforce import ordering check?", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515184228", "createdAt": "2020-10-30T15:31:15Z", "author": {"login": "mikemccand"}, "path": "lucene/core/src/test/org/apache/lucene/index/TestOrdinalMap.java", "diffHunk": "@@ -32,6 +28,10 @@\n import org.apache.lucene.util.RamUsageTester;\n import org.apache.lucene.util.TestUtil;\n \n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0330e3af31c286af1a553d6169248dfec7a0b98"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2679, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}