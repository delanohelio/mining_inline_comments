{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1ODg0Mjg1", "number": 2004, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDozMjo0OFrOEvWL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODowNjoyNFrOEv6cew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDgyMDMzOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDozMjo0OFrOHkRthw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MToxNVrOHk6vfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwMDk2Nw==", "bodyText": "How many contexts do we expect here. Does it actually make sense to do a parallel stream?", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r507800967", "createdAt": "2020-10-19T14:32:48Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1838,6 +1838,22 @@ private void checkStateInZk(CoreDescriptor cd) throws InterruptedException, NotI\n     }\n   }\n \n+  public void tryCancelAllElections() {\n+    if (zkClient.isClosed()) {\n+      return;\n+    }\n+    electionContexts.values().parallelStream().forEach(context -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3MzIxNQ==", "bodyText": "No, it does not. Parallelstream was being used for close in ZkController.close() as well so this was basically copied code. However I checked and it is a lightweight operation. It basically removes a zk node and sets a volatile member. I have replaced this call with a serial forEach in both places.\n@hossman pointed out that this iteration wasn't safe so I have put the forEach inside a synchronized block", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508473215", "createdAt": "2020-10-20T12:51:15Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1838,6 +1838,22 @@ private void checkStateInZk(CoreDescriptor cd) throws InterruptedException, NotI\n     }\n   }\n \n+  public void tryCancelAllElections() {\n+    if (zkClient.isClosed()) {\n+      return;\n+    }\n+    electionContexts.values().parallelStream().forEach(context -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwMDk2Nw=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDg2NjU0OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDo0MDo0MFrOHkSK_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MToyMlrOHk6vyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwODUxMQ==", "bodyText": "This is never used?", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r507808511", "createdAt": "2020-10-19T14:40:40Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3MzI5MA==", "bodyText": "Removed", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508473290", "createdAt": "2020-10-20T12:51:22Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwODUxMQ=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDg3MzEwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDo0MjoxOFrOHkSPfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTowMzoxNFrOHmcV7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTY2Mg==", "bodyText": "Do we need to check for termination?", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r507809662", "createdAt": "2020-10-19T14:42:18Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {\n+    this.pauseUpdateRequests.set(false);\n+  }\n+\n+  /**\n+   * Registers in-flight update requests to this core.\n+   *\n+   * @return true if request was registered, false if update requests are paused\n+   */\n+  public boolean registerInFlightUpdate() {\n+    if (pauseUpdateRequests.get()) {\n+      return false;\n+    }\n+    inflightUpdatesCounter.register();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3MzgxOA==", "bodyText": "According to the javadocs, register() is a no-op if phaser has terminated so we don't need to worry about it.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508473818", "createdAt": "2020-10-20T12:52:04Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {\n+    this.pauseUpdateRequests.set(false);\n+  }\n+\n+  /**\n+   * Registers in-flight update requests to this core.\n+   *\n+   * @return true if request was registered, false if update requests are paused\n+   */\n+  public boolean registerInFlightUpdate() {\n+    if (pauseUpdateRequests.get()) {\n+      return false;\n+    }\n+    inflightUpdatesCounter.register();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTY2Mg=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NjU5MA==", "bodyText": "Should we return an error in this case? Does termination imply that the core is closed?", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508586590", "createdAt": "2020-10-20T15:02:25Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {\n+    this.pauseUpdateRequests.set(false);\n+  }\n+\n+  /**\n+   * Registers in-flight update requests to this core.\n+   *\n+   * @return true if request was registered, false if update requests are paused\n+   */\n+  public boolean registerInFlightUpdate() {\n+    if (pauseUpdateRequests.get()) {\n+      return false;\n+    }\n+    inflightUpdatesCounter.register();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTY2Mg=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MTQxMA==", "bodyText": "Maybe return inflightUpdatesCounter.register() > 0? Or >=, I'm not sure.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508591410", "createdAt": "2020-10-20T15:08:32Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {\n+    this.pauseUpdateRequests.set(false);\n+  }\n+\n+  /**\n+   * Registers in-flight update requests to this core.\n+   *\n+   * @return true if request was registered, false if update requests are paused\n+   */\n+  public boolean registerInFlightUpdate() {\n+    if (pauseUpdateRequests.get()) {\n+      return false;\n+    }\n+    inflightUpdatesCounter.register();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTY2Mg=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3MjMwMg==", "bodyText": "Thanks for bringing my attention to termination. The usage of the phaser was wrong before because it would get terminated the moment there were no in-flight requests. We actually never need to terminate the phaser at all. Now, we override onAdvance() and disable termination such that the phase keeps advancing and wraps around after reaching 65536.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r510072302", "createdAt": "2020-10-22T11:03:14Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();\n+    }\n+  }\n+\n+  /**\n+   * Unpauses update requests to this core\n+   */\n+  public void unpauseUpdates() {\n+    this.pauseUpdateRequests.set(false);\n+  }\n+\n+  /**\n+   * Registers in-flight update requests to this core.\n+   *\n+   * @return true if request was registered, false if update requests are paused\n+   */\n+  public boolean registerInFlightUpdate() {\n+    if (pauseUpdateRequests.get()) {\n+      return false;\n+    }\n+    inflightUpdatesCounter.register();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTY2Mg=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDk0MTYwOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDo1NToyMVrOHkS4uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MzoxOVrOHk61fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgyMDIxOQ==", "bodyText": "This is in the shutdown path, should we add a timeout? What happens if a disk is slow on write and something else times out underneath us?", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r507820219", "createdAt": "2020-10-19T14:55:21Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3NDc0OQ==", "bodyText": "Good point. I have added a small timeout (2500 ms) with the same value as the one used inside RecoveryStrategy for leader to finish in-flight requests. I think this default should be enough but it can be changed using a sysprop if needed.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508474749", "createdAt": "2020-10-20T12:53:19Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/update/SolrCoreState.java", "diffHunk": "@@ -86,7 +103,45 @@ public boolean decrefSolrCoreState(IndexWriterCloser closer) {\n     }\n     return close;\n   }\n-  \n+\n+  /**\n+   * Pauses all update requests to this core and waits (indefinitely) for all in-flight\n+   * update requests to finish\n+   */\n+  public void pauseUpdatesAndAwaitInflightRequests() {\n+    if (pauseUpdateRequests.compareAndSet(false, true)) {\n+      inflightUpdatesCounter.register();\n+      inflightUpdatesCounter.arriveAndAwaitAdvance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgyMDIxOQ=="}, "originalCommit": {"oid": "250da57bb50cd51423a01d91848c5f5afae7415d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTg2MjM4OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/core/CoreContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTowMzo1NVrOHlBu9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNTowMzo1NVrOHlBu9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4Nzc2Nw==", "bodyText": "Please check your IDE settings to not collapse imports like this.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508587767", "createdAt": "2020-10-20T15:03:55Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/core/CoreContainer.java", "diffHunk": "@@ -38,10 +38,7 @@\n import java.util.Properties;\n import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n+import java.util.concurrent.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a8ae69bcb6f49d2f7f38fca915d9000cc675e97"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njc2MDkxOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODowNjoyNFrOHlKpag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMDo1ODoyMlrOHmcLdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMzgwMg==", "bodyText": "While we're here, this line (and a few others) should be customThreadPool.submit(() -> IOUtils.closeQuietly(overseer); I have no idea why we're creating a collection and a stream for a single object.", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r508733802", "createdAt": "2020-10-20T18:06:24Z", "author": {"login": "madrob"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -653,7 +653,12 @@ public void close() {\n     customThreadPool.submit(() -> Collections.singleton(overseer).parallelStream().forEach(IOUtils::closeQuietly));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a8ae69bcb6f49d2f7f38fca915d9000cc675e97"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA2OTYyMw==", "bodyText": "I have cleaned it up", "url": "https://github.com/apache/lucene-solr/pull/2004#discussion_r510069623", "createdAt": "2020-10-22T10:58:22Z", "author": {"login": "shalinmangar"}, "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -653,7 +653,12 @@ public void close() {\n     customThreadPool.submit(() -> Collections.singleton(overseer).parallelStream().forEach(IOUtils::closeQuietly));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMzgwMg=="}, "originalCommit": {"oid": "0a8ae69bcb6f49d2f7f38fca915d9000cc675e97"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1165, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}