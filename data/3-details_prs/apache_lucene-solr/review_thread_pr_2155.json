{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxOTEyNTc2", "number": 2155, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODoxOTo0N1rOFH41Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODozNTo1OFrOFH5Hrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODE1NDY2OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODoxOTo0N1rOIJhkIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODowNzoyNFrOIPQnVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ==", "bodyText": "It doesn't make sense for LatLonPointQuery to search for Points that contain any geometry other than points. I'd throw an exception if the incoming geometry type is not a point or array of points.", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r546858019", "createdAt": "2020-12-21T18:19:47Z", "author": {"login": "nknize"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;\n+    }\n+    final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n+    // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n+    final byte[] minLat = new byte[Integer.BYTES];\n+    final byte[] maxLat = new byte[Integer.BYTES];\n+    final byte[] minLon = new byte[Integer.BYTES];\n+    final byte[] maxLon = new byte[Integer.BYTES];\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMinY()), minLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMaxY()), maxLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMinX()), minLon, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMaxX()), maxLon, 0);\n+    \n+    return new SpatialVisitor() {\n+      @Override\n+      protected Relation relate(byte[] minPackedValue, byte[] maxPackedValue) {\n+        if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n+                Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n+          // outside of global bounding box range\n+          return Relation.CELL_OUTSIDE_QUERY;\n+        }\n+\n+        double cellMinLat = decodeLatitude(minPackedValue, 0);\n+        double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n+        double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n+        double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n+\n+        return component2D.relate(cellMinLon, cellMaxLon, cellMinLat, cellMaxLat);\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> intersects() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> within() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Function<byte[], Component2D.WithinRelation> contains() {\n+        return packedValue -> component2D.withinPoint(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NjU2NA==", "bodyText": "Make sense and makes implementation cleaner. Still I return a MatchNoDocs query for the Query builders. Change is in 3e97bb8.", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r547166564", "createdAt": "2020-12-22T09:28:47Z", "author": {"login": "iverase"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;\n+    }\n+    final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n+    // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n+    final byte[] minLat = new byte[Integer.BYTES];\n+    final byte[] maxLat = new byte[Integer.BYTES];\n+    final byte[] minLon = new byte[Integer.BYTES];\n+    final byte[] maxLon = new byte[Integer.BYTES];\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMinY()), minLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMaxY()), maxLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMinX()), minLon, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMaxX()), maxLon, 0);\n+    \n+    return new SpatialVisitor() {\n+      @Override\n+      protected Relation relate(byte[] minPackedValue, byte[] maxPackedValue) {\n+        if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n+                Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n+          // outside of global bounding box range\n+          return Relation.CELL_OUTSIDE_QUERY;\n+        }\n+\n+        double cellMinLat = decodeLatitude(minPackedValue, 0);\n+        double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n+        double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n+        double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n+\n+        return component2D.relate(cellMinLon, cellMaxLon, cellMinLat, cellMaxLat);\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> intersects() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> within() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Function<byte[], Component2D.WithinRelation> contains() {\n+        return packedValue -> component2D.withinPoint(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ=="}, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg3MTc2Ng==", "bodyText": "This looks good!", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r552871766", "createdAt": "2021-01-06T18:07:24Z", "author": {"login": "nknize"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;\n+    }\n+    final GeoEncodingUtils.Component2DPredicate component2DPredicate = GeoEncodingUtils.createComponentPredicate(component2D);\n+    // bounding box over all geometries, this can speed up tree intersection/cheaply improve approximation for complex multi-geometries\n+    final byte[] minLat = new byte[Integer.BYTES];\n+    final byte[] maxLat = new byte[Integer.BYTES];\n+    final byte[] minLon = new byte[Integer.BYTES];\n+    final byte[] maxLon = new byte[Integer.BYTES];\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMinY()), minLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLatitude(component2D.getMaxY()), maxLat, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMinX()), minLon, 0);\n+    NumericUtils.intToSortableBytes(encodeLongitude(component2D.getMaxX()), maxLon, 0);\n+    \n+    return new SpatialVisitor() {\n+      @Override\n+      protected Relation relate(byte[] minPackedValue, byte[] maxPackedValue) {\n+        if (Arrays.compareUnsigned(minPackedValue, 0, Integer.BYTES, maxLat, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, 0, Integer.BYTES, minLat, 0, Integer.BYTES) < 0 ||\n+                Arrays.compareUnsigned(minPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, maxLon, 0, Integer.BYTES) > 0 ||\n+                Arrays.compareUnsigned(maxPackedValue, Integer.BYTES, Integer.BYTES + Integer.BYTES, minLon, 0, Integer.BYTES) < 0) {\n+          // outside of global bounding box range\n+          return Relation.CELL_OUTSIDE_QUERY;\n+        }\n+\n+        double cellMinLat = decodeLatitude(minPackedValue, 0);\n+        double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n+        double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n+        double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n+\n+        return component2D.relate(cellMinLon, cellMaxLon, cellMinLat, cellMaxLat);\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> intersects() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Predicate<byte[]> within() {\n+        return packedValue -> component2DPredicate.test(NumericUtils.sortableBytesToInt(packedValue, 0),\n+                NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES));\n+      }\n+\n+      @Override\n+      protected Function<byte[], Component2D.WithinRelation> contains() {\n+        return packedValue -> component2D.withinPoint(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1ODAxOQ=="}, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODIwMjA3OnYy", "diffSide": "RIGHT", "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxODozNTo1OFrOIJiAWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODowNzowNVrOIPQmlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw==", "bodyText": "I feel like there should be a better way of handling this. This has the look and feel of silent ignorance; that the encoding allowed something that doesn't make sense. I think we should do a better job handling this upstream instead of creating a visitor that looks the other way on such oddities.", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r546865243", "createdAt": "2020-12-21T18:35:58Z", "author": {"login": "nknize"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NTgxOA==", "bodyText": "The problem was in the way the component predicate is built. I have another thought and I think I push a better solution in 1cebeff", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r547165818", "createdAt": "2020-12-22T09:27:32Z", "author": {"login": "iverase"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw=="}, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg3MTU3NQ==", "bodyText": "\ud83d\udc4d  Much cleaner.", "url": "https://github.com/apache/lucene-solr/pull/2155#discussion_r552871575", "createdAt": "2021-01-06T18:07:05Z", "author": {"login": "nknize"}, "path": "lucene/core/src/java/org/apache/lucene/document/LatLonPointQuery.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.document;\n+\n+import org.apache.lucene.document.ShapeField.QueryRelation;\n+import org.apache.lucene.geo.Component2D;\n+import org.apache.lucene.geo.GeoEncodingUtils;\n+import org.apache.lucene.geo.LatLonGeometry;\n+import org.apache.lucene.geo.Line;\n+import org.apache.lucene.index.PointValues.Relation;\n+import org.apache.lucene.util.NumericUtils;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;\n+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;\n+\n+/**\n+ * Finds all previously indexed geo points that comply the given {@link QueryRelation} with\n+ * the specified array of {@link LatLonGeometry}.\n+ *\n+ * <p>The field must be indexed using one or more {@link LatLonPoint} added per document.\n+ *\n+ **/\n+final class LatLonPointQuery extends SpatialQuery {\n+  final private LatLonGeometry[] geometries;\n+  final private Component2D component2D;\n+  \n+  /**\n+   * Creates a query that matches all indexed shapes to the provided array of {@link LatLonGeometry}\n+   */\n+  LatLonPointQuery(String field, QueryRelation queryRelation, LatLonGeometry... geometries) {\n+    super(field, queryRelation);\n+    if (queryRelation == QueryRelation.WITHIN) {\n+      for (LatLonGeometry geometry : geometries) {\n+        if (geometry instanceof Line) {\n+          // TODO: line queries do not support within relations\n+          throw new IllegalArgumentException(\"LatLonPointQuery does not support \" + QueryRelation.WITHIN + \" queries with line geometries\");\n+        }\n+      }\n+    }\n+    this.component2D = LatLonGeometry.create(geometries);\n+    this.geometries = geometries.clone();\n+  }\n+  \n+  @Override\n+  protected SpatialVisitor getSpatialVisitor() {\n+    if (component2D.getMinY() > component2D.getMaxY()) {\n+      // encodeLatitudeCeil may cause minY to be > maxY iff\n+      // the delta between the longitude < the encoding resolution\n+      return EMPTYVISITOR;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NTI0Mw=="}, "originalCommit": {"oid": "e1b1551e0bae0f70aaf95beae70a8d519d1180e2"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1001, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}