{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMjAwOTg0", "number": 2110, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowOTo1OFrOE_Hznw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowOTo1OVrOE_Hzrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjIzNjQ3OnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cluster/placement/plugins/AffinityPlacementFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowOTo1OFrOH8px1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoxODoxNlrOH8qDxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MTEwOQ==", "bodyText": "PREDICTABLE_RANDOM:  This random generator (java.util.Random) is predictable (details)", "url": "https://github.com/apache/lucene-solr/pull/2110#discussion_r533361109", "createdAt": "2020-12-01T12:09:58Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cluster/placement/plugins/AffinityPlacementFactory.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.cluster.placement.plugins;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.solr.cluster.*;\n+import org.apache.solr.cluster.placement.*;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.SuppressForbidden;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>This factory is instantiated by config from its class name. Using it is the only way to create instances of\n+ * {@link AffinityPlacementPlugin}.</p>\n+ *\n+ * <p>In order to configure this plugin to be used for placement decisions, the following {@code curl} command (or something\n+ * equivalent) has to be executed once the cluster is already running in order to set\n+ * the appropriate Zookeeper stored configuration. Replace {@code localhost:8983} by one of your servers' IP address and port.</p>\n+ *\n+ * <pre>\n+ *\n+ * curl -X POST -H 'Content-type:application/json' -d '{\n+ * \"set-placement-plugin\": {\n+ * \"class\": \"org.apache.solr.cluster.placement.plugins.AffinityPlacementFactory\",\n+ * \"minimalFreeDiskGB\": 10,\n+ * \"prioritizedFreeDiskGB\": 50\n+ * }\n+ * }' http://localhost:8983/api/cluster\n+ * </pre>\n+ *\n+ * <p>The consequence will be the creation of an element in the Zookeeper file {@code /clusterprops.json} as follows:</p>\n+ *\n+ * <pre>\n+ *\n+ * \"placement-plugin\":{\n+ *     \"class\":\"org.apache.solr.cluster.placement.plugins.AffinityPlacementFactory\",\n+ *     \"minimalFreeDiskGB\":10,\n+ *     \"prioritizedFreeDiskGB\":50}\n+ * </pre>\n+ *\n+ * <p>In order to delete the placement-plugin section from {@code /clusterprops.json} (and to fallback to either Legacy\n+ * or rule based placement if configured for a collection), execute:</p>\n+ *\n+ * <pre>\n+ *\n+ * curl -X POST -H 'Content-type:application/json' -d '{\n+ * \"set-placement-plugin\" : null\n+ * }' http://localhost:8983/api/cluster\n+ * </pre>\n+ *\n+ *\n+ * <p>{@link AffinityPlacementPlugin} implements placing replicas in a way that replicate past Autoscaling config defined\n+ * <a href=\"https://github.com/lucidworks/fusion-cloud-native/blob/master/policy.json#L16\">here</a>.</p>\n+ *\n+ * <p>This specification is doing the following:\n+ * <p><i>Spread replicas per shard as evenly as possible across multiple availability zones (given by a sys prop),\n+ * assign replicas based on replica type to specific kinds of nodes (another sys prop), and avoid having more than\n+ * one replica per shard on the same node.<br>\n+ * Only after these constraints are satisfied do minimize cores per node or disk usage.</i></p>\n+ *\n+ * <p>Overall strategy of this plugin:</p>\n+ * <ul><li>\n+ *     The set of nodes in the cluster is obtained and transformed into 3 independent sets (that can overlap) of nodes\n+ *     accepting each of the three replica types.\n+ * </li><li>\n+ *     For each shard on which placing replicas is required and then for each replica type to place (starting with NRT,\n+ *     then TLOG then PULL): <ul>\n+ *         <li>The set of candidates nodes corresponding to the replica type is used and from that set are removed nodes\n+ *         that already have a replica (of any type) for that shard</li>\n+ *         <li>If there are not enough nodes, an error is thrown (this is checked further down during processing).</li>\n+ *         <li>The number of (already existing) replicas of the current type on each Availability Zone is collected.</li>\n+ *         <li>Separate the set of available nodes to as many subsets (possibly some are empty) as there are Availability Zones\n+ *         defined for the candidate nodes</li>\n+ *         <li>In each AZ nodes subset, sort the nodes by increasing total number of cores count, with possibly a condition\n+ *         that pushes nodes with low disk space to the end of the list? Or a weighted combination of the relative\n+ *         importance of these two factors? Some randomization? Marking as non available nodes with not enough disk space?\n+ *         These and other are likely aspects to be played with once the plugin is tested or observed to be running in prod,\n+ *         don't expect the initial code drop(s) to do all of that.</li>\n+ *         <li>Iterate over the number of replicas to place (for the current replica type for the current shard):\n+ *         <ul>\n+ *             <li>Based on the number of replicas per AZ collected previously, pick the non empty set of nodes having the\n+ *             lowest number of replicas. Then pick the first node in that set. That's the node the replica is placed one.\n+ *             Remove the node from the set of available nodes for the given AZ and increase the number of replicas placed\n+ *             on that AZ.</li>\n+ *         </ul></li>\n+ *         <li>During this process, the number of cores on the nodes in general is tracked to take into account placement\n+ *         decisions so that not all shards decide to put their replicas on the same nodes (they might though if these are\n+ *         the less loaded nodes).</li>\n+ *     </ul>\n+ * </li>\n+ * </ul>\n+ *\n+ * <p>This code is a realistic placement computation, based on a few assumptions. The code is written in such a way to\n+ * make it relatively easy to adapt it to (somewhat) different assumptions. Configuration options could be introduced\n+ * to allow configuration base option selection as well...</p>\n+ */\n+public class AffinityPlacementFactory implements PlacementPluginFactory {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  /**\n+   * <p>Name of the system property on a node indicating which (public cloud) Availability Zone that node is in. The value\n+   * is any string, different strings denote different availability zones.\n+   *\n+   * <p>Nodes on which this system property is not defined are considered being in the same Availability Zone\n+   * {@link #UNDEFINED_AVAILABILITY_ZONE} (hopefully the value of this constant is not the name of a real Availability Zone :).\n+   */\n+  public static final String AVAILABILITY_ZONE_SYSPROP = \"availability_zone\";\n+\n+  /**\n+   * <p>Name of the system property on a node indicating the type of replicas allowed on that node.\n+   * The value of that system property is a comma separated list or a single string of value names of\n+   * {@link org.apache.solr.cluster.Replica.ReplicaType} (case insensitive). If that property is not defined, that node is\n+   * considered accepting all replica types (i.e. undefined is equivalent to {@code \"NRT,Pull,tlog\"}).\n+   */\n+  public static final String REPLICA_TYPE_SYSPROP = \"replica_type\";\n+\n+  /**\n+   * This is the \"AZ\" name for nodes that do not define an AZ. Should not match a real AZ name (I think we're safe)\n+   */\n+  public static final String UNDEFINED_AVAILABILITY_ZONE = \"uNd3f1NeD\";\n+\n+  /**\n+   * If a node has strictly less GB of free disk than this value, the node is excluded from assignment decisions.\n+   * Set to 0 or less to disable.\n+   */\n+  public static final String MINIMAL_FREE_DISK_GB = \"minimalFreeDiskGB\";\n+\n+  /**\n+   * Replica allocation will assign replicas to nodes with at least this number of GB of free disk space regardless\n+   * of the number of cores on these nodes rather than assigning replicas to nodes with less than this amount of free\n+   * disk space if that's an option (if that's not an option, replicas can still be assigned to nodes with less than this\n+   * amount of free space).\n+   */\n+  public static final String PRIORITIZED_FREE_DISK_GB = \"prioritizedFreeDiskGB\";\n+\n+  /**\n+   * Empty public constructor is used to instantiate this factory. Using a factory pattern to allow the factory to do one\n+   * time costly operations if needed, and to only have to instantiate a default constructor class by name, rather than\n+   * having to call a constructor with more parameters (if we were to instantiate the plugin class directly without going\n+   * through a factory).\n+   */\n+  public AffinityPlacementFactory() {\n+  }\n+\n+  @Override\n+  public PlacementPlugin createPluginInstance(PlacementPluginConfig config) {\n+    final long minimalFreeDiskGB = config.getLongConfig(MINIMAL_FREE_DISK_GB, 20L);\n+    final long prioritizedFreeDiskGB = config.getLongConfig(PRIORITIZED_FREE_DISK_GB, 100L);\n+    return new AffinityPlacementPlugin(minimalFreeDiskGB, prioritizedFreeDiskGB);\n+  }\n+\n+  /**\n+   * See {@link AffinityPlacementFactory} for instructions on how to configure a cluster to use this plugin and details\n+   * on what the plugin does.\n+   */\n+  static class AffinityPlacementPlugin implements PlacementPlugin {\n+\n+    private final long minimalFreeDiskGB;\n+\n+    private final long prioritizedFreeDiskGB;\n+\n+    private Random random = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506e47cecb4b2610d2b2a9ea17a9ee3db096d1f7"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2NTcwMQ==", "bodyText": "This doesn't solve the issue but helps with tests, and it's a better method than adding a setter on AffinityPlacementPluginFactory:\n  static {\n    // We try to make things reproducible in the context of our tests by initializing the random instance\n    // based on the current seed\n    String seed = System.getProperty(\"tests.seed\");\n    if (seed == null) {\n      RANDOM = new Random();\n    } else {\n      RANDOM = new Random(seed.hashCode());\n    }\n  }\n\n(borrowed from OCMH)", "url": "https://github.com/apache/lucene-solr/pull/2110#discussion_r533365701", "createdAt": "2020-12-01T12:18:16Z", "author": {"login": "sigram"}, "path": "solr/core/src/java/org/apache/solr/cluster/placement/plugins/AffinityPlacementFactory.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.cluster.placement.plugins;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.solr.cluster.*;\n+import org.apache.solr.cluster.placement.*;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.SuppressForbidden;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>This factory is instantiated by config from its class name. Using it is the only way to create instances of\n+ * {@link AffinityPlacementPlugin}.</p>\n+ *\n+ * <p>In order to configure this plugin to be used for placement decisions, the following {@code curl} command (or something\n+ * equivalent) has to be executed once the cluster is already running in order to set\n+ * the appropriate Zookeeper stored configuration. Replace {@code localhost:8983} by one of your servers' IP address and port.</p>\n+ *\n+ * <pre>\n+ *\n+ * curl -X POST -H 'Content-type:application/json' -d '{\n+ * \"set-placement-plugin\": {\n+ * \"class\": \"org.apache.solr.cluster.placement.plugins.AffinityPlacementFactory\",\n+ * \"minimalFreeDiskGB\": 10,\n+ * \"prioritizedFreeDiskGB\": 50\n+ * }\n+ * }' http://localhost:8983/api/cluster\n+ * </pre>\n+ *\n+ * <p>The consequence will be the creation of an element in the Zookeeper file {@code /clusterprops.json} as follows:</p>\n+ *\n+ * <pre>\n+ *\n+ * \"placement-plugin\":{\n+ *     \"class\":\"org.apache.solr.cluster.placement.plugins.AffinityPlacementFactory\",\n+ *     \"minimalFreeDiskGB\":10,\n+ *     \"prioritizedFreeDiskGB\":50}\n+ * </pre>\n+ *\n+ * <p>In order to delete the placement-plugin section from {@code /clusterprops.json} (and to fallback to either Legacy\n+ * or rule based placement if configured for a collection), execute:</p>\n+ *\n+ * <pre>\n+ *\n+ * curl -X POST -H 'Content-type:application/json' -d '{\n+ * \"set-placement-plugin\" : null\n+ * }' http://localhost:8983/api/cluster\n+ * </pre>\n+ *\n+ *\n+ * <p>{@link AffinityPlacementPlugin} implements placing replicas in a way that replicate past Autoscaling config defined\n+ * <a href=\"https://github.com/lucidworks/fusion-cloud-native/blob/master/policy.json#L16\">here</a>.</p>\n+ *\n+ * <p>This specification is doing the following:\n+ * <p><i>Spread replicas per shard as evenly as possible across multiple availability zones (given by a sys prop),\n+ * assign replicas based on replica type to specific kinds of nodes (another sys prop), and avoid having more than\n+ * one replica per shard on the same node.<br>\n+ * Only after these constraints are satisfied do minimize cores per node or disk usage.</i></p>\n+ *\n+ * <p>Overall strategy of this plugin:</p>\n+ * <ul><li>\n+ *     The set of nodes in the cluster is obtained and transformed into 3 independent sets (that can overlap) of nodes\n+ *     accepting each of the three replica types.\n+ * </li><li>\n+ *     For each shard on which placing replicas is required and then for each replica type to place (starting with NRT,\n+ *     then TLOG then PULL): <ul>\n+ *         <li>The set of candidates nodes corresponding to the replica type is used and from that set are removed nodes\n+ *         that already have a replica (of any type) for that shard</li>\n+ *         <li>If there are not enough nodes, an error is thrown (this is checked further down during processing).</li>\n+ *         <li>The number of (already existing) replicas of the current type on each Availability Zone is collected.</li>\n+ *         <li>Separate the set of available nodes to as many subsets (possibly some are empty) as there are Availability Zones\n+ *         defined for the candidate nodes</li>\n+ *         <li>In each AZ nodes subset, sort the nodes by increasing total number of cores count, with possibly a condition\n+ *         that pushes nodes with low disk space to the end of the list? Or a weighted combination of the relative\n+ *         importance of these two factors? Some randomization? Marking as non available nodes with not enough disk space?\n+ *         These and other are likely aspects to be played with once the plugin is tested or observed to be running in prod,\n+ *         don't expect the initial code drop(s) to do all of that.</li>\n+ *         <li>Iterate over the number of replicas to place (for the current replica type for the current shard):\n+ *         <ul>\n+ *             <li>Based on the number of replicas per AZ collected previously, pick the non empty set of nodes having the\n+ *             lowest number of replicas. Then pick the first node in that set. That's the node the replica is placed one.\n+ *             Remove the node from the set of available nodes for the given AZ and increase the number of replicas placed\n+ *             on that AZ.</li>\n+ *         </ul></li>\n+ *         <li>During this process, the number of cores on the nodes in general is tracked to take into account placement\n+ *         decisions so that not all shards decide to put their replicas on the same nodes (they might though if these are\n+ *         the less loaded nodes).</li>\n+ *     </ul>\n+ * </li>\n+ * </ul>\n+ *\n+ * <p>This code is a realistic placement computation, based on a few assumptions. The code is written in such a way to\n+ * make it relatively easy to adapt it to (somewhat) different assumptions. Configuration options could be introduced\n+ * to allow configuration base option selection as well...</p>\n+ */\n+public class AffinityPlacementFactory implements PlacementPluginFactory {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  /**\n+   * <p>Name of the system property on a node indicating which (public cloud) Availability Zone that node is in. The value\n+   * is any string, different strings denote different availability zones.\n+   *\n+   * <p>Nodes on which this system property is not defined are considered being in the same Availability Zone\n+   * {@link #UNDEFINED_AVAILABILITY_ZONE} (hopefully the value of this constant is not the name of a real Availability Zone :).\n+   */\n+  public static final String AVAILABILITY_ZONE_SYSPROP = \"availability_zone\";\n+\n+  /**\n+   * <p>Name of the system property on a node indicating the type of replicas allowed on that node.\n+   * The value of that system property is a comma separated list or a single string of value names of\n+   * {@link org.apache.solr.cluster.Replica.ReplicaType} (case insensitive). If that property is not defined, that node is\n+   * considered accepting all replica types (i.e. undefined is equivalent to {@code \"NRT,Pull,tlog\"}).\n+   */\n+  public static final String REPLICA_TYPE_SYSPROP = \"replica_type\";\n+\n+  /**\n+   * This is the \"AZ\" name for nodes that do not define an AZ. Should not match a real AZ name (I think we're safe)\n+   */\n+  public static final String UNDEFINED_AVAILABILITY_ZONE = \"uNd3f1NeD\";\n+\n+  /**\n+   * If a node has strictly less GB of free disk than this value, the node is excluded from assignment decisions.\n+   * Set to 0 or less to disable.\n+   */\n+  public static final String MINIMAL_FREE_DISK_GB = \"minimalFreeDiskGB\";\n+\n+  /**\n+   * Replica allocation will assign replicas to nodes with at least this number of GB of free disk space regardless\n+   * of the number of cores on these nodes rather than assigning replicas to nodes with less than this amount of free\n+   * disk space if that's an option (if that's not an option, replicas can still be assigned to nodes with less than this\n+   * amount of free space).\n+   */\n+  public static final String PRIORITIZED_FREE_DISK_GB = \"prioritizedFreeDiskGB\";\n+\n+  /**\n+   * Empty public constructor is used to instantiate this factory. Using a factory pattern to allow the factory to do one\n+   * time costly operations if needed, and to only have to instantiate a default constructor class by name, rather than\n+   * having to call a constructor with more parameters (if we were to instantiate the plugin class directly without going\n+   * through a factory).\n+   */\n+  public AffinityPlacementFactory() {\n+  }\n+\n+  @Override\n+  public PlacementPlugin createPluginInstance(PlacementPluginConfig config) {\n+    final long minimalFreeDiskGB = config.getLongConfig(MINIMAL_FREE_DISK_GB, 20L);\n+    final long prioritizedFreeDiskGB = config.getLongConfig(PRIORITIZED_FREE_DISK_GB, 100L);\n+    return new AffinityPlacementPlugin(minimalFreeDiskGB, prioritizedFreeDiskGB);\n+  }\n+\n+  /**\n+   * See {@link AffinityPlacementFactory} for instructions on how to configure a cluster to use this plugin and details\n+   * on what the plugin does.\n+   */\n+  static class AffinityPlacementPlugin implements PlacementPlugin {\n+\n+    private final long minimalFreeDiskGB;\n+\n+    private final long prioritizedFreeDiskGB;\n+\n+    private Random random = new Random();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MTEwOQ=="}, "originalCommit": {"oid": "506e47cecb4b2610d2b2a9ea17a9ee3db096d1f7"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjIzNjYyOnYy", "diffSide": "RIGHT", "path": "solr/core/src/java/org/apache/solr/cluster/placement/plugins/RandomPlacementFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowOTo1OVrOH8px6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowOTo1OVrOH8px6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MTEyOA==", "bodyText": "PREDICTABLE_RANDOM:  This random generator (java.util.Random) is predictable (details)", "url": "https://github.com/apache/lucene-solr/pull/2110#discussion_r533361128", "createdAt": "2020-12-01T12:09:59Z", "author": {"login": "sonatype-lift"}, "path": "solr/core/src/java/org/apache/solr/cluster/placement/plugins/RandomPlacementFactory.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.cluster.placement.plugins;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.solr.cluster.Cluster;\n+import org.apache.solr.cluster.Node;\n+import org.apache.solr.cluster.Replica;\n+import org.apache.solr.cluster.SolrCollection;\n+import org.apache.solr.cluster.placement.*;\n+\n+/**\n+ * <p>Factory for creating {@link RandomPlacementPlugin}, a placement plugin implementing random placement for new\n+ * collection creation while preventing two replicas of same shard from being placed on same node..</p>\n+ *\n+ * <p>See {@link AffinityPlacementFactory} for a more realistic example and documentation.</p>\n+ */\n+public class RandomPlacementFactory implements PlacementPluginFactory {\n+\n+  @Override\n+  public PlacementPlugin createPluginInstance(PlacementPluginConfig config) {\n+    return new RandomPlacementPlugin();\n+  }\n+\n+  public static class RandomPlacementPlugin implements PlacementPlugin {\n+    private Random random = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506e47cecb4b2610d2b2a9ea17a9ee3db096d1f7"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1095, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}