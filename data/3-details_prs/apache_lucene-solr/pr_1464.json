{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMjM4MDI4", "number": 1464, "title": "LUCENE-9087: Build always trees with full leaves and lower the default value for maxPointsPerLeafNode", "bodyText": "This commit changes the logic used to build BKD trees to always construct trees with full leaves (except the last one). This change gives more control in the expected behaviour of the tree. In addition the special logic the we have for 1D trees constructs the same type of trees, therefore removing some discrepancy.\nIn addition, this commit lowers the default for maxPointsPerLeafNode from 1024 to 512 and simplifies the logic for rotating tree leaves.", "createdAt": "2020-04-28T16:47:40Z", "url": "https://github.com/apache/lucene-solr/pull/1464", "merged": true, "mergeCommit": {"oid": "96c47bc8508142b5bd11d2cdc492df380801efec"}, "closed": true, "closedAt": "2020-05-02T09:34:20Z", "author": {"login": "iverase"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbvNAfgH2gAyNDEwMjM4MDI4OjkwMGY0MTJjZjgxYzA3ZGJmMDM2NzMwMTIxNzc4NmQwZTQ3NDdkZGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdSrP8gH2gAyNDEwMjM4MDI4OmZkYzU0NDFmOWNmOGZiYjRlZWQxM2I0NzAwYjE1MTliN2RiNzRhZjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "900f412cf81c07dbf0367301217786d0e4747ddd", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/900f412cf81c07dbf0367301217786d0e4747ddd", "committedDate": "2020-04-27T13:21:47Z", "message": "change construction logic of the BKD tree to always build unbalanced trees with fully populated leaves."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c368f3bd7527b5eeab093f46ca45729348d49e36", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/c368f3bd7527b5eeab093f46ca45729348d49e36", "committedDate": "2020-04-28T14:11:12Z", "message": "Simplify logic to distribute points for avery recursion. Fix test bug."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2eb5c1aab5b38eec6ab856affb38ca86484c42", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/9f2eb5c1aab5b38eec6ab856affb38ca86484c42", "committedDate": "2020-04-28T16:19:55Z", "message": "Simplify logic for rotating leaves"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11ac8d4d1e673e12164d013254ddca8c296b9f0c", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/11ac8d4d1e673e12164d013254ddca8c296b9f0c", "committedDate": "2020-04-28T16:24:50Z", "message": "lower the default for maxPointsInLeafNode to 512"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c72768899fc84d7a3fc4259dece17187e33d465", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/7c72768899fc84d7a3fc4259dece17187e33d465", "committedDate": "2020-04-28T17:51:31Z", "message": "fail failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46d4fb062b296f0cae27749bd8b93db2b956199f", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/46d4fb062b296f0cae27749bd8b93db2b956199f", "committedDate": "2020-04-28T18:17:23Z", "message": "simplify slightly how we distribute unbalanced nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "580a9ba5bf57f6cacf9f61bad07ec4ce0334030f", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/580a9ba5bf57f6cacf9f61bad07ec4ce0334030f", "committedDate": "2020-04-28T18:40:11Z", "message": "small simplification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4e758dedf0e110b3d70c8b69350ebc9edd337e0", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/e4e758dedf0e110b3d70c8b69350ebc9edd337e0", "committedDate": "2020-04-29T05:31:42Z", "message": "remove duplicated comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "805e39a41a7236ac36265096e95872b46b493908", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/805e39a41a7236ac36265096e95872b46b493908", "committedDate": "2020-04-29T05:34:56Z", "message": "reorder comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dabdb4891b38771f94ba7ed5d1cb6562f48537d2", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/dabdb4891b38771f94ba7ed5d1cb6562f48537d2", "committedDate": "2020-04-30T07:31:34Z", "message": "extract method getNumLeftLeaveNodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff1123ea5928489ba570a8409eca40da7ed49ad1", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/ff1123ea5928489ba570a8409eca40da7ed49ad1", "committedDate": "2020-04-30T07:35:17Z", "message": "final clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3a050cff496a26fb679df9446e04b576401bd1e", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/d3a050cff496a26fb679df9446e04b576401bd1e", "committedDate": "2020-04-30T08:00:41Z", "message": "move rotate leaves to pack index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8089415c243135bb1ccc2093dd6701624e69c0", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/5b8089415c243135bb1ccc2093dd6701624e69c0", "committedDate": "2020-04-30T08:39:57Z", "message": "remove while loop from rotate tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b80627babd64c62bdaa725a03e389e5308227f87", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/b80627babd64c62bdaa725a03e389e5308227f87", "committedDate": "2020-04-30T09:11:10Z", "message": "add assert"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNjIyNzYz", "url": "https://github.com/apache/lucene-solr/pull/1464#pullrequestreview-402622763", "createdAt": "2020-04-29T12:36:15Z", "commit": {"oid": "805e39a41a7236ac36265096e95872b46b493908"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo0NjoyOFrOGOh4kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo0NjoyOFrOGOh4kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg4ODQwMg==", "bodyText": "is there an off-by-one error? I'd expect maxLevel to be ceil(log2(numLeaves)), which would be 32 - Integer.numberOfLeadingZeros(numLeaves-1) according to https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#numberOfLeadingZeros(int)", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417888402", "createdAt": "2020-04-30T09:46:28Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -730,6 +730,22 @@ private void rotateToTree(int nodeID, int offset, int count, byte[] index, List<\n     return newLeafBlockFPs;\n   }\n \n+  private int getNumLeftLeaveNodes(int numLeaves) {\n+    // return the max level for this number of leaves. If level is full it returns the next level\n+    int maxLevel = 32 - Integer.numberOfLeadingZeros(numLeaves);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dabdb4891b38771f94ba7ed5d1cb6562f48537d2"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97f86582199ed6dcb79c1cafd42fedc0eadc7f3d", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/97f86582199ed6dcb79c1cafd42fedc0eadc7f3d", "committedDate": "2020-04-30T10:36:16Z", "message": "make more clear the technique for distributing leaf nodes between left and right branches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f36e942d464206d709b41f0ea5ba4fd27062bc4", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/6f36e942d464206d709b41f0ea5ba4fd27062bc4", "committedDate": "2020-04-30T10:52:45Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0e008e109dc11841964037f9931e37c98607bfd", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/d0e008e109dc11841964037f9931e37c98607bfd", "committedDate": "2020-04-30T10:53:08Z", "message": "typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDQ2NzQ4", "url": "https://github.com/apache/lucene-solr/pull/1464#pullrequestreview-403446748", "createdAt": "2020-04-30T11:51:55Z", "commit": {"oid": "d0e008e109dc11841964037f9931e37c98607bfd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTo1MTo1NVrOGOl2lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzowODoyMVrOGOobjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1MzQzMA==", "bodyText": "nit: It's a bit sad that we try to protect against overflows  when dividing, but then don't check again for overflows when incrementing numLeaves. Can we compute the right value of numLeaves entirely before it gets converted to an int, e.g.\nfinal int numLeaves = Math.toIntExact((pointCount + maxPointsInLeafNode - 1) / maxPointsInLeafNode);", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417953430", "createdAt": "2020-04-30T11:51:55Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -420,16 +421,13 @@ private long writeFieldNDims(IndexOutput out, String fieldName, MutablePointValu\n     // Mark that we already finished:\n     finished = true;\n \n-    long countPerLeaf = pointCount = values.size();\n-    long innerNodeCount = 1;\n+    pointCount = values.size();\n \n-    while (countPerLeaf > maxPointsInLeafNode) {\n-      countPerLeaf = (countPerLeaf+1)/2;\n-      innerNodeCount *= 2;\n+    int numLeaves = Math.toIntExact(pointCount / maxPointsInLeafNode);\n+    if (pointCount % maxPointsInLeafNode != 0) {\n+      numLeaves++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e008e109dc11841964037f9931e37c98607bfd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4NTU0MQ==", "bodyText": "also assert that numLeftLeafNodes < 2L * (numLeaves - numLeftLeafNodes)?", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417985541", "createdAt": "2020-04-30T12:51:49Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -665,55 +663,45 @@ assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues,\n     }\n   }\n \n-  // TODO: there must be a simpler way?\n-  private void rotateToTree(int nodeID, int offset, int count, byte[] index, List<byte[]> leafBlockStartValues) {\n-    //System.out.println(\"ROTATE: nodeID=\" + nodeID + \" offset=\" + offset + \" count=\" + count + \" bpd=\" + bytesPerDim + \" index.length=\" + index.length);\n-    if (count == 1) {\n+  private void rotateToTree(int nodeID, int offset, int numNodes, byte[] index, List<byte[]> leafBlockStartValues) {\n+    if (numNodes == 1) {\n       // Leaf index node\n-      //System.out.println(\"  leaf index node\");\n-      //System.out.println(\"  index[\" + nodeID + \"] = blockStartValues[\" + offset + \"]\");\n       System.arraycopy(leafBlockStartValues.get(offset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n-    } else if (count > 1) {\n-      // Internal index node: binary partition of count\n-      int countAtLevel = 1;\n-      int totalCount = 0;\n-      while (true) {\n-        int countLeft = count - totalCount;\n-        //System.out.println(\"    cycle countLeft=\" + countLeft + \" coutAtLevel=\" + countAtLevel);\n-        if (countLeft <= countAtLevel) {\n-          // This is the last level, possibly partially filled:\n-          int lastLeftCount = Math.min(countAtLevel/2, countLeft);\n-          assert lastLeftCount >= 0;\n-          int leftHalf = (totalCount-1)/2 + lastLeftCount;\n-\n-          int rootOffset = offset + leftHalf;\n-          /*\n-          System.out.println(\"  last left count \" + lastLeftCount);\n-          System.out.println(\"  leftHalf \" + leftHalf + \" rightHalf=\" + (count-leftHalf-1));\n-          System.out.println(\"  rootOffset=\" + rootOffset);\n-          */\n-\n-          System.arraycopy(leafBlockStartValues.get(rootOffset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n-          //System.out.println(\"  index[\" + nodeID + \"] = blockStartValues[\" + rootOffset + \"]\");\n-\n-          // TODO: we could optimize/specialize, when we know it's simply fully balanced binary tree\n-          // under here, to save this while loop on each recursion\n-\n-          // Recurse left\n-          rotateToTree(2*nodeID, offset, leftHalf, index, leafBlockStartValues);\n-\n-          // Recurse right\n-          rotateToTree(2*nodeID+1, rootOffset+1, count-leftHalf-1, index, leafBlockStartValues);\n-          return;\n-        }\n-        totalCount += countAtLevel;\n-        countAtLevel *= 2;\n-      }\n+    } else if (numNodes > 1) {\n+      // Internal index node\n+      // numNodes + 1 is the number of leaves\n+      // -1 because there is one less inner node\n+      int leftHalf = getNumLeftLeafNodes(numNodes + 1) - 1;\n+      int rootOffset = offset + leftHalf;\n+\n+      System.arraycopy(leafBlockStartValues.get(rootOffset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n+\n+      // Recurse left\n+      rotateToTree(2*nodeID, offset, leftHalf, index, leafBlockStartValues);\n+      // Recurse right\n+      rotateToTree(2*nodeID+1, rootOffset+1, numNodes-leftHalf-1, index, leafBlockStartValues);\n     } else {\n-      assert count == 0;\n+      assert numNodes == 0;\n     }\n   }\n \n+  private int getNumLeftLeafNodes(int numLeaves) {\n+    assert numLeaves > 1: \"getNumLeftLeaveNodes() called with \" + numLeaves;\n+    // return the level that can be filled with this number of leaves\n+    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n+    // how many leaf nodes are in the full level\n+    int leavesFullLevel = 1 << lastFullLevel;\n+    // half of the leaf nodes from the full level goes to the left\n+    int numLeftLeafNodes = leavesFullLevel / 2;\n+    // leaf nodes that do not fit in the full level\n+    int unbalancedLeafNodes = numLeaves - leavesFullLevel;\n+    // distribute unbalanced leaf nodes\n+    numLeftLeafNodes += Math.min(unbalancedLeafNodes, numLeftLeafNodes);\n+    // we should always place unbalanced leaf nodes on the left\n+    assert numLeftLeafNodes >= numLeaves - numLeftLeafNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e008e109dc11841964037f9931e37c98607bfd"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5NTY2MQ==", "bodyText": "In getNumLeftLeafNodes above we do unbalancedLeafNodes = numLeaves - leavesFullLevel, which has a factor 2 difference with the above formula. I think I understand the reason but can me make it less confusing and avoid naming the same way different quantities?", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417995661", "createdAt": "2020-04-30T13:08:21Z", "author": {"login": "jpountz"}, "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -822,39 +804,27 @@ public long finish(IndexOutput out) throws IOException {\n \n     // Write index:\n     long indexFP = out.getFilePointer();\n-    writeIndex(out, Math.toIntExact(countPerLeaf), leafBlockFPs, splitPackedValues);\n+    writeIndex(out, maxPointsInLeafNode, leafBlockFPs, splitPackedValues);\n     return indexFP;\n   }\n \n   /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n   private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n-\n     int numLeaves = leafBlockFPs.length;\n-\n-    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n-    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n+    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.\n+    // In this case the leaf nodes may straddle the two bottom\n     // levels of the binary tree:\n-    if (numIndexDims == 1 && numLeaves > 1) {\n-      int levelCount = 2;\n-      while (true) {\n-        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n-          int lastLevel = 2*(numLeaves - levelCount);\n-          assert lastLevel >= 0;\n-          if (lastLevel != 0) {\n-            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n-            // at read-time, so that we can still delta code them on disk at write:\n-            long[] newLeafBlockFPs = new long[numLeaves];\n-            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n-            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n-            leafBlockFPs = newLeafBlockFPs;\n-          }\n-          break;\n-        }\n-\n-        levelCount *= 2;\n-      }\n+    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n+    int leavesFullLevel = 1 << lastFullLevel;\n+    int unbalancedLeafNodes = 2 * (numLeaves - leavesFullLevel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e008e109dc11841964037f9931e37c98607bfd"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b534c942f4ddb447d475816ee58ab6b0997db3", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/63b534c942f4ddb447d475816ee58ab6b0997db3", "committedDate": "2020-04-30T13:59:41Z", "message": "address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODg4NTgz", "url": "https://github.com/apache/lucene-solr/pull/1464#pullrequestreview-403888583", "createdAt": "2020-04-30T21:24:51Z", "commit": {"oid": "63b534c942f4ddb447d475816ee58ab6b0997db3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66ec20e74e1485ccb3412ef9249dd4fcf1f5b11c", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/66ec20e74e1485ccb3412ef9249dd4fcf1f5b11c", "committedDate": "2020-05-02T09:12:05Z", "message": "Merge branch 'master' into bkdtree-unbalanced"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdc5441f9cf8fbb4eed13b4700b1519b7db74af0", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/apache/lucene-solr/commit/fdc5441f9cf8fbb4eed13b4700b1519b7db74af0", "committedDate": "2020-05-02T09:15:25Z", "message": "add entry in CHANGES.txt"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2134, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}