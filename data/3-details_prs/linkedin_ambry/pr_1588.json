{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDc1MzU5", "number": 1588, "title": " Introduce CompositeDataNodeConfigSource", "bodyText": "Add CompositeDataNodeConfigSource that can be used to verify that two\nconfig sources are consistent with each other during a migration. Only\nthe primary config source will be used as the source of truth for\nother components.\nAdd config to allow switching between different config source impls.", "createdAt": "2020-07-13T20:34:23Z", "url": "https://github.com/linkedin/ambry/pull/1588", "merged": true, "mergeCommit": {"oid": "bbce36134a12f0da7e35ff3f803e767bb843ce91"}, "closed": true, "closedAt": "2020-08-05T17:05:44Z", "author": {"login": "cgtz"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0nzJ7gBqjM1NDEyNTc1OTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc75uedAFqTQ2MTU4MzMzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b4d4e8101dbd33aec04483931755c443561602e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/6b4d4e8101dbd33aec04483931755c443561602e", "committedDate": "2020-07-13T20:33:24Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}, "afterCommit": {"oid": "3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "committedDate": "2020-07-13T20:52:08Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "committedDate": "2020-07-13T20:52:08Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}, "afterCommit": {"oid": "cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "committedDate": "2020-07-13T20:52:28Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "committedDate": "2020-07-13T20:52:28Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}, "afterCommit": {"oid": "0dd95825618aa3fcfd9244619c10b3a1c75b261f", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/0dd95825618aa3fcfd9244619c10b3a1c75b261f", "committedDate": "2020-07-20T20:51:17Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dd95825618aa3fcfd9244619c10b3a1c75b261f", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/0dd95825618aa3fcfd9244619c10b3a1c75b261f", "committedDate": "2020-07-20T20:51:17Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}, "afterCommit": {"oid": "f522c513f5476b152c35facc0370a966487b918d", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/f522c513f5476b152c35facc0370a966487b918d", "committedDate": "2020-07-22T01:19:17Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "committedDate": "2020-07-24T23:41:14Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f522c513f5476b152c35facc0370a966487b918d", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/f522c513f5476b152c35facc0370a966487b918d", "committedDate": "2020-07-22T01:19:17Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}, "afterCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "committedDate": "2020-07-24T23:41:14Z", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MzA5NDg0", "url": "https://github.com/linkedin/ambry/pull/1588#pullrequestreview-456309484", "createdAt": "2020-07-28T05:20:18Z", "commit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNToyMDoxOVrOG39A6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNToyMDoxOVrOG39A6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyNDUyMQ==", "bodyText": "configSeen is used to compare consistency between primary and secondary source. It relies on DataNodeConfigChange, if the change is triggered by sealed list, I wonder where the DataNodeConfigChange for secondary source comes from?  (If ambry server only updates one source, i.e. InstanceConfig)", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461324521", "createdAt": "2020-07-28T05:20:19Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {\n+    final Map<String, DataNodeConfig> configsSeen = new ConcurrentHashMap<>();\n+    private final DataNodeConfigChangeListener userListener;\n+\n+    /**\n+     * @param userListener if non-null, this listener will be notified on any change.\n+     */\n+    public RecordingListener(DataNodeConfigChangeListener userListener) {\n+      this.userListener = userListener;\n+    }\n+\n+    @Override\n+    public void onDataNodeConfigChange(Iterable<DataNodeConfig> configs) {\n+      if (userListener != null) {\n+        userListener.onDataNodeConfigChange(configs);\n+      }\n+      for (DataNodeConfig config : configs) {\n+        configsSeen.put(config.getInstanceName(), config);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODY1MDMz", "url": "https://github.com/linkedin/ambry/pull/1588#pullrequestreview-456865033", "createdAt": "2020-07-28T17:42:51Z", "commit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo0Mjo1MlrOG4XjGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToyMDo0MlrOG4fUzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1OTI1Ng==", "bodyText": "Just to confirm, it seems addDataNodeConfigChangeListener for CompositeDataNodeConfigSource is called in one place (DatacenterInitializer) for now, so the else branch is temporarily not used? It's added here for other listener (if any) to introduce in the future?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461759256", "createdAt": "2020-07-28T17:42:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDYxMw==", "bodyText": "I need more clarification here. In this doc, for each operation (addDataNodeConfigChangeListener, get, set), looks like it only catches the exception from secondary source, is there any specific reason? In migration, both primary and secondary source can be InstanceConfig, PropertyStore, Is this because primary is source of truth and if there is an exception from primary, the exception is thrown immediately and whole operation fails?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461764613", "createdAt": "2020-07-28T17:51:41Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjAwNQ==", "bodyText": "If there is an exception from secondary source, do we really need to initiate consistency checker? I expect it to report inconsistency always (probably good for alerting?)", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461766005", "createdAt": "2020-07-28T17:53:46Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3NzEwNA==", "bodyText": "nit: can we just call it listener or changeListener instead of userListener?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461777104", "createdAt": "2020-07-28T18:12:44Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3OTc0NQ==", "bodyText": "same here,  I think changeListener or listener would suffice. (Two cents)", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461779745", "createdAt": "2020-07-28T18:17:23Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {\n+    final Map<String, DataNodeConfig> configsSeen = new ConcurrentHashMap<>();\n+    private final DataNodeConfigChangeListener userListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4MjMzMQ==", "bodyText": "optional:  maybe rename RecordingListener to ConfigChangeRecorder (or DataNodeConfigRecorder)", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461782331", "createdAt": "2020-07-28T18:21:53Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4Mzg5OQ==", "bodyText": "How about calling it listenerTransientInconsistentCount?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461783899", "createdAt": "2020-07-28T18:24:36Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DataNodeConfigSourceMetrics.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.MetricRegistry;\n+\n+\n+/**\n+ * Metrics for {@link DataNodeConfigSource} implementations\n+ */\n+class DataNodeConfigSourceMetrics {\n+  final Counter setInconsistentCount;\n+  final Counter getInconsistentCount;\n+  final Counter listenerInconsistentCount;\n+  final Counter listenerTrendingInconsistentCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NDkzMg==", "bodyText": "I know this metrics is helpful for testing but in practice I feel like we don't really need it. The other two inconsistent metrics should give us sufficient alerting. What do you think?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461784932", "createdAt": "2020-07-28T18:26:18Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DataNodeConfigSourceMetrics.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.MetricRegistry;\n+\n+\n+/**\n+ * Metrics for {@link DataNodeConfigSource} implementations\n+ */\n+class DataNodeConfigSourceMetrics {\n+  final Counter setInconsistentCount;\n+  final Counter getInconsistentCount;\n+  final Counter listenerInconsistentCount;\n+  final Counter listenerTrendingInconsistentCount;\n+  final Counter listenerConsistentCount;\n+\n+  DataNodeConfigSourceMetrics(MetricRegistry registry) {\n+    setInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"SetInconsistentCount\"));\n+    getInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"GetInconsistentCount\"));\n+    listenerInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerInconsistentCount\"));\n+    listenerTrendingInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerTrendingInconsistentCount\"));\n+    listenerConsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerConsistentCount\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NTg3MA==", "bodyText": "Just a random thought, are we able to remove these metrics after migration is complete?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461785870", "createdAt": "2020-07-28T18:28:02Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DatacenterInitializer.java", "diffHunk": "@@ -92,6 +94,7 @@\n     this.clusterChangeHandlerCallback = clusterChangeHandlerCallback;\n     this.helixClusterManagerCallback = helixClusterManagerCallback;\n     this.helixClusterManagerMetrics = helixClusterManagerMetrics;\n+    this.dataNodeConfigSourceMetrics = dataNodeConfigSourceMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjM3OQ==", "bodyText": "Just realize that the reason we need dcName is to construct PropertyStoreToDataNodeConfigAdapter. And the reason constructor needs that is we didn't add a DATACENTER_STR in the simple field of ZNRecord (we do have a simple field for dc in InstanceConfig). Any reason for this? (I probably missed previous context, let me know if I am wrong)", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461872379", "createdAt": "2020-07-28T20:54:11Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DatacenterInitializer.java", "diffHunk": "@@ -197,7 +200,8 @@ private DcInfo initializeHelixDatacenter() throws Exception {\n     // notification for a change from within the same thread that adds the listener, in the context of the add\n     // call. Therefore, when the call to add a listener returns, the initial notification will have been\n     // received and handled.\n-    DataNodeConfigSource dataNodeConfigSource = new InstanceConfigToDataNodeConfigAdapter(manager, clusterMapConfig);\n+    DataNodeConfigSource dataNodeConfigSource =\n+        ClusterMapUtils.getDataNodeConfigSource(clusterMapConfig, manager, dcName, dataNodeConfigSourceMetrics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjgzMg==", "bodyText": "Remove these imports?", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461872832", "createdAt": "2020-07-28T20:54:57Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -13,6 +13,8 @@\n  */\n package com.github.ambry.clustermap;\n \n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.utils.SystemTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4MzY3NA==", "bodyText": "This is never used, we can remove it.", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461883674", "createdAt": "2020-07-28T21:14:37Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -261,30 +263,38 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n           \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n     }\n     synchronized (helixAdministrationLock) {\n-      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n       String partitionName = replicaId.getPartitionId().toPathString();\n \n       // 1. invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state\n       //    transition on given replica. This method modifies MapFields in InstanceConfig.\n+      boolean instanceConfigUpdated = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjY2OQ==", "bodyText": "The current logic is correct but I am thinking if we can simplify this. setReplicaDisabledState method is only called when local node tries to enable/disable local replica. The enabled/disabled replica is always reflected by \"disabled list\" in dataNodeConfig. So I am thinking we don't have to check currentlyEnabled == disable. Instead, we may consider moving this piece of code into if (dataNodeConfigChanged) block. Only when the \"disabled list\" is updated, we call enable/disable partition in InstanceConfig. Hope my point makes some sense.", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461886669", "createdAt": "2020-07-28T21:20:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -261,30 +263,38 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n           \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n     }\n     synchronized (helixAdministrationLock) {\n-      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n       String partitionName = replicaId.getPartitionId().toPathString();\n \n       // 1. invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state\n       //    transition on given replica. This method modifies MapFields in InstanceConfig.\n+      boolean instanceConfigUpdated = false;\n       InstanceConfig instanceConfig = getInstanceConfig();\n       String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n       logger.info(\"{} replica {} on current node\", disable ? \"Disabling\" : \"Enabling\", partitionName);\n-      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);\n+      boolean currentlyEnabled = instanceConfig.getInstanceEnabledForPartition(resourceNameForPartition, partitionName);\n+      if (currentlyEnabled == disable) {\n+        instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);\n+        if (!helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig)) {\n+          logger.warn(\"setReplicaDisabledState() failed InstanceConfig update\");\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "658fce8da7c77c927053a547aacc801a91b33d23", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/658fce8da7c77c927053a547aacc801a91b33d23", "committedDate": "2020-07-29T19:38:25Z", "message": "Address Yingyi's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63d5df894dcf5c87dd8439827421f9591107f4a5", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/63d5df894dcf5c87dd8439827421f9591107f4a5", "committedDate": "2020-07-31T15:00:46Z", "message": "Add datacenter back to propertystore config record"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa03bf24f57a03fb28eb339136680ad8bd641faa", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/fa03bf24f57a03fb28eb339136680ad8bd641faa", "committedDate": "2020-07-31T15:02:59Z", "message": "Add missing blank line"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjYyMjg1", "url": "https://github.com/linkedin/ambry/pull/1588#pullrequestreview-460262285", "createdAt": "2020-08-03T18:49:32Z", "commit": {"oid": "fa03bf24f57a03fb28eb339136680ad8bd641faa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNTgzMzM4", "url": "https://github.com/linkedin/ambry/pull/1588#pullrequestreview-461583338", "createdAt": "2020-08-05T11:39:50Z", "commit": {"oid": "fa03bf24f57a03fb28eb339136680ad8bd641faa"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTozOTo1MVrOG8F8GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTozOTo1MVrOG8F8GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2NTA0OQ==", "bodyText": "Curious .. Why do we need to create a periodic thread to check consistency? Why can't we check on each call to ConfigChangeRecorder.onDataNodeConfigChange which is where we seem to be setting ConfigChangeRecorder.configsSeen.", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r465665049", "createdAt": "2020-08-05T11:39:51Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener listener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      ConfigChangeRecorder primaryListener = new ConfigChangeRecorder(listener);\n+      ConfigChangeRecorder secondaryListener = new ConfigChangeRecorder(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+        Utils.newThread(\"DataNodeConfigConsistencyChecker\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa03bf24f57a03fb28eb339136680ad8bd641faa"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1181, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}