{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTgwMjgy", "number": 1579, "title": "Change java ByteBuffer to netty ByteBuf in request and response.", "bodyText": "Starting use netty ByteBuf to replace java.nio.ByteBuffer in the network layer.\nThere are some issues with GetResponse, since it supports non-prefetched data from disk. Something need to be done in order to actually support ByteBufHolder for GetResponse.\nAfter this PR, Request and Response would have a method \"content\", if the returned value from method content is not null, then caller can use the returned ByteBuf as serialized bytes for the request and response.", "createdAt": "2020-06-25T18:13:00Z", "url": "https://github.com/linkedin/ambry/pull/1579", "merged": true, "mergeCommit": {"oid": "6a7fb0c899ea21b91d8c57260d5255c7aae65ebb"}, "closed": true, "closedAt": "2020-07-13T23:25:37Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcu85N-ABqjM0ODUyMTQ4MDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0p_K3gFqTQ0NzY3ODI1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0e246de10c5584552a9c9de9bb343d29aac5315", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/f0e246de10c5584552a9c9de9bb343d29aac5315", "committedDate": "2020-06-26T05:58:32Z", "message": "Protocol works"}, "afterCommit": {"oid": "c1977ce64ce06498055506203e48143021b2bbe8", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/c1977ce64ce06498055506203e48143021b2bbe8", "committedDate": "2020-06-26T06:03:15Z", "message": "Protocol works"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "028cfda980d816e5147e7725e4a0fea32e9a41fb", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/028cfda980d816e5147e7725e4a0fea32e9a41fb", "committedDate": "2020-06-26T06:09:39Z", "message": "Update the AmbrySendToHttp2Adapter"}, "afterCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "committedDate": "2020-06-26T18:23:05Z", "message": "Update the AmbrySendToHttp2Adapter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjAxNjc1", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-438601675", "createdAt": "2020-06-26T21:20:04Z", "commit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMToyMDowNVrOGpvA9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMToyMDowNVrOGpvA9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxNTA5Mw==", "bodyText": "Http2NetworkClient throws an exception\nrelease\n[2020-06-26 14:16:03,876] WARN An exception was thrown by com.github.ambry.network.http2.Http2NetworkClient$1.operationComplete() (io.netty.util.concurrent.DefaultPromise)\nio.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1\n\tat io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74)\n\tat io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138)\n\tat io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100)\n\tat com.github.ambry.protocol.PutRequest.release(PutRequest.java:269)\n\nNetty write decrease the ref cnt, but it doesn't set the variable to null. So we hit above exception.", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446415093", "createdAt": "2020-06-26T21:20:05Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());\n+    compositeByteBuf.addComponent(true, bufferToSend);\n+    if (blob instanceof CompositeByteBuf) {\n+      Iterator<ByteBuf> iter = ((CompositeByteBuf) blob).iterator();\n+      while (iter.hasNext()) {\n+        compositeByteBuf.addComponent(true, iter.next());\n+      }\n+    } else {\n+      compositeByteBuf.addComponent(true, blob);\n+    }\n+    compositeByteBuf.addComponent(true, crcByteBuf);\n+    blob = null;\n+    crcByteBuf = null;\n+    bufferToSend = compositeByteBuf;\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n+    if (bufferToSend == null) {\n+      prepareBuffer();\n+    }\n+    if (nioBuffers == null) {\n+      nioBuffers = bufferToSend.nioBuffers();\n+    }\n     long written = 0;\n-    try {\n-      if (sentBytes < sizeInBytes()) {\n-        if (bufferToSend == null) {\n-          // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-          // (everything except the blob content).\n-          prepareBuffer();\n-        }\n-        // If the header and metadata are not yet written out completely, try and write out as much of it now.\n-        if (bufferToSend.hasRemaining()) {\n-          written = channel.write(bufferToSend);\n-        }\n-\n-        // If the header and metadata were written out completely (in this call or a previous call),\n-        // try and write out as much of the blob now.\n-        if (!bufferToSend.hasRemaining() && blob != null) {\n-          int totalWrittenBytesForBlob = 0, currentWritten = -1;\n-          while (bufferIndex < nioBuffersFromBlob.length && currentWritten != 0) {\n-            currentWritten = -1;\n-            ByteBuffer byteBuffer = nioBuffersFromBlob[bufferIndex];\n-            if (!byteBuffer.hasRemaining()) {\n-              // some bytebuffers are zero length, ignore those bytebuffers.\n-              bufferIndex ++;\n-            } else {\n-              currentWritten = channel.write(byteBuffer);\n-              totalWrittenBytesForBlob += currentWritten;\n-            }\n-          }\n-          blob.skipBytes(totalWrittenBytesForBlob);\n-          written += totalWrittenBytesForBlob;\n-          okayToWriteCrc = !blob.isReadable();\n-        }\n-\n-        if (okayToWriteCrc && crcBuf.hasRemaining()) {\n-          if (blob != null) {\n-            blob.release();\n-            blob = null;\n-          }\n-          written += channel.write(crcBuf);\n+    if (sentBytes < sizeInBytes()) {\n+      int totalWrittenBytes = 0, currentWritten = -1;\n+      while (bufferIndex < nioBuffers.length && currentWritten != 0) {\n+        currentWritten = -1;\n+        ByteBuffer byteBuffer = nioBuffers[bufferIndex];\n+        if (!byteBuffer.hasRemaining()) {\n+          // some bytebuffers are zero length, ignore those bytebuffers.\n+          bufferIndex++;\n+        } else {\n+          currentWritten = channel.write(byteBuffer);\n+          totalWrittenBytes += currentWritten;\n         }\n-\n-        sentBytes += written;\n-      }\n-    } catch (Exception e) {\n-      if (blob != null) {\n-        blob.release();\n-        blob = null;\n       }\n+      bufferToSend.skipBytes(totalWrittenBytes);\n+      written += totalWrittenBytes;\n     }\n+    sentBytes += written;\n     return written;\n   }\n \n+  /**\n+   * Override release even if the {@link #content()}'s result is not null. When the {@link #prepareBuffer()} is\n+   * not invoked, there will be {@link #blob} and {@link #crcByteBuf} created but not returned by {@link #content()},\n+   * and we have to release them.\n+   * @return\n+   */\n   @Override\n-  public void release() {\n+  public boolean release() {\n     if (blob != null) {\n       blob.release();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjM3OTg2", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-438637986", "createdAt": "2020-06-26T23:01:51Z", "commit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzowMTo1MVrOGpw2cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDozMDo0NlrOGpxzrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NTE2OQ==", "bodyText": "One alternative to having Send always extend ByteBufHolder would be to have users do an instanceof check to see if it implements ByteBufHolder. However, if we intend to have almost all impls eventually support this, the way you have it is probably preferable. But there seem to be a ton of implementations of send where content just returns null.", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446445169", "createdAt": "2020-06-26T23:01:51Z", "author": {"login": "cgtz"}, "path": "ambry-api/src/main/java/com/github/ambry/network/Send.java", "diffHunk": "@@ -52,7 +54,9 @@ default void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n   long sizeInBytes();\n \n   /**\n-   * Release all the resource this object holds. Make this a default method so subclasses don't have to override it.\n+   * Return the data which is held by this {@link ByteBufHolder}. The result could be null, if it's null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjIyNA==", "bodyText": "can this import be removed?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446446224", "createdAt": "2020-06-26T23:06:48Z", "author": {"login": "cgtz"}, "path": "ambry-api/src/main/java/com/github/ambry/store/MessageReadSet.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import com.github.ambry.router.AsyncWritableChannel;\n import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0OTg1Ng==", "bodyText": "My understanding of this code was that an entry was only added to this map if the request is given a valid connection (line 215-225 would take out of pendingConnectionsToAssociatedRequests and add to correlationIdInFlightToConnectionId and connectionIdToRequestInFlight). Adding to the map would mean that this block of code handling connection checkout timeouts would never be executed for that connection. Am I missing an edge case here?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446449856", "createdAt": "2020-06-26T23:23:46Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -158,14 +156,19 @@ public SocketNetworkClient(Selector selector, NetworkConfig networkConfig, Netwo\n       if (time.milliseconds() - requestMetadata.requestQueuedAtMs > checkoutTimeoutMs) {\n         responseInfoList.add(\n             new ResponseInfo(requestMetadata.requestInfo, NetworkClientErrorCode.ConnectionUnavailable, null));\n+        requestMetadata.requestInfo.getRequest().release();\n         logger.trace(\"Failing request to host {} port {} due to connection unavailability\",\n             requestMetadata.requestInfo.getHost(), requestMetadata.requestInfo.getPort());\n         iter.remove();\n-        requestMetadata.requestInfo.getRequest().release();\n         if (requestMetadata.pendingConnectionId != null) {\n           pendingConnectionsToAssociatedRequests.remove(requestMetadata.pendingConnectionId);\n           requestMetadata.pendingConnectionId = null;\n         }\n+        String connId =\n+            correlationIdInFlightToConnectionId.get(requestMetadata.requestInfo.getRequest().getCorrelationId());\n+        if (connId != null) {\n+          connectionIdToRequestInFlight.remove(connId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MDkyMg==", "bodyText": "nit: can just use requestMetadataToRelease.forEach", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446450922", "createdAt": "2020-06-26T23:29:33Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -377,19 +388,17 @@ private void handleSelectorEvents(List<ResponseInfo> responseInfoList) {\n    */\n   @Override\n   public void close() {\n+    Set<RequestMetadata> requestMetadataToRelease = new HashSet<>();\n     if (pendingRequests != null) {\n-      pendingRequests.forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n-    } if (connectionIdToRequestInFlight != null) {\n-      connectionIdToRequestInFlight.values().forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n-    } if (pendingConnectionsToAssociatedRequests != null) {\n-      pendingConnectionsToAssociatedRequests.values().forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n+      requestMetadataToRelease.addAll(pendingRequests);\n+    }\n+    if (connectionIdToRequestInFlight != null) {\n+      requestMetadataToRelease.addAll(connectionIdToRequestInFlight.values());\n+    }\n+    if (pendingConnectionsToAssociatedRequests != null) {\n+      requestMetadataToRelease.addAll(pendingConnectionsToAssociatedRequests.values());\n     }\n+    requestMetadataToRelease.stream().forEach(requestMetadata -> requestMetadata.requestInfo.getRequest().release());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MTEyMw==", "bodyText": "extra println", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446451123", "createdAt": "2020-06-26T23:30:39Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -358,6 +360,15 @@ private void handleSelectorEvents(List<ResponseInfo> responseInfoList) {\n       networkMetrics.connectionDisconnected.inc();\n     }\n \n+    // Release all completed sends\n+    List<NetworkSend> completedSends = selector.completedSends();\n+    if (completedSends != null) {\n+      if (completedSends.size() > 0) {\n+        System.out.println(\"Release completed sends: \" + completedSends.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDg0Nw==", "bodyText": "Remove this import?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446460847", "createdAt": "2020-06-27T00:30:46Z", "author": {"login": "cgtz"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/DeleteResponse.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import com.github.ambry.server.ServerErrorCode;\n import com.github.ambry.utils.Utils;\n+import io.netty.buffer.ByteBuf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzI2NDU4", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-439326458", "createdAt": "2020-06-29T16:48:42Z", "commit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjo0ODo0M1rOGqZizA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzoxNjowMlrOGqahkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTg4NA==", "bodyText": "any reason not to use directBuffer?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447111884", "createdAt": "2020-06-29T16:48:43Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/GetResponse.java", "diffHunk": "@@ -114,46 +122,111 @@ public static GetResponse readFrom(DataInputStream stream, ClusterMap map) throw\n    * {@link GetResponse#writeTo(AsyncWritableChannel, Callback)}.\n    * This method allocate bufferToSend and write metadata to it if bufferToSend is null.\n    */\n-  private void prepareBufferToSend() {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n+  @Override\n+  protected void prepareBuffer() {\n+    if (toSend != null && toSend.content() != null) {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer((int) sizeInBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMzY0Nw==", "bodyText": "Not used.", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447113647", "createdAt": "2020-06-29T16:51:31Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -23,11 +23,15 @@\n import com.github.ambry.utils.CrcInputStream;\n import com.github.ambry.utils.Utils;\n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n import java.io.DataInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.ByteBuffer;\n import java.nio.channels.WritableByteChannel;\n+import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMTkzNA==", "bodyText": "Why explicitly use compositeHeapBuffer? I thought blob are direct buffers, no?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447121934", "createdAt": "2020-06-29T17:05:10Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMjk3Mg==", "bodyText": "bufferToSend.alloc() -> PooledByteBufAllocator.DEFAULT?\nFeel we can use PooledByteBufAllocator.DEFAULT almost everywhere in the first few versions.", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447122972", "createdAt": "2020-06-29T17:07:05Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMTkzNA=="}, "originalCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNzk1Mw==", "bodyText": "The implementation overuses bufferToSend and caused some confusion when I looked at the code.\nHow about just set\nbufferToSend = PooledByteBufAllocator.DEFAULT.compositBuffer() in the beginning,\nthen allocate temp buffer for headers and write blob to bufferToSend,\nfinally return bufferToSend?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447127953", "createdAt": "2020-06-29T17:16:02Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());\n+    compositeByteBuf.addComponent(true, bufferToSend);\n+    if (blob instanceof CompositeByteBuf) {\n+      Iterator<ByteBuf> iter = ((CompositeByteBuf) blob).iterator();\n+      while (iter.hasNext()) {\n+        compositeByteBuf.addComponent(true, iter.next());\n+      }\n+    } else {\n+      compositeByteBuf.addComponent(true, blob);\n+    }\n+    compositeByteBuf.addComponent(true, crcByteBuf);\n+    blob = null;\n+    crcByteBuf = null;\n+    bufferToSend = compositeByteBuf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab"}, "originalPosition": 109}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "committedDate": "2020-06-28T18:02:25Z", "message": "Fix memory leak in server"}, "afterCommit": {"oid": "489035ac900b2ff9960f0b83712c6a4c9a57cba8", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/489035ac900b2ff9960f0b83712c6a4c9a57cba8", "committedDate": "2020-06-29T22:39:38Z", "message": "More release"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTc4MDAx", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-439578001", "createdAt": "2020-06-29T23:54:57Z", "commit": {"oid": "8a5b8ade85ea6bf42370817328940c219613c5db"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzo1NDo1N1rOGqmiBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDoyOTo0OFrOGqnQTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNDY3OA==", "bodyText": "who releases the request if an IOException is thrown?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447324678", "createdAt": "2020-06-29T23:54:57Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/BlockingChannel.java", "diffHunk": "@@ -171,6 +171,7 @@ public void send(Send request) throws IOException {\n     while (!request.isSendComplete()) {\n       request.writeTo(writeChannel);\n     }\n+    request.release();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a5b8ade85ea6bf42370817328940c219613c5db"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNjUyNA==", "bodyText": "any reason to not call sizeInBytes() here?", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447336524", "createdAt": "2020-06-30T00:29:48Z", "author": {"login": "cgtz"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/GetResponse.java", "diffHunk": "@@ -114,46 +122,111 @@ public static GetResponse readFrom(DataInputStream stream, ClusterMap map) throw\n    * {@link GetResponse#writeTo(AsyncWritableChannel, Callback)}.\n    * This method allocate bufferToSend and write metadata to it if bufferToSend is null.\n    */\n-  private void prepareBufferToSend() {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n+  @Override\n+  protected void prepareBuffer() {\n+    if (toSend != null && toSend.content() != null) {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.ioBuffer((int) sizeInBytes());\n+    } else {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.ioBuffer(\n           (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a5b8ade85ea6bf42370817328940c219613c5db"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjE2OTE5", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-440216919", "createdAt": "2020-06-30T17:02:52Z", "commit": {"oid": "ee9bd56b6920be39cffd5c97fa1f902e716bf04c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowMjo1MlrOGrGElw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowMjo1MlrOGrGElw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0MTQzMQ==", "bodyText": "Please help add a counter metric(channelNotWriteableCounter) before streamChannel.writeAndFlush()  .\nif (!streamChannel.isWriteable() || !streamChannel.parentChannel().isWriteable() ) {\nchannelNotWriteableCounter.inc()\n}", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447841431", "createdAt": "2020-06-30T17:02:52Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -107,6 +107,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n                         System.currentTimeMillis() - streamAcquiredTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    // When success, handler would release the request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee9bd56b6920be39cffd5c97fa1f902e716bf04c"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjI5OTcz", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-440229973", "createdAt": "2020-06-30T17:19:38Z", "commit": {"oid": "c092dba5e0d5bbe127b9f95c913e4dc2749ad28e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxOTozOFrOGrGuGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxOTozOFrOGrGuGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1MjA1OA==", "bodyText": "logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(), streamChannel, streamChannel().bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447852058", "createdAt": "2020-06-30T17:19:38Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -98,6 +98,10 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable\", streamChannel.hashCode(), streamChannel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c092dba5e0d5bbe127b9f95c913e4dc2749ad28e"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "committedDate": "2020-07-13T17:35:03Z", "message": "Change java ByteBuffer to netty ByteBuf in request and response."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0656449db796b5225ea723d37d88f41e7b334cd", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/d0656449db796b5225ea723d37d88f41e7b334cd", "committedDate": "2020-06-30T17:31:38Z", "message": "Comments"}, "afterCommit": {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "committedDate": "2020-07-13T17:35:03Z", "message": "Change java ByteBuffer to netty ByteBuf in request and response."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDgxNDQx", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-447481441", "createdAt": "2020-07-13T18:05:54Z", "commit": {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Njc4MjUy", "url": "https://github.com/linkedin/ambry/pull/1579#pullrequestreview-447678252", "createdAt": "2020-07-13T23:25:15Z", "commit": {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1162, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}