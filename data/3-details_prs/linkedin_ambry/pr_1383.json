{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjQyNzYw", "number": 1383, "title": "Create RecoveryTestClusterAgentsFactory and RecoveryTestClusterManager", "bodyText": "This PR creates RecoveryTestClusterAgentsFactory and RecoveryTestClusterManager to enable replication of source of truth data for recovery verification.\nNOTE: Sample server.properties file for enabling RecoveryTestClusterAgentsFactory:\nhost.name=localhost\nport=6673\nclustermap.cluster.name=Ambry-EI\nclustermap.datacenter.name=ei4\nclustermap.host.name=localhost\nclustermap.port=6673\n\nclustermap.dcs.zk.connect.strings={\"zkInfo\":[{\"datacenter\":\"ei4\",\"id\":4,\"zkConnectStr\":\"zk-ei4-shared.int.linkedin.com:12913\"}]}\n\nclustermap.clusteragents.factory=com.github.ambry.clustermap.RecoveryTestClusterAgentsFactory\nclustermap.recovery.test.partition.layout={\"clusterName\":\"OneDiskOneReplica\",\"version\":88,\"partitions\":[{\"id\":0,\"partitionClass\":\"max-replicas-all-datacenters\",\"partitionState\":\"READ_WRITE\",\"replicaCapacityInBytes\":10737418240,\"replicas\":[{\"hostname\":\"localhost\",\"mountPath\":\"\\/tmp\\/1\",\"port\":6673}]}]}\nclustermap.recovery.test.hardware.layout={\"clusterName\":\"OneDiskOneReplica\",\"version\":99,\"datacenters\":[{\"dataNodes\":[{\"disks\":[{\"capacityInBytes\":21474836480,\"hardwareState\":\"AVAILABLE\",\"mountPath\":\"\\/tmp\\/1\"}],\"hardwareState\":\"AVAILABLE\",\"hostname\":\"localhost\",\"port\":6673}],\"name\":\"ei4\",\"id\":\"1\"}]}", "createdAt": "2020-02-13T02:55:05Z", "url": "https://github.com/linkedin/ambry/pull/1383", "merged": true, "mergeCommit": {"oid": "998439c8116cc6b99853942e564e1afa446b1389"}, "closed": true, "closedAt": "2020-02-19T00:02:44Z", "author": {"login": "ankagrawal"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEB7argFqTM1ODU1ODgyNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFrAFlgFqTM2MDc2MDQwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTU4ODI1", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-358558825", "createdAt": "2020-02-13T21:20:12Z", "commit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMToyMDoxMlrOFpj7gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTozNDo1M1rOFpkVtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNDYxMA==", "bodyText": "if this method can be called more than once, then clusterParticipant should be either volatile or AtomicReference.", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379124610", "createdAt": "2020-02-13T21:20:12Z", "author": {"login": "lightningrob"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import java.io.IOException;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *\n+ */\n+public class RecoveryTestClusterAgentsFactory implements ClusterAgentsFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeClusterAgentsFactory.class);\n+  private final StaticClusterAgentsFactory staticClusterAgentsFactory;\n+  private final HelixClusterAgentsFactory helixClusterAgentsFactory;\n+  private RecoveryTestClusterManager recoveryTestClusterManager;\n+  private ClusterParticipant clusterParticipant;\n+\n+  /**\n+   * Create an instance of this class.\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param hardwareLayoutFilePath the path to the hardware layout file.\n+   * @param partitionLayoutFilePath the path to the partition layout file.\n+   * @throws JSONException if there is an exception parsing the layout files.\n+   * @throws IOException if there is an IO error accessing or reading the layout files.\n+   */\n+  public RecoveryTestClusterAgentsFactory(ClusterMapConfig clusterMapConfig, String hardwareLayoutFilePath,\n+      String partitionLayoutFilePath) throws JSONException {\n+    PartitionLayout partitionLayout =\n+        new PartitionLayout(new HardwareLayout(clusterMapConfig.clustermapRecoveryTestHardwareLayout, clusterMapConfig),\n+            clusterMapConfig.clustermapRecoveryTestPartitionLayout, clusterMapConfig);\n+    staticClusterAgentsFactory = new StaticClusterAgentsFactory(clusterMapConfig, partitionLayout);\n+    helixClusterAgentsFactory =\n+        new HelixClusterAgentsFactory(clusterMapConfig, staticClusterAgentsFactory.getMetricRegistry());\n+  }\n+\n+  /**\n+   * Create and return a {@link RecoveryTestClusterManager}.\n+   * @return the constructed {@link RecoveryTestClusterManager}.\n+   * @throws Exception if constructing the underlying {@link StaticClusterManager} or the {@link HelixClusterManager}\n+   * throws an Exception.\n+   */\n+  @Override\n+  public RecoveryTestClusterManager getClusterMap() throws IOException {\n+    if (recoveryTestClusterManager == null) {\n+      StaticClusterManager staticClusterManager = staticClusterAgentsFactory.getClusterMap();\n+      HelixClusterManager helixClusterManager = null;\n+      try {\n+        helixClusterManager = helixClusterAgentsFactory.getClusterMap();\n+      } catch (Exception e) {\n+        logger.error(\"Helix cluster manager instantiation failed with exception\", e);\n+      }\n+      recoveryTestClusterManager = new RecoveryTestClusterManager(staticClusterManager, helixClusterManager);\n+    }\n+    return recoveryTestClusterManager;\n+  }\n+\n+  @Override\n+  public ClusterParticipant getClusterParticipant() throws IOException {\n+    if (clusterParticipant == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNTE0OQ==", "bodyText": "combine two lines", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379125149", "createdAt": "2020-02-13T21:21:14Z", "author": {"login": "lightningrob"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterManager.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A cluster manager that is a composed of a {@link StaticClusterManager} and a {@link HelixClusterManager}.\n+ * It provides a merged view of the static and helix clusters.\n+ */\n+public class RecoveryTestClusterManager implements ClusterMap {\n+  private final Logger logger = LoggerFactory.getLogger(CompositeClusterManager.class);\n+  final StaticClusterManager staticClusterManager;\n+  final HelixClusterManager helixClusterManager;\n+  final Map<AmbryDisk, Disk> ambryDiskToDiskMap;\n+  final Map<AmbryDataNode, DataNode> ambryDataNodeToDataNodeMap;\n+\n+  /**\n+   * Construct a RecoveryTestClusterManager instance.\n+   * @param staticClusterManager the {@link StaticClusterManager} object.\n+   * @param helixClusterManager the {@link HelixClusterManager} object.\n+   */\n+  RecoveryTestClusterManager(StaticClusterManager staticClusterManager, HelixClusterManager helixClusterManager) {\n+    this.staticClusterManager = staticClusterManager;\n+    this.helixClusterManager = helixClusterManager;\n+    ambryDataNodeToDataNodeMap = new HashMap<>();\n+    ambryDiskToDiskMap = new HashMap<>();\n+  }\n+\n+  @Override\n+  public PartitionId getPartitionIdFromStream(InputStream stream) throws IOException {\n+    DuplicatingInputStream duplicatingInputStream = new DuplicatingInputStream(stream);\n+    duplicatingInputStream.mark(0);\n+    PartitionId partitionIdStatic = staticClusterManager.getPartitionIdFromStream(duplicatingInputStream);\n+    return partitionIdStatic;\n+  }\n+\n+  @Override\n+  public List<PartitionId> getWritablePartitionIds(String partitionClass) {\n+    throw new UnsupportedOperationException(String.format(\"getWritablePartitionIds method is not supported\"));\n+  }\n+\n+  @Override\n+  public PartitionId getRandomWritablePartition(String partitionClass, List<PartitionId> partitionsToExclude) {\n+    throw new UnsupportedOperationException(String.format(\"getRandomWritablePartition method is not supported\"));\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Get all partition ids from both the underlying {@link StaticClusterManager}.\n+   * @param partitionClass the partition class whose partitions are required. Can be {@code null}\n+   * @return a list of partition ids from the underlying {@link StaticClusterManager}.\n+   */\n+  @Override\n+  public List<PartitionId> getAllPartitionIds(String partitionClass) {\n+    List<PartitionId> staticPartitionIds = staticClusterManager.getAllPartitionIds(partitionClass);\n+    return staticPartitionIds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNjM4NQ==", "bodyText": "do Objects.requireNonNull() on params", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379126385", "createdAt": "2020-02-13T21:23:57Z", "author": {"login": "lightningrob"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterManager.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A cluster manager that is a composed of a {@link StaticClusterManager} and a {@link HelixClusterManager}.\n+ * It provides a merged view of the static and helix clusters.\n+ */\n+public class RecoveryTestClusterManager implements ClusterMap {\n+  private final Logger logger = LoggerFactory.getLogger(CompositeClusterManager.class);\n+  final StaticClusterManager staticClusterManager;\n+  final HelixClusterManager helixClusterManager;\n+  final Map<AmbryDisk, Disk> ambryDiskToDiskMap;\n+  final Map<AmbryDataNode, DataNode> ambryDataNodeToDataNodeMap;\n+\n+  /**\n+   * Construct a RecoveryTestClusterManager instance.\n+   * @param staticClusterManager the {@link StaticClusterManager} object.\n+   * @param helixClusterManager the {@link HelixClusterManager} object.\n+   */\n+  RecoveryTestClusterManager(StaticClusterManager staticClusterManager, HelixClusterManager helixClusterManager) {\n+    this.staticClusterManager = staticClusterManager;\n+    this.helixClusterManager = helixClusterManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNzAxMg==", "bodyText": "Can it be null?  You assume it's not in other places.", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379127012", "createdAt": "2020-02-13T21:25:13Z", "author": {"login": "lightningrob"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterManager.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A cluster manager that is a composed of a {@link StaticClusterManager} and a {@link HelixClusterManager}.\n+ * It provides a merged view of the static and helix clusters.\n+ */\n+public class RecoveryTestClusterManager implements ClusterMap {\n+  private final Logger logger = LoggerFactory.getLogger(CompositeClusterManager.class);\n+  final StaticClusterManager staticClusterManager;\n+  final HelixClusterManager helixClusterManager;\n+  final Map<AmbryDisk, Disk> ambryDiskToDiskMap;\n+  final Map<AmbryDataNode, DataNode> ambryDataNodeToDataNodeMap;\n+\n+  /**\n+   * Construct a RecoveryTestClusterManager instance.\n+   * @param staticClusterManager the {@link StaticClusterManager} object.\n+   * @param helixClusterManager the {@link HelixClusterManager} object.\n+   */\n+  RecoveryTestClusterManager(StaticClusterManager staticClusterManager, HelixClusterManager helixClusterManager) {\n+    this.staticClusterManager = staticClusterManager;\n+    this.helixClusterManager = helixClusterManager;\n+    ambryDataNodeToDataNodeMap = new HashMap<>();\n+    ambryDiskToDiskMap = new HashMap<>();\n+  }\n+\n+  @Override\n+  public PartitionId getPartitionIdFromStream(InputStream stream) throws IOException {\n+    DuplicatingInputStream duplicatingInputStream = new DuplicatingInputStream(stream);\n+    duplicatingInputStream.mark(0);\n+    PartitionId partitionIdStatic = staticClusterManager.getPartitionIdFromStream(duplicatingInputStream);\n+    return partitionIdStatic;\n+  }\n+\n+  @Override\n+  public List<PartitionId> getWritablePartitionIds(String partitionClass) {\n+    throw new UnsupportedOperationException(String.format(\"getWritablePartitionIds method is not supported\"));\n+  }\n+\n+  @Override\n+  public PartitionId getRandomWritablePartition(String partitionClass, List<PartitionId> partitionsToExclude) {\n+    throw new UnsupportedOperationException(String.format(\"getRandomWritablePartition method is not supported\"));\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Get all partition ids from both the underlying {@link StaticClusterManager}.\n+   * @param partitionClass the partition class whose partitions are required. Can be {@code null}\n+   * @return a list of partition ids from the underlying {@link StaticClusterManager}.\n+   */\n+  @Override\n+  public List<PartitionId> getAllPartitionIds(String partitionClass) {\n+    List<PartitionId> staticPartitionIds = staticClusterManager.getAllPartitionIds(partitionClass);\n+    return staticPartitionIds;\n+  }\n+\n+  /**\n+   * Check for existence of the given datacenter from both the static and the helix based cluster managers and update\n+   * a metric if there is a mismatch.\n+   * @param datacenterName name of datacenter\n+   * @return true if the datacenter exists in the underlying {@link StaticClusterManager}; false otherwise.\n+   */\n+  @Override\n+  public boolean hasDatacenter(String datacenterName) {\n+    boolean staticHas = staticClusterManager.hasDatacenter(datacenterName);\n+    boolean helixHas = helixClusterManager.hasDatacenter(datacenterName);\n+    return staticHas || helixHas;\n+  }\n+\n+  @Override\n+  public byte getLocalDatacenterId() {\n+    return staticClusterManager.getLocalDatacenterId();\n+  }\n+\n+  @Override\n+  public String getDatacenterName(byte id) {\n+    String dcName = staticClusterManager.getDatacenterName(id);\n+    return (dcName != null) ? dcName : helixClusterManager.getDatacenterName(id);\n+  }\n+\n+  /**\n+   * Return the {@link DataNodeId} associated with the given hostname and port in the underlying\n+   * {@link StaticClusterManager}. If not found in static cluster map, then get the same from helix cluster map.\n+   * @param hostname of the DataNodeId\n+   * @param port of the DataNodeId\n+   * @return the {@link DataNodeId} associated with the given hostname and port.\n+   */\n+  @Override\n+  public DataNodeId getDataNodeId(String hostname, int port) {\n+    DataNodeId dataNode = staticClusterManager.getDataNodeId(hostname, port);\n+    if (dataNode == null) {\n+      dataNode = helixClusterManager.getDataNodeId(hostname, port);\n+    }\n+    return dataNode;\n+  }\n+\n+  /**\n+   * Get the list of {@link ReplicaId}s associated with the given {@link DataNodeId} in the underlying\n+   * {@link StaticClusterManager}. The list of {@link ReplicaId}s is obtained by merging replica lists from\n+   * {@link HelixClusterManager} and {@link StaticClusterManager}.\n+   * @param dataNodeId the {@link DataNodeId} for which the replicas are to be listed.\n+   * @return merged list of {@link ReplicaId}s as present in the underlying {@link StaticClusterManager} and\n+   * {@link HelixClusterManager} for the given node.\n+   */\n+  @Override\n+  public List<ReplicaId> getReplicaIds(DataNodeId dataNodeId) {\n+    List<ReplicaId> mergedReplicas = new ArrayList<>();\n+    for (ReplicaId staticReplica : staticClusterManager.getReplicaIds(dataNodeId)) {\n+      AmbryPartition partitionId = (AmbryPartition) getHelixPartition(staticReplica);\n+      if (partitionId == null) {\n+        throw new IllegalStateException(String.format(\"No partition %s not found in helix clustermap\",\n+            staticReplica.getPartitionId().toPathString()));\n+      }\n+      Partition partition = (Partition) staticReplica.getPartitionId();\n+      Partition compositePartition =\n+          new Partition(Long.parseLong(partitionId.toPathString()), partition.getPartitionClass(),\n+              partition.getPartitionState(), partition.getReplicaCapacityInBytes());\n+      for (ReplicaId replicaId : partitionId.getReplicaIds()) {\n+        compositePartition.addReplica(replicaId);\n+      }\n+      Replica compositeReplica = new Replica(compositePartition, (Disk) staticReplica.getDiskId(),\n+          ((Replica) staticReplica).getClusterMapConfig());\n+      compositePartition.addReplica(compositeReplica);\n+      mergedReplicas.add(compositeReplica);\n+    }\n+    return mergedReplicas;\n+  }\n+\n+  /**\n+   * Search from all the partitions of {@link HelixClusterManager}, the {@link PartitionId} with same partition id as\n+   * one in the {@link ReplicaId} passed.\n+   * @param replicaId {@link ReplicaId} object.\n+   * @return {@link PartitionId} of {@link HelixClusterManager}.\n+   */\n+  PartitionId getHelixPartition(ReplicaId replicaId) {\n+    return helixClusterManager.getAllPartitionIds(null)\n+        .stream()\n+        .filter(partitionId -> replicaId.getPartitionId().toPathString().equals(partitionId.toPathString()))\n+        .findAny()\n+        .get();\n+  }\n+\n+  /**\n+   * The list of {@link DataNodeId}s present in the underlying {@link HelixClusterManager}\n+   * @return the list of {@link DataNodeId}s present in the underlying {@link HelixClusterManager}\n+   */\n+  @Override\n+  public List<? extends DataNodeId> getDataNodeIds() {\n+    return helixClusterManager.getDataNodeIds();\n+  }\n+\n+  @Override\n+  public MetricRegistry getMetricRegistry() {\n+    return staticClusterManager.getMetricRegistry();\n+  }\n+\n+  /**\n+   * Relay the event to both the underlying {@link StaticClusterManager} and the underlying {@link HelixClusterManager}.\n+   * @param replicaId the {@link ReplicaId} for which this event has occurred.\n+   * @param event the {@link ReplicaEventType}.\n+   */\n+  @Override\n+  public void onReplicaEvent(ReplicaId replicaId, ReplicaEventType event) {\n+    helixClusterManager.onReplicaEvent(replicaId, event);\n+  }\n+\n+  @Override\n+  public JSONObject getSnapshot() {\n+    return staticClusterManager.getSnapshot();\n+  }\n+\n+  @Override\n+  public ReplicaId getBootstrapReplica(String partitionIdStr, DataNodeId dataNodeId) {\n+    return helixClusterManager.getBootstrapReplica(partitionIdStr, dataNodeId);\n+  }\n+\n+  @Override\n+  public void registerClusterMapListener(ClusterMapChangeListener clusterMapChangeListener) {\n+    if (helixClusterManager != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMTMxOA==", "bodyText": "These things look out of place here.\nAlso, if the cluster agents factories are constructed with the two layout files, why do we even need the config properties?", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379131318", "createdAt": "2020-02-13T21:34:53Z", "author": {"login": "lightningrob"}, "path": "ambry-api/src/main/java/com.github.ambry/config/ClusterMapConfig.java", "diffHunk": "@@ -231,6 +232,20 @@\n   @Default(\"false\")\n   public final boolean clustermapUpdateDatanodeInfo;\n \n+  /**\n+   * Partition layout json for recovery test cluster map.\n+   */\n+  @Config(\"clustermap.recovery.test.partition.layout\")\n+  @Default(\"{}\")\n+  public final JSONObject clustermapRecoveryTestPartitionLayout;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTc5MDMz", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-358579033", "createdAt": "2020-02-13T21:53:50Z", "commit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo1Mzo1MFrOFpk4Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo1NTowOVrOFpk6oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MDE5MA==", "bodyText": "CompositeClusterAgentsFactory -> RecoveryTestClusterAgentsFactory", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379140190", "createdAt": "2020-02-13T21:53:50Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import java.io.IOException;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *\n+ */\n+public class RecoveryTestClusterAgentsFactory implements ClusterAgentsFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeClusterAgentsFactory.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MDc2OQ==", "bodyText": "complete the java doc", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379140769", "createdAt": "2020-02-13T21:55:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import java.io.IOException;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTkwMjY2", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-358590266", "createdAt": "2020-02-13T22:13:24Z", "commit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMzoyNFrOFpla0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMzoyNFrOFpla0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTAxMA==", "bodyText": "As discussed offline, we can remove this config.", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379149010", "createdAt": "2020-02-13T22:13:24Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/config/ServerConfig.java", "diffHunk": "@@ -93,6 +93,13 @@\n   @Default(\"false\")\n   public final boolean serverValidateRequestBasedOnStoreState;\n \n+  /**\n+   * Should the server participate in any cluster.\n+   */\n+  @Config(\"server.should.not.participate.in.cluster\")\n+  @Default(\"false\")\n+  public boolean serverShouldNotParticipateInCluster;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679"}, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89bd3d8a27be52509f4e14fe4ba2d7f074af6679", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/89bd3d8a27be52509f4e14fe4ba2d7f074af6679", "committedDate": "2020-02-13T17:38:46Z", "message": "Typo fix"}, "afterCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/246f5cf00cab24b3c50891d0346929fccd20e3be", "committedDate": "2020-02-13T23:17:06Z", "message": "Create a no op ClusterParticipant. Remove shouldParticipate config. Address other review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjM3OTY0", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-358637964", "createdAt": "2020-02-14T00:05:54Z", "commit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDowNTo1NFrOFpnzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDozMzoxN1rOFpoP9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4Nzk5MQ==", "bodyText": "Any reason to change Replica to ReplicaId?  Partittion, Replica and Disk are for static clustermap. I think in this class, it is supposed to be Replica and cannot be another implementation of ReplicaId.", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379187991", "createdAt": "2020-02-14T00:05:54Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/Partition.java", "diffHunk": "@@ -44,7 +44,7 @@\n   private static final short Current_Version = 1;\n   private static final int Partition_Size_In_Bytes = Version_Field_Size_In_Bytes + 8;\n \n-  private final List<Replica> replicas;\n+  private final List<ReplicaId> replicas;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTc0MA==", "bodyText": "can remove this", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379191740", "createdAt": "2020-02-14T00:19:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.server.AmbryHealthReport;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A factory class to construct {@link RecoveryTestClusterManager} and a no op {@link ClusterParticipant}.\n+ * Only one instance of each type of objects will ever be created by this factory.\n+ */\n+public class RecoveryTestClusterAgentsFactory implements ClusterAgentsFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(RecoveryTestClusterAgentsFactory.class);\n+  private final StaticClusterAgentsFactory staticClusterAgentsFactory;\n+  private final HelixClusterAgentsFactory helixClusterAgentsFactory;\n+  private final AtomicReference<RecoveryTestClusterManager> recoveryTestClusterManagerRef = new AtomicReference<>();\n+  private final AtomicReference<ClusterParticipant> clusterParticipantRef = new AtomicReference<>();\n+\n+  /**\n+   * Create an instance of this class.\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param hardwareLayoutFilePath the path to the hardware layout file.\n+   * @param partitionLayoutFilePath the path to the partition layout file.\n+   * @throws JSONException if there is an exception parsing the layout files.\n+   * @throws IOException if there is an IO error accessing or reading the layout files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5NDk0OA==", "bodyText": "return can be removed", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379194948", "createdAt": "2020-02-14T00:31:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.server.AmbryHealthReport;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A factory class to construct {@link RecoveryTestClusterManager} and a no op {@link ClusterParticipant}.\n+ * Only one instance of each type of objects will ever be created by this factory.\n+ */\n+public class RecoveryTestClusterAgentsFactory implements ClusterAgentsFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(RecoveryTestClusterAgentsFactory.class);\n+  private final StaticClusterAgentsFactory staticClusterAgentsFactory;\n+  private final HelixClusterAgentsFactory helixClusterAgentsFactory;\n+  private final AtomicReference<RecoveryTestClusterManager> recoveryTestClusterManagerRef = new AtomicReference<>();\n+  private final AtomicReference<ClusterParticipant> clusterParticipantRef = new AtomicReference<>();\n+\n+  /**\n+   * Create an instance of this class.\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param hardwareLayoutFilePath the path to the hardware layout file.\n+   * @param partitionLayoutFilePath the path to the partition layout file.\n+   * @throws JSONException if there is an exception parsing the layout files.\n+   * @throws IOException if there is an IO error accessing or reading the layout files.\n+   */\n+  public RecoveryTestClusterAgentsFactory(ClusterMapConfig clusterMapConfig, String hardwareLayoutFilePath,\n+      String partitionLayoutFilePath) throws JSONException {\n+    PartitionLayout partitionLayout =\n+        new PartitionLayout(new HardwareLayout(clusterMapConfig.clustermapRecoveryTestHardwareLayout, clusterMapConfig),\n+            clusterMapConfig.clustermapRecoveryTestPartitionLayout, clusterMapConfig);\n+    staticClusterAgentsFactory = new StaticClusterAgentsFactory(clusterMapConfig, partitionLayout);\n+    helixClusterAgentsFactory =\n+        new HelixClusterAgentsFactory(clusterMapConfig, staticClusterAgentsFactory.getMetricRegistry());\n+  }\n+\n+  /**\n+   * Create and return a {@link RecoveryTestClusterManager}.\n+   * @return the constructed {@link RecoveryTestClusterManager}.\n+   * @throws Exception if constructing the underlying {@link StaticClusterManager} or the {@link HelixClusterManager}\n+   * throws an Exception.\n+   */\n+  @Override\n+  public RecoveryTestClusterManager getClusterMap() throws IOException {\n+    if (recoveryTestClusterManagerRef.get() == null) {\n+      StaticClusterManager staticClusterManager = staticClusterAgentsFactory.getClusterMap();\n+      HelixClusterManager helixClusterManager = null;\n+      try {\n+        helixClusterManager = helixClusterAgentsFactory.getClusterMap();\n+      } catch (Exception e) {\n+        logger.error(\"Helix cluster manager instantiation failed with exception\", e);\n+      }\n+      recoveryTestClusterManagerRef.compareAndSet(null,\n+          new RecoveryTestClusterManager(staticClusterManager, helixClusterManager));\n+    }\n+    return recoveryTestClusterManagerRef.get();\n+  }\n+\n+  @Override\n+  public ClusterParticipant getClusterParticipant() throws IOException {\n+    if (clusterParticipantRef.get() == null) {\n+      // create a no op cluster participant that does nothing. Just sits idly by!!! \u00af\\_(\u30c4)_/\u00af\n+      ClusterParticipant clusterParticipant = new ClusterParticipant() {\n+        @Override\n+        public void participate(List<AmbryHealthReport> ambryHealthReports) {\n+          return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5NTM4Mw==", "bodyText": "If there is an exception when getting helix cluster manager, should we terminate the startup?", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379195383", "createdAt": "2020-02-14T00:33:17Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/RecoveryTestClusterAgentsFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.server.AmbryHealthReport;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.json.JSONException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A factory class to construct {@link RecoveryTestClusterManager} and a no op {@link ClusterParticipant}.\n+ * Only one instance of each type of objects will ever be created by this factory.\n+ */\n+public class RecoveryTestClusterAgentsFactory implements ClusterAgentsFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(RecoveryTestClusterAgentsFactory.class);\n+  private final StaticClusterAgentsFactory staticClusterAgentsFactory;\n+  private final HelixClusterAgentsFactory helixClusterAgentsFactory;\n+  private final AtomicReference<RecoveryTestClusterManager> recoveryTestClusterManagerRef = new AtomicReference<>();\n+  private final AtomicReference<ClusterParticipant> clusterParticipantRef = new AtomicReference<>();\n+\n+  /**\n+   * Create an instance of this class.\n+   * @param clusterMapConfig the {@link ClusterMapConfig} to use.\n+   * @param hardwareLayoutFilePath the path to the hardware layout file.\n+   * @param partitionLayoutFilePath the path to the partition layout file.\n+   * @throws JSONException if there is an exception parsing the layout files.\n+   * @throws IOException if there is an IO error accessing or reading the layout files.\n+   */\n+  public RecoveryTestClusterAgentsFactory(ClusterMapConfig clusterMapConfig, String hardwareLayoutFilePath,\n+      String partitionLayoutFilePath) throws JSONException {\n+    PartitionLayout partitionLayout =\n+        new PartitionLayout(new HardwareLayout(clusterMapConfig.clustermapRecoveryTestHardwareLayout, clusterMapConfig),\n+            clusterMapConfig.clustermapRecoveryTestPartitionLayout, clusterMapConfig);\n+    staticClusterAgentsFactory = new StaticClusterAgentsFactory(clusterMapConfig, partitionLayout);\n+    helixClusterAgentsFactory =\n+        new HelixClusterAgentsFactory(clusterMapConfig, staticClusterAgentsFactory.getMetricRegistry());\n+  }\n+\n+  /**\n+   * Create and return a {@link RecoveryTestClusterManager}.\n+   * @return the constructed {@link RecoveryTestClusterManager}.\n+   * @throws Exception if constructing the underlying {@link StaticClusterManager} or the {@link HelixClusterManager}\n+   * throws an Exception.\n+   */\n+  @Override\n+  public RecoveryTestClusterManager getClusterMap() throws IOException {\n+    if (recoveryTestClusterManagerRef.get() == null) {\n+      StaticClusterManager staticClusterManager = staticClusterAgentsFactory.getClusterMap();\n+      HelixClusterManager helixClusterManager = null;\n+      try {\n+        helixClusterManager = helixClusterAgentsFactory.getClusterMap();\n+      } catch (Exception e) {\n+        logger.error(\"Helix cluster manager instantiation failed with exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjUyNDgx", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-359252481", "createdAt": "2020-02-14T22:21:10Z", "commit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjoyMToxMFrOFqFSPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjoyMzoyN1rOFqFU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MTEwMg==", "bodyText": "Why we need this change? They might have different types?", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379671102", "createdAt": "2020-02-14T22:21:10Z", "author": {"login": "jsjtzyy"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PartitionRequestInfo.java", "diffHunk": "@@ -42,7 +42,7 @@ public PartitionRequestInfo(PartitionId partitionId, List<BlobId> blobIds) {\n     totalIdSize = 0;\n     for (BlobId id : blobIds) {\n       totalIdSize += id.sizeInBytes();\n-      if (!partitionId.equals(id.getPartition())) {\n+      if (!partitionId.toPathString().equals(id.getPartition().toPathString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MTc5MQ==", "bodyText": "same here, I feel compareTo would suffice", "url": "https://github.com/linkedin/ambry/pull/1383#discussion_r379671791", "createdAt": "2020-02-14T22:23:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicaThread.java", "diffHunk": "@@ -851,7 +851,9 @@ private void writeMessagesToLocalStoreAndAdvanceTokens(List<ExchangeMetadataResp\n               getResponse.getPartitionResponseInfoList().get(partitionResponseInfoIndex);\n           responseHandler.onEvent(remoteReplicaInfo.getReplicaId(), partitionResponseInfo.getErrorCode());\n           partitionResponseInfoIndex++;\n-          if (partitionResponseInfo.getPartition().compareTo(remoteReplicaInfo.getReplicaId().getPartitionId()) != 0) {\n+          if (!partitionResponseInfo.getPartition()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "246f5cf00cab24b3c50891d0346929fccd20e3be"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d6df3216b4f85fa7261543583432896e1d4058a", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/7d6df3216b4f85fa7261543583432896e1d4058a", "committedDate": "2020-02-15T02:42:58Z", "message": "Create RecoveryTestClusterAgentsFactory and RecoveryTestClusterManager to enable replication of source of truth data for recovery verification."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45e308feadf34c3398e5e39300bd554bcd131669", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/45e308feadf34c3398e5e39300bd554bcd131669", "committedDate": "2020-02-15T02:42:59Z", "message": "Fix a unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d503d63cc4f5b88fd042ac4b2b0cf5bc016cfe6", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/4d503d63cc4f5b88fd042ac4b2b0cf5bc016cfe6", "committedDate": "2020-02-15T02:44:57Z", "message": "Create a no op ClusterParticipant. Remove shouldParticipate config. Address other review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5ac869c9da1fddfec29672a7f42442cf2ca25f", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/ee5ac869c9da1fddfec29672a7f42442cf2ca25f", "committedDate": "2020-02-15T02:44:57Z", "message": "Address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f2476526de30b973c349a1cb8f9a236c744b94a", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/7f2476526de30b973c349a1cb8f9a236c744b94a", "committedDate": "2020-02-15T01:57:03Z", "message": "Address review comments"}, "afterCommit": {"oid": "ee5ac869c9da1fddfec29672a7f42442cf2ca25f", "author": {"user": {"login": "ankagrawal", "name": "Ankur Agrawal"}}, "url": "https://github.com/linkedin/ambry/commit/ee5ac869c9da1fddfec29672a7f42442cf2ca25f", "committedDate": "2020-02-15T02:44:57Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzI5NjY2", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-359329666", "createdAt": "2020-02-15T06:24:09Z", "commit": {"oid": "ee5ac869c9da1fddfec29672a7f42442cf2ca25f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzYwNDA5", "url": "https://github.com/linkedin/ambry/pull/1383#pullrequestreview-360760409", "createdAt": "2020-02-19T00:01:43Z", "commit": {"oid": "ee5ac869c9da1fddfec29672a7f42442cf2ca25f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1613, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}