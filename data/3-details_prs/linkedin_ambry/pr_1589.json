{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDc3Nzky", "number": 1589, "title": "Drop http2 request in two cases", "bodyText": "Drop request on router requests to drop a request.\nDrop request on writeAndFlush exceeds threshold.\nAdjusted Netty High and Low WaterMark for isWriteable() tracking.\nThere was an assumption that a stream channel can be released twice. This is wrong because MultiplexedChannelRecord maintains a counter for streams on it. This PR fixs it by checking if RESPONSE_INFO attr null or not.", "createdAt": "2020-07-13T20:39:36Z", "url": "https://github.com/linkedin/ambry/pull/1589", "merged": true, "mergeCommit": {"oid": "aaece214f40775ea7177863c5fe537d8ff8f2234"}, "closed": true, "closedAt": "2020-07-17T19:35:58Z", "author": {"login": "zzmao"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0nqZYgBqjM1NDEyMjY0MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc15FjDgFqTQ1MDkxMDA5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6cdf23132994f79c33a2a7ea1b1354047707a99b", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/6cdf23132994f79c33a2a7ea1b1354047707a99b", "committedDate": "2020-07-13T20:32:14Z", "message": "clean up"}, "afterCommit": {"oid": "8bc826b093b0c9816386acea017306bd76525ffd", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/8bc826b093b0c9816386acea017306bd76525ffd", "committedDate": "2020-07-13T20:42:31Z", "message": "clean up"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8bc826b093b0c9816386acea017306bd76525ffd", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/8bc826b093b0c9816386acea017306bd76525ffd", "committedDate": "2020-07-13T20:42:31Z", "message": "clean up"}, "afterCommit": {"oid": "27026608d4372f99a98ad0022a1f1e71aec79a81", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/27026608d4372f99a98ad0022a1f1e71aec79a81", "committedDate": "2020-07-13T20:45:23Z", "message": "clean up"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27026608d4372f99a98ad0022a1f1e71aec79a81", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/27026608d4372f99a98ad0022a1f1e71aec79a81", "committedDate": "2020-07-13T20:45:23Z", "message": "clean up"}, "afterCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9", "committedDate": "2020-07-13T21:24:34Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Njk2ODE0", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-447696814", "createdAt": "2020-07-14T00:09:56Z", "commit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDowOTo1NlrOGw_KUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDowOTo1NlrOGw_KUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA==", "bodyText": "Is there a reason for dropping the connection at this point as opposed to just waiting until the router tells the NetworkClient to drop the request after routerRequestTimeoutMs? At this point, the request has already been flushed successfully so the request memory would have already been freed.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454019664", "createdAt": "2020-07-14T00:09:56Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9e8a0091a9704d967c810a07211a4517fd289e5", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/f9e8a0091a9704d967c810a07211a4517fd289e5", "committedDate": "2020-07-14T18:01:20Z", "message": "drop request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/890096ef0838c4deedd988f89f42b3366bc13928", "committedDate": "2020-07-14T19:32:27Z", "message": "exception"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9", "committedDate": "2020-07-13T21:24:34Z", "message": "clean up"}, "afterCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/890096ef0838c4deedd988f89f42b3366bc13928", "committedDate": "2020-07-14T19:32:27Z", "message": "exception"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NDE3OTM0", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-448417934", "createdAt": "2020-07-14T19:53:58Z", "commit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOTo1Mzo1OFrOGxi8sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOTo1ODoxMlrOGxjFxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjAwMA==", "bodyText": "I am not worried about this. Comparing to the small object ByteBuf, the byte content held by ByteBuf is way larger. As long as the byte content can be reclaimed by the memory pool, we can ignore the small ByteBuf object.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454606000", "createdAt": "2020-07-14T19:53:58Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjYyNw==", "bodyText": "is there a possibility that redyResponseInfos contain responses for the dropped request? if so, do we care?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454606627", "createdAt": "2020-07-14T19:55:08Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ==", "bodyText": "Also, should probably remove the correlationIds for these responses from the inflight map.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454608325", "createdAt": "2020-07-14T19:58:12Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/a311b0d669412821d2c9084cfd624b2e135b661b", "committedDate": "2020-07-14T20:49:31Z", "message": "address justin comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1c8a04712cd406ff526d981f643fdb84b76f277", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/b1c8a04712cd406ff526d981f643fdb84b76f277", "committedDate": "2020-07-14T20:27:10Z", "message": "address justin comment"}, "afterCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/a311b0d669412821d2c9084cfd624b2e135b661b", "committedDate": "2020-07-14T20:49:31Z", "message": "address justin comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NDgwOTA0", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-448480904", "createdAt": "2020-07-14T21:30:40Z", "commit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozMDo0MFrOGxmFEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0NjoyOVrOGxmhug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzI5Ng==", "bodyText": "what is this? This handler is not used anywhere, and it seems like we are trying to print out some info when it's a stream exception, which makes this a stream handler, doesn't stream handler belong to Http2NetworkClient.StreamChannelInitializer?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454657296", "createdAt": "2020-07-14T21:30:40Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1OTIzMA==", "bodyText": "correlationIdInFlightToChannelMap.remove(correlationId) would be better.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454659230", "createdAt": "2020-07-14T21:34:43Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,24 +84,47 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n+    if (requestsToDrop.size() != 0) {\n+      logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n+      http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.get(correlationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NDYzNA==", "bodyText": "Yes and no. When using Unpooled bytebuf, big chunk of data will rely on gc to release the memory. When using Pooled ByteBuf, big chunk of data will rely on calling release method to return the chunk back to the pool. GC doesn't reclaim the data chunk, only the small heap memory of ByteBuf fields.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454664634", "createdAt": "2020-07-14T21:46:29Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NDc1OTY1", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-448475965", "createdAt": "2020-07-14T21:22:27Z", "commit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMjoyN1rOGxl1Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1Mzo1NlrOGxmuKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzI1OQ==", "bodyText": "is this added to the pipeline anywhere?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454653259", "createdAt": "2020-07-14T21:22:27Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -49,6 +56,7 @@ public Http2ChannelPoolHandler(SSLFactory sslFactory, String host, int port, Htt\n     this.host = host;\n     this.port = port;\n     this.http2ClientConfig = http2ClientConfig;\n+    this.connectionInboundExceptionHandler = new ConnectionInboundExceptionHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NzgxOQ==", "bodyText": "\"which from...\" -> \"for a request which was already dropped\"", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454667819", "createdAt": "2020-07-14T21:53:56Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+      if (cause instanceof Http2Exception.StreamException) {\n+        // This usually happens when server returns response which from a dropped request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "feb4cce14b41752ec3379089522f2bf86b38df32", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/feb4cce14b41752ec3379089522f2bf86b38df32", "committedDate": "2020-07-14T22:04:51Z", "message": "address justin comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b332e8776f02f5ff19216d5533da0ff53b95844", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/7b332e8776f02f5ff19216d5533da0ff53b95844", "committedDate": "2020-07-15T17:48:38Z", "message": "fix stream counter overflow issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MTE2NzMw", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-449116730", "createdAt": "2020-07-15T16:26:01Z", "commit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNjowMVrOGyFv3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzo0OToxOVrOGyJKuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3NjE1OQ==", "bodyText": "nit: remove whitespace at the end of these log messages", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176159", "createdAt": "2020-07-15T16:26:01Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/MultiplexedChannelRecord.java", "diffHunk": "@@ -268,18 +268,21 @@ private boolean claimStream() {\n     for (int attempt = 0; attempt < 5; ++attempt) {\n \n       if (state != RecordState.OPEN) {\n+        log.warn(\"claimStream fail because state is closed. \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3NjYyNQ==", "bodyText": "remove whitespace here", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176625", "createdAt": "2020-07-15T16:26:45Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "diffHunk": "@@ -1357,7 +1357,7 @@ private void fetchRequests(RequestRegistrationCallback<PutOperation> requestRegi\n         requestRegistrationCallback.registerRequestToSend(PutOperation.this, request);\n         replicaIterator.remove();\n         if (RouterUtils.isRemoteReplica(routerConfig, replicaId)) {\n-          logger.trace(\"Making request with correlationId {} to a remote replica {} in {} \", correlationId,\n+          logger.debug(\"Making request with correlationId {} to a remote replica {} in {} \", correlationId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3Njk4Ng==", "bodyText": "what is the new import used for?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176986", "createdAt": "2020-07-15T16:27:22Z", "author": {"login": "cgtz"}, "path": "build.gradle", "diffHunk": "@@ -248,7 +248,8 @@ project(':ambry-network') {\n         compile project(':ambry-api'),\n                 project(':ambry-utils'),\n                 project(':ambry-commons'),\n-                project(':ambry-clustermap')\n+                project(':ambry-clustermap'),\n+                project(':ambry-protocol')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNzE5NA==", "bodyText": "Why doesn't the ref count get decremented in other exception cases? Are we assuming that other exception cases come from ChannelHandlers written by Ambry that don't decrement the ref count?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455207194", "createdAt": "2020-07-15T17:16:24Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -124,8 +164,11 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     releaseAndCloseStreamChannel(streamChannel);\n                     http2ClientResponseHandler.getResponseInfoQueue()\n                         .put(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n-                    // release related bytebuf\n-                    requestInfo.getRequest().release();\n+                    if (!(future.cause() instanceof ClosedChannelException)) {\n+                      // If it's ClosedChannelException caused by drop request, it's probably refCnt has been decreased.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMjE4NQ==", "bodyText": "Does this mean that a request cannot be dropped if stream acquisition takes a long time? I guess that is okay since that may be a rare occurrence and would require some complicated logic in the acquire listener to determine if the request can be sent or not.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455232185", "createdAt": "2020-07-15T17:49:19Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ=="}, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "071d56cbc65d7496502252f4bdeace2ad41e4a3d", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/071d56cbc65d7496502252f4bdeace2ad41e4a3d", "committedDate": "2020-07-15T17:42:14Z", "message": "fix stream counter overflow issue"}, "afterCommit": {"oid": "7b332e8776f02f5ff19216d5533da0ff53b95844", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/7b332e8776f02f5ff19216d5533da0ff53b95844", "committedDate": "2020-07-15T17:48:38Z", "message": "fix stream counter overflow issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjI5Mjg3", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-449229287", "createdAt": "2020-07-15T18:36:37Z", "commit": {"oid": "7b332e8776f02f5ff19216d5533da0ff53b95844"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9f09c3156c74d5004e18edd9fdd7920b7bd7b42", "author": {"user": {"login": "zzmao", "name": "Ze Mao"}}, "url": "https://github.com/linkedin/ambry/commit/f9f09c3156c74d5004e18edd9fdd7920b7bd7b42", "committedDate": "2020-07-15T21:07:23Z", "message": "remove white space"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwOTEwMDk1", "url": "https://github.com/linkedin/ambry/pull/1589#pullrequestreview-450910095", "createdAt": "2020-07-17T19:34:43Z", "commit": {"oid": "f9f09c3156c74d5004e18edd9fdd7920b7bd7b42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1184, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}