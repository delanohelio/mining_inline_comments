{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNDYzMjA0", "number": 1557, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo0NjoxM1rOEDrDLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzozMzowN1rOED_HDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg2NTEwOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo0NjoxM1rOGg1Ajw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDozODo0N1rOGg4fEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NjExMQ==", "bodyText": "Suggest making these Callable since they are not run as threads.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437076111", "createdAt": "2020-06-09T00:46:13Z", "author": {"login": "lightningrob"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -94,8 +94,10 @@\n   // TODO remove this once ZK migration is complete\n   private AtomicBoolean isSealed = new AtomicBoolean(false);\n   protected PersistentIndex index;\n+\n   // THIS IS ONLY FOR TEST.\n-  protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable operationBeforeSynchronizationFunc = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzA3NA==", "bodyText": "change the type to callable.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437133074", "createdAt": "2020-06-09T04:38:47Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -94,8 +94,10 @@\n   // TODO remove this once ZK migration is complete\n   private AtomicBoolean isSealed = new AtomicBoolean(false);\n   protected PersistentIndex index;\n+\n   // THIS IS ONLY FOR TEST.\n-  protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable operationBeforeSynchronizationFunc = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NjExMQ=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg4Mjk3OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo1NjoxMVrOGg1LCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDozODo1M1rOGg4fKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODc5Mw==", "bodyText": "You can use lambda callables here as well.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437078793", "createdAt": "2020-06-09T00:56:11Z", "author": {"login": "lightningrob"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -714,6 +714,62 @@ public Void call() throws Exception {\n     }\n   }\n \n+  /**\n+   * Test the case where a Put happens while a Delete is doing the preliminary check.\n+   * Since the delete happens before put, delete should return a ID_NOT_FOUND error.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteAndPutTest() throws Exception {\n+    MockId id = getUniqueId();\n+    final CountDownLatch getEndOffsetLatch = new CountDownLatch(1);\n+    final CountDownLatch findKeyLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setBetweenGetEndOffsetAndFindKeyFunc(() -> {\n+      getEndOffsetLatch.countDown();\n+      try {\n+        findKeyLatch.await();\n+      } catch (Exception e) {\n+      }\n+    });\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(new Callable<Void>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzA5OQ==", "bodyText": "done.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437133099", "createdAt": "2020-06-09T04:38:53Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -714,6 +714,62 @@ public Void call() throws Exception {\n     }\n   }\n \n+  /**\n+   * Test the case where a Put happens while a Delete is doing the preliminary check.\n+   * Since the delete happens before put, delete should return a ID_NOT_FOUND error.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteAndPutTest() throws Exception {\n+    MockId id = getUniqueId();\n+    final CountDownLatch getEndOffsetLatch = new CountDownLatch(1);\n+    final CountDownLatch findKeyLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setBetweenGetEndOffsetAndFindKeyFunc(() -> {\n+      getEndOffsetLatch.countDown();\n+      try {\n+        findKeyLatch.await();\n+      } catch (Exception e) {\n+      }\n+    });\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(new Callable<Void>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODc5Mw=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg4NTI0OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo1NzozN1rOGg1MbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDozODozNlrOGg4e7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3OTE0OA==", "bodyText": "Nit: this callback is only invoked during delete while the first one is called in every method.  Suggest renaming it to indicate it's only for delete, or at least add a comment.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437079148", "createdAt": "2020-06-09T00:57:37Z", "author": {"login": "lightningrob"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -94,8 +94,10 @@\n   // TODO remove this once ZK migration is complete\n   private AtomicBoolean isSealed = new AtomicBoolean(false);\n   protected PersistentIndex index;\n+\n   // THIS IS ONLY FOR TEST.\n-  protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable betweenGetEndOffsetAndFindKeyFunc = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzAzNw==", "bodyText": "update the variable's name.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437133037", "createdAt": "2020-06-09T04:38:36Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -94,8 +94,10 @@\n   // TODO remove this once ZK migration is complete\n   private AtomicBoolean isSealed = new AtomicBoolean(false);\n   protected PersistentIndex index;\n+\n   // THIS IS ONLY FOR TEST.\n-  protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable operationBeforeSynchronizationFunc = null;\n+  volatile protected Runnable betweenGetEndOffsetAndFindKeyFunc = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3OTE0OA=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg5MTUxOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMTowMTowN1rOGg1QCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDo0MDoxMFrOGg4gbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDA3Mw==", "bodyText": "For this type of conditional execution, AtomicObject is safer than volatile.  II believe it's technically possible for this to get a NPE since volatile doesn't prevent the variable from being overwritten between checking for null and running.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437080073", "createdAt": "2020-06-09T01:01:07Z", "author": {"login": "lightningrob"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -835,6 +845,15 @@ private void maybeCallBeforeSynchronizationFunc() {\n     }\n   }\n \n+  /**\n+   * Call {@link #betweenGetEndOffsetAndFindKeyFunc} if it's not null. This is for testing only.\n+   */\n+  private void maybeCallBetweenGetEndOffsetAndFindKeyFunc() {\n+    if (betweenGetEndOffsetAndFindKeyFunc != null) {\n+      betweenGetEndOffsetAndFindKeyFunc.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzQyMg==", "bodyText": "good catch on the NPE. But I think it's fine to use volatile since we are not doing any CAS operation here. I updated to make sure the NPE doesn't happen.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437133422", "createdAt": "2020-06-09T04:40:10Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -835,6 +845,15 @@ private void maybeCallBeforeSynchronizationFunc() {\n     }\n   }\n \n+  /**\n+   * Call {@link #betweenGetEndOffsetAndFindKeyFunc} if it's not null. This is for testing only.\n+   */\n+  private void maybeCallBetweenGetEndOffsetAndFindKeyFunc() {\n+    if (betweenGetEndOffsetAndFindKeyFunc != null) {\n+      betweenGetEndOffsetAndFindKeyFunc.run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDA3Mw=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzEyMzA2OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyMjoyNFrOGg3c6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxMzo0MlrOGhUZig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjEzNg==", "bodyText": "Can we add a log here to further verify our theory?  Something like this:\nlogger.error(\"Cannot delete id {} because {}\", info.getStoreKey(), value == null ? \"it is not found in the index\" : \"its PUT record is out of current offset before check\");\n\nOr maybe you can add more message to StoreException.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437116136", "createdAt": "2020-06-09T03:22:24Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,9 +514,17 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallBetweenGetEndOffsetAndFindKeyFunc();\n       for (MessageInfo info : infosToDelete) {\n         IndexValue value = index.findKey(info.getStoreKey());\n-        if (value == null) {\n+        // TODO: Passing a FileSpan the findKey and change the findKey implementation to fully restrict the index\n+        // searching space to be limited within the given FileSpan.\n+        if (value == null || (value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0 && value.isPut())) {\n+          // A temporary fix to deal with this particular corner case.\n+          // Between calling index.getCurrentEndOffset and findKey method, there is a Put record of the same blob\n+          // is inserted to index.\n+          // index.getCurrentEndOffset should create a virtual snapshot for this delete method. Everything happens after\n+          // this end offset would be considered as happening outside of the snapshot.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNjQzNA==", "bodyText": "changed the  exception message to carry more information about the error.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437136434", "createdAt": "2020-06-09T04:52:50Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,9 +514,17 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallBetweenGetEndOffsetAndFindKeyFunc();\n       for (MessageInfo info : infosToDelete) {\n         IndexValue value = index.findKey(info.getStoreKey());\n-        if (value == null) {\n+        // TODO: Passing a FileSpan the findKey and change the findKey implementation to fully restrict the index\n+        // searching space to be limited within the given FileSpan.\n+        if (value == null || (value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0 && value.isPut())) {\n+          // A temporary fix to deal with this particular corner case.\n+          // Between calling index.getCurrentEndOffset and findKey method, there is a Put record of the same blob\n+          // is inserted to index.\n+          // index.getCurrentEndOffset should create a virtual snapshot for this delete method. Everything happens after\n+          // this end offset would be considered as happening outside of the snapshot.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjEzNg=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MDQxMA==", "bodyText": "Do ID_Not_Found errors msgs get logged anywhere in AmbryRequests?", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437590410", "createdAt": "2020-06-09T17:13:42Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,9 +514,17 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallBetweenGetEndOffsetAndFindKeyFunc();\n       for (MessageInfo info : infosToDelete) {\n         IndexValue value = index.findKey(info.getStoreKey());\n-        if (value == null) {\n+        // TODO: Passing a FileSpan the findKey and change the findKey implementation to fully restrict the index\n+        // searching space to be limited within the given FileSpan.\n+        if (value == null || (value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0 && value.isPut())) {\n+          // A temporary fix to deal with this particular corner case.\n+          // Between calling index.getCurrentEndOffset and findKey method, there is a Put record of the same blob\n+          // is inserted to index.\n+          // index.getCurrentEndOffset should create a virtual snapshot for this delete method. Everything happens after\n+          // this end offset would be considered as happening outside of the snapshot.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjEzNg=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzIxMjI0OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDoyMzo1OFrOGg4Rjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDo1NDozMlrOGg4tog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyOTYxNA==", "bodyText": "Since we have this callable here, can we remove maybeCallBeforeSynchronizationFunc in this delete method? I think we can reuse maybeCallBetweenGetEndOffsetAndFindKeyFunc to complete other concurrency tests.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437129614", "createdAt": "2020-06-09T04:23:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,9 +514,17 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallBetweenGetEndOffsetAndFindKeyFunc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNjgwMg==", "bodyText": "I think they are both necessary. They are testing different corner cases. And I certainly want to remove the getEndOffsetAndFindKey callback after in next PR.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437136802", "createdAt": "2020-06-09T04:54:32Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,9 +514,17 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallBetweenGetEndOffsetAndFindKeyFunc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyOTYxNA=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzIzNjE3OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDozOTo1MFrOGg4gHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDo1MzowMVrOGg4sWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzM0MA==", "bodyText": "I feel like it's more appropriate to put getEndOffsetLatch.await() and findKeyLatch.countDown() into the call() method that performs putOneBlobWithId", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437133340", "createdAt": "2020-06-09T04:39:50Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -714,6 +714,62 @@ public Void call() throws Exception {\n     }\n   }\n \n+  /**\n+   * Test the case where a Put happens while a Delete is doing the preliminary check.\n+   * Since the delete happens before put, delete should return a ID_NOT_FOUND error.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteAndPutTest() throws Exception {\n+    MockId id = getUniqueId();\n+    final CountDownLatch getEndOffsetLatch = new CountDownLatch(1);\n+    final CountDownLatch findKeyLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setBetweenGetEndOffsetAndFindKeyFunc(() -> {\n+      getEndOffsetLatch.countDown();\n+      try {\n+        findKeyLatch.await();\n+      } catch (Exception e) {\n+      }\n+    });\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(new Callable<Void>() {\n+        @Override\n+        public Void call() throws Exception {\n+          MessageInfo info =\n+              new MessageInfo(id, DELETE_RECORD_SIZE, id.getAccountId(), id.getContainerId(), time.milliseconds(),\n+                  MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+          store.delete(Collections.singletonList(info));\n+          return null;\n+        }\n+      });\n+      // Now make sure delete is on the way\n+      getEndOffsetLatch.await();\n+      Future<Void> putFuture = executorService.submit(new Callable<Void>() {\n+        @Override\n+        public Void call() throws Exception {\n+          putOneBlobWithId(id, PUT_RECORD_SIZE, Utils.Infinite_Time);\n+          return null;\n+        }\n+      });\n+      putFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzNjQ3NA==", "bodyText": "good idea.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437136474", "createdAt": "2020-06-09T04:53:01Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -714,6 +714,62 @@ public Void call() throws Exception {\n     }\n   }\n \n+  /**\n+   * Test the case where a Put happens while a Delete is doing the preliminary check.\n+   * Since the delete happens before put, delete should return a ID_NOT_FOUND error.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteAndPutTest() throws Exception {\n+    MockId id = getUniqueId();\n+    final CountDownLatch getEndOffsetLatch = new CountDownLatch(1);\n+    final CountDownLatch findKeyLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setBetweenGetEndOffsetAndFindKeyFunc(() -> {\n+      getEndOffsetLatch.countDown();\n+      try {\n+        findKeyLatch.await();\n+      } catch (Exception e) {\n+      }\n+    });\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(new Callable<Void>() {\n+        @Override\n+        public Void call() throws Exception {\n+          MessageInfo info =\n+              new MessageInfo(id, DELETE_RECORD_SIZE, id.getAccountId(), id.getContainerId(), time.milliseconds(),\n+                  MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+          store.delete(Collections.singletonList(info));\n+          return null;\n+        }\n+      });\n+      // Now make sure delete is on the way\n+      getEndOffsetLatch.await();\n+      Future<Void> putFuture = executorService.submit(new Callable<Void>() {\n+        @Override\n+        public Void call() throws Exception {\n+          putOneBlobWithId(id, PUT_RECORD_SIZE, Utils.Infinite_Time);\n+          return null;\n+        }\n+      });\n+      putFuture.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMzM0MA=="}, "originalCommit": {"oid": "abc882dfe77284a4db611bb023fd9b3a835b8139"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjE1MTgzOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzozMzowN1rOGhVGNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo0MToxOVrOGhVY0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwMTg0Ng==", "bodyText": "There could be one other edge case here where both a put and a ttl update are present after indexEndOffsetBeforeCheck. In this case a put entry will be returned with the \"Ttl_Update_Index\" flag set, which will make value.isPut() return false (See https://github.com/linkedin/ambry/blob/master/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java#L629)\nI suppose this may be even lower probability so we may not need to worry about this in this temporary fix. However, at some point its probably worth looking back on the IndexValue.isPut method (i.e. does a put with ttlupdate flag set by the index logic count as a put record?).", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437601846", "createdAt": "2020-06-09T17:33:07Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,10 +515,20 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallInDeleteBetweenGetEndOffsetAndFindKey();\n       for (MessageInfo info : infosToDelete) {\n         IndexValue value = index.findKey(info.getStoreKey());\n-        if (value == null) {\n-          throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n+        // TODO: Passing a FileSpan the findKey and change the findKey implementation to fully restrict the index\n+        // searching space to be limited within the given FileSpan.\n+        if (value == null || (value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0 && value.isPut())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795cd27f489dbc21b0b587187e68eda8487f8b52"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYxMQ==", "bodyText": "yeah, this is caused by a slight different rule when reading the indexvalue than writing the indexvalue. When writing index value, PUT and TTL_UPDATE are different records. While reading indexvalue, TTL_UPDATE will be merged with other records. It becomes just a flag.\nI suppose we don't have to worry about it at this PR, since next PR, I will use a FileSpan to restrict the search space in findKey.", "url": "https://github.com/linkedin/ambry/pull/1557#discussion_r437606611", "createdAt": "2020-06-09T17:41:19Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -512,10 +515,20 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n       List<IndexValue> indexValuesToDelete = new ArrayList<>();\n       List<Short> lifeVersions = new ArrayList<>();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      maybeCallInDeleteBetweenGetEndOffsetAndFindKey();\n       for (MessageInfo info : infosToDelete) {\n         IndexValue value = index.findKey(info.getStoreKey());\n-        if (value == null) {\n-          throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n+        // TODO: Passing a FileSpan the findKey and change the findKey implementation to fully restrict the index\n+        // searching space to be limited within the given FileSpan.\n+        if (value == null || (value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0 && value.isPut())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwMTg0Ng=="}, "originalCommit": {"oid": "795cd27f489dbc21b0b587187e68eda8487f8b52"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1250, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}