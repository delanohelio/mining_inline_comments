{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzA3NzQy", "number": 1379, "title": "Add handleUndeleteRequest method to AmbryRequests", "bodyText": "Adding handleUndeleteRequest method to AmbryRequests class to handle undelete requests from ambry-frontend.\nAdd unit test and integration test for handleUndeleteRequest\nChange some of the Store implementation in replication test, but since we are not change replication logic for undelete now, we don't change those implementation to support undelete for now.", "createdAt": "2020-02-10T19:21:59Z", "url": "https://github.com/linkedin/ambry/pull/1379", "merged": true, "mergeCommit": {"oid": "db6879a5ddef7a70cbf76c5a39f1c4f23c4e2a77"}, "closed": true, "closedAt": "2020-02-14T21:19:47Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDFDKVABqjMwMjQ2NDY1NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEUxIsgFqTM1OTE3MjA3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aad65937642aedeaa20821067afe7233f2a54d91", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/aad65937642aedeaa20821067afe7233f2a54d91", "committedDate": "2020-02-10T21:02:38Z", "message": "fix test"}, "afterCommit": {"oid": "15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "committedDate": "2020-02-10T22:40:01Z", "message": "fix test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "committedDate": "2020-02-10T22:40:01Z", "message": "fix test"}, "afterCommit": {"oid": "315196578d9aeb29921077a163f4f250496f6f8a", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/315196578d9aeb29921077a163f4f250496f6f8a", "committedDate": "2020-02-11T01:25:56Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fb5c4b3283bad6ad7e83cfd7b943c2ae3ee8b89", "author": {"user": {"login": "dharju", "name": "David Harju"}}, "url": "https://github.com/linkedin/ambry/commit/2fb5c4b3283bad6ad7e83cfd7b943c2ae3ee8b89", "committedDate": "2020-02-12T19:24:30Z", "message": "Add handleUndeleteRequest method to AmbryRequests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7279ad26be40c10df363795b946e7e2b06197675", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/7279ad26be40c10df363795b946e7e2b06197675", "committedDate": "2020-02-12T19:24:30Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f91f71498656ad1f78a66557b12d63a17ec453cc", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/f91f71498656ad1f78a66557b12d63a17ec453cc", "committedDate": "2020-02-12T19:24:30Z", "message": "Add writeTo method to UndeleteResponse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dedd67c2f648f3b21ce2f67f6a0d33775b7bfea", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/8dedd67c2f648f3b21ce2f67f6a0d33775b7bfea", "committedDate": "2020-02-12T19:24:30Z", "message": "Fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDY0Mjkw", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-358464290", "createdAt": "2020-02-13T18:48:20Z", "commit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0ODoyMFrOFpfbqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0ODoyMFrOFpfbqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MDkyMA==", "bodyText": "storeToUndelete?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379050920", "createdAt": "2020-02-13T18:48:20Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDY1MzUx", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-358465351", "createdAt": "2020-02-13T18:49:52Z", "commit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0OTo1MlrOFpfezw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0OTo1MlrOFpfezw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MTcyNw==", "bodyText": "ID_Deleted is the expected case, no?\nWhy no ID_Undeleted?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379051727", "createdAt": "2020-02-13T18:49:52Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDY1ODg5", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-358465889", "createdAt": "2020-02-13T18:50:42Z", "commit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MDo0M1rOFpfghQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MDo0M1rOFpfghQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjE2NQ==", "bodyText": "unExpectedStoreUndeleteError?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052165", "createdAt": "2020-02-13T18:50:43Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();\n+      } else {\n+        logInErrorLevel = true;\n+        metrics.unExpectedStoreDeleteError.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDY2MjA3", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-358466207", "createdAt": "2020-02-13T18:51:11Z", "commit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MToxMlrOFpfhfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MToxMlrOFpfhfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjQxMw==", "bodyText": "undeleteAuthorizationFailure?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052413", "createdAt": "2020-02-13T18:51:12Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDY3OTUz", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-358467953", "createdAt": "2020-02-13T18:53:37Z", "commit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/bec9a78176ab495dc8409efb70e58fdacd8cdf20", "committedDate": "2020-02-13T19:18:23Z", "message": "Address comments about metrics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/01605864ac2919dcf44d2791a7e7cfaef8b02e82", "committedDate": "2020-02-11T21:00:42Z", "message": "Fix"}, "afterCommit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/bec9a78176ab495dc8409efb70e58fdacd8cdf20", "committedDate": "2020-02-13T19:18:23Z", "message": "Address comments about metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MTY2MjI4", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-359166228", "createdAt": "2020-02-14T19:23:27Z", "commit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMzoyN1rOFqBJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMzoyN1rOFqBJ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzQxMA==", "bodyText": "Can we move this piece of code into isRequestEnabled() ?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379603410", "createdAt": "2020-02-14T19:23:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServerRequests.java", "diffHunk": "@@ -614,6 +615,10 @@ protected ServerErrorCode validateRequest(PartitionId partition, RequestOrRespon\n       metrics.partitionReadOnlyError.inc();\n       return ServerErrorCode.Partition_ReadOnly;\n     }\n+    if (requestType.equals(RequestOrResponseType.UndeleteRequest) && !serverConfig.serverHandleUndeleteRequestEnabled) {\n+      metrics.temporarilyDisabledError.inc();\n+      return ServerErrorCode.Temporarily_Disabled;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf924157a7c7c261c9ff91f5bbb4dadea5b51acd", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/bf924157a7c7c261c9ff91f5bbb4dadea5b51acd", "committedDate": "2020-02-14T19:31:47Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MTcyMDcx", "url": "https://github.com/linkedin/ambry/pull/1379#pullrequestreview-359172071", "createdAt": "2020-02-14T19:33:33Z", "commit": {"oid": "bf924157a7c7c261c9ff91f5bbb4dadea5b51acd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1605, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}