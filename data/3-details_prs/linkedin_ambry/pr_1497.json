{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMDgyNjQz", "number": 1497, "title": "Cloud undelete Implementation for VCR", "bodyText": "Note that this is Phase 1 of undelete support in cloud, for VCR and DR cases only.\nSupport for frontend related cases coming soon with other cloud blob store changes for supporting serving data in azure.", "createdAt": "2020-04-30T02:28:33Z", "url": "https://github.com/linkedin/ambry/pull/1497", "merged": true, "mergeCommit": {"oid": "c7a2c554315b688d049d96cd02bd429a2a5b998d"}, "closed": true, "closedAt": "2020-05-05T23:46:25Z", "author": {"login": "ankagrawal"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccxmRngFqTQwMzc2MjMxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcecnXagFqTQwNjIyMTU4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzYyMzE1", "url": "https://github.com/linkedin/ambry/pull/1497#pullrequestreview-403762315", "createdAt": "2020-04-30T18:12:32Z", "commit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxMjozM1rOGO0yyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODozOTozMFrOGO1sEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5ODIxOQ==", "bodyText": "I want to point out that info.getLifeVersion might return -1 (MessageInfo.LIFE_VERSION_FROM_FRONTEND). If so, it means we have to fetch the current lifeVersion and increment it and then put it back to the azure and cosmo. Can you add a todo here so later we can deal with it.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418198219", "createdAt": "2020-04-30T18:12:33Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -398,7 +398,24 @@ private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudSto\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    checkStarted();\n+    try {\n+      BlobId blobId = (BlobId) info.getStoreKey();\n+      // We do not have enough information in cache to check life version.\n+      // It is expected that un-deletes will be very rare, so its ok to trade off occasional hits to azure,\n+      // in lieu of maintaining live version along with blob id in cache.\n+      short newLifeVersion =\n+          requestAgent.doWithRetries(() -> cloudDestination.undeleteBlob(blobId, info.getLifeVersion()), \"Undelete\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTgzNw==", "bodyText": "BTW, delete method would also have to be take lifeVersion into consideration. For instance, if the current lifeVersion is 0 and replication thread calls delete with lifeVersion being 2, then we have to update lifeVersion as well, even if we don't change the deletion_time.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418199837", "createdAt": "2020-04-30T18:15:24Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -398,7 +398,24 @@ private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudSto\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxMjg4MA==", "bodyText": "nit: can you add the field name as the second parameter to requireNoNull method.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418212880", "createdAt": "2020-04-30T18:39:30Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -292,15 +293,15 @@ public CloudBlobMetadata getBlobMetadata(BlobId blobId) throws BlobStorageExcept\n   /**\n    * Update the metadata for the specified blob.\n    * @param blobId The {@link BlobId} to update.\n-   * @param fieldName The metadata field to modify.\n-   * @param value The new value.\n+   * @param updateFields Map of field names and new values to modify.\n    * @return a {@link UpdateResponse} with the updated metadata.\n    * @throws BlobStorageException if the blob does not exist or an error occurred.\n    * @throws IllegalStateException on request timeout.\n    */\n-  public UpdateResponse updateBlobMetadata(BlobId blobId, String fieldName, Object value) throws BlobStorageException {\n+  public UpdateResponse updateBlobMetadata(BlobId blobId, Map<String, Object> updateFields)\n+      throws BlobStorageException {\n     Objects.requireNonNull(blobId, \"BlobId cannot be null\");\n-    Objects.requireNonNull(fieldName, \"Field name cannot be null\");\n+    updateFields.keySet().stream().forEach(field -> Objects.requireNonNull(updateFields.get(field)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "660c248b512eaa692cce1ca77c5a9560e7d28c3e", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/660c248b512eaa692cce1ca77c5a9560e7d28c3e", "committedDate": "2020-05-01T20:27:00Z", "message": "Update life version on delete\nMake cache life version aware\nFix existing tests."}, "afterCommit": {"oid": "1bcbc89c4f609d7804d96fcd721120265ce0e9be", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/1bcbc89c4f609d7804d96fcd721120265ce0e9be", "committedDate": "2020-05-01T20:28:28Z", "message": "Update life version on delete\nMake cache life version aware\nFix existing tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NDk0MDQ1", "url": "https://github.com/linkedin/ambry/pull/1497#pullrequestreview-404494045", "createdAt": "2020-05-02T02:52:01Z", "commit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1MjowMVrOGPcZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNzo1M1rOGPeSLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzEzMg==", "bodyText": "We don't need a separate constructor, lifeVersion can be added to the constructor that takes everything.  I don't even think we need it in the constructor since it's always going to be set on an existing blob/record.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418847132", "createdAt": "2020-05-02T02:52:01Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobMetadata.java", "diffHunk": "@@ -123,6 +125,27 @@ public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime,\n    */\n   public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime, long size,\n       EncryptionOrigin encryptionOrigin, String vcrKmsContext, String cryptoAgentFactory, long encryptedSize) {\n+    this(blobId, creationTime, expirationTime, size, encryptionOrigin, vcrKmsContext, cryptoAgentFactory, encryptedSize,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0ODI1Ng==", "bodyText": "Mention how if affects behavior.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418848256", "createdAt": "2020-05-02T02:54:59Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "diffHunk": "@@ -51,10 +51,20 @@ boolean uploadBlob(BlobId blobId, long inputLength, CloudBlobMetadata cloudBlobM\n    * Mark a blob as deleted in the cloud destination.\n    * @param blobId id of the Ambry blob\n    * @param deletionTime time of blob deletion\n+   * @param lifeVersion life version of the blob to be deleted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2NzgxMg==", "bodyText": "Where do you throw an error?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418867812", "createdAt": "2020-05-02T03:42:03Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, Utils.Infinite_Time);\n+    updateBlobMetadata(blobId, updateFields);\n+    // We either update lifeVersion or throw error. So this should work for now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2ODkwMQ==", "bodyText": "Does the lifeVersion also need to be passed on put/upload?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418868901", "createdAt": "2020-05-02T03:44:51Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTQwNw==", "bodyText": "What if the blob went from state TTL_UPDATED to DELETED before getting undeleted.  Does it matter that we are switching it back to CREATED?  It seems okay, just checking.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418875407", "createdAt": "2020-05-02T04:01:02Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -381,24 +382,52 @@ public void delete(List<MessageInfo> infos) throws StoreException {\n    * Delete the specified blob if needed depending on the cache state.\n    * @param blobId the blob to delete\n    * @param deletionTime the deletion time\n+   * @param lifeVersion life version of the blob.\n    * @return whether the deletion was performed\n    * @throws CloudStorageException\n    */\n-  private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudStorageException {\n+  private boolean deleteIfNeeded(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n     String blobKey = blobId.getID();\n     // Note: always check cache before operation attempt, since this could be a retry after a CONFLICT error,\n     // in which case the cache may have been updated by another thread.\n-    if (!checkCacheState(blobKey, BlobState.DELETED)) {\n-      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime);\n-      addToCache(blobKey, BlobState.DELETED);\n+    if (!checkCacheState(blobKey, lifeVersion, BlobState.DELETED)) {\n+      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime, lifeVersion);\n+      addToCache(blobKey, lifeVersion, BlobState.DELETED);\n       return deleted;\n     }\n     return false;\n   }\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    checkStarted();\n+    try {\n+      return requestAgent.doWithRetries(() -> undeleteIfNeeded((BlobId) info.getStoreKey(), info.getLifeVersion()),\n+          \"Undelete\", partitionId.toPathString());\n+    } catch (CloudStorageException cex) {\n+      StoreErrorCodes errorCode =\n+          (cex.getStatusCode() == STATUS_NOT_FOUND) ? StoreErrorCodes.ID_Not_Found : StoreErrorCodes.IOError;\n+      throw new StoreException(cex, errorCode);\n+    }\n+  }\n+\n+  /**\n+   * Undelete the specified blob if needed depending on the cache state.\n+   * @param blobId the blob to delete.\n+   * @param lifeVersion life version of the deleted blob.\n+   * @return final updated life version of the blob.\n+   * @throws CloudStorageException in case any exception happens during undelete.\n+   */\n+  private short undeleteIfNeeded(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    // See note in deleteIfNeeded.\n+    if (!checkCacheState(blobId.getID(), lifeVersion, BlobState.CREATED)) {\n+      short newLifeVersion = cloudDestination.undeleteBlob(blobId, lifeVersion);\n+      addToCache(blobId.getID(), newLifeVersion, BlobState.CREATED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NjM4OQ==", "bodyText": "The javadoc for these 2 lines looks messed up.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418876389", "createdAt": "2020-05-02T04:03:40Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -442,21 +471,37 @@ private boolean updateTtlIfNeeded(BlobId blobId) throws CloudStorageException {\n     // See note in deleteIfNeeded.\n     if (!checkCacheState(blobKey, BlobState.TTL_UPDATED, BlobState.DELETED)) {\n       boolean updated = cloudDestination.updateBlobExpiration(blobId, Utils.Infinite_Time);\n-      addToCache(blobKey, BlobState.TTL_UPDATED);\n+      // We do not have the definitive value of life version here. So we add to cache with minimum valid value.\n+      // If the key is present in cache, then correct life version will be updated. (see method {@link addToCache}).\n+      // If not then in worst case, the cache might let some operations with higher life version go through again.\n+      addToCache(blobKey, (short) 0, BlobState.TTL_UPDATED);\n       return updated;\n     }\n     return false;\n   }\n \n   /**\n    * Check the blob state in the recent blob cache against one or more desired states.\n+   * Note that this check ignores the life version of the blob.\n    * @param blobKey the blob key to lookup.\n    * @param desiredStates the desired state(s) to check.  If empty, any cached state is accepted.\n    * @return true if the blob key is in the cache in one of the desired states, otherwise false.\n    */\n   private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n+    return checkCacheState(blobKey, IGNORE_LIFE_VERSION, desiredStates);\n+  }\n+\n+  /**\n+   * Check the blob state in the recent blob cache against one or more desired states and life version.\n+   * @param blobKey the blob key to lookup.\n+   * @param lifeVersion the desired state(s) to check.  If empty, any cached state is accepted.\n+   * @param desiredStates true if the blob key is in the cache in one of the desired states and has appropriate life", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NzE1NA==", "bodyText": "What if lifeVersion doesn't match?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418877154", "createdAt": "2020-05-02T04:05:37Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -466,7 +511,9 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n         return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3Nzk5Nw==", "bodyText": "Can this just be Math.max(lifeVersion, recentBlobCache.get(blobKey).getLifeVersion()) ?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418877997", "createdAt": "2020-05-02T04:07:53Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -480,12 +527,21 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n   /**\n    * Add a blob state mapping to the recent blob cache.\n    * @param blobKey the blob key to cache.\n+   * @param lifeVersion life version to cache.\n    * @param blobState the state of the blob.\n    */\n-  // Visible for test\n-  void addToCache(String blobKey, BlobState blobState) {\n+  // Visible for test.\n+  void addToCache(String blobKey, short lifeVersion, BlobState blobState) {\n     if (isVcr) {\n-      recentBlobCache.put(blobKey, blobState);\n+      if (blobState == BlobState.TTL_UPDATED) {\n+        // In case of ttl update we update the ttl without taking into account the life version.\n+        // So make sure that we do not decrease the lifeVersion in cache due to an incoming ttl update.\n+        if (recentBlobCache.containsKey(blobKey)) {\n+          lifeVersion = (lifeVersion > recentBlobCache.get(blobKey).getLifeVersion()) ? lifeVersion\n+              : recentBlobCache.get(blobKey).getLifeVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1OTc3MTMy", "url": "https://github.com/linkedin/ambry/pull/1497#pullrequestreview-405977132", "createdAt": "2020-05-05T16:53:48Z", "commit": {"oid": "474bce4eddb1ca0d447ab5552d959be621b76017"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcc01387d0e5b08e89133597da7845359b1a5e7c", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/dcc01387d0e5b08e89133597da7845359b1a5e7c", "committedDate": "2020-05-05T21:22:29Z", "message": "code comment fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0596a7cf70bec64cee5f92d3630bcb31ccb33710", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/0596a7cf70bec64cee5f92d3630bcb31ccb33710", "committedDate": "2020-05-05T21:22:29Z", "message": "Production code for undelete support in cloud for VCR only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47f1fcb6f6528a938162243fbf37e9ddbf54bc0d", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/47f1fcb6f6528a938162243fbf37e9ddbf54bc0d", "committedDate": "2020-05-05T21:22:29Z", "message": "Cleanup and existing test fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a28b8ba383eb6c3676eb71eebd8b5b96e47a631a", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/a28b8ba383eb6c3676eb71eebd8b5b96e47a631a", "committedDate": "2020-05-05T21:22:29Z", "message": "Add tests for undelete. Also added some fixes and refactoring."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d1ef410abf966310f5d2ae18c78640a89aac9cf", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/6d1ef410abf966310f5d2ae18c78640a89aac9cf", "committedDate": "2020-05-05T21:22:29Z", "message": "Update life version on delete\nMake cache life version aware\nFix existing tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31104f48cdf1f93d73c316a2d01cc3a91eb4f715", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/31104f48cdf1f93d73c316a2d01cc3a91eb4f715", "committedDate": "2020-05-05T21:22:29Z", "message": "Add new unit tests for cloud blob store."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18ce07564b514d330e8c197258594818805c2aaf", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/18ce07564b514d330e8c197258594818805c2aaf", "committedDate": "2020-05-05T21:22:29Z", "message": "Add integration test and cleanup code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45c73f136d218edd1efef19f95fae2138f52ddde", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/45c73f136d218edd1efef19f95fae2138f52ddde", "committedDate": "2020-05-05T21:22:29Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f00b94105814712b5a62dd8c51ecbec061a328ed", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/f00b94105814712b5a62dd8c51ecbec061a328ed", "committedDate": "2020-05-05T21:22:29Z", "message": "fix tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "474bce4eddb1ca0d447ab5552d959be621b76017", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/474bce4eddb1ca0d447ab5552d959be621b76017", "committedDate": "2020-05-04T15:13:21Z", "message": "fix tests."}, "afterCommit": {"oid": "f00b94105814712b5a62dd8c51ecbec061a328ed", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/f00b94105814712b5a62dd8c51ecbec061a328ed", "committedDate": "2020-05-05T21:22:29Z", "message": "fix tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjIxNTg2", "url": "https://github.com/linkedin/ambry/pull/1497#pullrequestreview-406221586", "createdAt": "2020-05-05T23:24:09Z", "commit": {"oid": "f00b94105814712b5a62dd8c51ecbec061a328ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1439, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}