{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTk1MTQ5", "number": 1402, "title": "Add more tests to hard deleter for undelete record", "bodyText": "Adding more tests to hard deleter to test undelete record.\nChange how hard deleter prune the recovery range.", "createdAt": "2020-02-27T01:50:28Z", "url": "https://github.com/linkedin/ambry/pull/1402", "merged": true, "mergeCommit": {"oid": "cb99b624acb28d580608446c91b83decdcc0c420"}, "closed": true, "closedAt": "2020-03-09T17:12:34Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI2_35gBqjMwODM2MjIzOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMAzmWAFqTM3MTM1Mjc0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45b68a7e6add4588da3605b60b5efcf46d172bda", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/45b68a7e6add4588da3605b60b5efcf46d172bda", "committedDate": "2020-02-27T01:47:42Z", "message": "Add more tests to hard deleter for undelete record"}, "afterCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/800ca7861ec747243c4bd0bb3ee6c4f103bb511e", "committedDate": "2020-02-28T21:41:59Z", "message": "Add even more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTI5ODEw", "url": "https://github.com/linkedin/ambry/pull/1402#pullrequestreview-367529810", "createdAt": "2020-03-02T21:11:12Z", "commit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMToxMToxM1rOFwvYEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMTo0OTowN1rOFwwiog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1MjE3OA==", "bodyText": "java doc for this class please", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386652178", "createdAt": "2020-03-02T21:11:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -653,22 +680,39 @@ private void performHardDeletes(List<MessageInfo> messageInfoList) throws StoreE\n     }\n   }\n \n+  class HardDeletePersistItem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1MzE0MA==", "bodyText": "What if recovery range has been pruned but failed to persist cleanup token, will it be a problem?", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386653140", "createdAt": "2020-03-02T21:13:05Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -352,6 +359,24 @@ void preLogFlush() {\n   void postLogFlush() {\n     /* start token saved before the flush is now safe to be persisted */\n     startTokenSafeToPersist = startTokenBeforeLogFlush;\n+\n+    hardDeleteLock.lock();\n+    try {\n+      // PersistCleanupToken because startTokenSafeToPersist changed.\n+      pruneHardDeleteRecoveryRange();\n+      persistCleanupToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1ODY5OA==", "bodyText": "any reason to change the ordering here? Throttle the hard delete I/O ?", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386658698", "createdAt": "2020-03-02T21:23:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -625,9 +652,9 @@ private void performHardDeletes(List<MessageInfo> messageInfoList) throws StoreE\n           throw new StoreException(\"Aborting hard deletes as store is shutting down\",\n               StoreErrorCodes.Store_Shutting_Down);\n         }\n+        diskIOScheduler.getSlice(HARD_DELETE_CLEANUP_JOB_NAME, HARD_DELETE_CLEANUP_JOB_NAME, logWriteInfo.size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY2MDk5OA==", "bodyText": "The method looks good, minor suggestion is to align with your comment and do a token type check at the very beginning. (Reject Journal based token)", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386660998", "createdAt": "2020-03-02T21:28:46Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -705,52 +751,64 @@ int getSize() {\n       DataOutputStream dataOutputStream = new DataOutputStream(outStream);\n \n       /* Write the number of entries */\n-      dataOutputStream.writeInt(blobReadOptionsList.size());\n+      dataOutputStream.writeInt(items.size());\n \n       /* Write all the blobReadOptions */\n-      for (BlobReadOptions blobReadOptions : blobReadOptionsList) {\n-        dataOutputStream.write(blobReadOptions.toBytes());\n+      for (HardDeletePersistItem item : items) {\n+        dataOutputStream.write(item.blobReadOptions.toBytes());\n       }\n \n       /* Write all the messageStoreRecoveryInfos */\n-      for (byte[] recoveryInfo : messageStoreRecoveryInfoList) {\n+      for (HardDeletePersistItem item : items) {\n         /* First write the size of the recoveryInfo */\n-        dataOutputStream.writeInt(recoveryInfo.length);\n+        dataOutputStream.writeInt(item.messagesStoreRecoveryInfo.length);\n \n         /* Now, write the recoveryInfo */\n-        dataOutputStream.write(recoveryInfo);\n+        dataOutputStream.write(item.messagesStoreRecoveryInfo);\n       }\n \n       return outStream.toByteArray();\n     }\n \n     /**\n-     * Prunes entries in the range from the start up to, but excluding, the entry with the passed in key.\n+     * Prunes entries in the range from the start up to, but excluding, the entry with the passed in token.\n+     * Token passed to this method has to be a indexed based one.\n      */\n-    void pruneTill(StoreKey storeKey) {\n-      Iterator<BlobReadOptions> blobReadOptionsListIterator = blobReadOptionsList.iterator();\n-      Iterator<byte[]> messageStoreRecoveryListIterator = messageStoreRecoveryInfoList.iterator();\n-      while (blobReadOptionsListIterator.hasNext()) {\n-      /* Note: In the off chance that there are multiple presence of the same key in this range due to prior software\n-         bugs, note that this method prunes only till the first occurrence of the key. If it so happens that a\n-         later occurrence is the one really associated with this token, it does not affect the safety.\n-         Persisting more than what is required is okay as hard deleting a blob is an idempotent operation. */\n-        messageStoreRecoveryListIterator.next();\n-        if (blobReadOptionsListIterator.next().getMessageInfo().getStoreKey().equals(storeKey)) {\n-          break;\n+    void pruneTill(StoreFindToken token) {\n+      Iterator<HardDeletePersistItem> itemsIterator = items.iterator();\n+      while (itemsIterator.hasNext()) {\n+        HardDeletePersistItem item = itemsIterator.next();\n+        if (item.startTokenForBlobReadOptions.getType() == FindTokenType.Uninitialized) {\n+          itemsIterator.remove();\n         } else {\n-          blobReadOptionsListIterator.remove();\n-          messageStoreRecoveryListIterator.remove();\n+          if (compareTwoTokens(item.startTokenForBlobReadOptions, token) >= 0) {\n+            break;\n+          } else {\n+            itemsIterator.remove();\n+          }\n         }\n       }\n     }\n \n-    private List<BlobReadOptions> getBlobReadOptionsList() {\n-      return blobReadOptionsList;\n+    /**\n+     * Compare two StoreFindTokens and return the result as an integer like compareTo interface.\n+     * These two tokens have to be IndexBased tokens.\n+     * @param token1 The first token to compare.\n+     * @param token2 The second tokent to compare.\n+     * @return 0 means they are equal. negative number means token1 is less than token2. postive number means the opposite.\n+     */\n+    int compareTwoTokens(StoreFindToken token1, StoreFindToken token2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY2NzkzMA==", "bodyText": "Could you explain a little bit about this case?", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386667930", "createdAt": "2020-03-02T21:42:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -705,52 +751,64 @@ int getSize() {\n       DataOutputStream dataOutputStream = new DataOutputStream(outStream);\n \n       /* Write the number of entries */\n-      dataOutputStream.writeInt(blobReadOptionsList.size());\n+      dataOutputStream.writeInt(items.size());\n \n       /* Write all the blobReadOptions */\n-      for (BlobReadOptions blobReadOptions : blobReadOptionsList) {\n-        dataOutputStream.write(blobReadOptions.toBytes());\n+      for (HardDeletePersistItem item : items) {\n+        dataOutputStream.write(item.blobReadOptions.toBytes());\n       }\n \n       /* Write all the messageStoreRecoveryInfos */\n-      for (byte[] recoveryInfo : messageStoreRecoveryInfoList) {\n+      for (HardDeletePersistItem item : items) {\n         /* First write the size of the recoveryInfo */\n-        dataOutputStream.writeInt(recoveryInfo.length);\n+        dataOutputStream.writeInt(item.messagesStoreRecoveryInfo.length);\n \n         /* Now, write the recoveryInfo */\n-        dataOutputStream.write(recoveryInfo);\n+        dataOutputStream.write(item.messagesStoreRecoveryInfo);\n       }\n \n       return outStream.toByteArray();\n     }\n \n     /**\n-     * Prunes entries in the range from the start up to, but excluding, the entry with the passed in key.\n+     * Prunes entries in the range from the start up to, but excluding, the entry with the passed in token.\n+     * Token passed to this method has to be a indexed based one.\n      */\n-    void pruneTill(StoreKey storeKey) {\n-      Iterator<BlobReadOptions> blobReadOptionsListIterator = blobReadOptionsList.iterator();\n-      Iterator<byte[]> messageStoreRecoveryListIterator = messageStoreRecoveryInfoList.iterator();\n-      while (blobReadOptionsListIterator.hasNext()) {\n-      /* Note: In the off chance that there are multiple presence of the same key in this range due to prior software\n-         bugs, note that this method prunes only till the first occurrence of the key. If it so happens that a\n-         later occurrence is the one really associated with this token, it does not affect the safety.\n-         Persisting more than what is required is okay as hard deleting a blob is an idempotent operation. */\n-        messageStoreRecoveryListIterator.next();\n-        if (blobReadOptionsListIterator.next().getMessageInfo().getStoreKey().equals(storeKey)) {\n-          break;\n+    void pruneTill(StoreFindToken token) {\n+      Iterator<HardDeletePersistItem> itemsIterator = items.iterator();\n+      while (itemsIterator.hasNext()) {\n+        HardDeletePersistItem item = itemsIterator.next();\n+        if (item.startTokenForBlobReadOptions.getType() == FindTokenType.Uninitialized) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3MTI2Ng==", "bodyText": "For concurrency, let's make sure all variables shared by HardDeleter thread and Index persistor thread to be volatile.", "url": "https://github.com/linkedin/ambry/pull/1402#discussion_r386671266", "createdAt": "2020-03-02T21:49:07Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/HardDeleter.java", "diffHunk": "@@ -89,9 +89,9 @@\n    * startTokenBeforeLogFlush: This token is set to the current start token just before log flush and once the log is\n    *                           flushed, this is used to set startTokenSafeToPersist.\n    */\n-  private FindToken startToken;\n   private FindToken startTokenBeforeLogFlush;\n-  private FindToken startTokenSafeToPersist;\n+  private volatile FindToken startTokenSafeToPersist;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0c0c1d86e969f1645bee8112fb1c6e3a0931a25", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/d0c0c1d86e969f1645bee8112fb1c6e3a0931a25", "committedDate": "2020-03-04T00:01:35Z", "message": "Add more tests to hard deleter for undelete record"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4345cd6237deb736526c9f1bf7351120e3942c0", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e4345cd6237deb736526c9f1bf7351120e3942c0", "committedDate": "2020-03-04T00:01:35Z", "message": "Add even more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4412c6929a5950386f6a2af694a703be3d41531", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a4412c6929a5950386f6a2af694a703be3d41531", "committedDate": "2020-03-04T00:46:07Z", "message": "Add something"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "800ca7861ec747243c4bd0bb3ee6c4f103bb511e", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/800ca7861ec747243c4bd0bb3ee6c4f103bb511e", "committedDate": "2020-02-28T21:41:59Z", "message": "Add even more tests"}, "afterCommit": {"oid": "a4412c6929a5950386f6a2af694a703be3d41531", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a4412c6929a5950386f6a2af694a703be3d41531", "committedDate": "2020-03-04T00:46:07Z", "message": "Add something"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MzAzODMz", "url": "https://github.com/linkedin/ambry/pull/1402#pullrequestreview-369303833", "createdAt": "2020-03-05T05:30:59Z", "commit": {"oid": "a4412c6929a5950386f6a2af694a703be3d41531"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzUyNzQ5", "url": "https://github.com/linkedin/ambry/pull/1402#pullrequestreview-371352749", "createdAt": "2020-03-09T16:49:32Z", "commit": {"oid": "a4412c6929a5950386f6a2af694a703be3d41531"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1648, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}