{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNDg2MzEz", "number": 1493, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NDo0OFrOD32gMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NDo0OFrOD32gMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODkxMjQ5OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/CompositeNetworkClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NDo0OFrOGOV_2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo1NTo0MFrOGOWK0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MzY1Ng==", "bodyText": "If we eat this exception, what will happen to the response consumers, will they just time out?", "url": "https://github.com/linkedin/ambry/pull/1493#discussion_r417693656", "createdAt": "2020-04-30T00:44:48Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/main/java/com/github/ambry/network/CompositeNetworkClient.java", "diffHunk": "@@ -71,23 +81,46 @@\n         requestsToDropByType.get(replicaType).add(correlationId);\n       }\n     }\n-    List<ResponseInfo> responses = new ArrayList<>();\n+\n+    // send requests using child clients from background threads so that inactive clients do not block the other client\n+    // from making progress.\n+    AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n+    ArrayList<Future<List<ResponseInfo>>> sendAndPollFutures = new ArrayList<>(childNetworkClients.size());\n     childNetworkClients.forEach((replicaType, client) -> {\n       List<RequestInfo> requestsToSend = requestsToSendByType.get(replicaType);\n       Set<Integer> requestsToDrop = requestsToDropByType.get(replicaType);\n       if (!requestsToSend.isEmpty() || !requestsToDrop.isEmpty()) {\n         logger.trace(\"replicaType={}, requestsToSend={}, requestsToDrop={}\", replicaType, requestsToSend,\n             requestsToDrop);\n       }\n-      List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n-      childClientResponses.forEach(responseInfo -> {\n-        // clean up correlation ids for completed requests\n-        if (responseInfo.getRequestInfo() != null) {\n-          correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+      sendAndPollFutures.add(executor.submit(() -> {\n+        List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n+        if (wakeupCalled.compareAndSet(false, true)) {\n+          // the client that gets a response first can wake up the other clients so that they do not waste time waiting\n+          // for the poll timeout to expire. This helps when one child client is very active and the others have very\n+          // little activity.\n+          childNetworkClients.values().stream().filter(c -> c != client).forEach(NetworkClient::wakeup);\n         }\n-        responses.add(responseInfo);\n-      });\n+        return childClientResponses;\n+      }));\n     });\n+\n+    // process responses returned by each child client\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    for (Future<List<ResponseInfo>> future : sendAndPollFutures) {\n+      try {\n+        List<ResponseInfo> responseInfoList = future.get();\n+        for (ResponseInfo responseInfo : responseInfoList) {\n+          // clean up correlation ids for completed requests\n+          if (responseInfo.getRequestInfo() != null) {\n+            correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+          }\n+          responses.add(responseInfo);\n+        }\n+      } catch (InterruptedException | ExecutionException e) {\n+        logger.error(\"Hit unexpected exception on parallel sendAndPoll.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "992c6ea35dcc39cdc2e155f9998bee3a133394a9"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5NjQ2Ng==", "bodyText": "Yep, they will just time out in the router after the configured routerRequestTimeout and a request will be sent to another replica.\nThis isn't the greatest, but i noticed that if we rethrow the exception (or encounter any other RuntimeException in sendAndPoll), the router will be closed: https://github.com/linkedin/ambry/blob/master/ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java#L1012\nI think swallowing the error is better than doing this. However, one could also argue that such errors are truly unexpected and require the frontend to be restarted.", "url": "https://github.com/linkedin/ambry/pull/1493#discussion_r417696466", "createdAt": "2020-04-30T00:55:40Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/CompositeNetworkClient.java", "diffHunk": "@@ -71,23 +81,46 @@\n         requestsToDropByType.get(replicaType).add(correlationId);\n       }\n     }\n-    List<ResponseInfo> responses = new ArrayList<>();\n+\n+    // send requests using child clients from background threads so that inactive clients do not block the other client\n+    // from making progress.\n+    AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n+    ArrayList<Future<List<ResponseInfo>>> sendAndPollFutures = new ArrayList<>(childNetworkClients.size());\n     childNetworkClients.forEach((replicaType, client) -> {\n       List<RequestInfo> requestsToSend = requestsToSendByType.get(replicaType);\n       Set<Integer> requestsToDrop = requestsToDropByType.get(replicaType);\n       if (!requestsToSend.isEmpty() || !requestsToDrop.isEmpty()) {\n         logger.trace(\"replicaType={}, requestsToSend={}, requestsToDrop={}\", replicaType, requestsToSend,\n             requestsToDrop);\n       }\n-      List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n-      childClientResponses.forEach(responseInfo -> {\n-        // clean up correlation ids for completed requests\n-        if (responseInfo.getRequestInfo() != null) {\n-          correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+      sendAndPollFutures.add(executor.submit(() -> {\n+        List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n+        if (wakeupCalled.compareAndSet(false, true)) {\n+          // the client that gets a response first can wake up the other clients so that they do not waste time waiting\n+          // for the poll timeout to expire. This helps when one child client is very active and the others have very\n+          // little activity.\n+          childNetworkClients.values().stream().filter(c -> c != client).forEach(NetworkClient::wakeup);\n         }\n-        responses.add(responseInfo);\n-      });\n+        return childClientResponses;\n+      }));\n     });\n+\n+    // process responses returned by each child client\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    for (Future<List<ResponseInfo>> future : sendAndPollFutures) {\n+      try {\n+        List<ResponseInfo> responseInfoList = future.get();\n+        for (ResponseInfo responseInfo : responseInfoList) {\n+          // clean up correlation ids for completed requests\n+          if (responseInfo.getRequestInfo() != null) {\n+            correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+          }\n+          responses.add(responseInfo);\n+        }\n+      } catch (InterruptedException | ExecutionException e) {\n+        logger.error(\"Hit unexpected exception on parallel sendAndPoll.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MzY1Ng=="}, "originalCommit": {"oid": "992c6ea35dcc39cdc2e155f9998bee3a133394a9"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1534, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}