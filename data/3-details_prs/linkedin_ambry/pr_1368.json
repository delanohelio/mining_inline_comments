{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzY3NjU5", "number": 1368, "title": "Introduce clustermap change listener to propagate remote replica addition/removal events", "bodyText": "With \"move replica\", Helix cluster manager should be able to dynamically add/remove remote replica infos and therefore clustermap will be dynamically changed. External components like ReplicationManager needs to update thread assignment and some in-mem data structures in repsonse to such changes. This PR introduces clustermap change listener which allows ReplicationManager to listen to any change in\nclustermap and take actions accordingly. For now, there is only one method in clustermap\nchange listener: onReplicaAddedOrRemoved(), we could add more methods like onReplicaLeadershipChange etc if needed.\n\nRemote replica addition/removal in clustermap is currently supported by dynamic cluster change handler only.( #1355 )", "createdAt": "2020-01-28T00:14:06Z", "url": "https://github.com/linkedin/ambry/pull/1368", "merged": true, "mergeCommit": {"oid": "bc91abdb70c1b76dbacedfaeb8e2a9d57333f254"}, "closed": true, "closedAt": "2020-02-10T18:58:35Z", "author": {"login": "jsjtzyy"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcAw91gAFqTM1MjQzMTY3OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDB2jmgFqTM1NjE4MTg0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNDMxNjc4", "url": "https://github.com/linkedin/ambry/pull/1368#pullrequestreview-352431678", "createdAt": "2020-02-03T17:31:54Z", "commit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNzozMTo1NFrOFk5rTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxODowODo1NlrOFk6wlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzODAyOQ==", "bodyText": "Since we dont really support, do you think throwing an exception might work here?", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374238029", "createdAt": "2020-02-03T17:31:54Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/StaticClusterManager.java", "diffHunk": "@@ -153,6 +153,11 @@ public MetricRegistry getMetricRegistry() {\n     return metricRegistry;\n   }\n \n+  @Override\n+  public void registerClusterMapListener(ClusterMapChangeListener clusterMapChangeListener) {\n+    // no op for static cluster map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0ODk1Mw==", "bodyText": "If startupLatch is interrupted, could we might miss a replica event?  If yes, then should we throw an exception?", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374248953", "createdAt": "2020-02-03T17:54:16Z", "author": {"login": "ankagrawal"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MDI1OQ==", "bodyText": "Is it possible that we add a replica for a pre-existing store (maybe as a retry, or re-assignment of a partition)? In that case maybe we can read any existing replica token.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374250259", "createdAt": "2020-02-03T17:56:56Z", "author": {"login": "ankagrawal"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MjgyMQ==", "bodyText": "Looks like this method will be called either for replicas being added or removed. We should use a boolean then (e.g, isRemove), instead of two lists.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374252821", "createdAt": "2020-02-03T18:02:15Z", "author": {"login": "ankagrawal"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1NTc2NA==", "bodyText": "Also it looks like we have some duplicate code between this method and addReplica/removeReplica methods. Can we try to refactor?", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374255764", "createdAt": "2020-02-03T18:08:56Z", "author": {"login": "ankagrawal"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzgyOTkx", "url": "https://github.com/linkedin/ambry/pull/1368#pullrequestreview-353382991", "createdAt": "2020-02-04T23:47:06Z", "commit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMzo0NzowNlrOFlne4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwMDozODoyN1rOFloWdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4ODUxNA==", "bodyText": "I suggest adding a private class to serve as the implementation of ClusterMapChangeListener, just like PartitionStateChangeListener.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374988514", "createdAt": "2020-02-04T23:47:06Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5ODM2Ng==", "bodyText": "please lock getRemoveReplicaInfos method as well, this lock is protecting remoteReplicas list, we should lock it everywhere we use it.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374998366", "createdAt": "2020-02-05T00:21:36Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/PartitionInfo.java", "diffHunk": "@@ -50,6 +53,44 @@ public ReplicaId getLocalReplicaId() {\n     return this.localReplicaId;\n   }\n \n+  /**\n+   * Add {@link RemoteReplicaInfo} to this {@link PartitionInfo} if it is previously absent.\n+   * @param remoteReplicaInfo the {@link RemoteReplicaInfo} to add.\n+   * @return {@code true} if remote replica info is added. {@code false} if it is already present\n+   */\n+  boolean addReplicaInfoIfAbsent(RemoteReplicaInfo remoteReplicaInfo) {\n+    lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5OTg4NA==", "bodyText": "we should only add remoteReplicaInfo to the \"toAdd\" list when it was successfully added to partitionInfo, so we should move this statement in the if-else statement above.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r374999884", "createdAt": "2020-02-05T00:27:25Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjUwMg==", "bodyText": "why do we need this? we can just change the PartitionInfo's remove method to take a replica id as parameter, and looping the list in PartitionInfo, it's more aligned with addReplicaInfo.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r375002502", "createdAt": "2020-02-05T00:37:43Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);\n+        }\n+        addRemoteReplicaInfoToReplicaThread(replicaInfosToAdd, true);\n+\n+        // 4. remove replicaInfo from existing partitionInfo and replica-threads\n+        List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+        for (ReplicaId remoteReplica : removedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          List<RemoteReplicaInfo> remoteReplicaInfos = new ArrayList<>(partitionInfo.getRemoteReplicaInfos());\n+          for (RemoteReplicaInfo remoteReplicaInfo : remoteReplicaInfos) {\n+            if (remoteReplicaInfo.getReplicaId().getDataNodeId() == remoteReplica.getDataNodeId()) {\n+              logger.info(\"Removing remote replica {} on {} from replica threads.\", remoteReplica.getReplicaPath(),\n+                  remoteReplica.getDataNodeId());\n+              replicaInfosToRemove.add(remoteReplicaInfo);\n+              if (partitionInfo.removeRelicaInfoIfPresent(remoteReplicaInfo)) {\n+                replicationMetrics.removeMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+              }\n+              break;\n+            }\n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAwMjc0Mw==", "bodyText": "And we should put this statement within if-else statement as well.", "url": "https://github.com/linkedin/ambry/pull/1368#discussion_r375002743", "createdAt": "2020-02-05T00:38:27Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-replication/src/main/java/com.github.ambry.replication/ReplicationManager.java", "diffHunk": "@@ -115,8 +127,89 @@ public void start() throws ReplicationException {\n         this.scheduler.scheduleAtFixedRate(persistor, replicationConfig.replicationTokenFlushDelaySeconds,\n             replicationConfig.replicationTokenFlushIntervalSeconds, TimeUnit.SECONDS);\n       }\n+      started = true;\n     } catch (IOException e) {\n       logger.error(\"IO error while starting replication\", e);\n+    } finally {\n+      startupLatch.countDown();\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+   * concurrently update remote replica infos.\n+   */\n+  @Override\n+  public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas) {\n+    // 1. wait for start() to complete\n+    try {\n+      startupLatch.await();\n+    } catch (InterruptedException e) {\n+      logger.warn(\"Waiting for startup is interrupted.\");\n+    }\n+    if (started) {\n+      // Read-write lock avoids contention between addReplica()/removeReplica() and onReplicaAddedOrRemoved() methods.\n+      // Read lock for current method should suffice because multiple threads from cluster change handlers should be able\n+      // to access partitionToPartitionInfo map. Each thead only updates PartitionInfo of certain partition and synchronization\n+      // is only required within PartitionInfo. Also, addRemoteReplicaInfoToReplicaThread() is thread-safe which allows\n+      // several threads from cluster change handlers to add remoteReplicaInfo\n+      rwLock.readLock().lock();\n+      try {\n+        // 2. determine if added/removed replicas have peer replica on local node.\n+        //    We skip the replica on current node because it should already be added/removed by state transition thread.\n+        Set<ReplicaId> addedPeerReplicas = addedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+        Set<ReplicaId> removedPeerReplicas = removedReplicas.stream()\n+            .filter(r -> partitionToPartitionInfo.containsKey(r.getPartitionId()) && r.getDataNodeId() != currentNode)\n+            .collect(Collectors.toSet());\n+\n+        // No additional synchronization is required because cluster change handler of each dc only updates replica-threads\n+        // belonging to certain dc. Hence, there is only one thread adding/removing remote replicas within a certain dc.\n+\n+        // 3. create replicaInfo for new remote replicas and assign them to replica-threads.\n+        List<RemoteReplicaInfo> replicaInfosToAdd = new ArrayList<>();\n+        for (ReplicaId remoteReplica : addedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          // create findToken, remoteReplicaInfo\n+          FindToken findToken =\n+              this.tokenHelper.getFindTokenFactoryFromReplicaType(remoteReplica.getReplicaType()).getNewFindToken();\n+          RemoteReplicaInfo remoteReplicaInfo =\n+              new RemoteReplicaInfo(remoteReplica, partitionInfo.getLocalReplicaId(), partitionInfo.getStore(),\n+                  findToken,\n+                  TimeUnit.SECONDS.toMillis(storeConfig.storeDataFlushIntervalSeconds) * Replication_Delay_Multiplier,\n+                  SystemTime.getInstance(), remoteReplica.getDataNodeId().getPortToConnectTo());\n+          logger.info(\"Adding remote replica {} on {} to partition info.\", remoteReplica.getReplicaPath(),\n+              remoteReplica.getDataNodeId());\n+          if (partitionInfo.addReplicaInfoIfAbsent(remoteReplicaInfo)) {\n+            replicationMetrics.addMetricsForRemoteReplicaInfo(remoteReplicaInfo);\n+          }\n+          replicaInfosToAdd.add(remoteReplicaInfo);\n+        }\n+        addRemoteReplicaInfoToReplicaThread(replicaInfosToAdd, true);\n+\n+        // 4. remove replicaInfo from existing partitionInfo and replica-threads\n+        List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+        for (ReplicaId remoteReplica : removedPeerReplicas) {\n+          PartitionInfo partitionInfo = partitionToPartitionInfo.get(remoteReplica.getPartitionId());\n+          List<RemoteReplicaInfo> remoteReplicaInfos = new ArrayList<>(partitionInfo.getRemoteReplicaInfos());\n+          for (RemoteReplicaInfo remoteReplicaInfo : remoteReplicaInfos) {\n+            if (remoteReplicaInfo.getReplicaId().getDataNodeId() == remoteReplica.getDataNodeId()) {\n+              logger.info(\"Removing remote replica {} on {} from replica threads.\", remoteReplica.getReplicaPath(),\n+                  remoteReplica.getDataNodeId());\n+              replicaInfosToRemove.add(remoteReplicaInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb970c85dffe8ec29ab97ceeac61368a13df65c7"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51646d14277b1f3847e11976e3d229c3a72fa5ff", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/51646d14277b1f3847e11976e3d229c3a72fa5ff", "committedDate": "2020-02-07T01:44:15Z", "message": "Introduce clustermap change listener to notify replica addition/removal\nevents\n\nWith \"move replica\", Helix cluster manager should be able to dynamically\nadd/remove remote replica infos and therefore clustermap will be\ndynamically changed. External components like ReplicationManager needs\nto update thread assignment and some in-mem data structures in repsonse\nto such changes. This PR introduces clustermap change listener which\nallows ReplicationManager to listen to any change in clustermap and take\nactions accordingly. For now, there is only one method in clustermap\nchange listener: onReplicaAddedOrRemoved(), we could add more methods\nlike onReplicaLeadershipChange etc if needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccbe4921d57156f8ce6e53de36b6faeb1223d6bb", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/ccbe4921d57156f8ce6e53de36b6faeb1223d6bb", "committedDate": "2020-02-07T01:44:15Z", "message": "add some tests and remove replica from metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daeceece1f483b5f7ed91cecb5368967990bed07", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/daeceece1f483b5f7ed91cecb5368967990bed07", "committedDate": "2020-02-07T01:44:15Z", "message": "add more test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "977da233aaa798ac1e1d2e809a0cd187633c8c60", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/977da233aaa798ac1e1d2e809a0cd187633c8c60", "committedDate": "2020-02-07T01:44:15Z", "message": "improve test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4123b715e7c1fac2242581e3e2bc113cae2cb65", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/c4123b715e7c1fac2242581e3e2bc113cae2cb65", "committedDate": "2020-02-07T01:44:15Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "committedDate": "2020-02-07T01:54:20Z", "message": "rebase and fix conflicts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b12d085904063c45c424a58c1514e7a9537e5f51", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/b12d085904063c45c424a58c1514e7a9537e5f51", "committedDate": "2020-02-07T01:00:53Z", "message": "comments"}, "afterCommit": {"oid": "fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/fa026e959ab942eb5a41d3fa5fd7778cc7e7cb7b", "committedDate": "2020-02-07T01:54:20Z", "message": "rebase and fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8c6f9d66c95c85c95292234f3798e1eb7c4aecf", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/e8c6f9d66c95c85c95292234f3798e1eb7c4aecf", "committedDate": "2020-02-07T21:13:35Z", "message": "one more test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTQwOTc5", "url": "https://github.com/linkedin/ambry/pull/1368#pullrequestreview-356140979", "createdAt": "2020-02-10T17:53:32Z", "commit": {"oid": "e8c6f9d66c95c85c95292234f3798e1eb7c4aecf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73106457fc9cf11ae98dcd66d6b358b4d2f50dd3", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/73106457fc9cf11ae98dcd66d6b358b4d2f50dd3", "committedDate": "2020-02-10T18:01:48Z", "message": "minor comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTgxODQ4", "url": "https://github.com/linkedin/ambry/pull/1368#pullrequestreview-356181848", "createdAt": "2020-02-10T18:57:21Z", "commit": {"oid": "73106457fc9cf11ae98dcd66d6b358b4d2f50dd3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1579, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}