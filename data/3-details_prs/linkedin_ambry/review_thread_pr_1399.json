{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODYzNzg4", "number": 1399, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMjoyNjo0MlrODlRV1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMjozNToyMFrODlRayQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDA4MDIxOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMjoyNjo0MlrOFyEfug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTo0NjozMVrOFyHDyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA0Njc3OA==", "bodyText": "Since instancesAdded is changed during execution, so does it need to be final?", "url": "https://github.com/linkedin/ambry/pull/1399#discussion_r388046778", "createdAt": "2020-03-05T02:26:42Z", "author": {"login": "xuhao417347761"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -94,22 +98,28 @@\n   private final String zkLayoutPath;\n   private final String stateModelDef;\n   private final Map<String, HelixAdmin> adminForDc = new HashMap<>();\n-  private final Map<String, Map<DiskId, SortedSet<Replica>>> instanceToDiskReplicasMap = new HashMap<>();\n-  private final Map<String, Map<String, DataNodeId>> dcToInstanceNameToDataNodeId = new HashMap<>();\n+  // These two maps should be concurrent map because they are accessed in multi-threaded context (see addUpdateInstances\n+  // method).\n+  // For now, the inner map doesn't need to be concurrent map because it is within a certain dc which means there should\n+  // be only one thread that updates it.\n+  private final ConcurrentHashMap<String, Map<DiskId, SortedSet<Replica>>> instanceToDiskReplicasMap =\n+      new ConcurrentHashMap<>();\n+  private final ConcurrentHashMap<String, Map<String, DataNodeId>> dcToInstanceNameToDataNodeId =\n+      new ConcurrentHashMap<>();\n   private final int maxPartitionsInOneResource;\n   private final boolean dryRun;\n   private final boolean forceRemove;\n-  private int maxResource = -1;\n+  private final boolean resourceChangeOnly;\n   private final String clusterName;\n   private boolean expectMoreInHelixDuringValidate = false;\n-  private Map<String, Set<String>> instancesNotForceRemovedByDc = new HashMap<>();\n-  private Map<String, Set<String>> partitionsNotForceRemovedByDc = new HashMap<>();\n-  private int instancesAdded = 0;\n-  private int instancesUpdated = 0;\n-  private int instancesDropped = 0;\n-  private int resourcesAdded = 0;\n-  private int resourcesUpdated = 0;\n-  private int resourcesDropped = 0;\n+  private ConcurrentHashMap<String, Set<String>> instancesNotForceRemovedByDc = new ConcurrentHashMap<>();\n+  private ConcurrentHashMap<String, Set<String>> partitionsNotForceRemovedByDc = new ConcurrentHashMap<>();\n+  private final AtomicInteger instancesAdded = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8354612cd60a37d59441c0809aeae811b475f612"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4ODc3Ng==", "bodyText": "The final means the reference doesn't change. The value of this object is allowed to be mutable.", "url": "https://github.com/linkedin/ambry/pull/1399#discussion_r388088776", "createdAt": "2020-03-05T05:46:31Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -94,22 +98,28 @@\n   private final String zkLayoutPath;\n   private final String stateModelDef;\n   private final Map<String, HelixAdmin> adminForDc = new HashMap<>();\n-  private final Map<String, Map<DiskId, SortedSet<Replica>>> instanceToDiskReplicasMap = new HashMap<>();\n-  private final Map<String, Map<String, DataNodeId>> dcToInstanceNameToDataNodeId = new HashMap<>();\n+  // These two maps should be concurrent map because they are accessed in multi-threaded context (see addUpdateInstances\n+  // method).\n+  // For now, the inner map doesn't need to be concurrent map because it is within a certain dc which means there should\n+  // be only one thread that updates it.\n+  private final ConcurrentHashMap<String, Map<DiskId, SortedSet<Replica>>> instanceToDiskReplicasMap =\n+      new ConcurrentHashMap<>();\n+  private final ConcurrentHashMap<String, Map<String, DataNodeId>> dcToInstanceNameToDataNodeId =\n+      new ConcurrentHashMap<>();\n   private final int maxPartitionsInOneResource;\n   private final boolean dryRun;\n   private final boolean forceRemove;\n-  private int maxResource = -1;\n+  private final boolean resourceChangeOnly;\n   private final String clusterName;\n   private boolean expectMoreInHelixDuringValidate = false;\n-  private Map<String, Set<String>> instancesNotForceRemovedByDc = new HashMap<>();\n-  private Map<String, Set<String>> partitionsNotForceRemovedByDc = new HashMap<>();\n-  private int instancesAdded = 0;\n-  private int instancesUpdated = 0;\n-  private int instancesDropped = 0;\n-  private int resourcesAdded = 0;\n-  private int resourcesUpdated = 0;\n-  private int resourcesDropped = 0;\n+  private ConcurrentHashMap<String, Set<String>> instancesNotForceRemovedByDc = new ConcurrentHashMap<>();\n+  private ConcurrentHashMap<String, Set<String>> partitionsNotForceRemovedByDc = new ConcurrentHashMap<>();\n+  private final AtomicInteger instancesAdded = new AtomicInteger();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA0Njc3OA=="}, "originalCommit": {"oid": "8354612cd60a37d59441c0809aeae811b475f612"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDA5Mjg5OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMjozNToyMFrOFyEnyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTo1NzowNVrOFyHN7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA0ODg0Mg==", "bodyText": "Too long, better to split it.", "url": "https://github.com/linkedin/ambry/pull/1399#discussion_r388048842", "createdAt": "2020-03-05T02:35:20Z", "author": {"login": "xuhao417347761"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -645,35 +674,41 @@ private void addUpdateInstances(String dcName, Map<String, Set<String>> partitio\n   private void addUpdateResources(String dcName, Map<String, Set<String>> partitionsToInstancesInDc) {\n     HelixAdmin dcAdmin = adminForDc.get(dcName);\n     List<String> resourcesInCluster = dcAdmin.getResourcesInCluster(clusterName);\n+    // maxResource may vary from one dc to another (special partition class allows partitions to exist in one dc only)\n+    int maxResource = -1;\n     for (String resourceName : resourcesInCluster) {\n       boolean resourceModified = false;\n       if (!resourceName.matches(\"\\\\d+\")) {\n         // there may be other resources created under the cluster (say, for stats) that are not part of the\n         // cluster map. These will be ignored.\n         continue;\n       }\n-      maxResource = Math.max(maxResource, Integer.valueOf(resourceName));\n+      maxResource = Math.max(maxResource, Integer.parseInt(resourceName));\n       IdealState resourceIs = dcAdmin.getResourceIdealState(clusterName, resourceName);\n       for (String partitionName : new HashSet<>(resourceIs.getPartitionSet())) {\n         Set<String> instanceSetInHelix = resourceIs.getInstanceSet(partitionName);\n         Set<String> instanceSetInStatic = partitionsToInstancesInDc.remove(partitionName);\n         if (instanceSetInStatic == null || instanceSetInStatic.isEmpty()) {\n           if (forceRemove) {\n-            info(\"*** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n-                partitionName);\n+            info(\"[{}] *** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n+                dcName.toUpperCase(), partitionName);\n             // this is a hacky way of removing a partition from the resource, as there isn't another way today.\n             // Helix team is planning to provide an API for this.\n             resourceIs.getRecord().getListFields().remove(partitionName);\n             resourceModified = true;\n           } else {\n             info(\n-                \"*** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\");\n+                \"[{}] *** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\",\n+                dcName.toUpperCase());\n             expectMoreInHelixDuringValidate = true;\n-            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> new HashSet<>()).add(partitionName);\n+            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> ConcurrentHashMap.newKeySet())\n+                .add(partitionName);\n           }\n         } else if (!instanceSetInStatic.equals(instanceSetInHelix)) {\n-          info(\"Different instance sets for partition {} under resource {}. Updating Helix using static.\",\n-              partitionName, resourceName);\n+          info(\n+              \"[{}] Different instance sets for partition {} under resource {}. Updating Helix using static. Previous instance set: [{}], new instance set: [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8354612cd60a37d59441c0809aeae811b475f612"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4ODk5MA==", "bodyText": "Sorry, I don't quite understand, could you offer some suggestions here? Thanks in advance.", "url": "https://github.com/linkedin/ambry/pull/1399#discussion_r388088990", "createdAt": "2020-03-05T05:47:32Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -645,35 +674,41 @@ private void addUpdateInstances(String dcName, Map<String, Set<String>> partitio\n   private void addUpdateResources(String dcName, Map<String, Set<String>> partitionsToInstancesInDc) {\n     HelixAdmin dcAdmin = adminForDc.get(dcName);\n     List<String> resourcesInCluster = dcAdmin.getResourcesInCluster(clusterName);\n+    // maxResource may vary from one dc to another (special partition class allows partitions to exist in one dc only)\n+    int maxResource = -1;\n     for (String resourceName : resourcesInCluster) {\n       boolean resourceModified = false;\n       if (!resourceName.matches(\"\\\\d+\")) {\n         // there may be other resources created under the cluster (say, for stats) that are not part of the\n         // cluster map. These will be ignored.\n         continue;\n       }\n-      maxResource = Math.max(maxResource, Integer.valueOf(resourceName));\n+      maxResource = Math.max(maxResource, Integer.parseInt(resourceName));\n       IdealState resourceIs = dcAdmin.getResourceIdealState(clusterName, resourceName);\n       for (String partitionName : new HashSet<>(resourceIs.getPartitionSet())) {\n         Set<String> instanceSetInHelix = resourceIs.getInstanceSet(partitionName);\n         Set<String> instanceSetInStatic = partitionsToInstancesInDc.remove(partitionName);\n         if (instanceSetInStatic == null || instanceSetInStatic.isEmpty()) {\n           if (forceRemove) {\n-            info(\"*** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n-                partitionName);\n+            info(\"[{}] *** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n+                dcName.toUpperCase(), partitionName);\n             // this is a hacky way of removing a partition from the resource, as there isn't another way today.\n             // Helix team is planning to provide an API for this.\n             resourceIs.getRecord().getListFields().remove(partitionName);\n             resourceModified = true;\n           } else {\n             info(\n-                \"*** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\");\n+                \"[{}] *** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\",\n+                dcName.toUpperCase());\n             expectMoreInHelixDuringValidate = true;\n-            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> new HashSet<>()).add(partitionName);\n+            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> ConcurrentHashMap.newKeySet())\n+                .add(partitionName);\n           }\n         } else if (!instanceSetInStatic.equals(instanceSetInHelix)) {\n-          info(\"Different instance sets for partition {} under resource {}. Updating Helix using static.\",\n-              partitionName, resourceName);\n+          info(\n+              \"[{}] Different instance sets for partition {} under resource {}. Updating Helix using static. Previous instance set: [{}], new instance set: [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA0ODg0Mg=="}, "originalCommit": {"oid": "8354612cd60a37d59441c0809aeae811b475f612"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5MTM3NA==", "bodyText": "I mean this line or string is too long. It is better to split into two lines.", "url": "https://github.com/linkedin/ambry/pull/1399#discussion_r388091374", "createdAt": "2020-03-05T05:57:05Z", "author": {"login": "xuhao417347761"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -645,35 +674,41 @@ private void addUpdateInstances(String dcName, Map<String, Set<String>> partitio\n   private void addUpdateResources(String dcName, Map<String, Set<String>> partitionsToInstancesInDc) {\n     HelixAdmin dcAdmin = adminForDc.get(dcName);\n     List<String> resourcesInCluster = dcAdmin.getResourcesInCluster(clusterName);\n+    // maxResource may vary from one dc to another (special partition class allows partitions to exist in one dc only)\n+    int maxResource = -1;\n     for (String resourceName : resourcesInCluster) {\n       boolean resourceModified = false;\n       if (!resourceName.matches(\"\\\\d+\")) {\n         // there may be other resources created under the cluster (say, for stats) that are not part of the\n         // cluster map. These will be ignored.\n         continue;\n       }\n-      maxResource = Math.max(maxResource, Integer.valueOf(resourceName));\n+      maxResource = Math.max(maxResource, Integer.parseInt(resourceName));\n       IdealState resourceIs = dcAdmin.getResourceIdealState(clusterName, resourceName);\n       for (String partitionName : new HashSet<>(resourceIs.getPartitionSet())) {\n         Set<String> instanceSetInHelix = resourceIs.getInstanceSet(partitionName);\n         Set<String> instanceSetInStatic = partitionsToInstancesInDc.remove(partitionName);\n         if (instanceSetInStatic == null || instanceSetInStatic.isEmpty()) {\n           if (forceRemove) {\n-            info(\"*** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n-                partitionName);\n+            info(\"[{}] *** Partition {} no longer present in the static clustermap, removing from Resource *** \",\n+                dcName.toUpperCase(), partitionName);\n             // this is a hacky way of removing a partition from the resource, as there isn't another way today.\n             // Helix team is planning to provide an API for this.\n             resourceIs.getRecord().getListFields().remove(partitionName);\n             resourceModified = true;\n           } else {\n             info(\n-                \"*** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\");\n+                \"[{}] *** forceRemove option not provided, resources will not be removed (use --forceRemove to forcefully remove)\",\n+                dcName.toUpperCase());\n             expectMoreInHelixDuringValidate = true;\n-            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> new HashSet<>()).add(partitionName);\n+            partitionsNotForceRemovedByDc.computeIfAbsent(dcName, k -> ConcurrentHashMap.newKeySet())\n+                .add(partitionName);\n           }\n         } else if (!instanceSetInStatic.equals(instanceSetInHelix)) {\n-          info(\"Different instance sets for partition {} under resource {}. Updating Helix using static.\",\n-              partitionName, resourceName);\n+          info(\n+              \"[{}] Different instance sets for partition {} under resource {}. Updating Helix using static. Previous instance set: [{}], new instance set: [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA0ODg0Mg=="}, "originalCommit": {"oid": "8354612cd60a37d59441c0809aeae811b475f612"}, "originalPosition": 336}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1732, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}