{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMDgyNjQz", "number": 1497, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxMjozM1rOD4JzKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNzo1MlrOD4l1dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjA3NDAyOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxMjozM1rOGO0yyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNDo1NToyMVrOGPCH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5ODIxOQ==", "bodyText": "I want to point out that info.getLifeVersion might return -1 (MessageInfo.LIFE_VERSION_FROM_FRONTEND). If so, it means we have to fetch the current lifeVersion and increment it and then put it back to the azure and cosmo. Can you add a todo here so later we can deal with it.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418198219", "createdAt": "2020-04-30T18:12:33Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -398,7 +398,24 @@ private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudSto\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    checkStarted();\n+    try {\n+      BlobId blobId = (BlobId) info.getStoreKey();\n+      // We do not have enough information in cache to check life version.\n+      // It is expected that un-deletes will be very rare, so its ok to trade off occasional hits to azure,\n+      // in lieu of maintaining live version along with blob id in cache.\n+      short newLifeVersion =\n+          requestAgent.doWithRetries(() -> cloudDestination.undeleteBlob(blobId, info.getLifeVersion()), \"Undelete\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxNjYxMA==", "bodyText": "done", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418416610", "createdAt": "2020-05-01T04:55:21Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -398,7 +398,24 @@ private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudSto\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    checkStarted();\n+    try {\n+      BlobId blobId = (BlobId) info.getStoreKey();\n+      // We do not have enough information in cache to check life version.\n+      // It is expected that un-deletes will be very rare, so its ok to trade off occasional hits to azure,\n+      // in lieu of maintaining live version along with blob id in cache.\n+      short newLifeVersion =\n+          requestAgent.doWithRetries(() -> cloudDestination.undeleteBlob(blobId, info.getLifeVersion()), \"Undelete\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5ODIxOQ=="}, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjA4NDA0OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNToyNFrOGO05HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNToyNFrOGO05HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTgzNw==", "bodyText": "BTW, delete method would also have to be take lifeVersion into consideration. For instance, if the current lifeVersion is 0 and replication thread calls delete with lifeVersion being 2, then we have to update lifeVersion as well, even if we don't change the deletion_time.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418199837", "createdAt": "2020-04-30T18:15:24Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -398,7 +398,24 @@ private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudSto\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjE2MzczOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureBlobDataAccessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODozOTozMFrOGO1sEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxMToyOVrOGPC-Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxMjg4MA==", "bodyText": "nit: can you add the field name as the second parameter to requireNoNull method.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418212880", "createdAt": "2020-04-30T18:39:30Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -292,15 +293,15 @@ public CloudBlobMetadata getBlobMetadata(BlobId blobId) throws BlobStorageExcept\n   /**\n    * Update the metadata for the specified blob.\n    * @param blobId The {@link BlobId} to update.\n-   * @param fieldName The metadata field to modify.\n-   * @param value The new value.\n+   * @param updateFields Map of field names and new values to modify.\n    * @return a {@link UpdateResponse} with the updated metadata.\n    * @throws BlobStorageException if the blob does not exist or an error occurred.\n    * @throws IllegalStateException on request timeout.\n    */\n-  public UpdateResponse updateBlobMetadata(BlobId blobId, String fieldName, Object value) throws BlobStorageException {\n+  public UpdateResponse updateBlobMetadata(BlobId blobId, Map<String, Object> updateFields)\n+      throws BlobStorageException {\n     Objects.requireNonNull(blobId, \"BlobId cannot be null\");\n-    Objects.requireNonNull(fieldName, \"Field name cannot be null\");\n+    updateFields.keySet().stream().forEach(field -> Objects.requireNonNull(updateFields.get(field)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMDQ5MA==", "bodyText": "done", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418430490", "createdAt": "2020-05-01T06:11:29Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -292,15 +293,15 @@ public CloudBlobMetadata getBlobMetadata(BlobId blobId) throws BlobStorageExcept\n   /**\n    * Update the metadata for the specified blob.\n    * @param blobId The {@link BlobId} to update.\n-   * @param fieldName The metadata field to modify.\n-   * @param value The new value.\n+   * @param updateFields Map of field names and new values to modify.\n    * @return a {@link UpdateResponse} with the updated metadata.\n    * @throws BlobStorageException if the blob does not exist or an error occurred.\n    * @throws IllegalStateException on request timeout.\n    */\n-  public UpdateResponse updateBlobMetadata(BlobId blobId, String fieldName, Object value) throws BlobStorageException {\n+  public UpdateResponse updateBlobMetadata(BlobId blobId, Map<String, Object> updateFields)\n+      throws BlobStorageException {\n     Objects.requireNonNull(blobId, \"BlobId cannot be null\");\n-    Objects.requireNonNull(fieldName, \"Field name cannot be null\");\n+    updateFields.keySet().stream().forEach(field -> Objects.requireNonNull(updateFields.get(field)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxMjg4MA=="}, "originalCommit": {"oid": "e206d6eb4e006e1441003037a5212c5e10dec62e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjM5NDM4OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1MjowMVrOGPcZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyNTo1M1rOGQC1Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzEzMg==", "bodyText": "We don't need a separate constructor, lifeVersion can be added to the constructor that takes everything.  I don't even think we need it in the constructor since it's always going to be set on an existing blob/record.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418847132", "createdAt": "2020-05-02T02:52:01Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobMetadata.java", "diffHunk": "@@ -123,6 +125,27 @@ public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime,\n    */\n   public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime, long size,\n       EncryptionOrigin encryptionOrigin, String vcrKmsContext, String cryptoAgentFactory, long encryptedSize) {\n+    this(blobId, creationTime, expirationTime, size, encryptionOrigin, vcrKmsContext, cryptoAgentFactory, encryptedSize,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3Njc1NQ==", "bodyText": "fixed.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419476755", "createdAt": "2020-05-04T14:25:53Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobMetadata.java", "diffHunk": "@@ -123,6 +125,27 @@ public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime,\n    */\n   public CloudBlobMetadata(BlobId blobId, long creationTime, long expirationTime, long size,\n       EncryptionOrigin encryptionOrigin, String vcrKmsContext, String cryptoAgentFactory, long encryptedSize) {\n+    this(blobId, creationTime, expirationTime, size, encryptionOrigin, vcrKmsContext, cryptoAgentFactory, encryptedSize,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0NzEzMg=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjQwMzkzOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMjo1NDo1OVrOGPceAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDo0ODoxMVrOGQD1xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0ODI1Ng==", "bodyText": "Mention how if affects behavior.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418848256", "createdAt": "2020-05-02T02:54:59Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "diffHunk": "@@ -51,10 +51,20 @@ boolean uploadBlob(BlobId blobId, long inputLength, CloudBlobMetadata cloudBlobM\n    * Mark a blob as deleted in the cloud destination.\n    * @param blobId id of the Ambry blob\n    * @param deletionTime time of blob deletion\n+   * @param lifeVersion life version of the blob to be deleted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ5MzMxOA==", "bodyText": "done.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419493318", "createdAt": "2020-05-04T14:48:11Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "diffHunk": "@@ -51,10 +51,20 @@ boolean uploadBlob(BlobId blobId, long inputLength, CloudBlobMetadata cloudBlobM\n    * Mark a blob as deleted in the cloud destination.\n    * @param blobId id of the Ambry blob\n    * @param deletionTime time of blob deletion\n+   * @param lifeVersion life version of the blob to be deleted.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg0ODI1Ng=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjU3Njc3OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMzo0MjowM1rOGPdqZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNTowNzozOFrOGQEt3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2NzgxMg==", "bodyText": "Where do you throw an error?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418867812", "createdAt": "2020-05-02T03:42:03Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, Utils.Infinite_Time);\n+    updateBlobMetadata(blobId, updateFields);\n+    // We either update lifeVersion or throw error. So this should work for now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUwNzY3OQ==", "bodyText": "in updateBlobMetadata, there are three cases possible\n\nthere is an exception during the update.\nupdate is successful and we return true.\nupdate returns false, because metadata is already updated to the asked values.\n\nSo, in effect, either the lifeversion gets updated, or an error is thrown.\nAnyways, with the upcoming cloudblob store changes to support frontend request, I will handle this case to return the correct lifeVersion. So this is a temporary fix to enable replication, and unblock undelete testing, while I am working on cloud blob store related changes.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419507679", "createdAt": "2020-05-04T15:07:38Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, Utils.Infinite_Time);\n+    updateBlobMetadata(blobId, updateFields);\n+    // We either update lifeVersion or throw error. So this should work for now.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2NzgxMg=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjU4NjY5OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwMzo0NDo1MVrOGPdupQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDo1OToyOVrOGQEW4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2ODkwMQ==", "bodyText": "Does the lifeVersion also need to be passed on put/upload?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418868901", "createdAt": "2020-05-02T03:44:51Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUwMTc5Mw==", "bodyText": "When a put happens\n\nDuring replication : this should be the first time we have seen this blob during replication from store. The lifeVersion for the blob should be 0. Delete and undelete should be replicated later.\nFrom frontend : the blob's lifeversion should be 0.\n\nSo we should be good in both the cases. However, when we replicate from vcr to vcr (if and when we do), then we might have to consider the case that the metadata is always at the latest version.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419501793", "createdAt": "2020-05-04T14:59:29Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -151,13 +152,30 @@ public void downloadBlob(BlobId blobId, OutputStream outputStream) throws CloudS\n   }\n \n   @Override\n-  public boolean deleteBlob(BlobId blobId, long deletionTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+  public boolean deleteBlob(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n+    Map<String, Object> updateFields = new HashMap<>();\n+    // TODO Frontend support needs to handle the special case of life version = MessageInfo.LIFE_VERSION_FROM_FRONTEND\n+    updateFields.put(CloudBlobMetadata.FIELD_LIFE_VERSION, lifeVersion);\n+    updateFields.put(CloudBlobMetadata.FIELD_DELETION_TIME, deletionTime);\n+    return updateBlobMetadata(blobId, updateFields);\n   }\n \n   @Override\n   public boolean updateBlobExpiration(BlobId blobId, long expirationTime) throws CloudStorageException {\n-    return updateBlobMetadata(blobId, CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime);\n+    return updateBlobMetadata(blobId,\n+        Collections.singletonMap(CloudBlobMetadata.FIELD_EXPIRATION_TIME, expirationTime));\n+  }\n+\n+  @Override\n+  public short undeleteBlob(BlobId blobId, short lifeVersion) throws CloudStorageException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg2ODkwMQ=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjY0NDcyOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMTowMlrOGPeIDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyODo1NFrOGQC-Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTQwNw==", "bodyText": "What if the blob went from state TTL_UPDATED to DELETED before getting undeleted.  Does it matter that we are switching it back to CREATED?  It seems okay, just checking.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418875407", "createdAt": "2020-05-02T04:01:02Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -381,24 +382,52 @@ public void delete(List<MessageInfo> infos) throws StoreException {\n    * Delete the specified blob if needed depending on the cache state.\n    * @param blobId the blob to delete\n    * @param deletionTime the deletion time\n+   * @param lifeVersion life version of the blob.\n    * @return whether the deletion was performed\n    * @throws CloudStorageException\n    */\n-  private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudStorageException {\n+  private boolean deleteIfNeeded(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n     String blobKey = blobId.getID();\n     // Note: always check cache before operation attempt, since this could be a retry after a CONFLICT error,\n     // in which case the cache may have been updated by another thread.\n-    if (!checkCacheState(blobKey, BlobState.DELETED)) {\n-      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime);\n-      addToCache(blobKey, BlobState.DELETED);\n+    if (!checkCacheState(blobKey, lifeVersion, BlobState.DELETED)) {\n+      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime, lifeVersion);\n+      addToCache(blobKey, lifeVersion, BlobState.DELETED);\n       return deleted;\n     }\n     return false;\n   }\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    checkStarted();\n+    try {\n+      return requestAgent.doWithRetries(() -> undeleteIfNeeded((BlobId) info.getStoreKey(), info.getLifeVersion()),\n+          \"Undelete\", partitionId.toPathString());\n+    } catch (CloudStorageException cex) {\n+      StoreErrorCodes errorCode =\n+          (cex.getStatusCode() == STATUS_NOT_FOUND) ? StoreErrorCodes.ID_Not_Found : StoreErrorCodes.IOError;\n+      throw new StoreException(cex, errorCode);\n+    }\n+  }\n+\n+  /**\n+   * Undelete the specified blob if needed depending on the cache state.\n+   * @param blobId the blob to delete.\n+   * @param lifeVersion life version of the deleted blob.\n+   * @return final updated life version of the blob.\n+   * @throws CloudStorageException in case any exception happens during undelete.\n+   */\n+  private short undeleteIfNeeded(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    // See note in deleteIfNeeded.\n+    if (!checkCacheState(blobId.getID(), lifeVersion, BlobState.CREATED)) {\n+      short newLifeVersion = cloudDestination.undeleteBlob(blobId, lifeVersion);\n+      addToCache(blobId.getID(), newLifeVersion, BlobState.CREATED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3OTEwNw==", "bodyText": "TTL_UPDATED is also being tracked in the _isTtlUpdated flag in BlobLifeState.  So even though we are switching it back to CREATED, it should be ok. Anyways, once the blob is marked as deleted, we cannot determine if it went from TTL_UPDATED when doing undelete.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419479107", "createdAt": "2020-05-04T14:28:54Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -381,24 +382,52 @@ public void delete(List<MessageInfo> infos) throws StoreException {\n    * Delete the specified blob if needed depending on the cache state.\n    * @param blobId the blob to delete\n    * @param deletionTime the deletion time\n+   * @param lifeVersion life version of the blob.\n    * @return whether the deletion was performed\n    * @throws CloudStorageException\n    */\n-  private boolean deleteIfNeeded(BlobId blobId, long deletionTime) throws CloudStorageException {\n+  private boolean deleteIfNeeded(BlobId blobId, long deletionTime, short lifeVersion) throws CloudStorageException {\n     String blobKey = blobId.getID();\n     // Note: always check cache before operation attempt, since this could be a retry after a CONFLICT error,\n     // in which case the cache may have been updated by another thread.\n-    if (!checkCacheState(blobKey, BlobState.DELETED)) {\n-      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime);\n-      addToCache(blobKey, BlobState.DELETED);\n+    if (!checkCacheState(blobKey, lifeVersion, BlobState.DELETED)) {\n+      boolean deleted = cloudDestination.deleteBlob(blobId, deletionTime, lifeVersion);\n+      addToCache(blobKey, lifeVersion, BlobState.DELETED);\n       return deleted;\n     }\n     return false;\n   }\n \n   @Override\n   public short undelete(MessageInfo info) throws StoreException {\n-    throw new UnsupportedOperationException(\"Undelete not supported in cloud store\");\n+    checkStarted();\n+    try {\n+      return requestAgent.doWithRetries(() -> undeleteIfNeeded((BlobId) info.getStoreKey(), info.getLifeVersion()),\n+          \"Undelete\", partitionId.toPathString());\n+    } catch (CloudStorageException cex) {\n+      StoreErrorCodes errorCode =\n+          (cex.getStatusCode() == STATUS_NOT_FOUND) ? StoreErrorCodes.ID_Not_Found : StoreErrorCodes.IOError;\n+      throw new StoreException(cex, errorCode);\n+    }\n+  }\n+\n+  /**\n+   * Undelete the specified blob if needed depending on the cache state.\n+   * @param blobId the blob to delete.\n+   * @param lifeVersion life version of the deleted blob.\n+   * @return final updated life version of the blob.\n+   * @throws CloudStorageException in case any exception happens during undelete.\n+   */\n+  private short undeleteIfNeeded(BlobId blobId, short lifeVersion) throws CloudStorageException {\n+    // TODO: Currently this is implemented for undeletes via replication only for DR.\n+    // See note in deleteIfNeeded.\n+    if (!checkCacheState(blobId.getID(), lifeVersion, BlobState.CREATED)) {\n+      short newLifeVersion = cloudDestination.undeleteBlob(blobId, lifeVersion);\n+      addToCache(blobId.getID(), newLifeVersion, BlobState.CREATED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTQwNw=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjY1MzQ4OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMzo0MFrOGPeL5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNjozMFrOGQDUoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NjM4OQ==", "bodyText": "The javadoc for these 2 lines looks messed up.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418876389", "createdAt": "2020-05-02T04:03:40Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -442,21 +471,37 @@ private boolean updateTtlIfNeeded(BlobId blobId) throws CloudStorageException {\n     // See note in deleteIfNeeded.\n     if (!checkCacheState(blobKey, BlobState.TTL_UPDATED, BlobState.DELETED)) {\n       boolean updated = cloudDestination.updateBlobExpiration(blobId, Utils.Infinite_Time);\n-      addToCache(blobKey, BlobState.TTL_UPDATED);\n+      // We do not have the definitive value of life version here. So we add to cache with minimum valid value.\n+      // If the key is present in cache, then correct life version will be updated. (see method {@link addToCache}).\n+      // If not then in worst case, the cache might let some operations with higher life version go through again.\n+      addToCache(blobKey, (short) 0, BlobState.TTL_UPDATED);\n       return updated;\n     }\n     return false;\n   }\n \n   /**\n    * Check the blob state in the recent blob cache against one or more desired states.\n+   * Note that this check ignores the life version of the blob.\n    * @param blobKey the blob key to lookup.\n    * @param desiredStates the desired state(s) to check.  If empty, any cached state is accepted.\n    * @return true if the blob key is in the cache in one of the desired states, otherwise false.\n    */\n   private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n+    return checkCacheState(blobKey, IGNORE_LIFE_VERSION, desiredStates);\n+  }\n+\n+  /**\n+   * Check the blob state in the recent blob cache against one or more desired states and life version.\n+   * @param blobKey the blob key to lookup.\n+   * @param lifeVersion the desired state(s) to check.  If empty, any cached state is accepted.\n+   * @param desiredStates true if the blob key is in the cache in one of the desired states and has appropriate life", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDgzMg==", "bodyText": "fixed.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419484832", "createdAt": "2020-05-04T14:36:30Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -442,21 +471,37 @@ private boolean updateTtlIfNeeded(BlobId blobId) throws CloudStorageException {\n     // See note in deleteIfNeeded.\n     if (!checkCacheState(blobKey, BlobState.TTL_UPDATED, BlobState.DELETED)) {\n       boolean updated = cloudDestination.updateBlobExpiration(blobId, Utils.Infinite_Time);\n-      addToCache(blobKey, BlobState.TTL_UPDATED);\n+      // We do not have the definitive value of life version here. So we add to cache with minimum valid value.\n+      // If the key is present in cache, then correct life version will be updated. (see method {@link addToCache}).\n+      // If not then in worst case, the cache might let some operations with higher life version go through again.\n+      addToCache(blobKey, (short) 0, BlobState.TTL_UPDATED);\n       return updated;\n     }\n     return false;\n   }\n \n   /**\n    * Check the blob state in the recent blob cache against one or more desired states.\n+   * Note that this check ignores the life version of the blob.\n    * @param blobKey the blob key to lookup.\n    * @param desiredStates the desired state(s) to check.  If empty, any cached state is accepted.\n    * @return true if the blob key is in the cache in one of the desired states, otherwise false.\n    */\n   private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n+    return checkCacheState(blobKey, IGNORE_LIFE_VERSION, desiredStates);\n+  }\n+\n+  /**\n+   * Check the blob state in the recent blob cache against one or more desired states and life version.\n+   * @param blobKey the blob key to lookup.\n+   * @param lifeVersion the desired state(s) to check.  If empty, any cached state is accepted.\n+   * @param desiredStates true if the blob key is in the cache in one of the desired states and has appropriate life", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NjM4OQ=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjY2MDQwOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNTozN1rOGPeO4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDo0MTo0MVrOGQDjZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NzE1NA==", "bodyText": "What if lifeVersion doesn't match?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418877154", "createdAt": "2020-05-02T04:05:37Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -466,7 +511,9 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n         return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4ODYxMg==", "bodyText": "If no desired states are passed, it means that we are just searching if we ever saw the blob in any state. In this case lifeVersion doesn't matter. This happens in findMissingKeys and shouldUpload. In both the cases all we want to check is if we ever the saw the blob before.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419488612", "createdAt": "2020-05-04T14:41:41Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -466,7 +511,9 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n         return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NzE1NA=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNjY2NzQxOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowNzo1M1rOGPeSLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDo0Mzo1MFrOGQDpVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3Nzk5Nw==", "bodyText": "Can this just be Math.max(lifeVersion, recentBlobCache.get(blobKey).getLifeVersion()) ?", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r418877997", "createdAt": "2020-05-02T04:07:53Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -480,12 +527,21 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n   /**\n    * Add a blob state mapping to the recent blob cache.\n    * @param blobKey the blob key to cache.\n+   * @param lifeVersion life version to cache.\n    * @param blobState the state of the blob.\n    */\n-  // Visible for test\n-  void addToCache(String blobKey, BlobState blobState) {\n+  // Visible for test.\n+  void addToCache(String blobKey, short lifeVersion, BlobState blobState) {\n     if (isVcr) {\n-      recentBlobCache.put(blobKey, blobState);\n+      if (blobState == BlobState.TTL_UPDATED) {\n+        // In case of ttl update we update the ttl without taking into account the life version.\n+        // So make sure that we do not decrease the lifeVersion in cache due to an incoming ttl update.\n+        if (recentBlobCache.containsKey(blobKey)) {\n+          lifeVersion = (lifeVersion > recentBlobCache.get(blobKey).getLifeVersion()) ? lifeVersion\n+              : recentBlobCache.get(blobKey).getLifeVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ5MDEzNA==", "bodyText": "fixed.", "url": "https://github.com/linkedin/ambry/pull/1497#discussion_r419490134", "createdAt": "2020-05-04T14:43:50Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudBlobStore.java", "diffHunk": "@@ -480,12 +527,21 @@ private boolean checkCacheState(String blobKey, BlobState... desiredStates) {\n   /**\n    * Add a blob state mapping to the recent blob cache.\n    * @param blobKey the blob key to cache.\n+   * @param lifeVersion life version to cache.\n    * @param blobState the state of the blob.\n    */\n-  // Visible for test\n-  void addToCache(String blobKey, BlobState blobState) {\n+  // Visible for test.\n+  void addToCache(String blobKey, short lifeVersion, BlobState blobState) {\n     if (isVcr) {\n-      recentBlobCache.put(blobKey, blobState);\n+      if (blobState == BlobState.TTL_UPDATED) {\n+        // In case of ttl update we update the ttl without taking into account the life version.\n+        // So make sure that we do not decrease the lifeVersion in cache due to an incoming ttl update.\n+        if (recentBlobCache.containsKey(blobKey)) {\n+          lifeVersion = (lifeVersion > recentBlobCache.get(blobKey).getLifeVersion()) ? lifeVersion\n+              : recentBlobCache.get(blobKey).getLifeVersion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3Nzk5Nw=="}, "originalCommit": {"oid": "c3580a91c6f0f05e917ec2b63f76487cf409a201"}, "originalPosition": 166}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1540, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}