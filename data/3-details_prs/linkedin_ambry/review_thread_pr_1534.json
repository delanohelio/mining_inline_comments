{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyOTc1MjY0", "number": 1534, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzoxMjo0MlrOEBceIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDowODozMFrOEEf69A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTUwNDk2OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/AmbryReplica.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzoxMjo0MlrOGdS43Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNToyNzowNlrOGe2Slg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MTM1Nw==", "bodyText": "Why are these public now as opposed to adding methods to ReplicaId/DiskId/etc. interfaces?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r433371357", "createdAt": "2020-06-01T17:12:42Z", "author": {"login": "cgtz"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/AmbryReplica.java", "diffHunk": "@@ -25,7 +25,7 @@\n /**\n  * {@link ReplicaId} implementation to use within dynamic cluster managers.\n  */\n-abstract class AmbryReplica implements ReplicaId {\n+public abstract class AmbryReplica implements ReplicaId {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5OTk1OA==", "bodyText": "Making these public for mocking purpose (MockAmbryReplica extends this), I will try to figure out another way to mock and avoiding doing so.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434999958", "createdAt": "2020-06-04T05:27:06Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/AmbryReplica.java", "diffHunk": "@@ -25,7 +25,7 @@\n /**\n  * {@link ReplicaId} implementation to use within dynamic cluster managers.\n  */\n-abstract class AmbryReplica implements ReplicaId {\n+public abstract class AmbryReplica implements ReplicaId {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MTM1Nw=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDgwMTEwOnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzoxNjowMlrOGeHAbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNToxNDoxMlrOGe2FdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNTI2Mg==", "bodyText": "It seems like similar methods like recoverFromDecomission do not have default impls and some impls throw UnsupportedOperationException. Is there a reason for the difference here?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434225262", "createdAt": "2020-06-02T23:16:02Z", "author": {"login": "cgtz"}, "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "diffHunk": "@@ -171,6 +171,13 @@\n    */\n   boolean recoverFromDecommission();\n \n+  /**\n+   * @return {@code true} if the store is disabled on error (due to disk I/O issue).\n+   */\n+  default boolean disabledOnError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5NjU5Nw==", "bodyText": "No specific reason. I was trying to avoid adding this new method to other implementations. Maybe I should add it to other impl and throw exception there to make it consistent with other methods in this interface.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434996597", "createdAt": "2020-06-04T05:14:12Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "diffHunk": "@@ -171,6 +171,13 @@\n    */\n   boolean recoverFromDecommission();\n \n+  /**\n+   * @return {@code true} if the store is disabled on error (due to disk I/O issue).\n+   */\n+  default boolean disabledOnError() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNTI2Mg=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg0ODEzOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixParticipant.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzo0MDo0N1rOGeHdWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTozMDo1NFrOGe2W-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMjY2NA==", "bodyText": "Could MockHelixParticipant(ClusterMapConfig) call this(clusterMapConfig, new MockHelixManagerFactory())?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434232664", "createdAt": "2020-06-02T23:40:47Z", "author": {"login": "cgtz"}, "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixParticipant.java", "diffHunk": "@@ -24,20 +24,22 @@\n import java.util.stream.Collectors;\n import org.mockito.Mockito;\n \n-import static org.mockito.Mockito.*;\n import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+import static org.mockito.Mockito.*;\n \n \n public class MockHelixParticipant extends HelixParticipant {\n   public static MetricRegistry metricRegistry = new MetricRegistry();\n   public Boolean updateNodeInfoReturnVal = null;\n   public PartitionStateChangeListener mockStatsManagerListener = null;\n+  public boolean overrideDisableReplicaMethod = true;\n   CountDownLatch listenerLatch = null;\n   ReplicaState replicaState = ReplicaState.OFFLINE;\n   ReplicaId currentReplica = null;\n   ReplicaSyncUpManager replicaSyncUpService = null;\n   private Set<ReplicaId> sealedReplicas = new HashSet<>();\n   private Set<ReplicaId> stoppedReplicas = new HashSet<>();\n+  private Set<ReplicaId> disabledReplicas = new HashSet<>();\n   private PartitionStateChangeListener mockReplicationManagerListener;\n \n   public MockHelixParticipant(ClusterMapConfig clusterMapConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMTA4Mg==", "bodyText": "yep, we can, good point", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r435001082", "createdAt": "2020-06-04T05:30:54Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixParticipant.java", "diffHunk": "@@ -24,20 +24,22 @@\n import java.util.stream.Collectors;\n import org.mockito.Mockito;\n \n-import static org.mockito.Mockito.*;\n import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+import static org.mockito.Mockito.*;\n \n \n public class MockHelixParticipant extends HelixParticipant {\n   public static MetricRegistry metricRegistry = new MetricRegistry();\n   public Boolean updateNodeInfoReturnVal = null;\n   public PartitionStateChangeListener mockStatsManagerListener = null;\n+  public boolean overrideDisableReplicaMethod = true;\n   CountDownLatch listenerLatch = null;\n   ReplicaState replicaState = ReplicaState.OFFLINE;\n   ReplicaId currentReplica = null;\n   ReplicaSyncUpManager replicaSyncUpService = null;\n   private Set<ReplicaId> sealedReplicas = new HashSet<>();\n   private Set<ReplicaId> stoppedReplicas = new HashSet<>();\n+  private Set<ReplicaId> disabledReplicas = new HashSet<>();\n   private PartitionStateChangeListener mockReplicationManagerListener;\n \n   public MockHelixParticipant(ClusterMapConfig clusterMapConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMjY2NA=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg1MDg5OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzo0MjoyMVrOGeHfEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTozMTo0OVrOGe2X8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMzEwNQ==", "bodyText": "final", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434233105", "createdAt": "2020-06-02T23:42:21Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -90,6 +91,7 @@\n   private FileLock fileLock;\n   private volatile ReplicaState currentState;\n   private volatile boolean recoverFromDecommission;\n+  private AtomicBoolean disabledOnError = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMTMzMA==", "bodyText": "fixed", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r435001330", "createdAt": "2020-06-04T05:31:49Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -90,6 +91,7 @@\n   private FileLock fileLock;\n   private volatile ReplicaState currentState;\n   private volatile boolean recoverFromDecommission;\n+  private AtomicBoolean disabledOnError = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMzEwNQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg4NDA4OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowMToxNVrOGeHzGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNToyODowNVrOGe2T6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODIzNQ==", "bodyText": "for testing i would prefer having a setter instead of getter for the AtomicBoolean object.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434238235", "createdAt": "2020-06-03T00:01:15Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -1033,6 +1064,14 @@ AtomicInteger getErrorCount() {\n     return errorCount;\n   }\n \n+  /**\n+   * Exposed for testing.\n+   * @return a boolean value that indicates whether current store is disabled due to I/O error.\n+   */\n+  AtomicBoolean getDisabledOnError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDI5OQ==", "bodyText": "will do", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r435000299", "createdAt": "2020-06-04T05:28:05Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -1033,6 +1064,14 @@ AtomicInteger getErrorCount() {\n     return errorCount;\n   }\n \n+  /**\n+   * Exposed for testing.\n+   * @return a boolean value that indicates whether current store is disabled due to I/O error.\n+   */\n+  AtomicBoolean getDisabledOnError() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODIzNQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg4NzczOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com/github/ambry/store/StorageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowMzoyMVrOGeH1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTozMzoxOFrOGe2Ztw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODgxOQ==", "bodyText": "minor: since the added if throws, this code doesn't need to be in an else clause. This can shorten the diff a bit and seems to match the existing style of this method a bit better.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434238819", "createdAt": "2020-06-03T00:03:21Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/StorageManager.java", "diffHunk": "@@ -512,35 +512,45 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n       // if replica is null that means partition is not on current node (this shouldn't happen unless we use server admin\n       // tool to remove the store before initiating decommission on this partition). We throw exception in this case.\n       if (replica != null) {\n-        // 0. as long as local replica exists, we create a decommission file in its dir\n-        File decommissionFile = new File(replica.getReplicaPath(), BlobStore.DECOMMISSION_FILE_NAME);\n-        try {\n-          if (!decommissionFile.exists()) {\n-            // if not present, create one.\n-            decommissionFile.createNewFile();\n-            logger.info(\"Decommission file is created for replica {}\", replica.getReplicaPath());\n-          }\n-        } catch (IOException e) {\n-          logger.error(\"IOException occurs when creating decommission file for replica \" + partitionName, e);\n-          throw new StateTransitionException(\n-              \"Couldn't create decommission file for replica \" + replica.getReplicaPath(), ReplicaOperationFailure);\n+        Store localStore = getStore(replica.getPartitionId(), true);\n+        if (localStore == null) {\n+          throw new StateTransitionException(\"Store \" + partitionName + \" is not found on current node\",\n+              ReplicaNotFound);\n         }\n-        Store localStore = getStore(replica.getPartitionId());\n-        if (localStore != null) {\n-          // 1. set state to INACTIVE\n-          localStore.setCurrentState(ReplicaState.INACTIVE);\n-          logger.info(\"Store {} is set to INACTIVE\", partitionName);\n-          // 2. disable compaction on this store\n-          if (!controlCompactionForBlobStore(replica.getPartitionId(), false)) {\n-            logger.error(\"Failed to disable compaction on store {}\", partitionName);\n-            // we set error code to ReplicaNotFound because that is the only reason why compaction may fail.\n-            throw new StateTransitionException(\"Couldn't disable compaction on replica \" + replica.getReplicaPath(),\n-                ReplicaNotFound);\n-          }\n-          logger.info(\"Compaction is successfully disabled on store {}\", partitionName);\n+        if (localStore.disabledOnError()) {\n+          // if store is disabled due to disk I/O error, we explicitly throw an exception to mark partition as ERROR state\n+          throw new StateTransitionException(\"Store \" + partitionName + \" is disabled due to I/O error\",\n+              ReplicaOperationFailure);\n         } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMTc4Mw==", "bodyText": "Touche!", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r435001783", "createdAt": "2020-06-04T05:33:18Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/StorageManager.java", "diffHunk": "@@ -512,35 +512,45 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n       // if replica is null that means partition is not on current node (this shouldn't happen unless we use server admin\n       // tool to remove the store before initiating decommission on this partition). We throw exception in this case.\n       if (replica != null) {\n-        // 0. as long as local replica exists, we create a decommission file in its dir\n-        File decommissionFile = new File(replica.getReplicaPath(), BlobStore.DECOMMISSION_FILE_NAME);\n-        try {\n-          if (!decommissionFile.exists()) {\n-            // if not present, create one.\n-            decommissionFile.createNewFile();\n-            logger.info(\"Decommission file is created for replica {}\", replica.getReplicaPath());\n-          }\n-        } catch (IOException e) {\n-          logger.error(\"IOException occurs when creating decommission file for replica \" + partitionName, e);\n-          throw new StateTransitionException(\n-              \"Couldn't create decommission file for replica \" + replica.getReplicaPath(), ReplicaOperationFailure);\n+        Store localStore = getStore(replica.getPartitionId(), true);\n+        if (localStore == null) {\n+          throw new StateTransitionException(\"Store \" + partitionName + \" is not found on current node\",\n+              ReplicaNotFound);\n         }\n-        Store localStore = getStore(replica.getPartitionId());\n-        if (localStore != null) {\n-          // 1. set state to INACTIVE\n-          localStore.setCurrentState(ReplicaState.INACTIVE);\n-          logger.info(\"Store {} is set to INACTIVE\", partitionName);\n-          // 2. disable compaction on this store\n-          if (!controlCompactionForBlobStore(replica.getPartitionId(), false)) {\n-            logger.error(\"Failed to disable compaction on store {}\", partitionName);\n-            // we set error code to ReplicaNotFound because that is the only reason why compaction may fail.\n-            throw new StateTransitionException(\"Couldn't disable compaction on replica \" + replica.getReplicaPath(),\n-                ReplicaNotFound);\n-          }\n-          logger.info(\"Compaction is successfully disabled on store {}\", partitionName);\n+        if (localStore.disabledOnError()) {\n+          // if store is disabled due to disk I/O error, we explicitly throw an exception to mark partition as ERROR state\n+          throw new StateTransitionException(\"Store \" + partitionName + \" is disabled due to I/O error\",\n+              ReplicaOperationFailure);\n         } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODgxOQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg5MzgwOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowNzowM1rOGeH5JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMDo1Njo1MlrOGgLzxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzOTc4MA==", "bodyText": "is there a test for the \"Store \" + partitionName + \" is not found on current node\" case?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434239780", "createdAt": "2020-06-03T00:07:03Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "diffHunk": "@@ -357,15 +357,25 @@ public void replicaFromStandbyToInactiveTest() throws Exception {\n       assertEquals(\"Error code doesn't match\", StoreNotStarted, e.getErrorCode());\n     }\n     storageManager.startBlobStore(localReplica.getPartitionId());\n-    // 4. success case (verify both replica's state and decommission file)\n+    // 4. store is disabled due to disk I/O error", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTA5Mg==", "bodyText": "test case added", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r436401092", "createdAt": "2020-06-07T20:56:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "diffHunk": "@@ -357,15 +357,25 @@ public void replicaFromStandbyToInactiveTest() throws Exception {\n       assertEquals(\"Error code doesn't match\", StoreNotStarted, e.getErrorCode());\n     }\n     storageManager.startBlobStore(localReplica.getPartitionId());\n-    // 4. success case (verify both replica's state and decommission file)\n+    // 4. store is disabled due to disk I/O error", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzOTc4MA=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg5NjYzOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/StoreTestUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowODo0MlrOGeH6zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTo0NjowNlrOGe2oTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MDIwNA==", "bodyText": "Why can't MockReplicaId be used here?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434240204", "createdAt": "2020-06-03T00:08:42Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StoreTestUtils.java", "diffHunk": "@@ -140,6 +144,54 @@ public void setSealedState(boolean isSealed) {\n     }\n   }\n \n+  public static class MockAmbryReplica extends AmbryReplica {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTUxNg==", "bodyText": "setReplicaDisabledState in HelixParticipant checks if passed in replicaId is an instance of AmbryReplica", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r435005516", "createdAt": "2020-06-04T05:46:06Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StoreTestUtils.java", "diffHunk": "@@ -140,6 +144,54 @@ public void setSealedState(boolean isSealed) {\n     }\n   }\n \n+  public static class MockAmbryReplica extends AmbryReplica {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MDIwNA=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDkwNzA3OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDoxNDo1MlrOGeIBRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODozNTo1OFrOGgrCPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTg2MQ==", "bodyText": "it looks like this method just updates the ZnRecord java object. Do you need to call HelixAdmin.setInstanceConfig like was done in setDisabledReplicas. Also, I was wondering if we need the additional disabledReplicas field or if we could just use HELIX_DISABLED_PARTITION? I may be missing something, but it seems like they hold the same set of information and are updated together at the same time.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434241861", "createdAt": "2020-06-03T00:14:52Z", "author": {"login": "cgtz"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -254,6 +245,33 @@ public boolean updateDataNodeInfoInCluster(ReplicaId replicaId, boolean shouldEx\n     return Collections.unmodifiableMap(partitionStateChangeListeners);\n   }\n \n+  @Override\n+  public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n+    if (!(replicaId instanceof AmbryReplica)) {\n+      throw new IllegalArgumentException(\n+          \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n+    }\n+    synchronized (helixAdministrationLock) {\n+      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n+      String partitionName = replicaId.getPartitionId().toPathString();\n+      if (!disable && disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Removing the partition {} from disabledReplicas list\", partitionName);\n+        disabledReplicas.remove(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      } else if (disable && !disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Adding the partition {} to disabledReplicas list\", partitionName);\n+        disabledReplicas.add(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      }\n+\n+      // invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state transition\n+      InstanceConfig instanceConfig = getInstanceConfig();\n+      String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n+      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDUzNQ==", "bodyText": "Good question. Yes, you are right, disabledReplicas and HELIX_DISABLED_PARTITION hold the same information. Let me explain a little more.\n\nWhy we need an extra disabled list?  setInstanceEnabledForPartition is Helix native method and is also used by \"move replica\" feature. When we decommission a replica, the first step is to call this method to disable replica. It will add HELIX_DISABLED_PARTITION map in InstanceConfig. There is a problem that when server restarts, it sees this map and cannot tell if the replica is disabled because of disk failure or because of replica decommission. Hence, I add this disabledReplicas to only hold replicas that are disabled due to disk failure and server will attempt to re-enable them.\nWhy we don't call setInstanceConfig again? setInstanceEnabledForPartition automatically updates InstanceConfig by change MapFields. Looks like it's not necessary to set InstanceConfig again. I also hesitate on calling setInstanceConfig as it overrides all fields (ListFields, MapFields and SimpleFields)\nHope this comment makes more sense.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r434294535", "createdAt": "2020-06-03T03:59:24Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -254,6 +245,33 @@ public boolean updateDataNodeInfoInCluster(ReplicaId replicaId, boolean shouldEx\n     return Collections.unmodifiableMap(partitionStateChangeListeners);\n   }\n \n+  @Override\n+  public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n+    if (!(replicaId instanceof AmbryReplica)) {\n+      throw new IllegalArgumentException(\n+          \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n+    }\n+    synchronized (helixAdministrationLock) {\n+      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n+      String partitionName = replicaId.getPartitionId().toPathString();\n+      if (!disable && disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Removing the partition {} from disabledReplicas list\", partitionName);\n+        disabledReplicas.remove(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      } else if (disable && !disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Adding the partition {} to disabledReplicas list\", partitionName);\n+        disabledReplicas.add(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      }\n+\n+      // invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state transition\n+      InstanceConfig instanceConfig = getInstanceConfig();\n+      String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n+      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTg2MQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMjMwOA==", "bodyText": "Thanks for clarifying point 1.\nFor 2, I am still a little confused about how setInstanceEnabledforPartition ensures that the change is reflected in zookeeper. It looks like all the implementation does is call _record.setListField(InstanceConfigProperty.HELIX_DISABLED_PARTITION.toString(), list);\nThis seems to only change the local state of the java object (ZNRecord is just a data object without a link to the persistence layer), but I thought that a call to HelixAdmin.setInstanceConfig was needed to actually call zookeeper client. This is what is done in the implementation of setSealedReplicas\nI guess my idea would be to not call setInstanceConfig inside of setDisabledReplicas and instead call it once at the end of this method after all changes to the local InstanceConfig object have been made.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r436902308", "createdAt": "2020-06-08T18:17:05Z", "author": {"login": "cgtz"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -254,6 +245,33 @@ public boolean updateDataNodeInfoInCluster(ReplicaId replicaId, boolean shouldEx\n     return Collections.unmodifiableMap(partitionStateChangeListeners);\n   }\n \n+  @Override\n+  public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n+    if (!(replicaId instanceof AmbryReplica)) {\n+      throw new IllegalArgumentException(\n+          \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n+    }\n+    synchronized (helixAdministrationLock) {\n+      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n+      String partitionName = replicaId.getPartitionId().toPathString();\n+      if (!disable && disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Removing the partition {} from disabledReplicas list\", partitionName);\n+        disabledReplicas.remove(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      } else if (disable && !disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Adding the partition {} to disabledReplicas list\", partitionName);\n+        disabledReplicas.add(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      }\n+\n+      // invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state transition\n+      InstanceConfig instanceConfig = getInstanceConfig();\n+      String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n+      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTg2MQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwOTU5Ng==", "bodyText": "yeah, you are right. I checked my previous usage of setInstanceEnabledForPartition in HelixBootstrapUpgradeUtil, it did call setInstanceConfig in the end. I will correct this part and probably re-arrange the order:\nstep1: calling setInstanceEnabledForPartition, make sure it updates the map fields (for our new version, it won't call _record.setListField)\nstep2: updating our own disabled replica list\nstep3: calling setInstanceConfig to make both of them take effect\nWhat do you think?   (changing the order is to avoid setInstanceEnabledForPartition overrides the list field, although it should not)", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r436909596", "createdAt": "2020-06-08T18:30:28Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -254,6 +245,33 @@ public boolean updateDataNodeInfoInCluster(ReplicaId replicaId, boolean shouldEx\n     return Collections.unmodifiableMap(partitionStateChangeListeners);\n   }\n \n+  @Override\n+  public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n+    if (!(replicaId instanceof AmbryReplica)) {\n+      throw new IllegalArgumentException(\n+          \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n+    }\n+    synchronized (helixAdministrationLock) {\n+      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n+      String partitionName = replicaId.getPartitionId().toPathString();\n+      if (!disable && disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Removing the partition {} from disabledReplicas list\", partitionName);\n+        disabledReplicas.remove(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      } else if (disable && !disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Adding the partition {} to disabledReplicas list\", partitionName);\n+        disabledReplicas.add(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      }\n+\n+      // invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state transition\n+      InstanceConfig instanceConfig = getInstanceConfig();\n+      String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n+      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTg2MQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjcwMA==", "bodyText": "Yep, I think that order makes sense", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r436912700", "createdAt": "2020-06-08T18:35:58Z", "author": {"login": "cgtz"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -254,6 +245,33 @@ public boolean updateDataNodeInfoInCluster(ReplicaId replicaId, boolean shouldEx\n     return Collections.unmodifiableMap(partitionStateChangeListeners);\n   }\n \n+  @Override\n+  public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n+    if (!(replicaId instanceof AmbryReplica)) {\n+      throw new IllegalArgumentException(\n+          \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n+    }\n+    synchronized (helixAdministrationLock) {\n+      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n+      String partitionName = replicaId.getPartitionId().toPathString();\n+      if (!disable && disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Removing the partition {} from disabledReplicas list\", partitionName);\n+        disabledReplicas.remove(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      } else if (disable && !disabledReplicas.contains(partitionName)) {\n+        logger.info(\"Adding the partition {} to disabledReplicas list\", partitionName);\n+        disabledReplicas.add(partitionName);\n+        setDisabledReplicas(disabledReplicas);\n+      }\n+\n+      // invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state transition\n+      InstanceConfig instanceConfig = getInstanceConfig();\n+      String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n+      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTg2MQ=="}, "originalCommit": {"oid": "374861135f71d03cd67c2fd67e43165965d30ee5"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTUyNzU2OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDowODozMFrOGiKQ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyMDo0MlrOGiKdtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjkxOA==", "bodyText": "why pass in a new object instead the one in localStore?", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r438472918", "createdAt": "2020-06-11T00:08:30Z", "author": {"login": "zzmao"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "diffHunk": "@@ -357,15 +369,26 @@ public void replicaFromStandbyToInactiveTest() throws Exception {\n       assertEquals(\"Error code doesn't match\", StoreNotStarted, e.getErrorCode());\n     }\n     storageManager.startBlobStore(localReplica.getPartitionId());\n-    // 4. success case (verify both replica's state and decommission file)\n+    // 5. store is disabled due to disk I/O error\n+    BlobStore localStore = (BlobStore) storageManager.getStore(localReplica.getPartitionId());\n+    AtomicBoolean mockDisabledOnError = new AtomicBoolean(true);\n+    localStore.setDisabledOnError(mockDisabledOnError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be6ea6989c43e2c85492e24de7aa8c6f10c0dd89"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjIxNA==", "bodyText": "This is to override boolean variable disabledOnError for testing purpose. We are not allowed to directly modify the disabledOnError within blobstore. Hope this makes sense.", "url": "https://github.com/linkedin/ambry/pull/1534#discussion_r438476214", "createdAt": "2020-06-11T00:20:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/StorageManagerTest.java", "diffHunk": "@@ -357,15 +369,26 @@ public void replicaFromStandbyToInactiveTest() throws Exception {\n       assertEquals(\"Error code doesn't match\", StoreNotStarted, e.getErrorCode());\n     }\n     storageManager.startBlobStore(localReplica.getPartitionId());\n-    // 4. success case (verify both replica's state and decommission file)\n+    // 5. store is disabled due to disk I/O error\n+    BlobStore localStore = (BlobStore) storageManager.getStore(localReplica.getPartitionId());\n+    AtomicBoolean mockDisabledOnError = new AtomicBoolean(true);\n+    localStore.setDisabledOnError(mockDisabledOnError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjkxOA=="}, "originalCommit": {"oid": "be6ea6989c43e2c85492e24de7aa8c6f10c0dd89"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1619, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}