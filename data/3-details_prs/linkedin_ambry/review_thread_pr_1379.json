{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzA3NzQy", "number": 1379, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0ODoyMFrODfqJXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMzoyN1rODf_hOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIyOTc0OnYy", "diffSide": "RIGHT", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0ODoyMFrOFpfbqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0ODoyMFrOFpfbqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MDkyMA==", "bodyText": "storeToUndelete?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379050920", "createdAt": "2020-02-13T18:48:20Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIzNDk0OnYy", "diffSide": "RIGHT", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0OTo1MlrOFpfezw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo0OTo1MlrOFpfezw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MTcyNw==", "bodyText": "ID_Deleted is the expected case, no?\nWhy no ID_Undeleted?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379051727", "createdAt": "2020-02-13T18:49:52Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIzNzc0OnYy", "diffSide": "RIGHT", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MDo0M1rOFpfghQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MDo0M1rOFpfghQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjE2NQ==", "bodyText": "unExpectedStoreUndeleteError?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052165", "createdAt": "2020-02-13T18:50:43Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();\n+      } else {\n+        logInErrorLevel = true;\n+        metrics.unExpectedStoreDeleteError.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTIzOTE5OnYy", "diffSide": "RIGHT", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MToxMlrOFpfhfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxODo1MToxMlrOFpfhfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjQxMw==", "bodyText": "undeleteAuthorizationFailure?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052413", "createdAt": "2020-02-13T18:51:12Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01605864ac2919dcf44d2791a7e7cfaef8b02e82"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODczMTQ3OnYy", "diffSide": "RIGHT", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServerRequests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMzoyN1rOFqBJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTozMTo1N1rOFqBYaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzQxMA==", "bodyText": "Can we move this piece of code into isRequestEnabled() ?", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379603410", "createdAt": "2020-02-14T19:23:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServerRequests.java", "diffHunk": "@@ -614,6 +615,10 @@ protected ServerErrorCode validateRequest(PartitionId partition, RequestOrRespon\n       metrics.partitionReadOnlyError.inc();\n       return ServerErrorCode.Partition_ReadOnly;\n     }\n+    if (requestType.equals(RequestOrResponseType.UndeleteRequest) && !serverConfig.serverHandleUndeleteRequestEnabled) {\n+      metrics.temporarilyDisabledError.inc();\n+      return ServerErrorCode.Temporarily_Disabled;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNzE0Nw==", "bodyText": "sure", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379607147", "createdAt": "2020-02-14T19:31:57Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServerRequests.java", "diffHunk": "@@ -614,6 +615,10 @@ protected ServerErrorCode validateRequest(PartitionId partition, RequestOrRespon\n       metrics.partitionReadOnlyError.inc();\n       return ServerErrorCode.Partition_ReadOnly;\n     }\n+    if (requestType.equals(RequestOrResponseType.UndeleteRequest) && !serverConfig.serverHandleUndeleteRequestEnabled) {\n+      metrics.temporarilyDisabledError.inc();\n+      return ServerErrorCode.Temporarily_Disabled;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzQxMA=="}, "originalCommit": {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1699, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}