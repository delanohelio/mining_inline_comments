{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDczNDgw", "number": 1531, "title": "Integrate Cosmos BulkDelete stored procedure into compaction.", "bodyText": "", "createdAt": "2020-05-22T18:06:20Z", "url": "https://github.com/linkedin/ambry/pull/1531", "merged": true, "mergeCommit": {"oid": "ac3bb8b1cda2118e4ba0c8065eddbc36d8077125"}, "closed": true, "closedAt": "2020-05-27T19:43:39Z", "author": {"login": "lightningrob"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcj2OgagH2gAyNDIyMDczNDgwOmVhN2UxZmU5M2ZiMTFmNTNmMGU4NTY4MjVlMTA3NGI4MGQzYjkzNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclT3fMgH2gAyNDIyMDczNDgwOjQxMTMwNjUwM2JjZTRmYzE1Y2E3ZWNhNzM2YTgxZTFhZThhNjRkZjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "committedDate": "2020-05-22T18:04:09Z", "message": "Integrate Cosmos BulkDelete stored procedure into compaction."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzM4NjE1", "url": "https://github.com/linkedin/ambry/pull/1531#pullrequestreview-417338615", "createdAt": "2020-05-24T08:41:31Z", "commit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTkyNjYw", "url": "https://github.com/linkedin/ambry/pull/1531#pullrequestreview-418592660", "createdAt": "2020-05-26T19:05:00Z", "commit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTowMFrOGasRJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTo0OFrOGasS0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ0NA==", "bodyText": "when continuation is true, we just try again with the same list of blob IDs. Is the stored procedure idempotent?", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641444", "createdAt": "2020-05-26T19:05:00Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTg3NQ==", "bodyText": "does this count include blobs that were already deleted from previous iterations?", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641875", "createdAt": "2020-05-26T19:05:48Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();\n+        requestCharge += response.getRequestCharge();\n+        Document responseDoc = response.getResponseAsDocument();\n+        more = responseDoc.getBoolean(PROPERTY_CONTINUATION);\n+        deleteCount += responseDoc.getInt(PROPERTY_DELETED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a54a9e101ac976a4830487fee36a15f7395e8e7", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/5a54a9e101ac976a4830487fee36a15f7395e8e7", "committedDate": "2020-05-27T06:01:23Z", "message": "Check in BulkDelete stored procedure as resource"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "411306503bce4fc15ca7eca736a81e1ae8a64df8", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/411306503bce4fc15ca7eca736a81e1ae8a64df8", "committedDate": "2020-05-27T07:10:05Z", "message": "Exclude resource from license check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1509, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}