{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NDc3Nzky", "number": 1589, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDowOTo1NlrOEODJhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzoxNjoyNFrOEOxyUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTY3MTA4OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDowOTo1NlrOGw_KUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0NjoyOVrOGxmhug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA==", "bodyText": "Is there a reason for dropping the connection at this point as opposed to just waiting until the router tells the NetworkClient to drop the request after routerRequestTimeoutMs? At this point, the request has already been flushed successfully so the request memory would have already been freed.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454019664", "createdAt": "2020-07-14T00:09:56Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5NjMwOQ==", "bodyText": "I agree with you . Changed http2DropRequestOnWriteAndFlushTimeout to false by default.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454596309", "createdAt": "2020-07-14T19:36:04Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5NzgxNg==", "bodyText": "Want to discuss with your guys @justinlin-linkedin @cgtz :\nIf a request is flushed successfully(here), its refCnt is decreased, but there is a reference chain that AttributeKey<RequestInfo> -> PutRequest -> Bytebuf, so even refCnt is 0, data is still in memory and can't be recycled. Is this something we can improve?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454597816", "createdAt": "2020-07-14T19:39:11Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjAwMA==", "bodyText": "I am not worried about this. Comparing to the small object ByteBuf, the byte content held by ByteBuf is way larger. As long as the byte content can be reclaimed by the memory pool, we can ignore the small ByteBuf object.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454606000", "createdAt": "2020-07-14T19:53:58Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzODMyOA==", "bodyText": "Not fully understand your comment.\nIf it's PutRquest and it holds big chunk of data, we should break the link between PutRequst -> ByteBuf, for GC to recycle, right?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454638328", "createdAt": "2020-07-14T20:53:32Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NDYzNA==", "bodyText": "Yes and no. When using Unpooled bytebuf, big chunk of data will rely on gc to release the memory. When using Pooled ByteBuf, big chunk of data will rely on calling release method to return the chunk back to the pool. GC doesn't reclaim the data chunk, only the small heap memory of ByteBuf fields.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454664634", "createdAt": "2020-07-14T21:46:29Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,34 +83,61 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n     long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n     // Send request\n     http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n     for (RequestInfo requestInfo : requestsToSend) {\n       long streamInitiateTime = System.currentTimeMillis();\n+\n+      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n+      long waitingTime = streamInitiateTime - request.requestCreateTime;\n+      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n+\n       this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n           .acquire()\n           .addListener((GenericFutureListener<Future<Channel>>) future -> {\n             if (future.isSuccess()) {\n               http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n+              correlationIdInFlightToChannelMap.put(requestInfo.getRequest().getCorrelationId(), streamChannel);\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(),\n+                    streamChannel, streamChannel.bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());\n+              }\n               streamChannel.writeAndFlush(requestInfo.getRequest()).addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n-                  // Listener will be notified after data is removed from ChannelOutboundBuffer (netty's send buffer)\n+                  // Listener will be notified right after data is removed from ChannelOutboundBuffer (netty's send buffer)\n                   // After removing from ChannelOutboundBuffer, it goes to OS send buffer.\n                   if (future.isSuccess()) {\n-                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n-                        System.currentTimeMillis() - streamAcquiredTime);\n+                    long writeAndFlushUsedTime = System.currentTimeMillis() - streamAcquiredTime;\n+                    http2ClientMetrics.http2StreamWriteAndFlushTime.update(writeAndFlushUsedTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    if (writeAndFlushUsedTime > http2ClientConfig.http2WriteAndFlushTimeoutMs) {\n+                      // This usually happens if remote can't accept data in time.\n+                      logger.warn(\n+                          \"WriteAndFlush exceeds http2RequestTimeoutMs {}ms, used time: {}ms, stream channel {}\",\n+                          http2ClientConfig.http2WriteAndFlushTimeoutMs, writeAndFlushUsedTime, streamChannel);\n+                      if (http2ClientConfig.http2DropRequestOnWriteAndFlushTimeout) {\n+                        releaseAndCloseStreamChannel(streamChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTY2NA=="}, "originalCommit": {"oid": "4f8108d2fb4f02b8d6bff8edb0edbe4d7f900fb9"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTQ0MTc0OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOTo1NTowOFrOGxi_Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMDo1MDoxOVrOGxkz5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjYyNw==", "bodyText": "is there a possibility that redyResponseInfos contain responses for the dropped request? if so, do we care?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454606627", "createdAt": "2020-07-14T19:55:08Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzNjUxNw==", "bodyText": "It should include responses from dropped request. That's how router knows it was drooped.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454636517", "createdAt": "2020-07-14T20:50:19Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjYyNw=="}, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTQ1MjI5OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOTo1ODoxMlrOGxjFxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODowNDozOVrOGyJxAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ==", "bodyText": "Also, should probably remove the correlationIds for these responses from the inflight map.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454608325", "createdAt": "2020-07-14T19:58:12Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNTM3OQ==", "bodyText": "Good catch. Re-organized the map logic:\nadd: when a stream is acquired\nremove: after http2ClientResponseHandler.getResponseInfoQueue().poll()", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454625379", "createdAt": "2020-07-14T20:30:05Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ=="}, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMjE4NQ==", "bodyText": "Does this mean that a request cannot be dropped if stream acquisition takes a long time? I guess that is okay since that may be a rare occurrence and would require some complicated logic in the acquire listener to determine if the request can be sent or not.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455232185", "createdAt": "2020-07-15T17:49:19Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ=="}, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0MTk4NQ==", "bodyText": "You are right, if a stream is not acquired, it's won't be in inflight map, so it can't be dropped. It's rare, we don't expect stream acquisition takes a long time.\nAnd since the inflight map's value is streamChannel(to close it in case of drop request), we can't add <correlationId, streamChannel> to inflight map before stream acquisition done.\nAn extra time check can be made right after stream acquired if it's really need.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455241985", "createdAt": "2020-07-15T18:04:39Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -144,6 +174,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n     if (requestsToDrop.size() != 0) {\n       logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n       http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.remove(correlationId);\n+        if (streamChannel != null) {\n+          releaseAndCloseStreamChannel(streamChannel);\n+        }\n+      }\n     }\n \n     http2ClientResponseHandler.getResponseInfoQueue().poll(readyResponseInfos, pollTimeoutMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwODMyNQ=="}, "originalCommit": {"oid": "890096ef0838c4deedd988f89f42b3366bc13928"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTczOTg3OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToyMjoyN1rOGxl1Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMjoxNzoxM1rOGxnUCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzI1OQ==", "bodyText": "is this added to the pipeline anywhere?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454653259", "createdAt": "2020-07-14T21:22:27Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -49,6 +56,7 @@ public Http2ChannelPoolHandler(SSLFactory sslFactory, String host, int port, Htt\n     this.host = host;\n     this.port = port;\n     this.http2ClientConfig = http2ClientConfig;\n+    this.connectionInboundExceptionHandler = new ConnectionInboundExceptionHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3NzUxNA==", "bodyText": "yes, added to connection pipeline. Stream pipeline is not impacted.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454677514", "createdAt": "2020-07-14T22:17:13Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -49,6 +56,7 @@ public Http2ChannelPoolHandler(SSLFactory sslFactory, String host, int port, Htt\n     this.host = host;\n     this.port = port;\n     this.http2ClientConfig = http2ClientConfig;\n+    this.connectionInboundExceptionHandler = new ConnectionInboundExceptionHandler();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzI1OQ=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc2NDg2OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozMDo0MFrOGxmFEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzo1NDozNlrOGyJXhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzI5Ng==", "bodyText": "what is this? This handler is not used anywhere, and it seems like we are trying to print out some info when it's a stream exception, which makes this a stream handler, doesn't stream handler belong to Http2NetworkClient.StreamChannelInitializer?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454657296", "createdAt": "2020-07-14T21:30:40Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MTU5NQ==", "bodyText": "If a request is drop, its streamChannel will be closed, but if a response is already inflight, and then arrives client.\nHttp2MultiplexHandler will report unknown stream id error and print a long stack.\nThe handler here is to avoid such useless stack in our log.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454671595", "createdAt": "2020-07-14T22:02:17Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzI5Ng=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzNTQ2MA==", "bodyText": "Are we sure that all resources on child channels will be released if the exception is caught and swallowed here?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455235460", "createdAt": "2020-07-15T17:54:36Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzI5Ng=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc3NjcwOnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozNDo0M1rOGxmMng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozNDo0M1rOGxmMng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1OTIzMA==", "bodyText": "correlationIdInFlightToChannelMap.remove(correlationId) would be better.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454659230", "createdAt": "2020-07-14T21:34:43Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -79,24 +84,47 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics,\n         new StreamChannelInitializer());\n     this.http2ClientMetrics = http2ClientMetrics;\n+    correlationIdInFlightToChannelMap = new ConcurrentHashMap<>();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    long startTime = System.currentTimeMillis();\n+\n     List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n+    if (requestsToDrop.size() != 0) {\n+      logger.warn(\"Number of requestsToDrop: {}\", requestsToDrop.size());\n+      http2ClientMetrics.http2RequestsToDropCount.inc(requestsToDrop.size());\n+      for (int correlationId : requestsToDrop) {\n+        Channel streamChannel = correlationIdInFlightToChannelMap.get(correlationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTgzMDc4OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1Mzo1NlrOGxmuKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1Mzo1NlrOGxmuKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NzgxOQ==", "bodyText": "\"which from...\" -> \"for a request which was already dropped\"", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r454667819", "createdAt": "2020-07-14T21:53:56Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -64,5 +72,19 @@ public void channelCreated(Channel ch) throws Exception {\n         .build());\n     pipeline.addLast(new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()));\n   }\n+\n+  @ChannelHandler.Sharable\n+  private static class ConnectionInboundExceptionHandler extends ChannelInboundHandlerAdapter {\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+      if (cause instanceof Http2Exception.StreamException) {\n+        // This usually happens when server returns response which from a dropped request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTExNzQ0OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/MultiplexedChannelRecord.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNjowMVrOGyFv3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNjowMVrOGyFv3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3NjE1OQ==", "bodyText": "nit: remove whitespace at the end of these log messages", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176159", "createdAt": "2020-07-15T16:26:01Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/MultiplexedChannelRecord.java", "diffHunk": "@@ -268,18 +268,21 @@ private boolean claimStream() {\n     for (int attempt = 0; attempt < 5; ++attempt) {\n \n       if (state != RecordState.OPEN) {\n+        log.warn(\"claimStream fail because state is closed. \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTEyMDUyOnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNjo0NVrOGyFxsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNjo0NVrOGyFxsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3NjYyNQ==", "bodyText": "remove whitespace here", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176625", "createdAt": "2020-07-15T16:26:45Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "diffHunk": "@@ -1357,7 +1357,7 @@ private void fetchRequests(RequestRegistrationCallback<PutOperation> requestRegi\n         requestRegistrationCallback.registerRequestToSend(PutOperation.this, request);\n         replicaIterator.remove();\n         if (RouterUtils.isRemoteReplica(routerConfig, replicaId)) {\n-          logger.trace(\"Making request with correlationId {} to a remote replica {} in {} \", correlationId,\n+          logger.debug(\"Making request with correlationId {} to a remote replica {} in {} \", correlationId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTEyMjc3OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyNzoyMlrOGyFzGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMjowMTo1NFrOGyS2EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3Njk4Ng==", "bodyText": "what is the new import used for?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455176986", "createdAt": "2020-07-15T16:27:22Z", "author": {"login": "cgtz"}, "path": "build.gradle", "diffHunk": "@@ -248,7 +248,8 @@ project(':ambry-network') {\n         compile project(':ambry-api'),\n                 project(':ambry-utils'),\n                 project(':ambry-commons'),\n-                project(':ambry-clustermap')\n+                project(':ambry-clustermap'),\n+                project(':ambry-protocol')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0NjI5MQ==", "bodyText": "It's used for a metric:\n      RequestOrResponse request = (RequestOrResponse) (requestInfo.getRequest());\n      long waitingTime = streamInitiateTime - request.requestCreateTime;\n      http2ClientMetrics.requestToNetworkClientLatencyMs.update(waitingTime);\n\nI can remove this metric if it's not clean to import ambry-protocol.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455246291", "createdAt": "2020-07-15T18:11:47Z", "author": {"login": "zzmao"}, "path": "build.gradle", "diffHunk": "@@ -248,7 +248,8 @@ project(':ambry-network') {\n         compile project(':ambry-api'),\n                 project(':ambry-utils'),\n                 project(':ambry-commons'),\n-                project(':ambry-clustermap')\n+                project(':ambry-clustermap'),\n+                project(':ambry-protocol')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3Njk4Ng=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM5MDczNw==", "bodyText": "It is probably okay to import since that dependency is probably needed by anyone that uses the network client anyways. One other alternative would be to add a getCreationTime() method to the SendWithCorrelationId interface. I don't have a strong preference for either direction though.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455390737", "createdAt": "2020-07-15T22:01:54Z", "author": {"login": "cgtz"}, "path": "build.gradle", "diffHunk": "@@ -248,7 +248,8 @@ project(':ambry-network') {\n         compile project(':ambry-api'),\n                 project(':ambry-utils'),\n                 project(':ambry-commons'),\n-                project(':ambry-clustermap')\n+                project(':ambry-clustermap'),\n+                project(':ambry-protocol')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3Njk4Ng=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTMxMjE4OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzoxNjoyNFrOGyHpGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTowNzoyNVrOGyMBJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNzE5NA==", "bodyText": "Why doesn't the ref count get decremented in other exception cases? Are we assuming that other exception cases come from ChannelHandlers written by Ambry that don't decrement the ref count?", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455207194", "createdAt": "2020-07-15T17:16:24Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -124,8 +164,11 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     releaseAndCloseStreamChannel(streamChannel);\n                     http2ClientResponseHandler.getResponseInfoQueue()\n                         .put(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n-                    // release related bytebuf\n-                    requestInfo.getRequest().release();\n+                    if (!(future.cause() instanceof ClosedChannelException)) {\n+                      // If it's ClosedChannelException caused by drop request, it's probably refCnt has been decreased.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1ODE4Ng==", "bodyText": "It's because I am not clear when exactly refCnt is decreased. Let me do more reading.", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455258186", "createdAt": "2020-07-15T18:30:54Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -124,8 +164,11 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     releaseAndCloseStreamChannel(streamChannel);\n                     http2ClientResponseHandler.getResponseInfoQueue()\n                         .put(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n-                    // release related bytebuf\n-                    requestInfo.getRequest().release();\n+                    if (!(future.cause() instanceof ClosedChannelException)) {\n+                      // If it's ClosedChannelException caused by drop request, it's probably refCnt has been decreased.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNzE5NA=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODg4NA==", "bodyText": "@cgtz @justinlin-linkedin   I need suggestions from you.\nI just did an experiment which added  an excpetion throw in AmbrySendToHttp2Adaptor.write() (after ctx.write(dataFrame, promise)). In this case, writeAndFlush listener see refCnt 1.\nBut in the other case we saw, channel closed, writeAndFlush listener is also triggered. refCnt is 0. (because if we do one more refCnt decrase, netty reports error.)", "url": "https://github.com/linkedin/ambry/pull/1589#discussion_r455278884", "createdAt": "2020-07-15T19:07:25Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -124,8 +164,11 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     releaseAndCloseStreamChannel(streamChannel);\n                     http2ClientResponseHandler.getResponseInfoQueue()\n                         .put(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n-                    // release related bytebuf\n-                    requestInfo.getRequest().release();\n+                    if (!(future.cause() instanceof ClosedChannelException)) {\n+                      // If it's ClosedChannelException caused by drop request, it's probably refCnt has been decreased.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwNzE5NA=="}, "originalCommit": {"oid": "a311b0d669412821d2c9084cfd624b2e135b661b"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1320, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}