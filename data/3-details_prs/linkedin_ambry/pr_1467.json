{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTIxMTYz", "number": 1467, "title": "Add skeleton for router to support undelete", "bodyText": "First step to support undelete in the frontend. This PR adds skeleton code in the router for undelete manager and undelete operation.", "createdAt": "2020-04-09T16:24:36Z", "url": "https://github.com/linkedin/ambry/pull/1467", "merged": true, "mergeCommit": {"oid": "1189ff1daf7589d8a041c83b999433f0106b8e5a"}, "closed": true, "closedAt": "2020-04-21T02:01:30Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWLQbdgFqTM5MTI4ODQyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZo_fAAFqTM5NjkxNzk2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjg4NDIy", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-391288422", "createdAt": "2020-04-10T06:33:37Z", "commit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozMzozN1rOGDyVKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozOTowN1rOGDya3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzUzMA==", "bodyText": "Java Doc", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406623530", "createdAt": "2020-04-10T06:33:37Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -287,6 +287,30 @@ private OperationController getOperationController() {\n     return futureResult;\n   }\n \n+  @Override\n+  public Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDA5Nw==", "bodyText": "???\nLooks like the implementation is also for GET?", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624097", "createdAt": "2020-04-10T06:35:50Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +746,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDk5MQ==", "bodyText": "Based on my recent experience, default may cause some test issues because it brings in a default implementation. Prefer to have same interface as updateBlobTtl .", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624991", "createdAt": "2020-04-10T06:39:07Z", "author": {"login": "zzmao"}, "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -88,6 +88,22 @@\n    */\n   Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs, Callback<Void> callback);\n \n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+   * @param blobId The ID of the blob that needs to be undeleted.\n+   * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+   * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+   * @return A future that would contain information about whether the undelete succeeded or not, eventually.\n+   */\n+  default Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/56586050df9da58b9ae55c58deba855cd6b5af80", "committedDate": "2020-04-09T16:28:42Z", "message": "Remove duplicate code"}, "afterCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/eb0e436fe160467c36ad52254d568602ae811fee", "committedDate": "2020-04-10T18:30:34Z", "message": "Remove default implmentation of undeleteBlob"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2Nzc2MDA0", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396776004", "createdAt": "2020-04-20T20:10:20Z", "commit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxMDoyMFrOGIlqzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxMzo0N1rOGIlyWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1ODk1OQ==", "bodyText": "completeUpdateBlobUndeleteOperation", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411658959", "createdAt": "2020-04-20T20:10:20Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA==", "bodyText": "The code looks like similar to updateBlobTtl. Is it possible to unify them?", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660050", "createdAt": "2020-04-20T20:12:15Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDg4OA==", "bodyText": "Tracks callbacks for update operations(TtlUpdate, Undelete)....", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660888", "createdAt": "2020-04-20T20:13:47Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MDE4OTMw", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-395018930", "createdAt": "2020-04-16T21:39:55Z", "commit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozOTo1NVrOGG4JRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTozNToxOVrOGIkYhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NDUxOQ==", "bodyText": "minor: there is no Callback to be invoked. Rephrase this comment please.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409864519", "createdAt": "2020-04-16T21:39:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -167,4 +176,14 @@\n   default Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs) {\n     return updateBlobTtl(blobId, serviceId, expiresAtMs, null);\n   }\n+\n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NTU1Nw==", "bodyText": "nit: format this file", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409865557", "createdAt": "2020-04-16T21:42:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob\n+ */\n+class BatchOperationCallbackTracker {\n+  static final FutureResult<Void> DUMMY_FUTURE = new FutureResult<>();\n+\n+  private final FutureResult<Void> futureResult;\n+  private final Callback<Void> callback;\n+  private final long numBlobIds;\n+  private final ConcurrentMap<BlobId, Boolean> blobIdToAck = new ConcurrentHashMap<>();\n+  private final AtomicLong ackedCount = new AtomicLong(0);\n+  private final AtomicBoolean completed = new AtomicBoolean(false);\n+\n+  /**\n+   * Constructor\n+   * @param blobIds the {@link BlobId}s being tracked\n+   * @param futureResult the {@link FutureResult} to be triggered once acks are received for all blobs\n+   * @param callback the {@link Callback} to be triggered once acks are received for all blobs\n+   */\n+  BatchOperationCallbackTracker(List<BlobId> blobIds, FutureResult<Void> futureResult,\n+      Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwNDU0OA==", "bodyText": "minor: for TtlUpdate and Undelete operations", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409904548", "createdAt": "2020-04-16T23:23:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ==", "bodyText": "should be completeUndeleteBlobOperation", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636151", "createdAt": "2020-04-20T19:32:17Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjk4OA==", "bodyText": "you probably need a dedicated metric routerMetrics.ageAtUndelete", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636988", "createdAt": "2020-04-20T19:33:45Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNzg5NA==", "bodyText": "And try to write a test that covers this case.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411637894", "createdAt": "2020-04-20T19:35:19Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde9fe3c136071f9d5add87eb0fd6c46de8e1c4b", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/cde9fe3c136071f9d5add87eb0fd6c46de8e1c4b", "committedDate": "2020-04-20T20:43:41Z", "message": "Add skeleton for router to support undelete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "648a87764e343992d3b77f4d79b93deb89ada2f0", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/648a87764e343992d3b77f4d79b93deb89ada2f0", "committedDate": "2020-04-20T20:43:41Z", "message": "Remove duplicate code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec8e31450b92d4f3abb9fae9fc8544e01511c559", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/ec8e31450b92d4f3abb9fae9fc8544e01511c559", "committedDate": "2020-04-20T20:43:41Z", "message": "Remove default implmentation of undeleteBlob"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/0d56c055fab0b7f879b27c5083ba1a63da08e551", "committedDate": "2020-04-20T20:49:20Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/eb0e436fe160467c36ad52254d568602ae811fee", "committedDate": "2020-04-10T18:30:34Z", "message": "Remove default implmentation of undeleteBlob"}, "afterCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/0d56c055fab0b7f879b27c5083ba1a63da08e551", "committedDate": "2020-04-20T20:49:20Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODY5MjE3", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396869217", "createdAt": "2020-04-20T22:57:52Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Nzo1MlrOGIrB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Nzo1MlrOGIrB6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5NQ==", "bodyText": "I know the logic is mostly from TtlUpdate but let's be careful on Undelete own logic here. Note that GetOption.None returns all blobs that are not expired and not deleted.  I wonder if we should use Include_Deleted_Blobs for undelete operation. Please double check GetOption enum.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411746795", "createdAt": "2020-04-20T22:57:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -706,6 +752,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before undelete)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODcwMTU0", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396870154", "createdAt": "2020-04-20T22:59:55Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OTo1NVrOGIrFqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OTo1NVrOGIrFqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzc1Mg==", "bodyText": "should beUndeleteOperation.class", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747752", "createdAt": "2020-04-20T22:59:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -243,6 +250,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentOperationRate\"));\n     deleteBlobOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationRate\"));\n+    undeleteBlobOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationRate\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODcwMjY2", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396870266", "createdAt": "2020-04-20T23:00:12Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoxMlrOGIrGGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoxMlrOGIrGGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzg2Ng==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747866", "createdAt": "2020-04-20T23:00:12Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -252,6 +261,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetBlobNotOriginateLocalOperationRate\"));\n     deleteBlobNotOriginateLocalOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobNotOriginateLocalOperationRate\"));\n+    undeleteBlobNotOriginateLocalOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobNotOriginateLocalOperationRate\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODcwMzEw", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396870310", "createdAt": "2020-04-20T23:00:20Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoyMFrOGIrGRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoyMFrOGIrGRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzkxMA==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747910", "createdAt": "2020-04-20T23:00:20Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -282,6 +293,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.histogram(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobOperationTotalTimeMs\"));\n     deleteBlobOperationLatencyMs =\n         metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationLatencyMs\"));\n+    undeleteBlobOperationLatencyMs =\n+        metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationLatencyMs\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODcwNzQ5", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396870749", "createdAt": "2020-04-20T23:01:26Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMToyNlrOGIrICA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMToyNlrOGIrICA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0ODM2MA==", "bodyText": "make sure all recently added metrics in this file have been updated to either UndeleteOperation.class or UndeleteManager.class", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411748360", "createdAt": "2020-04-20T23:01:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -312,6 +325,7 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n     getEncryptedBlobWithSegmentErrorCount =\n         metricRegistry.counter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentErrorCount\"));\n     deleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobErrorCount\"));\n+    undeleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobErrorCount\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODc2ODM1", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396876835", "createdAt": "2020-04-20T23:17:48Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNzo0OFrOGIrg8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNzo0OFrOGIrg8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDczOA==", "bodyText": "redundant cast, can remove (UndeleteRequest)", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411754738", "createdAt": "2020-04-20T23:17:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountService;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import com.github.ambry.clustermap.ClusterMapUtils;\n+import com.github.ambry.commons.BlobId;\n+import com.github.ambry.commons.ResponseHandler;\n+import com.github.ambry.config.RouterConfig;\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.notification.NotificationSystem;\n+import com.github.ambry.protocol.UndeleteRequest;\n+import com.github.ambry.protocol.UndeleteResponse;\n+import com.github.ambry.utils.Pair;\n+import com.github.ambry.utils.Time;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\n+/**\n+ * Handles {@link UndeleteOperation}. A {@code UndeleteManager} keeps track of all the Undelete\n+ * operations that are assigned to it, and manages their states and life cycles.\n+ */\n+public class UndeleteManager {\n+  private final ClusterMap clusterMap;\n+  private final NotificationSystem notificationSystem;\n+  private final Time time;\n+  private final ResponseHandler responseHandler;\n+  private final AccountService accountService;\n+  private final NonBlockingRouterMetrics routerMetrics;\n+  private final RouterConfig routerConfig;\n+  private final Set<UndeleteOperation> undeleteOperations = ConcurrentHashMap.newKeySet();\n+  private final Map<Integer, UndeleteOperation> correlationIdToUndeleteOperation = new HashMap<>();\n+  private final RequestRegistrationCallback<UndeleteOperation> requestRegistrationCallback =\n+      new RequestRegistrationCallback<>(correlationIdToUndeleteOperation);\n+\n+  /**\n+   * Creates a UndeleteManager.\n+   * @param clusterMap The {@link ClusterMap} of the cluster.\n+   * @param responseHandler The {@link ResponseHandler} used to notify failures for failure detection.\n+   * @param notificationSystem The {@link NotificationSystem} used for notifying undelete for blobs.\n+   * @param accountService The {@link AccountService} used for account/container id and name mapping.\n+   * @param routerConfig The {@link RouterConfig} containing the configs for the UndeleteManager.\n+   * @param routerMetrics The {@link NonBlockingRouterMetrics} to be used for reporting metrics.\n+   * @param time The {@link Time} instance to use.\n+   */\n+  UndeleteManager(ClusterMap clusterMap, ResponseHandler responseHandler, NotificationSystem notificationSystem,\n+      AccountService accountService, RouterConfig routerConfig, NonBlockingRouterMetrics routerMetrics, Time time) {\n+    this.clusterMap = clusterMap;\n+    this.responseHandler = responseHandler;\n+    this.notificationSystem = notificationSystem;\n+    this.accountService = accountService;\n+    this.routerConfig = routerConfig;\n+    this.routerMetrics = routerMetrics;\n+    this.time = time;\n+  }\n+\n+  /**\n+   * Submits {@link UndeleteOperation}(s) to this {@link UndeleteManager}.\n+   * @param blobIdStrs The original blobId strings\n+   * @param serviceId The service ID of the service undeleting the blob(s). This can be null if unknown.\n+   * @param futureResult The {@link FutureResult} that will contain the result eventually and exception if any.\n+   * @param callback The {@link Callback} that will be called on completion of the request.\n+   * @throws RouterException if the blobIdStr is invalid.\n+   */\n+  void submitUndeleteOperation(Collection<String> blobIdStrs, String serviceId, FutureResult<Void> futureResult,\n+      Callback<Void> callback) throws RouterException {\n+    List<BlobId> blobIds = new ArrayList<>();\n+    for (String blobIdStr : blobIdStrs) {\n+      BlobId blobId = RouterUtils.getBlobIdFromString(blobIdStr, clusterMap);\n+      if (blobId.getDatacenterId() != ClusterMapUtils.UNKNOWN_DATACENTER_ID\n+          && blobId.getDatacenterId() != clusterMap.getLocalDatacenterId()) {\n+        routerMetrics.undeleteBlobNotOriginateLocalOperationRate.mark();\n+      }\n+      blobIds.add(blobId);\n+    }\n+    if (blobIds.size() == 1) {\n+      UndeleteOperation undeleteOperation =\n+          new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobIds.get(0), serviceId, time.milliseconds(),\n+              callback, time, futureResult);\n+      undeleteOperations.add(undeleteOperation);\n+    } else {\n+      BatchOperationCallbackTracker tracker = new BatchOperationCallbackTracker(blobIds, futureResult, callback);\n+      long operationTimeMs = time.milliseconds();\n+      for (BlobId blobId : blobIds) {\n+        UndeleteOperation undeleteOperation =\n+            new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobId, serviceId, operationTimeMs,\n+                tracker.getCallback(blobId), time, BatchOperationCallbackTracker.DUMMY_FUTURE);\n+        undeleteOperations.add(undeleteOperation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Polls all undelete operations and populates a list of {@link RequestInfo} to be sent to data nodes in order to\n+   * complete undelete operations.\n+   * @param requestsToSend list to be filled with the requests created.\n+   * @param requestsToDrop list to be filled with the requests to drop.\n+   */\n+  void poll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop) {\n+    long startTime = time.milliseconds();\n+    requestRegistrationCallback.setRequestsToSend(requestsToSend);\n+    requestRegistrationCallback.setRequestsToDrop(requestsToDrop);\n+    for (UndeleteOperation op : undeleteOperations) {\n+      boolean exceptionEncountered = false;\n+      try {\n+        op.poll(requestRegistrationCallback);\n+      } catch (Exception e) {\n+        exceptionEncountered = true;\n+        op.setOperationException(new RouterException(\"Undelete poll encountered unexpected error\", e,\n+            RouterErrorCode.UnexpectedInternalError));\n+      }\n+      if (exceptionEncountered || op.isOperationComplete()) {\n+        if (undeleteOperations.remove(op)) {\n+          // In order to ensure that an operation is completed only once, call onComplete() only at the place where the\n+          // operation actually gets removed from the set of operations. See comment within close().\n+          onComplete(op);\n+        }\n+      }\n+    }\n+    routerMetrics.undeleteManagerPollTimeMs.update(time.milliseconds() - startTime);\n+  }\n+\n+  /**\n+   * Handles responses received for each of the {@link UndeleteOperation} within this UndeleteManager.\n+   * @param responseInfo the {@link ResponseInfo} containing the response.\n+   */\n+  void handleResponse(ResponseInfo responseInfo) {\n+    long startTime = time.milliseconds();\n+    UndeleteResponse undeleteResponse =\n+        RouterUtils.extractResponseAndNotifyResponseHandler(responseHandler, routerMetrics, responseInfo,\n+            UndeleteResponse::readFrom, UndeleteResponse::getError);\n+    RequestInfo routerRequestInfo = responseInfo.getRequestInfo();\n+    int correlationId = ((UndeleteRequest) routerRequestInfo.getRequest()).getCorrelationId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODgzMDU2", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396883056", "createdAt": "2020-04-20T23:25:35Z", "commit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b75acb470744e144990b1c3a62f908f6352e3e9f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/b75acb470744e144990b1c3a62f908f6352e3e9f", "committedDate": "2020-04-20T23:50:50Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTExODUy", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396911852", "createdAt": "2020-04-21T00:39:42Z", "commit": {"oid": "b75acb470744e144990b1c3a62f908f6352e3e9f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTE3OTY0", "url": "https://github.com/linkedin/ambry/pull/1467#pullrequestreview-396917964", "createdAt": "2020-04-21T00:59:44Z", "commit": {"oid": "b75acb470744e144990b1c3a62f908f6352e3e9f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1376, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}