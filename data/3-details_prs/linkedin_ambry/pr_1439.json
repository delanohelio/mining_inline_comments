{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODg1NDkx", "number": 1439, "title": "Support netty bytebuf in PutOperation", "bodyText": "This PR starts to support netty bytebuf in the PutOperation. There are some benefits out of it.\nWe don't have to copy the content from http channel to a java bytebuffer\nWe can avoid a memory allocation for java bytebuffer.", "createdAt": "2020-03-25T23:58:48Z", "url": "https://github.com/linkedin/ambry/pull/1439", "merged": true, "mergeCommit": {"oid": "53c147127c2ce2e76bda433f43805ff765759258"}, "closed": true, "closedAt": "2020-04-06T17:07:43Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRg71rgFqTM4MjMyMTI3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVB11gAFqTM4ODQ0OTcyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMzIxMjc0", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-382321274", "createdAt": "2020-03-26T18:55:46Z", "commit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1NTo0NlrOF8V2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1NTo0NlrOF8V2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNjgyNA==", "bodyText": "remove?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r398816824", "createdAt": "2020-03-26T18:55:46Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com.github.ambry.network/Selector.java", "diffHunk": "@@ -788,6 +788,7 @@ private NetworkSend write(SelectionKey key, Transmission transmission) {\n     } catch (IOException e) {\n       // We have key information if we log IOException here.\n       handleReadWriteIOException(e, key);\n+      //transmission.networkSend.getPayload().release();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODY0Nzg4", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-384864788", "createdAt": "2020-03-31T15:43:51Z", "commit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTo0Mzo1MlrOF-cNKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNjoyNDozMVrOF-d-0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxODE1NQ==", "bodyText": "not directly in the scope of this PR, but since you're making changes, could you make this inner class static along with DecryptJobResult.", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401018155", "createdAt": "2020-03-31T15:43:52Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java", "diffHunk": "@@ -103,25 +112,31 @@ public void closeJob(GeneralSecurityException gse) {\n    */\n   class EncryptJobResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAyMTc1OA==", "bodyText": "Could this just be buf.readBytes(dest) instead of iterating through the nio buffers?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401021758", "createdAt": "2020-03-31T15:48:40Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/test/java/com.github.ambry.router/ChunkFillTest.java", "diffHunk": "@@ -319,20 +319,20 @@ private void fillChunksAndAssertSuccess() throws Exception {\n   private void assertDataIdentity(ClusterMap clusterMap) throws IOException {\n     if (!testEncryption) {\n       ByteBuffer dest = ByteBuffer.allocate(totalSizeWritten);\n-      for (ByteBuffer buf : compositeBuffers) {\n+      for (ByteBuf buf : compositeBuffers) {\n         Assert.assertNotNull(\"All chunks should have come in\", buf);\n-        buf.flip();\n-        dest.put(buf);\n+        for (ByteBuffer buffer: buf.nioBuffers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTEwNw==", "bodyText": "why was the leak helper disabled for this test case?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401041107", "createdAt": "2020-03-31T16:15:41Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/test/java/com.github.ambry.router/NonBlockingRouterTest.java", "diffHunk": "@@ -411,6 +413,7 @@ public void testRouterNoPartitionInLocalDC() throws Exception {\n    */\n   @Test\n   public void testRequestResponseHandlerThreadExitFlow() throws Exception {\n+    nettyByteBufLeakHelper.setDisabled(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0NzI0OQ==", "bodyText": "nit: if less then -> is less than, than this -> then this", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401047249", "createdAt": "2020-03-31T16:24:31Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -562,9 +587,11 @@ void fillChunks() {\n         }\n       }\n       if (chunkFillingCompletedSuccessfully) {\n+        // If the blob size if less then 4MB or the last chunk size is less than 4MB, than this lastChunk will be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTc4Mjk4", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-384978298", "createdAt": "2020-03-31T18:03:43Z", "commit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowMzo0M1rOF-h06g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1Nzo1OFrOF-l6Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMDI1MA==", "bodyText": "there is an empty if condition here", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401110250", "createdAt": "2020-03-31T18:03:43Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -528,10 +551,12 @@ void fillChunks() {\n       PutChunk chunkToFill;\n       while (!isChunkFillingDone()) {\n         // Attempt to fill a chunk\n-        if (channelReadBuffer == null) {\n-          channelReadBuffer = chunkFillerChannel.getNextChunk(0);\n+        if (channelReadBuf == null) {\n+          channelReadBuf = chunkFillerChannel.getNextByteBuf(0);\n+          if (channelReadBuf != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyNjA4MQ==", "bodyText": "Could this be a lower log level? Or moved inside of the if (lastChunk != null) check so it only is printed if there was a chunk still being built?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401126081", "createdAt": "2020-03-31T18:30:22Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -575,10 +602,21 @@ void fillChunks() {\n           }\n         }\n       }\n+      if (operationCompleted) {\n+        logger.info(\"Clear unfinished chunk since operation is completed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MTI2MA==", "bodyText": "The clear() method does not seem like it was meant to be called from non-main threads. Is it necessary to do all of the cleanup or just call releaseBlobContent here and in fillChunks()?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401161260", "createdAt": "2020-03-31T19:29:06Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {\n+                  logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n+                  if (!isMetadataChunk()) {\n+                    releaseBlobContent();\n+                  }\n+                  encryptJobMetricsTracker.onJobResultProcessingStart();\n+                  if (exception == null && !isOperationComplete()) {\n+                    if (!isMetadataChunk()) {\n+                      buf = result.getEncryptedBlobContent();\n+                    }\n+                    encryptedPerBlobKey = result.getEncryptedKey();\n+                    chunkUserMetadata = result.getEncryptedUserMetadata().array();\n+                    logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n+                    prepareForSending();\n+                    chunkReadyAtMs = time.milliseconds();\n+                  } else {\n+                    encryptJobMetricsTracker.incrementOperationError();\n+                    if (!isOperationComplete()) {\n+                      logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n+                      // If we are here, then the result is null. no need to release it.\n+                      setOperationExceptionAndComplete(new RouterException(\n+                          \"Exception thrown on encrypting the content for chunk at index \" + chunkIndex, exception,\n+                          RouterErrorCode.UnexpectedInternalError));\n+                    } else {\n+                      logger.trace(\n+                          \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n+                          chunkIndex, getOperationException(), exception);\n+                      // If we are here, then the operation is completed and the exception could be null, in this case,\n+                      // we have to release the content in the result.\n+                      if (result != null) {\n+                        result.release();\n+                      }\n+                    }\n+                  }\n+                  routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n+                  encryptJobMetricsTracker.onJobResultProcessingComplete();\n+                  routerCallback.onPollReady();\n+                  // double check if the operation is not completed. If so, we have to release the buf here, since in\n+                  // main thread, chunk might already be released.\n+                  if (isOperationComplete()) {\n+                    logger.info(\"Clear put chunk in encryption callback since operation is completed\");\n+                    clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MzA0Mg==", "bodyText": "This lambda is quite long. Could you move it to a helper function. e.g. void onEncryptionComplete(EncryptJobResult, Exception)?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401163042", "createdAt": "2020-03-31T19:32:25Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTEzMw==", "bodyText": "It seems like this buffer is retained and then retained again with toEncrypt.retainedDuplicate() and then released at the end of this method. Could the retain from this line and release on 1204 be removed?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401165133", "createdAt": "2020-03-31T19:36:15Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1144,6 +1138,7 @@ private void prepareForSending() {\n      * Submits encrypt job for the given {@link PutChunk} and processes the callback for the same\n      */\n     private void encryptChunk() {\n+      ByteBuf toEncrypt = buf.retain();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODI4NA==", "bodyText": "for declaringtoWrite and remaininSlice you can remove the assignment part because of each of them are assigned by all the cases afterwards", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168284", "createdAt": "2020-03-31T19:42:03Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODM4OQ==", "bodyText": "size unused", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168389", "createdAt": "2020-03-31T19:42:16Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MTQzNw==", "bodyText": "The javadocs for CompositeByteBuf recommend using the alloc.compositeBuffer() methods if possible. Probably since the allocators seem to wrap the buffer with extra leak detection stuff (see AbstractByteBufAllocator). Also, the third param is the max number of child components in the buffer, not the max size in bytes. I guess it is still valuable to raise the limit since the default limit seems to be 16 from AbstractByteBufAllocator.\nThis can probably be composite = buf.isDirect()? buf.alloc().compositeDirectBuffer(maxComponents) : buf.alloc().compositeHeapBuffer(maxComponents) instead.", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401171437", "createdAt": "2020-03-31T19:47:56Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {\n+          // Buf is already a CompositeByteBuf, then just add the slice from\n+          ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n+        } else {\n+          CompositeByteBuf composite =\n+              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw==", "bodyText": "What if channelReadBuf was already a CompositeByteBuf? Would it be safer to just initialize the buffer in prepareForBuilding instead of use type checking logic here? The only thing that I think would be lost would be if the buffer came with a non-default allocator and the logic about direct vs not, but I don't think either of these will be used in practice unless the composite buffers capacity is expanded or components are squashed together inside.", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401177103", "createdAt": "2020-03-31T19:57:58Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9"}, "originalPosition": 427}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "committedDate": "2020-03-25T16:28:10Z", "message": "Comments"}, "afterCommit": {"oid": "7898d32775be9befbe576ff3fe427a21d04afb26", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/7898d32775be9befbe576ff3fe427a21d04afb26", "committedDate": "2020-04-01T20:30:20Z", "message": "Rebase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7898d32775be9befbe576ff3fe427a21d04afb26", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/7898d32775be9befbe576ff3fe427a21d04afb26", "committedDate": "2020-04-01T20:30:20Z", "message": "Rebase"}, "afterCommit": {"oid": "be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "committedDate": "2020-04-01T20:36:31Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NTYwMjc4", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-386560278", "createdAt": "2020-04-02T15:48:54Z", "commit": {"oid": "573eefe64025e2a6cc69c95eb02dd89b155b471f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2Njc4MzQ0", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-386678344", "createdAt": "2020-04-02T18:13:23Z", "commit": {"oid": "573eefe64025e2a6cc69c95eb02dd89b155b471f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoxMzoyNFrOF_3nIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoyNjo1M1rOF_4FZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTc0NQ==", "bodyText": "any reason to increase it?", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402515745", "createdAt": "2020-04-02T18:13:24Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java", "diffHunk": "@@ -71,7 +71,7 @@ public void close() {\n         }\n       }\n       try {\n-        scheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);\n+        scheduler.awaitTermination(10000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573eefe64025e2a6cc69c95eb02dd89b155b471f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA==", "bodyText": "Can you explain a little bit how fillFrom triggered?  I am not familiar with this area.\nFor 1 MB blob put, will it trigger fillFrom multiple times?\nMy concern here is if this will cause many small ByteBufs in buf.", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402523494", "createdAt": "2020-04-02T18:26:53Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "diffHunk": "@@ -1211,22 +1229,33 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite;\n+      if (buf == null) {\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        // buf already has some bytes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573eefe64025e2a6cc69c95eb02dd89b155b471f"}, "originalPosition": 413}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca1583e6dd81d1097a856553990b84b354114732", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/ca1583e6dd81d1097a856553990b84b354114732", "committedDate": "2020-04-03T23:02:41Z", "message": "Using Netty ByteByte in PutOperation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba16d5908141ec0955d17afbd5617dbab4ab6db", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/3ba16d5908141ec0955d17afbd5617dbab4ab6db", "committedDate": "2020-04-03T23:02:41Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1436919a5886e64d89587704ca0682c1e4e1a71f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/1436919a5886e64d89587704ca0682c1e4e1a71f", "committedDate": "2020-04-03T23:02:41Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "committedDate": "2020-04-03T23:02:41Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "800d95e84c472219464019dded7a628f5d7ca084", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/800d95e84c472219464019dded7a628f5d7ca084", "committedDate": "2020-04-03T23:02:41Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8081abee24fdbf49e321a60604957fb09f666b79", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/8081abee24fdbf49e321a60604957fb09f666b79", "committedDate": "2020-04-03T23:02:41Z", "message": "Another comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2897ff86eb5d41c300a7c539fd52eef00b0dd429", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/2897ff86eb5d41c300a7c539fd52eef00b0dd429", "committedDate": "2020-04-03T23:02:41Z", "message": "Fix test failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "committedDate": "2020-04-03T23:16:39Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e189cca5d65a0d91806fd7fc99970d403475e918", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e189cca5d65a0d91806fd7fc99970d403475e918", "committedDate": "2020-04-02T21:45:22Z", "message": "Fix test failure"}, "afterCommit": {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "committedDate": "2020-04-03T23:16:39Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDQ5NzI5", "url": "https://github.com/linkedin/ambry/pull/1439#pullrequestreview-388449729", "createdAt": "2020-04-06T17:07:12Z", "commit": {"oid": "cec396a216436b638079bd8c60fee71151eb19c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1328, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}