{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNDQ2MDgx", "number": 1562, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMzowMTo1OVrOEGi12w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoxMzowNVrOEG0fMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Mjk3NzU1OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMzowMTo1OVrOGlaKgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzowOTo0M1rOGl4mcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3OTE3MA==", "bodyText": "return the set of sealed partitions...", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r441879170", "createdAt": "2020-06-17T23:01:59Z", "author": {"login": "xuhao417347761"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "155ee6e5c8904434716a7ac48a37da940fd150d7"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3Nzg0MQ==", "bodyText": "fixed", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442377841", "createdAt": "2020-06-18T17:09:43Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3OTE3MA=="}, "originalCommit": {"oid": "155ee6e5c8904434716a7ac48a37da940fd150d7"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTg2ODY0OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoxMzowNVrOGl2gQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzowOTo1MVrOGl4m0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzQ5MA==", "bodyText": "replicasOnNode is a set of all replicas on a node, you may want to log the node id here.", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442343490", "createdAt": "2020-06-18T16:13:05Z", "author": {"login": "xuhao417347761"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.\n+   */\n+  private Set<String> getSealedPartitionsInHelixCluster() throws Exception {\n+    info(\"Aggregating sealed partitions from cluster {} in Helix\", clusterName);\n+    CountDownLatch sealedPartitionLatch = new CountDownLatch(adminForDc.size());\n+    AtomicInteger errorCount = new AtomicInteger();\n+    Map<String, Set<String>> dcToSealedPartitions = new ConcurrentHashMap<>();\n+    Map<String, Set<String>> nodeToNonExistentReplicas = new ConcurrentHashMap<>();\n+    for (Datacenter dc : staticClusterMap.hardwareLayout.getDatacenters()) {\n+      HelixAdmin admin = adminForDc.get(dc.getName());\n+      if (admin == null) {\n+        info(\"Skipping {}\", dc.getName());\n+        continue;\n+      }\n+      ensureOrThrow(zkClientForDc.get(dc.getName()) == null ? admin.getClusters().contains(clusterName)\n+              : ZKUtil.isClusterSetup(clusterName, zkClientForDc.get(dc.getName())),\n+          \"Cluster not found in ZK \" + dataCenterToZkAddress.get(dc.getName()));\n+      Utils.newThread(() -> {\n+        try {\n+          getSealedPartitionsInDc(dc, dcToSealedPartitions, nodeToNonExistentReplicas);\n+        } catch (Throwable t) {\n+          logger.error(\"[{}] error message: {}\", dc.getName().toUpperCase(), t.getMessage());\n+          errorCount.getAndIncrement();\n+        } finally {\n+          sealedPartitionLatch.countDown();\n+        }\n+      }, false).start();\n+    }\n+    sealedPartitionLatch.await(10, TimeUnit.MINUTES);\n+    ensureOrThrow(errorCount.get() == 0, \"Error occurred when aggregating sealed partitions in cluster \" + clusterName);\n+    Set<String> sealedPartitionsInCluster = new HashSet<>();\n+    info(\"========================= Summary =========================\");\n+    for (Map.Entry<String, Set<String>> entry : dcToSealedPartitions.entrySet()) {\n+      info(\"Dc {} has {} sealed partitions.\", entry.getKey(), entry.getValue().size());\n+      sealedPartitionsInCluster.addAll(entry.getValue());\n+    }\n+    info(\"========================= Sealed Partitions across All DCs =========================\");\n+    info(\"Total number of sealed partitions in cluster = {}\", sealedPartitionsInCluster.size());\n+    info(\"Sealed partitions are {}\", sealedPartitionsInCluster.toString());\n+    if (!nodeToNonExistentReplicas.isEmpty()) {\n+      info(\"Following {} nodes have sealed replica that are not actually present\", nodeToNonExistentReplicas.size());\n+      for (Map.Entry<String, Set<String>> entry : nodeToNonExistentReplicas.entrySet()) {\n+        info(\"{} has non-existent replicas: {}\", entry.getKey(), entry.getValue().toString());\n+      }\n+    }\n+    info(\"Successfully aggregate sealed from cluster {} in Helix\", clusterName);\n+    return sealedPartitionsInCluster;\n+  }\n+\n+  /**\n+   * Get sealed partitions from given datacenter.\n+   * @param dc the datacenter where sealed partitions come from.\n+   * @param dcToSealedPartitions a map to track sealed partitions in each dc. This entry associated with given dc will\n+   *                             be populated in this method.\n+   * @param nodeToNonExistentReplicas a map to track if any replica is in sealed list but not actually on local node.\n+   */\n+  private void getSealedPartitionsInDc(Datacenter dc, Map<String, Set<String>> dcToSealedPartitions,\n+      Map<String, Set<String>> nodeToNonExistentReplicas) {\n+    String dcName = dc.getName();\n+    dcToSealedPartitions.put(dcName, new HashSet<>());\n+    HelixAdmin admin = adminForDc.get(dcName);\n+    Set<String> allInstancesInHelix = new HashSet<>(admin.getInstancesInCluster(clusterName));\n+    for (DataNodeId dataNodeId : dc.getDataNodes()) {\n+      DataNode dataNode = (DataNode) dataNodeId;\n+      Set<String> replicasOnNode = staticClusterMap.getReplicas(dataNode)\n+          .stream()\n+          .map(replicaId -> replicaId.getPartitionId().toPathString())\n+          .collect(Collectors.toSet());\n+      String instanceName = getInstanceName(dataNode);\n+      ensureOrThrow(allInstancesInHelix.contains(instanceName), \"Instance not present in Helix \" + instanceName);\n+      InstanceConfig instanceConfig = admin.getInstanceConfig(clusterName, instanceName);\n+      List<String> sealedReplicas = instanceConfig.getRecord().getListField(ClusterMapUtils.SEALED_STR);\n+      if (sealedReplicas != null) {\n+        for (String sealedReplica : sealedReplicas) {\n+          info(\"Replica {} is sealed on {}\", sealedReplica, instanceName);\n+          dcToSealedPartitions.get(dcName).add(sealedReplica);\n+          if (!replicasOnNode.contains(sealedReplica)) {\n+            logger.warn(\"Replica {} is in sealed list but not on node {}\", sealedReplica, replicasOnNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "155ee6e5c8904434716a7ac48a37da940fd150d7"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3NzkzOA==", "bodyText": "Good catch, fixed", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442377938", "createdAt": "2020-06-18T17:09:51Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.\n+   */\n+  private Set<String> getSealedPartitionsInHelixCluster() throws Exception {\n+    info(\"Aggregating sealed partitions from cluster {} in Helix\", clusterName);\n+    CountDownLatch sealedPartitionLatch = new CountDownLatch(adminForDc.size());\n+    AtomicInteger errorCount = new AtomicInteger();\n+    Map<String, Set<String>> dcToSealedPartitions = new ConcurrentHashMap<>();\n+    Map<String, Set<String>> nodeToNonExistentReplicas = new ConcurrentHashMap<>();\n+    for (Datacenter dc : staticClusterMap.hardwareLayout.getDatacenters()) {\n+      HelixAdmin admin = adminForDc.get(dc.getName());\n+      if (admin == null) {\n+        info(\"Skipping {}\", dc.getName());\n+        continue;\n+      }\n+      ensureOrThrow(zkClientForDc.get(dc.getName()) == null ? admin.getClusters().contains(clusterName)\n+              : ZKUtil.isClusterSetup(clusterName, zkClientForDc.get(dc.getName())),\n+          \"Cluster not found in ZK \" + dataCenterToZkAddress.get(dc.getName()));\n+      Utils.newThread(() -> {\n+        try {\n+          getSealedPartitionsInDc(dc, dcToSealedPartitions, nodeToNonExistentReplicas);\n+        } catch (Throwable t) {\n+          logger.error(\"[{}] error message: {}\", dc.getName().toUpperCase(), t.getMessage());\n+          errorCount.getAndIncrement();\n+        } finally {\n+          sealedPartitionLatch.countDown();\n+        }\n+      }, false).start();\n+    }\n+    sealedPartitionLatch.await(10, TimeUnit.MINUTES);\n+    ensureOrThrow(errorCount.get() == 0, \"Error occurred when aggregating sealed partitions in cluster \" + clusterName);\n+    Set<String> sealedPartitionsInCluster = new HashSet<>();\n+    info(\"========================= Summary =========================\");\n+    for (Map.Entry<String, Set<String>> entry : dcToSealedPartitions.entrySet()) {\n+      info(\"Dc {} has {} sealed partitions.\", entry.getKey(), entry.getValue().size());\n+      sealedPartitionsInCluster.addAll(entry.getValue());\n+    }\n+    info(\"========================= Sealed Partitions across All DCs =========================\");\n+    info(\"Total number of sealed partitions in cluster = {}\", sealedPartitionsInCluster.size());\n+    info(\"Sealed partitions are {}\", sealedPartitionsInCluster.toString());\n+    if (!nodeToNonExistentReplicas.isEmpty()) {\n+      info(\"Following {} nodes have sealed replica that are not actually present\", nodeToNonExistentReplicas.size());\n+      for (Map.Entry<String, Set<String>> entry : nodeToNonExistentReplicas.entrySet()) {\n+        info(\"{} has non-existent replicas: {}\", entry.getKey(), entry.getValue().toString());\n+      }\n+    }\n+    info(\"Successfully aggregate sealed from cluster {} in Helix\", clusterName);\n+    return sealedPartitionsInCluster;\n+  }\n+\n+  /**\n+   * Get sealed partitions from given datacenter.\n+   * @param dc the datacenter where sealed partitions come from.\n+   * @param dcToSealedPartitions a map to track sealed partitions in each dc. This entry associated with given dc will\n+   *                             be populated in this method.\n+   * @param nodeToNonExistentReplicas a map to track if any replica is in sealed list but not actually on local node.\n+   */\n+  private void getSealedPartitionsInDc(Datacenter dc, Map<String, Set<String>> dcToSealedPartitions,\n+      Map<String, Set<String>> nodeToNonExistentReplicas) {\n+    String dcName = dc.getName();\n+    dcToSealedPartitions.put(dcName, new HashSet<>());\n+    HelixAdmin admin = adminForDc.get(dcName);\n+    Set<String> allInstancesInHelix = new HashSet<>(admin.getInstancesInCluster(clusterName));\n+    for (DataNodeId dataNodeId : dc.getDataNodes()) {\n+      DataNode dataNode = (DataNode) dataNodeId;\n+      Set<String> replicasOnNode = staticClusterMap.getReplicas(dataNode)\n+          .stream()\n+          .map(replicaId -> replicaId.getPartitionId().toPathString())\n+          .collect(Collectors.toSet());\n+      String instanceName = getInstanceName(dataNode);\n+      ensureOrThrow(allInstancesInHelix.contains(instanceName), \"Instance not present in Helix \" + instanceName);\n+      InstanceConfig instanceConfig = admin.getInstanceConfig(clusterName, instanceName);\n+      List<String> sealedReplicas = instanceConfig.getRecord().getListField(ClusterMapUtils.SEALED_STR);\n+      if (sealedReplicas != null) {\n+        for (String sealedReplica : sealedReplicas) {\n+          info(\"Replica {} is sealed on {}\", sealedReplica, instanceName);\n+          dcToSealedPartitions.get(dcName).add(sealedReplica);\n+          if (!replicasOnNode.contains(sealedReplica)) {\n+            logger.warn(\"Replica {} is in sealed list but not on node {}\", sealedReplica, replicasOnNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzQ5MA=="}, "originalCommit": {"oid": "155ee6e5c8904434716a7ac48a37da940fd150d7"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1268, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}