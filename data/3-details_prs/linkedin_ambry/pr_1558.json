{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTY3Njkx", "number": 1558, "title": "FindKey method takes FileSpan as the entire search space.", "bodyText": "Before this PR, findKey in PersistentIndex, uses FileSpan in a unorthodoxy way. It basically uses FileSpan as a way to locate index segments to search.\nFor instance, if we have three index segments, and their respective start offset and end offset are [0, 1000), [1000, 2000), [2000, 3000), then when we have a FileSpan whose start and end offset are [500, 2500], findKey would know that the all three index segments should be searched up, since the start offset is located within the first index segment and the end offset is located at the third segment.\nThe problem the actual record's offset is 2700, which is not covered in the FileSpan, but covered in the third segment, this record will be returned by findKey. In this case, FileSpan doesn't serve as a search space for findKey, but rather an pointer to find the index segments, which then would become search space.\nThis PR would fix this issue by changing findKey and strictly respect FileSpan as search space. It also has a few subtle changes.\n\nFileSpan's start offset is inclusive, but end offset would be exclusive.\nCompaction without undelete, would persist a cutoff offset to indicate if the delete is in effect. The cutoffset  used to be the start offset of the index segment, now it will be the end offset.", "createdAt": "2020-06-10T02:49:19Z", "url": "https://github.com/linkedin/ambry/pull/1558", "merged": true, "mergeCommit": {"oid": "ba5f1a20682e48b42eeedf6925c54309d1f54fe4"}, "closed": true, "closedAt": "2020-08-12T16:18:21Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpwvmqgFqTQyNzY3NTI1Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-N17BgFqTQ2NjA3MjM5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njc1MjU2", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-427675256", "createdAt": "2020-06-10T02:50:08Z", "commit": {"oid": "3384a9c2b50fc49a67df33856c7be12d4517b1f2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMjo1MDowOFrOGhjDNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMzowMzoyOFrOGhjQnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMDQ1NA==", "bodyText": "now that findKey treats filespan as the search space, we don't need to compare it again here.", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r437830454", "createdAt": "2020-06-10T02:50:08Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -577,8 +569,7 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n             IndexValue value = index.findKey(info.getStoreKey(), fileSpan,\n                 EnumSet.of(PersistentIndex.IndexEntryType.PUT, PersistentIndex.IndexEntryType.DELETE,\n                     PersistentIndex.IndexEntryType.UNDELETE));\n-            if (value != null && value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0) {\n-              // Make sure the value is actually after the indexEndOffsetBeforeCheck\n+            if (value != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3384a9c2b50fc49a67df33856c7be12d4517b1f2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMjgwNw==", "bodyText": "Use end offset instead of start offset. Since we now changed how findKey treats filespan, the start offset will not make findKey to \"include the whole index segment in the search\" anymore.\nThis offset is persisted in the disk while compaction cycle is not finished, which means we have to deal with the old offset if we deploy the new version of ambry-server. Luckily for us, even if we treat the old start offset as the new end offset, it will only ignore some PUT records in the current compaction. When the next compaction kicks off, it will compact those PUT records eventually.\nFor example, assume we have two three index segment [0, 1000), [1000, 2000), [2000, 3000) and the cutoff offset on disk is 1000. Before this PR, 1000 means when findKey searches keys, it will search in the first and second index segment. After this PR, findKey will only search within the first segment and ignore the second segment. If there are delete records in the second segment, it will not be searched. So some PUT records will not see delete records while compacting. But this is fine, since when the next compaction starts, it will now use the end offset of the second, and all the delete records in the second index segment will be seen by the compaction.", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r437832807", "createdAt": "2020-06-10T02:59:11Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreCompactor.java", "diffHunk": "@@ -1178,9 +1178,7 @@ private Offset getStartOffsetOfLastIndexSegmentForDeleteCheck() {\n         long referenceTimeMs = compactionLog.getCompactionDetails().getReferenceTimeMs();\n         for (IndexSegment indexSegment : srcIndex.getIndexSegments().descendingMap().values()) {\n           if (indexSegment.getLastModifiedTimeMs() < referenceTimeMs) {\n-            // NOTE: using start offset here because of the way FileSpan is treated in PersistentIndex.findKey().\n-            // using this as the end offset for delete includes the whole index segment in the search.\n-            cutoffOffset = indexSegment.getStartOffset();\n+            cutoffOffset = indexSegment.getEndOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bceabec3856344188548ef7d0cb2fd7f9c02232"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMjkwMQ==", "bodyText": "FileSpan is the search space now, if the space is empty, just return null.", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r437832901", "createdAt": "2020-06-10T02:59:35Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -575,6 +588,9 @@ IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> type\n    */\n   private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n       ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    if (fileSpan != null && fileSpan.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bceabec3856344188548ef7d0cb2fd7f9c02232"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMzg4NQ==", "bodyText": "End offset in FileSpan is exclusive so we don't have to include the end offset. Assuming we have several index segments and the map of indexSegments look like this (it's offset to index segment).\n{\n0       :index segment1\n1000 :index segment2\n2000 :index segment3\n3000 :index segment4\n}\nWhen the filespan is [500, 2000), then we should only search on index segment1 and index segment2. index segment 3's start offset is 2000, but 2000 in filespan is exclusive, we don't need it.", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r437833885", "createdAt": "2020-06-10T03:03:28Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -587,7 +603,7 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n         logger.trace(\"Searching for {} in index with filespan ranging from {} to {}\", key, fileSpan.getStartOffset(),\n             fileSpan.getEndOffset());\n         segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n-            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+            indexSegments.lowerKey(fileSpan.getEndOffset()), true).descendingMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bceabec3856344188548ef7d0cb2fd7f9c02232"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTU4NDI3", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-429958427", "createdAt": "2020-06-12T18:35:18Z", "commit": {"oid": "1af2b3f55e144408a6454bb2c59f59ef40481b62"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozNToxOFrOGjN_fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODozNToxOFrOGjN_fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjU5MQ==", "bodyText": "I looked at the callers of the this method, looks like they are still using [start, end] assumption. Any reason not change caller to [start, end+1)?", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r439582591", "createdAt": "2020-06-12T18:35:18Z", "author": {"login": "zzmao"}, "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -575,6 +588,9 @@ IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> type\n    */\n   private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1af2b3f55e144408a6454bb2c59f59ef40481b62"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1af2b3f55e144408a6454bb2c59f59ef40481b62", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/1af2b3f55e144408a6454bb2c59f59ef40481b62", "committedDate": "2020-06-10T03:04:14Z", "message": "Typo"}, "afterCommit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/cc0b66b243d66677c07054a9bd5ce8bca4e23136", "committedDate": "2020-06-14T04:41:30Z", "message": "More tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTY1OTI1", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-433565925", "createdAt": "2020-06-18T19:02:09Z", "commit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTowMjoxMFrOGl8YvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTowMjoxMFrOGl8YvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzOTg2OA==", "bodyText": "I feel like there shouldn't be issues here, but could you double check the queries that PersistentIndex.findEntriesSince() uses to make sure that the exclusive end offset is okay? I think those methods use getCurrentEndOffset which uses the end offset of the last index segment. Is IndexSegment.getEndOffset() inclusive or exclusive?", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r442439868", "createdAt": "2020-06-18T19:02:10Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/FileSpan.java", "diffHunk": "@@ -53,7 +54,14 @@ Offset getEndOffset() {\n    * @return {@code true} if {@code offset} is in this {@link FileSpan} (start and end offsets are considered inclusive)\n    */\n   boolean inSpan(Offset offset) {\n-    return offset.compareTo(startOffset) >= 0 && offset.compareTo(endOffset) <= 0;\n+    return offset.compareTo(startOffset) >= 0 && offset.compareTo(endOffset) < 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTI2ODY0", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-442126864", "createdAt": "2020-07-03T03:34:51Z", "commit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwMzozNDo1MVrOGsit-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNDowNjozNFrOGsjFQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM1OTM1Mw==", "bodyText": "minor: has to follow ...", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r449359353", "createdAt": "2020-07-03T03:34:51Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -574,16 +566,24 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n           FileSpan fileSpan = new FileSpan(indexEndOffsetBeforeCheck, currentIndexEndOffset);\n           int i = 0;\n           for (MessageInfo info : infosToDelete) {\n-            IndexValue value = index.findKey(info.getStoreKey(), fileSpan,\n-                EnumSet.of(PersistentIndex.IndexEntryType.PUT, PersistentIndex.IndexEntryType.DELETE,\n-                    PersistentIndex.IndexEntryType.UNDELETE));\n-            if (value != null && value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0) {\n-              // Make sure the value is actually after the indexEndOffsetBeforeCheck\n-              if (value.isDelete() && value.getLifeVersion() == lifeVersions.get(i)) {\n-                throw new StoreException(\n-                    \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-                    StoreErrorCodes.ID_Deleted);\n+            IndexValue value =\n+                index.findKey(info.getStoreKey(), fileSpan, EnumSet.allOf(PersistentIndex.IndexEntryType.class));\n+            if (value != null) {\n+              // There are several possible cases that can exist here. Delete has be follow either PUT, TTL_UPDATE or UNDELETE.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2NTMxNA==", "bodyText": "I need a little clarification of this if-else block. The if branch makes sense to me but for the else branch, what if the value.isDelete() == true,  it seems to throw exception directly.  Actually this might be a valid case.\n(Correct me if I am wrong and let me know anything I missed here)", "url": "https://github.com/linkedin/ambry/pull/1558#discussion_r449365314", "createdAt": "2020-07-03T04:06:34Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -801,8 +803,7 @@ public short undelete(MessageInfo info) throws StoreException {\n           FileSpan fileSpan = new FileSpan(indexEndOffsetBeforeCheck, currentIndexEndOffset);\n           IndexValue value = index.findKey(info.getStoreKey(), fileSpan,\n               EnumSet.of(PersistentIndex.IndexEntryType.DELETE, PersistentIndex.IndexEntryType.UNDELETE));\n-          if (value != null && value.getOffset().compareTo(indexEndOffsetBeforeCheck) >= 0) {\n-            // Make sure the value is actually after the indexEndOffsetBeforeCheck\n+          if (value != null) {\n             if (value.isUndelete() && value.getLifeVersion() == revisedLifeVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc0b66b243d66677c07054a9bd5ce8bca4e23136", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/cc0b66b243d66677c07054a9bd5ce8bca4e23136", "committedDate": "2020-06-14T04:41:30Z", "message": "More tests"}, "afterCommit": {"oid": "4e310aab44b9cfbb202a334b9e1fb695e06d1558", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/4e310aab44b9cfbb202a334b9e1fb695e06d1558", "committedDate": "2020-07-23T23:00:44Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjg5ODY4", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-460289868", "createdAt": "2020-08-03T19:36:50Z", "commit": {"oid": "4e310aab44b9cfbb202a334b9e1fb695e06d1558"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50917d097902859c0399d244ed31bdb62e21e7c3", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/50917d097902859c0399d244ed31bdb62e21e7c3", "committedDate": "2020-08-06T19:53:43Z", "message": "FindKey method takes FileSpan as the entire search space."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "374e7ac0d4a1a4540fda8ef9bcde7dd312c89555", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/374e7ac0d4a1a4540fda8ef9bcde7dd312c89555", "committedDate": "2020-08-06T19:53:43Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b484d7aa752bdd0d055e4fed61e4d84f43f0d558", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/b484d7aa752bdd0d055e4fed61e4d84f43f0d558", "committedDate": "2020-08-06T19:53:43Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccc75ca507783b2bba0b1eb879d5be00ab903cd7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/ccc75ca507783b2bba0b1eb879d5be00ab903cd7", "committedDate": "2020-08-06T19:53:43Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c9c68b964bdecbb810cd8cdf4e439c345b36991", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/9c9c68b964bdecbb810cd8cdf4e439c345b36991", "committedDate": "2020-08-06T19:53:43Z", "message": "Comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e310aab44b9cfbb202a334b9e1fb695e06d1558", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/4e310aab44b9cfbb202a334b9e1fb695e06d1558", "committedDate": "2020-07-23T23:00:44Z", "message": "Comments"}, "afterCommit": {"oid": "9c9c68b964bdecbb810cd8cdf4e439c345b36991", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/9c9c68b964bdecbb810cd8cdf4e439c345b36991", "committedDate": "2020-08-06T19:53:43Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MDcyMzky", "url": "https://github.com/linkedin/ambry/pull/1558#pullrequestreview-466072392", "createdAt": "2020-08-12T16:17:03Z", "commit": {"oid": "9c9c68b964bdecbb810cd8cdf4e439c345b36991"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1122, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}