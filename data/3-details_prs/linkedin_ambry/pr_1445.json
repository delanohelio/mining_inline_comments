{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTQzNTky", "number": 1445, "title": "Add support for cloud replicas to OperationTracker", "bodyText": "CLOUD_BACKED replicas differ from DISK_BACKED replicas in that they\nonly require one succesful response to deem the operation a success.\nThe changes in this commit tune the success target and parallelism based\non the type of replica requests are sent to. For DISK_BACKED replicas,\nthe policies remain the same, but for CLOUD_BACKED replicas, one\nsuccessful response will complete the operation. Additionally, only one\nrequest will be sent by SimpleOperationTracker at a time when a cloud\nrequest is in flight (since this one request would be able to\nsuccessfully complete the operation).\nNote to reviewers, this PR branch branches from #1440, so you can ignore the\nfirst commit, \"Integrate CompositeNetworkClient with CloudRouterFactory\",\nwhen reviewing this change.", "createdAt": "2020-03-28T19:36:46Z", "url": "https://github.com/linkedin/ambry/pull/1445", "merged": true, "mergeCommit": {"oid": "5c14efaf32c4b2c249d9aab29bac82b19d504f49"}, "closed": true, "closedAt": "2020-04-02T21:23:51Z", "author": {"login": "cgtz"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcS3NaigFqTM4NDMwNTcyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTzGbCgFqTM4Njc4NjM4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzA1NzI0", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-384305724", "createdAt": "2020-03-30T23:36:09Z", "commit": {"oid": "a695a482cbfe2d653b3050f28d450d280d3a2aad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzozNjowOVrOF-AEjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzozNjowOVrOF-AEjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzE5Nw==", "bodyText": "Do we need to keep different inflightCount for diskReplica and cloudReplica separately? If inflightCount already contains request cloudReplica and we compare this number to parallelism of diskReplica might be wrong. Let's say diskReplica's parallelism is 3 and now there are 2 inflight diskReplica and 1 inflight cloudReplica, then hasNext may return false. However, the actual number of inflight diskReplica is less than parallelism of disk replica.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400557197", "createdAt": "2020-03-30T23:36:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -323,12 +352,13 @@ public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequ\n   private class OpTrackerIterator implements Iterator<ReplicaId> {\n     @Override\n     public boolean hasNext() {\n-      return inflightCount < parallelism && replicaIterator.hasNext();\n+      return inflightCount < getCurrentParallelism() && replicaIterator.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a695a482cbfe2d653b3050f28d450d280d3a2aad"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzExNTc3", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-384311577", "createdAt": "2020-03-30T23:52:18Z", "commit": {"oid": "a695a482cbfe2d653b3050f28d450d280d3a2aad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzo1MjoxOFrOF-AYPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzo1MjoxOFrOF-AYPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MjIzNw==", "bodyText": "Sorry, I am not sure if I wrote the comments, but this can be applied to GET as well", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400562237", "createdAt": "2020-03-30T23:52:18Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -66,27 +69,32 @@\n class SimpleOperationTracker implements OperationTracker {\n   protected final String datacenterName;\n   protected final String originatingDcName;\n-  protected final int successTarget;\n-  protected final int parallelism;\n+  protected final int diskSuccessTarget;\n+  protected final int diskParallelism;\n+  protected final int cloudSuccessTarget;\n+  protected final int cloudParallelism;\n+  protected final boolean cloudReplicasPresent;\n+  // How many NotFound responses from originating dc will terminate the operation.\n+  // It's decided by the success target of each mutation operations, including put, delete, update ttl etc.\n+  protected final int originatingDcNotFoundFailureThreshold;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a695a482cbfe2d653b3050f28d450d280d3a2aad"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e9b65efbc36e1e28b986213a86a83975274734e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/6e9b65efbc36e1e28b986213a86a83975274734e", "committedDate": "2020-03-30T20:58:30Z", "message": "Some unit test cases"}, "afterCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/161788d6547b3f3965ea99cce073786bffee2fc0", "committedDate": "2020-03-31T00:19:25Z", "message": "Some unit test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0Mzc2MDAw", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-384376000", "createdAt": "2020-03-31T03:18:42Z", "commit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMzoxODo0MlrOF-D2Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwNDoyNjo1NlrOF-E3fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTA1NA==", "bodyText": "Curious why this is max and not sum.  Is it not possible to have inflight disk and cloud requests at the same time?\nIf the logic is correct, then suggest breaking this into two checks so the error message can specify which one is out of bounds.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400619054", "createdAt": "2020-03-31T03:18:42Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com.github.ambry.router/AdaptiveOperationTracker.java", "diffHunk": "@@ -83,7 +81,7 @@\n       localDcResourceToHistogram = getResourceToLatencyMap(routerOperation, true);\n       crossDcResourceToHistogram = getResourceToLatencyMap(routerOperation, false);\n     }\n-    if (parallelism > routerConfig.routerOperationTrackerMaxInflightRequests) {\n+    if (Math.max(diskParallelism, cloudParallelism) > routerConfig.routerOperationTrackerMaxInflightRequests) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyNTUzMw==", "bodyText": "Minor: can collapse to single line.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400625533", "createdAt": "2020-03-31T03:44:28Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -357,20 +388,40 @@ public ReplicaId next() {\n \n   private boolean hasFailed() {\n     boolean hasFailed;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n       hasFailed = totalReplicaCount - failedCount < Math.max(totalReplicaCount - 1,\n           routerConfig.routerPutSuccessTarget + disabledCount);\n     } else {\n-      hasFailed = (totalReplicaCount - failedCount) < successTarget || hasFailedOnNotFound();\n+      // if one type of replica has a lower success target, we can only call it a complete failure when there are fewer\n+      // than that target left to check. This could be optimized by saving the replica type of the remaining replicas\n+      // to try and choosing the success target based on their type.\n+      int minSuccessTarget = cloudReplicasPresent ? Math.min(diskSuccessTarget, cloudSuccessTarget) : diskSuccessTarget;\n+      hasFailed = (totalReplicaCount - failedCount) < minSuccessTarget || hasFailedOnNotFound();\n     }\n     return hasFailed;\n   }\n \n   /**\n-   * @return the success target number of this operation tracker.\n+   * @param replicaType the {@link ReplicaType}\n+   * @return the success target number of this operation tracker for the provided replica type.\n+   */\n+  int getSuccessTarget(ReplicaType replicaType) {\n+    if (replicaType == ReplicaType.CLOUD_BACKED) {\n+      return cloudSuccessTarget;\n+    } else {\n+      return diskSuccessTarget;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg==", "bodyText": "I'm having trouble following this logic.  Assuming there is a cloud replica present, totalReplicaCount = 13, minSuccessTarget will be 1, in which case failedCount has to equal totalReplicaCount to declare failure.  But if the cloud replica has failed, we will still require diskSuccessTarget successes among disk replicas - assume that is 2.  Then the most failures we can tolerate is 11 (10 disk + 1 cloud).  With failedCount = 12, hasFailed = (13-12 < 1) will be false but should be true, no?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400632016", "createdAt": "2020-03-31T04:10:44Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -357,20 +388,40 @@ public ReplicaId next() {\n \n   private boolean hasFailed() {\n     boolean hasFailed;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n       hasFailed = totalReplicaCount - failedCount < Math.max(totalReplicaCount - 1,\n           routerConfig.routerPutSuccessTarget + disabledCount);\n     } else {\n-      hasFailed = (totalReplicaCount - failedCount) < successTarget || hasFailedOnNotFound();\n+      // if one type of replica has a lower success target, we can only call it a complete failure when there are fewer\n+      // than that target left to check. This could be optimized by saving the replica type of the remaining replicas\n+      // to try and choosing the success target based on their type.\n+      int minSuccessTarget = cloudReplicasPresent ? Math.min(diskSuccessTarget, cloudSuccessTarget) : diskSuccessTarget;\n+      hasFailed = (totalReplicaCount - failedCount) < minSuccessTarget || hasFailedOnNotFound();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjkzMQ==", "bodyText": "This logic looks correct.  I'm not convinced about the hasFailed logic, seems like that needs to use a similar OR condition.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400632931", "createdAt": "2020-03-31T04:14:42Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -261,11 +284,13 @@\n   @Override\n   public boolean hasSucceeded() {\n     boolean hasSucceeded;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n-      hasSucceeded =\n-          succeededCount >= Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n+      // this logic only applies to disk replicas where the quorum can change during replica movement\n+      int dynamicSuccessTarget = Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+      hasSucceeded = diskSucceededCount >= dynamicSuccessTarget;\n     } else {\n-      hasSucceeded = succeededCount >= successTarget;\n+      hasSucceeded = diskSucceededCount >= diskSuccessTarget || cloudSucceededCount >= cloudSuccessTarget;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNDg0Mw==", "bodyText": "Since both of these test cases succeed, shouldn't we also have one that fails?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400634843", "createdAt": "2020-03-31T04:22:59Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/test/java/com.github.ambry.router/OperationTrackerTest.java", "diffHunk": "@@ -923,11 +925,59 @@ public void operationClassTest() {\n       // ensure the success target matches the number specified for each type of operaiton\n       if (operationTracker != null) {\n         assertEquals(\"The suggest target doesn't match\", (long) entry.getValue(),\n-            (operationTracker).getSuccessTarget());\n+            operationTracker.getSuccessTarget(ReplicaType.DISK_BACKED));\n       }\n     }\n   }\n \n+  /**\n+   * Test cases with cloud replicas in the local datacenter.\n+   */\n+  @Test\n+  public void cloudReplicaInLocalDcTest() {\n+    // test success in cloud dc\n+    initializeWithCloudDcs(true);\n+    originatingDcName = getDatacenters(ReplicaType.DISK_BACKED).iterator().next();\n+    OperationTracker ot =\n+        getOperationTracker(true, 2, 3, false, Integer.MAX_VALUE, RouterOperation.GetBlobOperation, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    // parallelism of 1 for cloud replicas, so only one request should be sent\n+    sendRequests(ot, 1, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.SUCCESS);\n+    // success target of 1 with cloud replicas.\n+    assertTrue(\"Operation should have succeeded\", ot.hasSucceeded());\n+    assertTrue(\"Operation should be done\", ot.isDone());\n+  }\n+\n+  /**\n+   * Test cases with cloud replicas in the remote datacenter.\n+   */\n+  @Test\n+  public void cloudReplicaInRemoteDcTest() {\n+    // test failure in disk dc with fallback to cloud DC\n+    initializeWithCloudDcs(false);\n+    originatingDcName = getDatacenters(ReplicaType.CLOUD_BACKED).iterator().next();\n+    OperationTracker ot =\n+        getOperationTracker(true, 2, 3, false, Integer.MAX_VALUE, RouterOperation.GetBlobOperation, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    // parallelism of 3 for disk replicas (local dc).\n+    sendRequests(ot, 3, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.FAILURE);\n+    // one response frees up a spot to send a cloud request\n+    sendRequests(ot, 1, false);\n+    for (int i = 0; i < 2; i++) {\n+      ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.FAILURE);\n+      // parallelism should have changed to 1 after cloud request was sent\n+      sendRequests(ot, 0, false);\n+    }\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.SUCCESS);\n+    assertTrue(\"Operation should have succeeded\", ot.hasSucceeded());\n+    assertTrue(\"Operation should be done\", ot.isDone());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNTc3Mg==", "bodyText": "Should compare to replicaType, no?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400635772", "createdAt": "2020-03-31T04:26:56Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/test/java/com.github.ambry.router/OperationTrackerTest.java", "diffHunk": "@@ -944,19 +994,64 @@ private void initialize() {\n     mockClusterMap = new MockClusterMap(false, datanodes, 1, Collections.singletonList(mockPartition), localDcName);\n   }\n \n+  /**\n+   * Initialize 4 DCs, 2 disk datacenters, 2 cloud datacenters. Each disk datacenter has 3 replicas, and each cloud\n+   * datacenter has 1 replica.\n+   * @param makeCloudDcLocal {@code true} to make the local datacenter one of the cloud datacenters.\n+   */\n+  private void initializeWithCloudDcs(boolean makeCloudDcLocal) {\n+    List<Port> portList = Collections.singletonList(new Port(PORT, PortType.PLAINTEXT));\n+    List<String> mountPaths = Collections.singletonList(\"mockMountPath\");\n+    mockPartition = new MockPartitionId();\n+    List<MockDataNodeId> diskNodes = Arrays.asList(new MockDataNodeId(portList, mountPaths, \"dc-0\"),\n+        new MockDataNodeId(portList, mountPaths, \"dc-1\"));\n+    populateReplicaList(3 * diskNodes.size(), ReplicaState.STANDBY, diskNodes);\n+    List<MockDataNodeId> cloudNodes = Arrays.asList(new MockDataNodeId(portList, Collections.emptyList(), \"cloud-dc-0\"),\n+        new MockDataNodeId(portList, Collections.emptyList(), \"cloud-dc-1\"));\n+    // only one cloud replica per cloud dc.\n+    populateReplicaList(cloudNodes.size(), ReplicaState.STANDBY, cloudNodes);\n+    datanodes = new ArrayList<>();\n+    datanodes.addAll(diskNodes);\n+    datanodes.addAll(cloudNodes);\n+    localDcName = (makeCloudDcLocal ? cloudNodes : diskNodes).get(0).getDatacenterName();\n+    mockClusterMap = new MockClusterMap(false, datanodes, 1, Collections.singletonList(mockPartition), localDcName);\n+  }\n+\n   /**\n    * Populate replicas for a partition.\n    * @param replicaCount The number of replicas to populate.\n    * @param replicaState The {@link ReplicaState} associated with these replicas.\n    */\n   private void populateReplicaList(int replicaCount, ReplicaState replicaState) {\n+    populateReplicaList(replicaCount, replicaState, datanodes);\n+  }\n+\n+  /**\n+   * Populate replicas for a partition.\n+   * @param replicaCount The number of replicas to populate.\n+   * @param replicaState The {@link ReplicaState} associated with these replicas.\n+   * @param datanodes the datanodes to populate with replicas\n+   */\n+  private void populateReplicaList(int replicaCount, ReplicaState replicaState, List<MockDataNodeId> datanodes) {\n     for (int i = 0; i < replicaCount; i++) {\n       ReplicaId replicaId = new MockReplicaId(PORT, mockPartition, datanodes.get(i % datanodes.size()), 0);\n       mockPartition.replicaIds.add(replicaId);\n       mockPartition.replicaAndState.put(replicaId, replicaState);\n     }\n   }\n \n+  /**\n+   * @param replicaType the type of replica to filter by.\n+   * @return the datacenter names with replicas of type {@code replicaType}.\n+   */\n+  private Set<String> getDatacenters(ReplicaType replicaType) {\n+    return mockPartition.getReplicaIds()\n+        .stream()\n+        .filter(r -> r.getReplicaType() == ReplicaType.CLOUD_BACKED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MDg5NDcy", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-385089472", "createdAt": "2020-03-31T20:43:16Z", "commit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDo0MzoxNlrOF-nevw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMToyNTozMFrOF-o0Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMjg3OQ==", "bodyText": "To make it compatible, let's add similar check in StaticClusterManager.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401202879", "createdAt": "2020-03-31T20:43:16Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixClusterManager.java", "diffHunk": "@@ -316,10 +316,14 @@ public void onReplicaEvent(ReplicaId replicaId, ReplicaEventType event) {\n         replica.getDataNodeId().onNodeTimeout();\n         break;\n       case Disk_Error:\n-        replica.getDiskId().onDiskError();\n+        if (replica.getReplicaType() == ReplicaType.DISK_BACKED) {\n+          replica.getDiskId().onDiskError();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNjIwNA==", "bodyText": "nit: can import ClusterMapSnapshotConstants in a static way.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401206204", "createdAt": "2020-03-31T20:49:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java", "diffHunk": "@@ -62,7 +63,7 @@\n public class CloudToStoreReplicationManagerTest {\n   private static final String NEW_PARTITION_NAME = \"12\";\n   private static final String CLOUD_DC_NAME = \"CloudDc\";\n-  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n+  private static final String VCR_MOUNT_PATH = ClusterMapSnapshotConstants.CLOUD_REPLICA_MOUNT + \"/1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwOTA1OA==", "bodyText": "nit: rename these two variables to isLocalDcReplica, isOriginatingDcReplica", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401209058", "createdAt": "2020-03-31T20:54:32Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -191,19 +202,21 @@\n     for (ReplicaId replicaId : replicas) {\n       examinedReplicas.add(replicaId);\n       String replicaDcName = replicaId.getDataNodeId().getDatacenterName();\n-      if (replicaDcName.equals(originatingDcName)) {\n+      boolean localDcReplica = replicaDcName.equals(datacenterName);\n+      boolean originatingDcReplica = replicaDcName.equals(originatingDcName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMjA2OQ==", "bodyText": "I think this check also applies to cloudParallelism.\nAlso, could you add additional info in the exception message to record operation type? (so far, only PUT operation has dynamic parallelism but it's still good to add type into error message)", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401212069", "createdAt": "2020-03-31T21:00:00Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -143,32 +154,32 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        successTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n             routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        parallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n+        crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        successTarget = routerConfig.routerDeleteSuccessTarget;\n-        parallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        successTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        parallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (parallelism < 1) {\n-      throw new IllegalArgumentException(\"Parallelism has to be > 0. Configured to be \" + parallelism);\n+    if (diskParallelism < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw==", "bodyText": "If I remember correctly, we are supposed to try replicas in local dc first, then replica in linkedin dcs, and then cloud replica. So this logic has changed?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401221133", "createdAt": "2020-03-31T21:18:02Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -227,22 +240,32 @@\n         replicaPool.add(downReplicas.pollFirst());\n       }\n     }\n+    cloudReplicasPresent =\n+        replicaPool.stream().map(ReplicaId::getReplicaType).anyMatch(Predicate.isEqual(ReplicaType.CLOUD_BACKED));\n     totalReplicaCount = replicaPool.size();\n-    if (totalReplicaCount < successTarget) {\n-      // {@link MockPartitionId#getReplicaIds} is returning a shared reference which may cause race condition.\n-      // Please report the test failure if you run into this exception.\n-      throw new IllegalArgumentException(\n-          generateErrorMessage(partitionId, examinedReplicas, replicaPool, backupReplicasToCheck, downReplicasToCheck));\n+\n+    // MockPartitionId.getReplicaIds() is returning a shared reference which may cause race condition.\n+    // Please report the test failure if you run into this exception.\n+    Supplier<IllegalArgumentException> notEnoughReplicasException = () -> new IllegalArgumentException(\n+        generateErrorMessage(partitionId, examinedReplicas, replicaPool, backupReplicasToCheck, downReplicasToCheck));\n+    // initialize this to the replica type of the first request to send so that parallelism is set correctly for the\n+    // first request\n+    inFlightReplicaType =\n+        replicaPool.stream().findFirst().map(ReplicaId::getReplicaType).orElseThrow(notEnoughReplicasException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMjgxNA==", "bodyText": "If routerGetEligibleReplicasByStateEnabled is true, the replicaPool won't include cloudReplica. Do we need to explicitly add it into pool?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401222814", "createdAt": "2020-03-31T21:21:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -227,22 +240,32 @@\n         replicaPool.add(downReplicas.pollFirst());\n       }\n     }\n+    cloudReplicasPresent =\n+        replicaPool.stream().map(ReplicaId::getReplicaType).anyMatch(Predicate.isEqual(ReplicaType.CLOUD_BACKED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNDc3NA==", "bodyText": "I would suggest renaming these variables to something like  diskReplicaSuccessCount to distinguish it from diskDownCount more easily.", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401224774", "createdAt": "2020-03-31T21:25:30Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -66,27 +69,32 @@\n class SimpleOperationTracker implements OperationTracker {\n   protected final String datacenterName;\n   protected final String originatingDcName;\n-  protected final int successTarget;\n-  protected final int parallelism;\n+  protected final int diskSuccessTarget;\n+  protected final int diskParallelism;\n+  protected final int cloudSuccessTarget;\n+  protected final int cloudParallelism;\n+  protected final boolean cloudReplicasPresent;\n+  // How many NotFound responses from originating dc will terminate the operation.\n+  // It's decided by the success target of each mutation operations, including put, delete, update ttl etc.\n+  protected final int originatingDcNotFoundFailureThreshold;\n+  protected final int totalReplicaCount;\n   protected final LinkedList<ReplicaId> replicaPool = new LinkedList<>();\n \n-  protected int totalReplicaCount = 0;\n   protected int inflightCount = 0;\n-  protected int succeededCount = 0;\n+  protected int diskSucceededCount = 0;\n+  protected int cloudSucceededCount = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/161788d6547b3f3965ea99cce073786bffee2fc0", "committedDate": "2020-03-31T00:19:25Z", "message": "Some unit test cases"}, "afterCommit": {"oid": "f79b617a171fd76922ac7b1e6ca9b0fe8b0806b9", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/f79b617a171fd76922ac7b1e6ca9b0fe8b0806b9", "committedDate": "2020-04-01T16:11:30Z", "message": "Address some comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bf658eeeda5b5c41df2f2e72c710e2bbb8eb3f9", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/3bf658eeeda5b5c41df2f2e72c710e2bbb8eb3f9", "committedDate": "2020-04-02T07:34:51Z", "message": "Add support for cloud replicas to OperationTracker\n\nCLOUD_BACKED replicas differ from DISK_BACKED replicas in that they\nonly require one succesful response to deem the operation a success.\nThe changes in this commit tune the success target and parallelism based\non the type of replica requests are sent to. For DISK_BACKED replicas,\nthe policies remain the same, but for CLOUD_BACKED replicas, one\nsuccessful response will complete the operation. Additionally, only one\nrequest will be sent by SimpleOperationTracker at a time when a cloud\nrequest is in flight (since this one request would be able to\nsuccessfully complete the operation)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61c9f4410636b305b58f4f3c8bb27af372514b49", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/61c9f4410636b305b58f4f3c8bb27af372514b49", "committedDate": "2020-04-02T07:34:51Z", "message": "Some unit test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a113b8c025785616baf8ffc32d08956996e2125d", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/a113b8c025785616baf8ffc32d08956996e2125d", "committedDate": "2020-04-02T07:34:51Z", "message": "Address some comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89ea14d558698c35445c4496b977fa4a6d45e572", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/89ea14d558698c35445c4496b977fa4a6d45e572", "committedDate": "2020-04-02T07:34:51Z", "message": "Fix test case issue with spaces in MockReplicaId.toString()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ba5b1e1e1ec42a201323d5e29f0ebc4b491b400", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/9ba5b1e1e1ec42a201323d5e29f0ebc4b491b400", "committedDate": "2020-04-02T07:34:51Z", "message": "Revert MockReplicaId.toString() changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "committedDate": "2020-04-02T07:34:51Z", "message": "Address remaining comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c4d22a00094576c687b031dff2a6e4b0954c4f3", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/3c4d22a00094576c687b031dff2a6e4b0954c4f3", "committedDate": "2020-04-01T19:13:50Z", "message": "Revert MockReplicaId.toString() changes"}, "afterCommit": {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "committedDate": "2020-04-02T07:34:51Z", "message": "Address remaining comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NjM3NjEw", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-386637610", "createdAt": "2020-04-02T17:22:39Z", "commit": {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoyMjozOVrOF_1h4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoyMjozOVrOF_1h4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MTYzMw==", "bodyText": "minor: numReplicasInLocalDc is updated but never accessed. Consider removing it?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402481633", "createdAt": "2020-04-02T17:22:39Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -191,19 +207,24 @@\n     for (ReplicaId replicaId : replicas) {\n       examinedReplicas.add(replicaId);\n       String replicaDcName = replicaId.getDataNodeId().getDatacenterName();\n-      if (replicaDcName.equals(originatingDcName)) {\n+      boolean isLocalDcReplica = replicaDcName.equals(datacenterName);\n+      boolean isOriginatingDcReplica = replicaDcName.equals(originatingDcName);\n+      if (isLocalDcReplica) {\n+        numReplicasInLocalDc++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NjQxMDk3", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-386641097", "createdAt": "2020-04-02T17:27:05Z", "commit": {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e", "committedDate": "2020-04-02T17:29:34Z", "message": "Remove unused variable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NzgyNDk3", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-386782497", "createdAt": "2020-04-02T21:16:40Z", "commit": {"oid": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToxNjo0MFrOF_8z_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToxNjo0MFrOF_8z_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMDk1OA==", "bodyText": "Is there still a TODO here?", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402600958", "createdAt": "2020-04-02T21:16:40Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -261,21 +288,32 @@\n   @Override\n   public boolean hasSucceeded() {\n     boolean hasSucceeded;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n-      hasSucceeded =\n-          succeededCount >= Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n+      // this logic only applies to disk replicas where the quorum can change during replica movement\n+      int dynamicSuccessTarget = Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+      hasSucceeded = diskReplicaSuccessCount >= dynamicSuccessTarget;\n     } else {\n-      hasSucceeded = succeededCount >= successTarget;\n+      hasSucceeded = diskReplicaSuccessCount >= diskSuccessTarget || cloudReplicaSuccessCount >= cloudSuccessTarget;\n     }\n     return hasSucceeded;\n   }\n \n   @Override\n   public boolean hasFailedOnNotFound() {\n-    return (originatingDcNotFoundFailureThreshold > 0\n-        && originatingDcNotFoundCount >= originatingDcNotFoundFailureThreshold) || (crossColoEnabled\n-        && diskDownCount + totalNotFoundCount > totalReplicaCount - successTarget);\n+    if (routerOperation == RouterOperation.PutOperation) {\n+      return false;\n+    }\n+    if (originatingDcNotFoundFailureThreshold > 0\n+        && originatingDcNotFoundCount >= originatingDcNotFoundFailureThreshold) {\n+      return true;\n+    }\n     // To account for GET operation, the threshold should be  >= totalReplicaCount - (success target - 1)\n+    // Right now, this only applies for disk replica only partitions and may not be completely accurate if there are\n+    // failures responses other than not found.\n+    // TODO support cloud replicas in this condition, also account for failures other than not found", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2Nzg2Mzgx", "url": "https://github.com/linkedin/ambry/pull/1445#pullrequestreview-386786381", "createdAt": "2020-04-02T21:22:49Z", "commit": {"oid": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1341, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}