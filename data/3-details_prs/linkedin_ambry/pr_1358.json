{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTEwMTQ5", "number": 1358, "title": "Add custom serializer to reduce size of CloudBlobMetadata", "bodyText": "Remove cloudBlobName field in favor of naming version", "createdAt": "2020-01-15T01:08:22Z", "url": "https://github.com/linkedin/ambry/pull/1358", "merged": true, "mergeCommit": {"oid": "608c1012b71ca167c8d5eeb27d3e94672fb78333"}, "closed": true, "closedAt": "2020-01-18T00:37:36Z", "author": {"login": "lightningrob"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6a4xsgH2gAyMzYyOTEwMTQ5OmU1MWQwYmY0YzZjMTdhOWZmMTE5Y2NkOTE5YmUxNzMwN2IyMmQ4MGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7WuQnAFqTM0NDg4MDc4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e51d0bf4c6c17a9ff119ccd919be17307b22d80f", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/e51d0bf4c6c17a9ff119ccd919be17307b22d80f", "committedDate": "2020-01-15T01:02:05Z", "message": "Custom serializer to reduce size of CloudBlobMetadata\nRemove cloudBlobName field in favor of naming version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/3647502fd233b6b7860b0ea7c3a7dba90b86141b", "committedDate": "2020-01-15T01:07:31Z", "message": "Revert enabling of test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzU5OTY0", "url": "https://github.com/linkedin/ambry/pull/1358#pullrequestreview-343359964", "createdAt": "2020-01-15T16:40:34Z", "commit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjo0MDozNFrOFd-1zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjo0MDo1MFrOFd-2Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MjYwNA==", "bodyText": "could you explain the purpose of these constructors? Would the value passed in always be CloudBlobMetadata.class?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982604", "createdAt": "2020-01-15T16:40:34Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Mjc1MA==", "bodyText": "what does passing a null type in mean?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982750", "createdAt": "2020-01-15T16:40:50Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzgxMDI3", "url": "https://github.com/linkedin/ambry/pull/1358#pullrequestreview-343381027", "createdAt": "2020-01-15T17:09:56Z", "commit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzowOTo1NlrOFd_z8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTowMDo0OFrOFeDBww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5ODUxNA==", "bodyText": "The javadocs for ObjectMapper say that the instance is thread safe and should be reused: https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/ObjectMapper.html. Could you make the ObjectMapper instance private static final?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366998514", "createdAt": "2020-01-15T17:09:56Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw==", "bodyText": "This also seems a little inefficient that you have to convert to a json node and then iterate through it to go back to the map. I guess the alternative is manually constructing the map, but that has the tradeoff of more duplicate code.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367001427", "createdAt": "2020-01-15T17:15:47Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNTI3Ng==", "bodyText": "I wonder if there is any reason to set FIELD_ENCRYPTION_ORIGIN if the value is EncryptionOrigin.ROUTER? I can't think of an immediate need other than being able to write analytics queries to count # of encrypted blobs.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367015276", "createdAt": "2020-01-15T17:43:33Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {\n+        gen.writeNumberField(FIELD_DELETION_TIME, value.deletionTime);\n+      }\n+      if (value.expirationTime > 0) {\n+        gen.writeNumberField(FIELD_EXPIRATION_TIME, value.expirationTime);\n+      }\n+      if (value.namingScheme > 0) {\n+        gen.writeNumberField(FIELD_NAMING_SCHEME, value.namingScheme);\n+      }\n+      // Encryption fields that may or may not apply\n+      if (value.encryptionOrigin == EncryptionOrigin.VCR) {\n+        gen.writeStringField(FIELD_ENCRYPTION_ORIGIN, value.encryptionOrigin.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyODgxMQ==", "bodyText": "Instead of adding a new constructor to CloudBlobMetadata just for this purpose, could you just call getClusterAwareAzureContainerName(blobID.getPartitionId().toPathString())?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367028811", "createdAt": "2020-01-15T18:12:53Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,55 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {\n+    return getAzureContainerName(new CloudBlobMetadata(blobId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyOTE4NA==", "bodyText": "Is this constructor only for the getAzureContainerName method?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367029184", "createdAt": "2020-01-15T18:13:39Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -75,6 +97,14 @@\n   public CloudBlobMetadata() {\n   }\n \n+  /**\n+   * Constructor from {@link BlobId}.  All other metadata are ignored.\n+   * @param blobId The BlobId for metadata record.\n+   */\n+  public CloudBlobMetadata(BlobId blobId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw==", "bodyText": "minor, but it may be worth making these constants into an unmodifiable list so they won't be tampered with.\npublic static final List<String> REQUIRED_FIELDS = Collections.unmodifiableList(Arrays.asList(FIELD_ID, FIELD_ACCOUNT_ID, ...))", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367050333", "createdAt": "2020-01-15T18:58:52Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw==", "bodyText": "should these time fields be >= 0, since technically 0 could be a valid timestamp?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367051203", "createdAt": "2020-01-15T19:00:48Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924341da1b110971eac32d63848ea10694ab9545", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/924341da1b110971eac32d63848ea10694ab9545", "committedDate": "2020-01-15T19:44:04Z", "message": "Merge branch 'master' of github.com:linkedin/ambry into blobmetadata-reduction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c0d210b027b480f1c6b1460ba659681f7a6d4ca", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/0c0d210b027b480f1c6b1460ba659681f7a6d4ca", "committedDate": "2020-01-15T22:11:20Z", "message": "Address Casey's review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05b1ae5e45a81d4232c29c735764f764787041d6", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/05b1ae5e45a81d4232c29c735764f764787041d6", "committedDate": "2020-01-15T23:05:59Z", "message": "Include encryptionOrigin in serialization when value is ROUTER"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7686f628cb07f8581ce104efe894e0b3f390efb", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/a7686f628cb07f8581ce104efe894e0b3f390efb", "committedDate": "2020-01-15T23:11:51Z", "message": "Removed unneded constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/75fa5562932cec3e9e9c11b841c760d638a93d5f", "committedDate": "2020-01-17T17:54:45Z", "message": "Remove static arrays from prod class\nAdd JsonIgnoreProperties to allow removal of fields from schema"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0Nzc0OTgx", "url": "https://github.com/linkedin/ambry/pull/1358#pullrequestreview-344774981", "createdAt": "2020-01-17T18:53:31Z", "commit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1MzozMVrOFfCIMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTowNDo0OVrOFfCaJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTA0MQ==", "bodyText": "javadocs missing.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085041", "createdAt": "2020-01-17T18:53:31Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTUxNQ==", "bodyText": "javadocs missing.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085515", "createdAt": "2020-01-17T18:54:39Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {\n+    return namingScheme;\n   }\n \n-  /**\n-   * Sets blob's name in cloud.\n-   * @param cloudBlobName the blob's name in cloud.\n-   * @return this instance.\n-   */\n-  public CloudBlobMetadata setCloudBlobName(String cloudBlobName) {\n-    this.cloudBlobName = cloudBlobName;\n+  public CloudBlobMetadata setNamingScheme(int namingScheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NjY0Mw==", "bodyText": "what does namingScheme represent?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368086643", "createdAt": "2020-01-17T18:57:16Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -43,12 +63,12 @@\n   private long size;\n   private int accountId;\n   private int containerId;\n-  private long expirationTime;\n-  private long deletionTime;\n-  private EncryptionOrigin encryptionOrigin;\n+  private long expirationTime = Utils.Infinite_Time;\n+  private long deletionTime = Utils.Infinite_Time;\n+  private int namingScheme = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4OTYzNw==", "bodyText": "Looks like we are passing blobid to this method now (instead of partitionID as earlier), and then creating CloudBlobMetadata object out of it, but only really using partitionId eventually. Unless I missed something, do we really need these changes?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368089637", "createdAt": "2020-01-17T19:04:49Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,56 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455", "author": {"user": {"login": "shipkit-org", "name": "shipkit.org automated bot"}}, "url": "https://github.com/linkedin/ambry/commit/7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455", "committedDate": "2020-01-17T22:04:38Z", "message": "Address Ankur's review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODgwNDE2", "url": "https://github.com/linkedin/ambry/pull/1358#pullrequestreview-344880416", "createdAt": "2020-01-17T22:43:44Z", "commit": {"oid": "7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODgwNzgz", "url": "https://github.com/linkedin/ambry/pull/1358#pullrequestreview-344880783", "createdAt": "2020-01-17T22:44:54Z", "commit": {"oid": "7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1554, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}