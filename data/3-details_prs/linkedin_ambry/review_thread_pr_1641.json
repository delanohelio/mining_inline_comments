{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MTMwNDYz", "number": 1641, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDozODoyOFrOEp_enw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NzoxNFrOEp_gUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDY3MTAzOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDozODoyOFrOHb_lkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDozODoyOFrOHb_lkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTQwOA==", "bodyText": "nit: IOException is not thrown in this method.", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115408", "createdAt": "2020-10-03T04:38:28Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDY3NDU1OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NTozNVrOHb_nPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NTozNVrOHb_nPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTgzOQ==", "bodyText": "I think you were trying to reset this in finally block:\n((MockBlobStore) store).setOperationBeforeSynchronization(null);", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115839", "createdAt": "2020-10-03T04:45:35Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {\n+    store.shutdown();\n+    ReplicaId replicaId = getMockReplicaId(tempDirStr);\n+    StoreConfig config = new StoreConfig(new VerifiableProperties(properties));\n+    MetricRegistry registry = new MetricRegistry();\n+    StoreMetrics metrics = new StoreMetrics(registry);\n+    MockBlobStoreStats mockBlobStoreStats = new MockBlobStoreStats(time);\n+    store = new MockBlobStore(replicaId, config, null, metrics, mockBlobStoreStats);\n+    store.start();\n+\n+    MockId id = put(1, PUT_RECORD_SIZE, Utils.Infinite_Time).get(0);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNull(mockBlobStoreStats.originalPutValue);\n+    assertNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isPut());\n+\n+    updateTtl(id);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNotNull(mockBlobStoreStats.originalPutValue);\n+    assertNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.originalPutValue.isPut());\n+\n+    delete(id);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNotNull(mockBlobStoreStats.originalPutValue);\n+    assertNotNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isDelete());\n+    assertTrue(mockBlobStoreStats.currentValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.previousValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.originalPutValue.isTtlUpdate());\n+\n+    // Delete a blob at the same time, put a new blob, make sure the blobstorestats still get everything.\n+    MockId id2 = put(1, PUT_RECORD_SIZE, expiresAtMs).get(0);\n+    final CountDownLatch synchronizationLatch = new CountDownLatch(1);\n+    final CountDownLatch putLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setOperationBeforeSynchronization(() -> {\n+      synchronizationLatch.countDown(); // put will wait until delete reach synchronization statement\n+      putLatch.await(); // then delete will wait until put finishes\n+      return null;\n+    });\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(() -> {\n+        delete(id2);\n+        return null;\n+      });\n+      Future<Void> putFuture = executorService.submit(() -> {\n+        // Now make sure delete already gets to synchronization\n+        synchronizationLatch.await();\n+        // Disable synchronization callback so put will not be blocked by it.\n+        ((MockBlobStore) store).setOperationBeforeSynchronization(null);\n+        put(1, PUT_RECORD_SIZE, Utils.Infinite_Time);\n+        // Now make sure the put is inserted into the index before continue delete\n+        putLatch.countDown();\n+        return null;\n+      });\n+      putFuture.get();\n+      deleteFuture.get();\n+\n+      // MockBlobStoreStats should capture delete operation\n+      assertNotNull(mockBlobStoreStats.currentValue);\n+      assertNotNull(mockBlobStoreStats.originalPutValue);\n+      assertNotNull(mockBlobStoreStats.previousValue);\n+      assertTrue(mockBlobStoreStats.currentValue.isDelete());\n+      assertTrue(mockBlobStoreStats.previousValue.isPut());\n+      assertTrue(mockBlobStoreStats.originalPutValue.isPut());\n+    } finally {\n+      ((MockBlobStore) store).setInDeleteBetweenGetEndOffsetAndFindKey(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDY3NTM4OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NzoxNVrOHb_nnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NzoxNVrOHb_nnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTkzNQ==", "bodyText": "The test name is too general, maybe rename it ? (Also add some java doc)", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115935", "createdAt": "2020-10-03T04:47:15Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1403, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}