{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDE5Njc3", "number": 1444, "title": "Change BlobStore so records can have a lifeVersion rather than -1", "bodyText": "BlobStore doesn't support operations where the lifeVersion is not -1. It always assume those operations are from frontend. This PR extends support to replication.\nAfter this PR, BlobStore will be able to put, ttl update, delete and undelete a blob that should have a higher lifeVersion.", "createdAt": "2020-03-28T00:27:05Z", "url": "https://github.com/linkedin/ambry/pull/1444", "merged": true, "mergeCommit": {"oid": "8e5af5261325d9b71601e273eb932f82dab4fc5f"}, "closed": true, "closedAt": "2020-04-03T23:25:07Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTdcqkABqjMxODk0OTczNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUJQxdAFqTM4NzYyODUxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "29908cfa63b0538ea507aa90f997ffb0dfad03e6", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/29908cfa63b0538ea507aa90f997ffb0dfad03e6", "committedDate": "2020-04-01T18:56:34Z", "message": "Fix"}, "afterCommit": {"oid": "2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "committedDate": "2020-04-01T20:03:28Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8eb308915b60225a55fbb9b8eb204880df5343a", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a8eb308915b60225a55fbb9b8eb204880df5343a", "committedDate": "2020-04-01T20:40:22Z", "message": "Change BlobStore so records can have a lifeVersion rather than -1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1451543b9e79cd4ab783631a43af5a3dd51b56d8", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/1451543b9e79cd4ab783631a43af5a3dd51b56d8", "committedDate": "2020-04-01T20:40:22Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57e6bb055e2a8a542372fa7e991e247bf86966b7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/57e6bb055e2a8a542372fa7e991e247bf86966b7", "committedDate": "2020-04-01T20:40:22Z", "message": "Fix the test failure again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c3a7c428027fbc61567f9766eb917f7dd95ec90", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/3c3a7c428027fbc61567f9766eb917f7dd95ec90", "committedDate": "2020-04-01T20:40:22Z", "message": "Fix the test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "committedDate": "2020-04-01T20:40:22Z", "message": "Fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3ab82843cd19fc91fe9907afdc3a16f0ca4ed81", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/c3ab82843cd19fc91fe9907afdc3a16f0ca4ed81", "committedDate": "2020-04-01T20:09:22Z", "message": "Rebase"}, "afterCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "committedDate": "2020-04-01T20:40:22Z", "message": "Fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTEzNjA3", "url": "https://github.com/linkedin/ambry/pull/1444#pullrequestreview-384913607", "createdAt": "2020-03-31T16:40:04Z", "commit": {"oid": "2f279b259571be0c1fd1d7590388d67b2ecdb1ee"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNjo0MDowNFrOF-emGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToxMDo0NVrOGAFTZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA1NzMwNw==", "bodyText": "nit: is triggered", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r401057307", "createdAt": "2020-03-31T16:40:04Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java", "diffHunk": "@@ -22,6 +22,8 @@\n  */\n public class MessageInfo {\n \n+  // The life version when the operation is trigger by the requests from frontend.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f279b259571be0c1fd1d7590388d67b2ecdb1ee"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjE2OA==", "bodyText": "This can be INFO level. (I finally understand this after reading your comment in BlobIdTransformer)", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722168", "createdAt": "2020-04-03T03:50:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw==", "bodyText": "Any concern to use msgInfo.isUndeleted() instead of false here ? The reason I am asking is in the future we probably forget to update this hard coded value.", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722917", "createdAt": "2020-04-03T03:54:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n         props = deserializeBlobProperties(msgStream);\n         metadata = deserializeUserMetadata(msgStream);\n         blobData = deserializeBlob(msgStream);\n       } else {\n-        throw new IllegalStateException(\"Message cannot be a deleted record \");\n+        throw new IllegalStateException(\"Message cannot be anything rather than put record \");\n       }\n       if (msgInfo.getStoreKey().equals(keyInStream)) {\n         // BlobIDTransformer only exists on ambry-server and replication between servers is relying on blocking channel\n         // which is still using java ByteBuffer. So, no need to consider releasing stuff.\n         // @todo, when netty Bytebuf is adopted for blocking channel on ambry-server, remember to release this ByteBuf.\n         PutMessageFormatInputStream transformedStream =\n             new PutMessageFormatInputStream(keyInStream, encryptionKey, props, metadata,\n-                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType());\n+                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType(),\n+                msgInfo.getLifeVersion());\n         MessageInfo transformedMsgInfo =\n             new MessageInfo(keyInStream, transformedStream.getSize(), msgInfo.isDeleted(), msgInfo.isTtlUpdated(),\n-                msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(), msgInfo.getContainerId(),\n-                msgInfo.getOperationTimeMs());\n+                false, msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNTYxMA==", "bodyText": "Actually, after second thought, shouldn't this be false for all three boolean variables (deleted, ttlUpdated, undeleted)? Since this is PUT record only, hmm, probably isTtlUpdated() is still required. (Correct me if I am wrong)", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402725610", "createdAt": "2020-04-03T04:06:43Z", "author": {"login": "jsjtzyy"}, "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n         props = deserializeBlobProperties(msgStream);\n         metadata = deserializeUserMetadata(msgStream);\n         blobData = deserializeBlob(msgStream);\n       } else {\n-        throw new IllegalStateException(\"Message cannot be a deleted record \");\n+        throw new IllegalStateException(\"Message cannot be anything rather than put record \");\n       }\n       if (msgInfo.getStoreKey().equals(keyInStream)) {\n         // BlobIDTransformer only exists on ambry-server and replication between servers is relying on blocking channel\n         // which is still using java ByteBuffer. So, no need to consider releasing stuff.\n         // @todo, when netty Bytebuf is adopted for blocking channel on ambry-server, remember to release this ByteBuf.\n         PutMessageFormatInputStream transformedStream =\n             new PutMessageFormatInputStream(keyInStream, encryptionKey, props, metadata,\n-                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType());\n+                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType(),\n+                msgInfo.getLifeVersion());\n         MessageInfo transformedMsgInfo =\n             new MessageInfo(keyInStream, transformedStream.getSize(), msgInfo.isDeleted(), msgInfo.isTtlUpdated(),\n-                msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(), msgInfo.getContainerId(),\n-                msgInfo.getOperationTimeMs());\n+                false, msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw=="}, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyODMxOQ==", "bodyText": "Why do we need this log? Can it be debug level?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402728319", "createdAt": "2020-04-03T04:19:06Z", "author": {"login": "jsjtzyy"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -182,6 +182,7 @@ public void handlePutRequest(NetworkRequest request) throws IOException, Interru\n         metrics.blobSizeInBytes.update(receivedRequest.getBlobSize());\n         metrics.blobUserMetadataSizeInBytes.update(receivedRequest.getUsermetadata().limit());\n         if (notification != null) {\n+          logger.info(\"AmbryRequests: write key \" + receivedRequest.getBlobId() + \" at port \" + currentNode.getPort());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ==", "bodyText": "Sorry, I forgot why we use this ctor of MessageInfo when handling undelete request, in which undeleted is false. Could you explain again?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402729785", "createdAt": "2020-04-03T04:26:04Z", "author": {"login": "jsjtzyy"}, "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -651,7 +654,7 @@ public void handleUndeleteRequest(NetworkRequest request) throws IOException, In\n         BlobId convertedBlobId = (BlobId) convertedStoreKey;\n         MessageInfo info =\n             new MessageInfo(convertedBlobId, -1, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n-                undeleteRequest.getOperationTimeMs());\n+                undeleteRequest.getOperationTimeMs(), MessageInfo.LIFE_VERSION_FROM_FRONTEND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMDczNw==", "bodyText": "can be INFO level", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402730737", "createdAt": "2020-04-03T04:30:18Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/BlobIdTransformer.java", "diffHunk": "@@ -157,6 +160,12 @@ private Message newMessage(InputStream inputStream, StoreKey newKey, MessageInfo\n     BlobId newBlobId = (BlobId) newKey;\n \n     if (headerFormat.isPutRecord()) {\n+      if (headerFormat.hasLifeVersion() && headerFormat.getLifeVersion() != oldMessageInfo.getLifeVersion()) {\n+        // The original Put buffer might have lifeVersion as 0, but the message info might have a higher lifeVersion.\n+        logger.trace(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjUxNQ==", "bodyText": "Try to understand why we don't insert infoFound.getLifeVersion() into constructed new message info.", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732515", "createdAt": "2020-04-03T04:38:00Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java", "diffHunk": "@@ -204,6 +204,11 @@ public void send(Send request) {\n                 infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), true, false,\n                     putMsgInfo.getExpirationTimeInMs(), putMsgInfo.getAccountId(), putMsgInfo.getContainerId(),\n                     putMsgInfo.getOperationTimeMs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjk5MQ==", "bodyText": "I am curious how much difference it has with this minor change.", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732991", "createdAt": "2020-04-03T04:40:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java", "diffHunk": "@@ -488,7 +488,7 @@ void trackUpdate(String host, int port, UpdateType updateType) {\n    * @throws InterruptedException\n    */\n   boolean awaitBlobCreations() throws InterruptedException {\n-    return creationHelper.await(10, TimeUnit.SECONDS);\n+    return creationHelper.await(11, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQyNg==", "bodyText": "if this is no longer valid, can we remove it?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733426", "createdAt": "2020-04-03T04:42:15Z", "author": {"login": "jsjtzyy"}, "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -141,10 +141,11 @@ public void run() {\n                     System.out.println(exceptionMsg);\n                     throw new IllegalStateException(exceptionMsg);\n                   }\n-                  checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput));\n+                  // blob property doesn't have the correct expiration time after ttl update.\n+                  //checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput), \"blobproperty\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQ4OA==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733488", "createdAt": "2020-04-03T04:42:30Z", "author": {"login": "jsjtzyy"}, "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -240,22 +241,27 @@ public void run() {\n                   if (ByteBuffer.wrap(blobout).compareTo(ByteBuffer.wrap(payload.blob)) != 0) {\n                     throw new IllegalStateException();\n                   }\n-                  checkExpiryTimeMatch(payload,\n-                      ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()));\n+                  //checkExpiryTimeMatch(payload,\n+                  //    ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()),\n+                  //    \"blobproperty in bloball\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDA2OQ==", "bodyText": "Is this for debug purpose? If it's really worth logging, how about using logger.trace ?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402740069", "createdAt": "2020-04-03T05:10:45Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -410,15 +409,21 @@ public void put(MessageWriteSet messageSetToWrite) throws StoreException {\n             ArrayList<IndexEntry> indexEntries = new ArrayList<>(messageInfo.size());\n             for (MessageInfo info : messageInfo) {\n               FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-              IndexValue value = new IndexValue(info.getSize(), fileSpan.getStartOffset(), info.getExpirationTimeInMs(),\n-                  info.getOperationTimeMs(), info.getAccountId(), info.getContainerId());\n+              // Put from frontend should always use 0 as lifeVersion. (0 is the starting life version number for any data).\n+              // Put from replication or recovery should use liferVersion as it's.\n+              short lifeVersion = IndexValue.hasLifeVersion(info.getLifeVersion()) ? info.getLifeVersion() : (short) 0;\n+              IndexValue value =\n+                  new IndexValue(info.getSize(), fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE,\n+                      info.getExpirationTimeInMs(), info.getOperationTimeMs(), info.getAccountId(),\n+                      info.getContainerId(), lifeVersion);\n               IndexEntry entry = new IndexEntry(info.getStoreKey(), value, info.getCrc());\n               indexEntries.add(entry);\n               endOffsetOfLastMessage = fileSpan.getEndOffset();\n             }\n             FileSpan fileSpan = new FileSpan(indexEntries.get(0).getValue().getOffset(), endOffsetOfLastMessage);\n             index.addToIndex(indexEntries, fileSpan);\n             for (IndexEntry newEntry : indexEntries) {\n+              System.out.println(\"Handle new put Entry for key \" + newEntry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "committedDate": "2020-04-03T07:04:43Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "committedDate": "2020-04-03T17:19:56Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDkzOTA5", "url": "https://github.com/linkedin/ambry/pull/1444#pullrequestreview-387493909", "createdAt": "2020-04-03T18:38:06Z", "commit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODozODowNlrOGAjXiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODozODo1M1rOGAjaMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ==", "bodyText": "I raised the same question in the other PR:\nwhy not check storeValidateAuthorization here? assume replication always correct?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403232649", "createdAt": "2020-04-03T18:38:06Z", "author": {"login": "zzmao"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzMyOA==", "bodyText": "minor: use isTtlUpdate() to make it consistent with other Ttl", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403233328", "createdAt": "2020-04-03T18:38:53Z", "author": {"login": "zzmao"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -542,9 +542,11 @@ void addEntry(IndexEntry entry, Offset fileEndOffset) throws StoreException {\n       }\n       if (resetKey == null) {\n         PersistentIndex.IndexEntryType type = PersistentIndex.IndexEntryType.PUT;\n-        if (entry.getValue().isFlagSet(IndexValue.Flags.Delete_Index)) {\n+        if (entry.getValue().isDelete()) {\n           type = PersistentIndex.IndexEntryType.DELETE;\n-        } else if (entry.getValue().isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+        } else if (entry.getValue().isUndelete()) {\n+          type = PersistentIndex.IndexEntryType.UNDELETE;\n+        } else if (entry.getValue().isTTLUpdate()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDY3ODQ1", "url": "https://github.com/linkedin/ambry/pull/1444#pullrequestreview-387467845", "createdAt": "2020-04-03T17:58:06Z", "commit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo1ODowNlrOGAhSug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxOToxNzowMVrOGAk4_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODY1MA==", "bodyText": "nit: (1) StoreKey (2) extra space between LifeVersion and should", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403198650", "createdAt": "2020-04-03T17:58:06Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "diffHunk": "@@ -41,29 +41,37 @@\n   StoreInfo get(List<? extends StoreKey> ids, EnumSet<StoreGetOptions> storeGetOptions) throws StoreException;\n \n   /**\n-   * Puts a set of messages into the store\n+   * Puts a set of messages into the store. When the lifeVersion is {@link MessageInfo#LIFE_VERSION_FROM_FRONTEND}, this\n+   * method is invoked by the responding to the frontend request. Otherwise, it's invoked in the replication thread.\n    * @param messageSetToWrite The message set to write to the store\n+   *                          Only the Storekey, OperationTime, ExpirationTime, LifeVersion  should be used in this method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTI5OQ==", "bodyText": "When revisiting this piece of code, I find line 518 directly throws exception if it's deleted without checking the version. I feel like it may have edge case there. Could you double check if it needs to be updated?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403225299", "createdAt": "2020-04-03T18:29:14Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()\n+              > info.getLifeVersion())) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.Life_Version_Conflict);\n+          }\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(info.getLifeVersion());\n         }\n-        indexValuesToDelete.add(value);\n-        lifeVersions.add(value.getLifeVersion());\n       }\n       synchronized (storeWriteLock) {\n         Offset currentIndexEndOffset = index.getCurrentEndOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MjczOQ==", "bodyText": "minor: line 847 in PersistentIndex, the java doc for lifeVersion should be delete record rather than undelete record", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403242739", "createdAt": "2020-04-03T18:52:15Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -525,7 +545,8 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         int correspondingPutIndex = 0;\n         for (MessageInfo info : updatedInfos) {\n           FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-          IndexValue deleteIndexValue = index.markAsDeleted(info.getStoreKey(), fileSpan, info.getOperationTimeMs());\n+          IndexValue deleteIndexValue =\n+              index.markAsDeleted(info.getStoreKey(), fileSpan, null, info.getOperationTimeMs(), info.getLifeVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTY4Mg==", "bodyText": "In which case the value could be null ?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403249682", "createdAt": "2020-04-03T19:01:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTY5Mg==", "bodyText": "In this PR, hasLifeVersion is always false, right? (because BlobStore.handleTtlUpate passes LIFE_VERSION_FROM_FRONTEND into this method)", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403251692", "createdAt": "2020-04-03T19:04:40Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n-    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    if (value != null && value.isDelete()) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+    } else if (value != null && value.isTTLUpdate()) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n     } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw==", "bodyText": "Could you explain why we pass info.getLifeVersion() rather than resolved lifeVersion to message info?", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403257597", "createdAt": "2020-04-03T19:17:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -660,15 +686,16 @@ public short undelete(MessageInfo info) throws StoreException {\n       StoreKey id = info.getStoreKey();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n       List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n-      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      index.validateSanityForUndelete(id, values, info.getLifeVersion());\n       IndexValue latestValue = values.get(0);\n       short lifeVersion = (short) (latestValue.getLifeVersion() + 1);\n       MessageFormatInputStream stream =\n           new UndeleteMessageFormatInputStream(id, info.getAccountId(), info.getContainerId(),\n               info.getOperationTimeMs(), lifeVersion);\n       // Update info to add stream size;\n       info =\n-          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs());\n+          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs(),\n+              info.getLifeVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/85d8ac616fb3f7734f9a3e265c583a5298c16365", "committedDate": "2020-04-03T19:55:24Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NjI4NTE1", "url": "https://github.com/linkedin/ambry/pull/1444#pullrequestreview-387628515", "createdAt": "2020-04-03T23:12:02Z", "commit": {"oid": "85d8ac616fb3f7734f9a3e265c583a5298c16365"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1337, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}