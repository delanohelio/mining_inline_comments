{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMzI3MzM4", "number": 1712, "title": "[StorageQuota] Add a storage usage refresher on top of mysql", "bodyText": "Add mysql implementation of storage usage refresher.", "createdAt": "2020-12-02T22:26:33Z", "url": "https://github.com/linkedin/ambry/pull/1712", "merged": true, "mergeCommit": {"oid": "5d1f1f5c234824970129afbbaa276a3380a2c89e"}, "closed": true, "closedAt": "2020-12-08T23:45:07Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdix4IRgFqTU0NDYxMjQyNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkS939gFqTU0NzcyNjk0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NjEyNDI1", "url": "https://github.com/linkedin/ambry/pull/1712#pullrequestreview-544612425", "createdAt": "2020-12-04T02:27:05Z", "commit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMjoyNzowNVrOH-9-PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNjozNzowOVrOH_C4Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc4OTExNg==", "bodyText": "nit: mysqlStoreRetryMax -> mysqlStoreRetryMaxCount", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535789116", "createdAt": "2020-12-04T02:27:05Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -76,6 +81,34 @@\n   @Default(\"30 * 60 * 1000\")\n   public final int sourcePollingIntervalMs;\n \n+  /**\n+   * The directory to store quota related backup files. If empty, then backup files will be disabled.\n+   */\n+  @Config(BACKUP_FILE_DIR)\n+  @Default(\"\")\n+  public final String backupFileDir;\n+\n+  /**\n+   * Duration in milliseconds to backoff if the mysql database query failed.\n+   */\n+  @Config(MYSQL_STORE_RETRY_BACKOFF_MS)\n+  @Default(\"10*60*1000\")\n+  public final long mysqlStoreRetryBackoffMs;\n+\n+  /**\n+   * Maximum retry times to execute a mysql database query.\n+   */\n+  @Config(MYSQL_STORE_RETRY_MAX)\n+  @Default(\"1\")\n+  public final int mysqlStoreRetryMax;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDQ0Nw==", "bodyText": "Could you explain the logic here?  Looks like if retries exceeds max count, it resets retries , increments its value and  schedule another round of retry ?", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535864447", "createdAt": "2020-12-04T06:23:35Z", "author": {"login": "jsjtzyy"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDYyNg==", "bodyText": "return can be removed", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535864626", "createdAt": "2020-12-04T06:24:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTAyMw==", "bodyText": "Why we need local variable base?", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535865023", "createdAt": "2020-12-04T06:25:07Z", "author": {"login": "jsjtzyy"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2OTQ2Ng==", "bodyText": "In bootstrap case or containerStorageUsageMonthlyBase cannot be fetched from Mysql or local backup, shouldn't we give it an empty map at line 85?", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r535869466", "createdAt": "2020-12-04T06:37:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        Map<String, Map<String, Long>> base =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+        containerStorageUsageMonthlyBase = base;\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMax) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+      }\n+      retries++;\n+      if (config.mysqlStoreRetryBackoffMs != 0) {\n+        scheduler.schedule(this::fetchMonthlyStorageUsageAndMaybeRetry, config.mysqlStoreRetryBackoffMs,\n+            TimeUnit.MILLISECONDS);\n+      }\n+      return;\n+    } else {\n+      retries = 0;\n+      tryPersistMonthlyUsage();\n+      scheduleStorageUsageMonthlyBaseFetcher();\n+    }\n+  }\n+\n+  /**\n+   * Schedule the task to fetch storage usage monthly base for next month.\n+   */\n+  private void scheduleStorageUsageMonthlyBaseFetcher() {\n+    long sleepDurationInSecs = secondsToNextTick(currentMonth, config.mysqlMonthlyBaseFetchOffsetSec);\n+    logger.info(\"Schedule to fetch container storage monthly base after \" + sleepDurationInSecs + \" seconds\");\n+    scheduler.schedule(this::fetchStorageUsageMonthlyBase, sleepDurationInSecs, TimeUnit.SECONDS);\n+  }\n+\n+  /**\n+   * The task to fetch storage usage monthly base.\n+   */\n+  void fetchStorageUsageMonthlyBase() {\n+    currentMonth = getCurrentMonth();\n+    fetchMonthlyStorageUsageAndMaybeRetry();\n+  }\n+\n+  /**\n+   * Return {@link #containerStorageUsageMonthlyBase}. Only used in test.\n+   * @return the {@link #containerStorageUsageMonthlyBase}.\n+   */\n+  Map<String, Map<String, Long>> getContainerStorageUsageMonthlyBase() {\n+    return Collections.unmodifiableMap(containerStorageUsageMonthlyBase);\n+  }\n+\n+  /**\n+   * Return {@link BackupFileManager}. Only used in test.\n+   * @return {@link BackupFileManager}.\n+   */\n+  BackupFileManager getBackupFileManager() {\n+    return backupFileManager;\n+  }\n+\n+  /**\n+   * Fetch the storage usage and schedule a task to periodically refresh the storage usage.\n+   */\n+  private void initialFetchAndSchedule() {\n+    Runnable updater = () -> {\n+      try {\n+        Map<String, Map<String, Long>> base = containerStorageUsageMonthlyBase;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff"}, "originalPosition": 239}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b016b6ea4af87a4b94920a7b9e9b5e96b5b177f7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/b016b6ea4af87a4b94920a7b9e9b5e96b5b177f7", "committedDate": "2020-12-04T19:20:21Z", "message": "[StorageQuota] Add a storage usage refresher on top of mysql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d730ec7c06274e2300b41b76b5339c590a8792c2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/d730ec7c06274e2300b41b76b5339c590a8792c2", "committedDate": "2020-12-04T19:44:16Z", "message": "comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a05dcf0bca1e630dfbd39844b22c76ffe56d96ff", "committedDate": "2020-12-02T22:24:25Z", "message": "[StorageQuota] Add a storage usage refresher on top of mysql"}, "afterCommit": {"oid": "d730ec7c06274e2300b41b76b5339c590a8792c2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/d730ec7c06274e2300b41b76b5339c590a8792c2", "committedDate": "2020-12-04T19:44:16Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/96e593a183bddda0ec76d839cf996712eaa22dbc", "committedDate": "2020-12-04T20:36:06Z", "message": "Fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTU0NTIx", "url": "https://github.com/linkedin/ambry/pull/1712#pullrequestreview-547554521", "createdAt": "2020-12-08T19:20:04Z", "commit": {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToyMDowNFrOIByIGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToyMjozMFrOIByOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MDc2Mg==", "bodyText": "So in this case is the base value the last month's value? If yes, then can customers be penalized for our failure to get monthly base.\nI am worried about the following scenario:\nexample accountId: A, containerId: B, container quota: 12G\ncurrent date: Dec 2\nBase Value Nov = 85G\nBase Value Dec = 90G (this could not be fetched due to some reason), so containerStorageUsageMonthlyBase[\"A\"][\"B\"] = 85G\nCurrent Usage Value for container = 100G\nWhats our response in this case?", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538740762", "createdAt": "2020-12-08T19:20:04Z", "author": {"login": "ankagrawal"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents\n+ * how many bytes containers used in this month. So it's monthly usage, not total usage.\n+ *\n+ * For example, in the beginning of Dec 2020, container A[100]_C[1]'s total container usage is 100GB, then this usage will\n+ * be saved in the monthly table. Then every time aggregation task is running, it will get the most up to date total usage\n+ * for this container and update it in a second table. The refresher will periodically fetches total container usages from\n+ * the second table and subtract values from the monthly table to get the usage for this month. If at the 10th days of this\n+ * month, the total usage of container A[100]_C[1] is 110GB, by subtracting 100GB from monthly table, we know the monthly\n+ * usage for this container is 10GB.\n+ */\n+public class MySqlStorageUsageRefresher implements StorageUsageRefresher {\n+  static final DateTimeFormatter DATE_TIME_FORMATTER = MySqlReportAggregatorTask.TIMESTAMP_FORMATTER;\n+  static final ZoneOffset ZONE_OFFSET = MySqlReportAggregatorTask.ZONE_OFFSET;\n+  static Time time = SystemTime.getInstance();\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlStorageUsageRefresher.class);\n+\n+  private final AccountStatsMySqlStore accountStatsMySqlStore;\n+  // Container storage usage for this month.\n+  private final AtomicReference<Map<String, Map<String, Long>>> containerStorageUsageForCurrentMonthRef =\n+      new AtomicReference<>(null);\n+  private final AtomicReference<Listener> listener = new AtomicReference<>(null);\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final BackupFileManager backupFileManager;\n+\n+  private volatile Map<String, Map<String, Long>> containerStorageUsageMonthlyBase;\n+  private volatile int retries = 0;\n+  private volatile String currentMonth = getCurrentMonth();\n+\n+  public MySqlStorageUsageRefresher(AccountStatsMySqlStore accountStatsMySqlStore, ScheduledExecutorService scheduler,\n+      StorageQuotaConfig config, ClusterMapConfig clusterMapConfig) throws IOException {\n+    this.accountStatsMySqlStore = Objects.requireNonNull(accountStatsMySqlStore, \"AccountStatsMySqlStore is null\");\n+    this.scheduler = Objects.requireNonNull(scheduler, \"Scheduler is null\");\n+    this.config = config;\n+    this.clusterMapConfig = clusterMapConfig;\n+    this.backupFileManager =\n+        this.config.backupFileDir.isEmpty() ? null : new BackupFileManager(this.config.backupFileDir);\n+    initializeContainerStorageUsageMonthlyBase();\n+    scheduleStorageUsageMonthlyBaseFetcher();\n+    initialFetchAndSchedule();\n+  }\n+\n+  @Override\n+  public Map<String, Map<String, Long>> getContainerStorageUsage() {\n+    return Collections.unmodifiableMap(containerStorageUsageForCurrentMonthRef.get());\n+  }\n+\n+  @Override\n+  public void registerListener(Listener listener) {\n+    Objects.requireNonNull(listener, \"Listener has to be non-null\");\n+    if (!this.listener.compareAndSet(null, listener)) {\n+      throw new IllegalStateException(\"Listener already registered\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize {@link #containerStorageUsageMonthlyBase}. Try to load it from backup files first, if backup file doesn't\n+   * exist for this month, then load it from mysql database.\n+   */\n+  private void initializeContainerStorageUsageMonthlyBase() {\n+    // First try to get the monthly base storage usage from backup\n+    try {\n+      if (backupFileManager != null) {\n+        containerStorageUsageMonthlyBase = backupFileManager.getBackupFileContent(currentMonth);\n+      }\n+      if (containerStorageUsageMonthlyBase != null) {\n+        return;\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"Failed to get container monthly usage for \" + currentMonth + \" from backup\", e);\n+    }\n+\n+    try {\n+      // If we are here, then loading monthly base from backup file failed. We have to fetch it from database.\n+      containerStorageUsageMonthlyBase =\n+          accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      // If the monthly base is indeed for this month, then try to persist it in the backup file.\n+      // There is a chance that the database has a snapshot from last month since the aggregation task is executed\n+      // every few minutes(maybe hours). Before the first aggregation task of this month is executed, the database\n+      // would have the snapshot of last month.\n+      if (currentMonth.equals(accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName))) {\n+        tryPersistMonthlyUsage();\n+      }\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Unable to fetch monthly storage usage from mysql\", e);\n+    }\n+  }\n+\n+  /**\n+   * Try to persist the monthly base usage in the backup file and ignore any exceptions.\n+   */\n+  private void tryPersistMonthlyUsage() {\n+    if (backupFileManager != null) {\n+      try {\n+        backupFileManager.persistentBackupFile(currentMonth, containerStorageUsageMonthlyBase);\n+      } catch (IOException e) {\n+        // Error already been logged from backup file manager.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Fetch the container monthly storage usage from mysql and update the in memory cache. If somehow it fails, we will\n+   * retry for several times before giving up.\n+   */\n+  private void fetchMonthlyStorageUsageAndMaybeRetry() {\n+    boolean shouldRetry = false;\n+    try {\n+      String monthValue = accountStatsMySqlStore.queryRecordedMonth(clusterMapConfig.clusterMapClusterName);\n+      if (monthValue.equals(currentMonth)) {\n+        containerStorageUsageMonthlyBase =\n+            accountStatsMySqlStore.queryMonthlyAggregatedStats(clusterMapConfig.clusterMapClusterName);\n+      } else {\n+        shouldRetry = true;\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Failed to refresh monthly storage usage\", e);\n+      shouldRetry = true;\n+    }\n+\n+    if (shouldRetry) {\n+      if (retries >= config.mysqlStoreRetryMaxCount) {\n+        logger.error(\"Failed to refresh monthly storage usage after \" + retries + \" retries, will skip for month: \"\n+            + currentMonth);\n+        retries = 0;\n+        scheduleStorageUsageMonthlyBaseFetcher();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTM4Mw==", "bodyText": "Why does ambry-quota need ambry-server? It should be the other way round.", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538741383", "createdAt": "2020-12-08T19:20:55Z", "author": {"login": "ankagrawal"}, "path": "build.gradle", "diffHunk": "@@ -448,6 +448,7 @@ project(':ambry-named-mysql') {\n project(':ambry-quota') {\n     dependencies {\n         compile project(':ambry-api'),\n+            project(':ambry-server'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MjQxNA==", "bodyText": "Nit: extra \"*\" in comment.", "url": "https://github.com/linkedin/ambry/pull/1712#discussion_r538742414", "createdAt": "2020-12-08T19:22:30Z", "author": {"login": "ankagrawal"}, "path": "ambry-quota/src/main/java/com/github/ambry/quota/MySqlStorageUsageRefresher.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.clustermap.MySqlReportAggregatorTask;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.server.mysql.AccountStatsMySqlStore;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Time;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.time.LocalDateTime;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.codehaus.jackson.type.TypeReference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link StorageUsageRefresher} implementation on top of mysql database.\n+ *\n+ * At the beginning of each month, aggregation task will take a snapshot of container storage usage and save this snapshot\n+ * on a mysql table. Aggregation task will not change this table until next month. The container storage usage in this\n+ * table becomes a monthly base for this month's container usage. And storage usage exposed by this refresher *represents", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e593a183bddda0ec76d839cf996712eaa22dbc"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bd1a9a8e35549b380991b2ae19fcac545f1c8fa", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/5bd1a9a8e35549b380991b2ae19fcac545f1c8fa", "committedDate": "2020-12-08T21:57:22Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjY5Njk0", "url": "https://github.com/linkedin/ambry/pull/1712#pullrequestreview-547669694", "createdAt": "2020-12-08T22:02:33Z", "commit": {"oid": "5bd1a9a8e35549b380991b2ae19fcac545f1c8fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI2OTQ2", "url": "https://github.com/linkedin/ambry/pull/1712#pullrequestreview-547726946", "createdAt": "2020-12-08T23:44:23Z", "commit": {"oid": "5bd1a9a8e35549b380991b2ae19fcac545f1c8fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1028, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}