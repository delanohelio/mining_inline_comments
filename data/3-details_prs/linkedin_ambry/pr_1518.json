{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2NDY1NTE2", "number": 1518, "title": "Notify routing table updates to replication manager and query the latest leader replica set from Routing table snapshot", "bodyText": "Notify the routing table updates in Helix dynamic cluster change handler to Replication Manager. On receiving this notification, replication Manager will:\n\nRe-query the latest set of remote leader replicas for the leader partitions on local node from the routing table snapshot and update its internal map.\nAssign the new remote leader replicas to replica threads (will be handled in future PRs)\nRemove old leader replicas to replica threads (will be handled in future PRs)", "createdAt": "2020-05-12T03:39:47Z", "url": "https://github.com/linkedin/ambry/pull/1518", "merged": true, "mergeCommit": {"oid": "56f0385be2116104f65c85f90b4e893822694e88"}, "closed": true, "closedAt": "2020-05-27T16:50:27Z", "author": {"login": "Arun-LinkedIn"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcijiVMgFqTQxMzI3OTMyMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABclSKxMAH2gAyNDE2NDY1NTE2OmY4YzI4YzQyMDI3OTQ5OTZiMGY2OWYzMTBjZTA3NzhiZWVmNDdmZTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjc5MzIx", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-413279321", "createdAt": "2020-05-18T05:26:08Z", "commit": {"oid": "9cffdd6b68c6f1169a63eb91f5df8842fd159a06"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNToyNjowOVrOGWn7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTo0MzowM1rOGWoMRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA5Mw==", "bodyText": "I think onRoutingTableChange is called when any of the routing table provider has changed in cluster(Note that each dc has its own routing table provider). In this sense, comments like (of this data center) and (in this data center) are not accurate, can we remove them?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r426376093", "createdAt": "2020-05-18T05:26:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/clustermap/ClusterMapChangeListener.java", "diffHunk": "@@ -26,4 +26,11 @@\n    * @param removedReplicas {@link ReplicaId}(s) that have been removed.\n    */\n   void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas);\n+\n+  /**\n+   * Take actions when there is a routing table update. This is triggered whenever there is any change to state of a replicas (of this data center) in the cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cffdd6b68c6f1169a63eb91f5df8842fd159a06"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3Njk0Nw==", "bodyText": "You can make this default, please refer to setInitialLocalPartitions in ClusterParticipant.java. Then you don't need to override it in other classes (where it is no-op)", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r426376947", "createdAt": "2020-05-18T05:29:29Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/clustermap/ClusterMapChangeListener.java", "diffHunk": "@@ -26,4 +26,11 @@\n    * @param removedReplicas {@link ReplicaId}(s) that have been removed.\n    */\n   void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaId> removedReplicas);\n+\n+  /**\n+   * Take actions when there is a routing table update. This is triggered whenever there is any change to state of a replicas (of this data center) in the cluster.\n+   * On this trigger, we can look up the latest states of all the replicas (in this data center) from the routing table snapshot {@link org.apache.helix.spectator.RoutingTableSnapshot}\n+   * with the help of various APIs provided in its class.\n+   */\n+  void onRoutingTableChange();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cffdd6b68c6f1169a63eb91f5df8842fd159a06"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3OTg1NQ==", "bodyText": "if onRoutingTableChange has default implementation in the interface class, we are able to remove this.", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r426379855", "createdAt": "2020-05-18T05:41:07Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CloudServiceClusterChangeHandler.java", "diffHunk": "@@ -79,6 +79,13 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n     listeners.forEach(listener -> listener.onReplicaAddedOrRemoved(newReplicas, Collections.emptyList()));\n   }\n \n+  @Override\n+  public void onRoutingTableChange() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cffdd6b68c6f1169a63eb91f5df8842fd159a06"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4MDM1OQ==", "bodyText": "can be removed", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r426380359", "createdAt": "2020-05-18T05:43:03Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -46,6 +47,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cffdd6b68c6f1169a63eb91f5df8842fd159a06"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODM3NTkx", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-414837591", "createdAt": "2020-05-19T21:29:57Z", "commit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToyOTo1OFrOGXzVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNjowOTozN1rOGX8iWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTU4Mw==", "bodyText": "nit: RoutingTableSnapshot (use CamelCase)", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427611583", "createdAt": "2020-05-19T21:29:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzU0OA==", "bodyText": "nit: Try to split these comments into multiple lines.", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427617548", "createdAt": "2020-05-19T21:42:44Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNjgyMQ==", "bodyText": "Since we have two read-write locks, we should rename them with more readable(meaningful) names. Following is an example (feel free to use other names)\nrwLock -> replicaMembershipLock\nrwLock1 -> replicaLeaderShipLock", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427626821", "createdAt": "2020-05-19T22:03:37Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -62,6 +63,7 @@\n   private final StoreConfig storeConfig;\n   private final DataNodeId currentNode;\n   private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ReadWriteLock rwlock1 = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjI3Mw==", "bodyText": "I would suggest renaming (1)currentRemoteLeaderReplicas to previousRemoteLeaderReplicas ;  (2) updatedRemoteLeaderReplicas to currentRemoteLeaderReplicas", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427736273", "createdAt": "2020-05-20T04:36:25Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0MDc3OQ==", "bodyText": "This can be slightly simplified as follows (assuming we new naming in previous comment):\ncurrentRemoteLeaderReplicas = new HashSet<>(partition.getReplicaIdsByState(ReplicaState.LEADER, null));\ncurrentRemoteLeaderReplicas.remove(localLeaderReplica);", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427740779", "createdAt": "2020-05-20T04:55:33Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)\n+              .stream()\n+              .filter(r -> !r.getDataNodeId().getDatacenterName().equals(dataNodeId.getDatacenterName()))\n+              .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NjQ3NA==", "bodyText": "No need to generate instance name, we can directly use remoteReplica here. (see toString() in AmbryServerReplica)", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427746474", "createdAt": "2020-05-20T05:17:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)\n+              .stream()\n+              .filter(r -> !r.getDataNodeId().getDatacenterName().equals(dataNodeId.getDatacenterName()))\n+              .collect(Collectors.toList());\n+\n+          //Collect the set of new remote leader replicas\n+          Set<ReplicaId> addedRemoteReplicas = new HashSet<>(updatedRemoteLeaderReplicas);\n+          addedRemoteReplicas.removeAll(currentRemoteLeaderReplicas);\n+\n+          //Collect the set of old remote leader replicas\n+          Set<ReplicaId> removedRemoteReplicas = new HashSet<>(currentRemoteLeaderReplicas);\n+          removedRemoteReplicas.removeAll(updatedRemoteLeaderReplicas);\n+\n+          for (ReplicaId remoteReplica : addedRemoteReplicas) {\n+            // for now, we are just logging the newly found remote leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Adding new remote leader {} for Partition {} to replicate from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NzYyMQ==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427757621", "createdAt": "2020-05-20T05:55:16Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)\n+              .stream()\n+              .filter(r -> !r.getDataNodeId().getDatacenterName().equals(dataNodeId.getDatacenterName()))\n+              .collect(Collectors.toList());\n+\n+          //Collect the set of new remote leader replicas\n+          Set<ReplicaId> addedRemoteReplicas = new HashSet<>(updatedRemoteLeaderReplicas);\n+          addedRemoteReplicas.removeAll(currentRemoteLeaderReplicas);\n+\n+          //Collect the set of old remote leader replicas\n+          Set<ReplicaId> removedRemoteReplicas = new HashSet<>(currentRemoteLeaderReplicas);\n+          removedRemoteReplicas.removeAll(updatedRemoteLeaderReplicas);\n+\n+          for (ReplicaId remoteReplica : addedRemoteReplicas) {\n+            // for now, we are just logging the newly found remote leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Adding new remote leader {} for Partition {} to replicate from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),\n+                partitionName, remoteReplica.getDataNodeId().getDatacenterName());\n+          }\n+\n+          //remove replicaInfo from existing partitionInfo and replica-threads\n+          List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+          for (ReplicaId remoteReplica : removedRemoteReplicas) {\n+            // for now, we are just logging the old leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Removing old remote leader {} for Partition {} from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MjI2Nw==", "bodyText": "why we need to check if peerLeaderReplicasByPartition contains partitionName? I feel  it's unnecessary.", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r427762267", "createdAt": "2020-05-20T06:09:37Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -386,33 +451,45 @@ public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     public void onPartitionBecomeLeaderFromStandby(String partitionName) {\n       logger.info(\"Partition state change notification from Standby to Leader received for partition {}\",\n           partitionName);\n-      //Changes for leader based replication - for now, we just log the list of peer leader replicas\n-      // 1. get replica ID of current node from store manager\n-      ReplicaId localReplica = storeManager.getReplica(partitionName);\n+      // Read-write lock to avoid contention between this thread (where partition is added to the map) and thread calling onRoutingTableUpdate() (where partitions are read and updated).\n+      rwlock1.writeLock().lock();\n+      try {\n+        //Changes for leader based replication - for now, we just log the list of peer leader replicas\n+        // 1. get replica ID of current node from store manager\n+        ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+        // 2. Get the peer leader replicas from all data centers for this partition\n+        List<? extends ReplicaId> leaderReplicas =\n+            localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n \n-      // 2. Get the peer leader replicas from all data centers for this partition\n-      List<? extends ReplicaId> leaderReplicas =\n-          localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n-\n-      // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n-      List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n-      for (ReplicaId leaderReplica : leaderReplicas) {\n-        if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n-          peerLeaderReplicas.add(leaderReplica);\n-          logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n-              getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n-              leaderReplica.getDataNodeId().getDatacenterName());\n+        // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+        List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+        for (ReplicaId leaderReplica : leaderReplicas) {\n+          if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+            peerLeaderReplicas.add(leaderReplica);\n+            logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+                getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+                leaderReplica.getDataNodeId().getDatacenterName());\n+          }\n         }\n+        peerLeaderReplicasByPartition.put(partitionName, peerLeaderReplicas);\n+      } finally {\n+        rwlock1.writeLock().unlock();\n       }\n-      peerLeaderReplicasByPartition.put(partitionName, peerLeaderReplicas);\n     }\n \n     @Override\n     public void onPartitionBecomeStandbyFromLeader(String partitionName) {\n       logger.info(\"Partition state change notification from Leader to Standby received for partition {}\",\n           partitionName);\n-      if (peerLeaderReplicasByPartition.containsKey(partitionName)) {\n-        peerLeaderReplicasByPartition.remove((partitionName));\n+      // Read-write lock to avoid contention between this thread (where partition are removed from the map) and thread calling onRoutingTableUpdate() (where partitions are read and updated to map).\n+      rwlock1.writeLock().lock();\n+      try {\n+        if (peerLeaderReplicasByPartition.containsKey(partitionName)) {\n+          peerLeaderReplicasByPartition.remove((partitionName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDk2Mzc1", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-415496375", "createdAt": "2020-05-20T16:11:48Z", "commit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMTo0OFrOGYTVuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMTo0OFrOGYTVuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzNTg2Nw==", "bodyText": "replicaInfosToRemove is never used, is this for future pr?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r428135867", "createdAt": "2020-05-20T16:11:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)\n+              .stream()\n+              .filter(r -> !r.getDataNodeId().getDatacenterName().equals(dataNodeId.getDatacenterName()))\n+              .collect(Collectors.toList());\n+\n+          //Collect the set of new remote leader replicas\n+          Set<ReplicaId> addedRemoteReplicas = new HashSet<>(updatedRemoteLeaderReplicas);\n+          addedRemoteReplicas.removeAll(currentRemoteLeaderReplicas);\n+\n+          //Collect the set of old remote leader replicas\n+          Set<ReplicaId> removedRemoteReplicas = new HashSet<>(currentRemoteLeaderReplicas);\n+          removedRemoteReplicas.removeAll(updatedRemoteLeaderReplicas);\n+\n+          for (ReplicaId remoteReplica : addedRemoteReplicas) {\n+            // for now, we are just logging the newly found remote leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Adding new remote leader {} for Partition {} to replicate from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),\n+                partitionName, remoteReplica.getDataNodeId().getDatacenterName());\n+          }\n+\n+          //remove replicaInfo from existing partitionInfo and replica-threads\n+          List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDk3NzIw", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-415497720", "createdAt": "2020-05-20T16:13:23Z", "commit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMzoyM1rOGYTaCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoxMzoyM1rOGYTaCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzNjk3MQ==", "bodyText": "I know in current PR, peerLeaderReplicasByPartition is only updated but not really used. In future PR, will it be passed into ReplicaThread?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r428136971", "createdAt": "2020-05-20T16:13:23Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +333,69 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {\n+      // This method is used to update the list of remote leaders used for 'Leader Based replication' model.\n+      // Below are the actions performed in this method:\n+      // 1. For each leader partition in the peerLeaderReplicasByPartition map, we do the following:\n+      // 2. Compare the list of existing remote leaders with the new list obtained from routingtablesnapshot and collect sets of added leaders and removed leaders\n+      // 3. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders\n+      // 4. Update the Replica state (going to be maintained in RemoteReplicaInfo class) of old remote leaders\n+\n+      // Read-write lock here avoids contention between this method and onPartitionBecomeLeaderFromStandby()/onPartitionBecomeStandbyFromLeader() (where leader partitions are added and removed from the map peerLeaderReplicasByPartition).\n+      // Read lock (for threads belonging to different cluster change handlers) is sufficient here because of following reasons:\n+      // 1. We are only updating the existing partitions (not adding or removing) in the 'peerLeaderReplicasByPartition' map. Since, it is a concurrent hash map, PUTs and GETs are clean.\n+      // 2. Updating of Replica state (going to be maintained in RemoteReplicaInfo class) of newly found remote leaders and old leaders will be synchronized in RemoteReplicaInfo class.\n+\n+      rwlock1.readLock().lock();\n+      try {\n+        for (String partitionName : peerLeaderReplicasByPartition.keySet()) {\n+          ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+          PartitionId partition = localLeaderReplica.getPartitionId();\n+          List<ReplicaId> currentRemoteLeaderReplicas = peerLeaderReplicasByPartition.get(partitionName);\n+          List<ReplicaId> updatedRemoteLeaderReplicas = partition.getReplicaIdsByState(ReplicaState.LEADER, null)\n+              .stream()\n+              .filter(r -> !r.getDataNodeId().getDatacenterName().equals(dataNodeId.getDatacenterName()))\n+              .collect(Collectors.toList());\n+\n+          //Collect the set of new remote leader replicas\n+          Set<ReplicaId> addedRemoteReplicas = new HashSet<>(updatedRemoteLeaderReplicas);\n+          addedRemoteReplicas.removeAll(currentRemoteLeaderReplicas);\n+\n+          //Collect the set of old remote leader replicas\n+          Set<ReplicaId> removedRemoteReplicas = new HashSet<>(currentRemoteLeaderReplicas);\n+          removedRemoteReplicas.removeAll(updatedRemoteLeaderReplicas);\n+\n+          for (ReplicaId remoteReplica : addedRemoteReplicas) {\n+            // for now, we are just logging the newly found remote leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Adding new remote leader {} for Partition {} to replicate from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),\n+                partitionName, remoteReplica.getDataNodeId().getDatacenterName());\n+          }\n+\n+          //remove replicaInfo from existing partitionInfo and replica-threads\n+          List<RemoteReplicaInfo> replicaInfosToRemove = new ArrayList<>();\n+          for (ReplicaId remoteReplica : removedRemoteReplicas) {\n+            // for now, we are just logging the old leader replicas\n+            // we will update the Replica state (going to be maintained in RemoteReplicaInfo object) of the relevant remote replicas in later PRs\n+            logger.info(\"Removing old remote leader {} for Partition {} from dc {}\",\n+                getInstanceName(remoteReplica.getDataNodeId().getHostname(), remoteReplica.getDataNodeId().getPort()),\n+                partitionName, remoteReplica.getDataNodeId().getDatacenterName());\n+          }\n+\n+          peerLeaderReplicasByPartition.put(partitionName, updatedRemoteLeaderReplicas);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c343a1661f00539cdc79ba691c3c90666e45dc89"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjQwNTA2", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-416640506", "createdAt": "2020-05-22T04:28:26Z", "commit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNDoyODoyNlrOGZKUSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNToyMDo1MlrOGZK_ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNjYxOQ==", "bodyText": "Any reason to make it protected? Can we change it to private static, something like this:\n  private static final Logger logger = LoggerFactory.getLogger(PartitionLeaderInfo.class);", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429036619", "createdAt": "2020-05-22T04:28:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition;\n+  protected final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNjg0OA==", "bodyText": "minor: can remove this and directly initialize it at line 41", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429036848", "createdAt": "2020-05-22T04:29:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition;\n+  protected final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzODA3MA==", "bodyText": "Can you elaborate a little more about purpose of this method? It's never used in current pr, I assume it'll be called in future PR.", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429038070", "createdAt": "2020-05-22T04:35:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition;\n+  protected final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+    this.storeManager = storeManager;\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // 2. Get the peer leader replicas from all data centers for this partition\n+    List<? extends ReplicaId> leaderReplicas =\n+        localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+    // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+    List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+    for (ReplicaId leaderReplica : leaderReplicas) {\n+      if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+        peerLeaderReplicas.add(leaderReplica);\n+        logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+            getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+            leaderReplica.getDataNodeId().getDatacenterName());\n+      }\n+    }\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.put(partitionName, new HashSet<>(peerLeaderReplicas));\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove a partition from the map of leader partitions. This method is thread safe.\n+   * @param partitionName name of the partition to be removed\n+   */\n+  public void removePartition(String partitionName) {\n+    // Read-write lock avoids contention from threads adding new leaders (addPartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.remove(partitionName);\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the list of remote leaders for all leader partitions (by looking at latest leader set in RoutingTableSnapshot). This method is thread safe.\n+   */\n+  public void refreshPeerLeadersForAllPartitions() {\n+\n+    // Read-write lock usage:\n+    // Avoids contention with threads adding new leaders (in addPeerLeadersByPartition()) and removing old leaders (in removePartition()).\n+    // Multiple threads can call this method in parallel as we only update existing partitions (no adding or removing). Since, it is a concurrent hash map, PUTs and GETs will be clean.\n+\n+    rwLock.readLock().lock();\n+    try {\n+      for (Map.Entry<String, Set<ReplicaId>> entry : peerLeaderReplicasByPartition.entrySet()) {\n+        String partitionName = entry.getKey();\n+        ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+        PartitionId partition = localLeaderReplica.getPartitionId();\n+        Set<ReplicaId> previousRemoteLeaderReplicas = entry.getValue();\n+        Set<ReplicaId> currentRemoteLeaderReplicas =\n+            new HashSet<>(partition.getReplicaIdsByState(ReplicaState.LEADER, null));\n+        currentRemoteLeaderReplicas.remove(localLeaderReplica);\n+        if (!previousRemoteLeaderReplicas.equals(currentRemoteLeaderReplicas)) {\n+          peerLeaderReplicasByPartition.put(partitionName, currentRemoteLeaderReplicas);\n+        }\n+      }\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Checks if a partition is a leader\n+   * @param partitionName\n+   * @return true if partition is a leader; else, it returns false\n+   */\n+  public boolean isPartitionPresent(String partitionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NTU4OQ==", "bodyText": "There will be race condition if we use read-lock here.  Following is an example(leader):\nremote DC1           remote DC2\nT1:        R1(R2, R3)             R4(R5, R6)\nT2:       R2 (R1, R3)             R4(R5, R6)           ---> current remote leader replica (R2, R4)\nT3:       R2 (R1, R3)             R5(R4, R6).          ---> current remote leader replica (R2, R5)\nIt's possible (R2, R5) get in first and then be overridden to (R2, R4)", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429045589", "createdAt": "2020-05-22T05:12:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition;\n+  protected final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+    this.storeManager = storeManager;\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // 2. Get the peer leader replicas from all data centers for this partition\n+    List<? extends ReplicaId> leaderReplicas =\n+        localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+    // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+    List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+    for (ReplicaId leaderReplica : leaderReplicas) {\n+      if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+        peerLeaderReplicas.add(leaderReplica);\n+        logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+            getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+            leaderReplica.getDataNodeId().getDatacenterName());\n+      }\n+    }\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.put(partitionName, new HashSet<>(peerLeaderReplicas));\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove a partition from the map of leader partitions. This method is thread safe.\n+   * @param partitionName name of the partition to be removed\n+   */\n+  public void removePartition(String partitionName) {\n+    // Read-write lock avoids contention from threads adding new leaders (addPartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.remove(partitionName);\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the list of remote leaders for all leader partitions (by looking at latest leader set in RoutingTableSnapshot). This method is thread safe.\n+   */\n+  public void refreshPeerLeadersForAllPartitions() {\n+\n+    // Read-write lock usage:\n+    // Avoids contention with threads adding new leaders (in addPeerLeadersByPartition()) and removing old leaders (in removePartition()).\n+    // Multiple threads can call this method in parallel as we only update existing partitions (no adding or removing). Since, it is a concurrent hash map, PUTs and GETs will be clean.\n+\n+    rwLock.readLock().lock();\n+    try {\n+      for (Map.Entry<String, Set<ReplicaId>> entry : peerLeaderReplicasByPartition.entrySet()) {\n+        String partitionName = entry.getKey();\n+        ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+        PartitionId partition = localLeaderReplica.getPartitionId();\n+        Set<ReplicaId> previousRemoteLeaderReplicas = entry.getValue();\n+        Set<ReplicaId> currentRemoteLeaderReplicas =\n+            new HashSet<>(partition.getReplicaIdsByState(ReplicaState.LEADER, null));\n+        currentRemoteLeaderReplicas.remove(localLeaderReplica);\n+        if (!previousRemoteLeaderReplicas.equals(currentRemoteLeaderReplicas)) {\n+          peerLeaderReplicasByPartition.put(partitionName, currentRemoteLeaderReplicas);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NzY1OA==", "bodyText": "I assume this will be called by replica thread. My question is how frequently it is called?  Do we need to get full snapshot of peerLeaderReplicasByPartition\uff1f", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429047658", "createdAt": "2020-05-22T05:20:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition;\n+  protected final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+    this.storeManager = storeManager;\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f28d49efb53485cdd766ffd26fd2c7113b1c511", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/8f28d49efb53485cdd766ffd26fd2c7113b1c511", "committedDate": "2020-05-22T20:38:08Z", "message": "Changes to notify replication manager of routing table updates in cluster map. Added new onRoutingTableChange() method in clusterMapChangeListener."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a845420ad80cd2422d0b2a4dfc9d13d88b08b8d", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/2a845420ad80cd2422d0b2a4dfc9d13d88b08b8d", "committedDate": "2020-05-22T20:38:08Z", "message": "Adding test for checking peerLeadersByPartition map is updated correctly in Replication manager on routing table updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41076009735c9c339bdbfcd7385144626e226669", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/41076009735c9c339bdbfcd7385144626e226669", "committedDate": "2020-05-22T20:38:08Z", "message": "Make onRoutingTableChange() in ClusterMapChangeListener as default to remove dependency on implementation in CloudServiceClusterChangeHandler and PartitionSelectionHelper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4f36e0270f655f5e6595ea2ec52c44c72b92790", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/e4f36e0270f655f5e6595ea2ec52c44c72b92790", "committedDate": "2020-05-22T20:38:08Z", "message": "Correct typo in previous commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b09dcb65442cbb0c3534fb9ff297858be4f517b", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/1b09dcb65442cbb0c3534fb9ff297858be4f517b", "committedDate": "2020-05-22T20:38:08Z", "message": "Move peerLeaderReplicasByPartition in-mem map inside a new class PartitionLeaderInfo to synchronize access between ReplicationManager and ReplicaThreads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a", "committedDate": "2020-05-22T20:38:08Z", "message": "Use write lock while refreshing the remote leader replica set in PartitionLeaderInfo"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/4f835ebb3dd5c9916fa2e7b291d3b38c1b47cb9a", "committedDate": "2020-05-22T00:40:59Z", "message": "Move peerLeaderReplicasByPartition in-mem map inside a new class PartitionLeaderInfo to synchronize access between ReplicationManager and ReplicaThreads"}, "afterCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a", "committedDate": "2020-05-22T20:38:08Z", "message": "Use write lock while refreshing the remote leader replica set in PartitionLeaderInfo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjkyNjQ5", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-417292649", "createdAt": "2020-05-23T16:52:57Z", "commit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxNjo1Mjo1N1rOGZqWag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwNToxMzozM1rOGZsswQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTQ1MA==", "bodyText": "we should populate partitionLeaderInfo within constructor of ReplicationManager.\nMake sure partitionLeaderInfo.refreshPeerLeadersForAllPartitions()\nis called after\nclusterMap.registerClusterMapListener(new ClusterMapChangeListenerImpl());", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429561450", "createdAt": "2020-05-23T16:52:57Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationEngine.java", "diffHunk": "@@ -120,7 +120,7 @@ public ReplicationEngine(ReplicationConfig replicationConfig, ClusterMapConfig c\n     this.transformerClassName = transformerClassName;\n     this.storeManager = storeManager;\n     replicaSyncUpManager = clusterParticipant == null ? null : clusterParticipant.getReplicaSyncUpManager();\n-    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+    partitionLeaderInfo = new PartitionLeaderInfo(storeManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTU0Nw==", "bodyText": "Add following piece of code at the beginning of this method, like what we did in onReplicaAddedOrRemoved:\n      // 1. wait for start() to complete\n      try {\n        startupLatch.await();\n      } catch (InterruptedException e) {\n        logger.warn(\"Waiting for startup is interrupted.\");\n        throw new IllegalStateException(\"Replication manager startup is interrupted while handling routing table change\");\n      }", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429561547", "createdAt": "2020-05-23T16:54:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationManager.java", "diffHunk": "@@ -331,6 +320,18 @@ public void onReplicaAddedOrRemoved(List<ReplicaId> addedReplicas, List<ReplicaI\n         }\n       }\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Note that, this method should be thread-safe because multiple threads (from different cluster change handlers) may\n+     * concurrently call this method.\n+     */\n+    @Override\n+    public void onRoutingTableChange() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTYzNg==", "bodyText": "Please refer to https://docs.google.com/document/d/1L2YuQ-2V9kf3QccYK3VOwCni4HfUM3-SUECeh00fpeU/edit for more details regarding \"Handle cluster changes during startup\"", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429561636", "createdAt": "2020-05-23T16:55:54Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/ReplicationEngine.java", "diffHunk": "@@ -120,7 +120,7 @@ public ReplicationEngine(ReplicationConfig replicationConfig, ClusterMapConfig c\n     this.transformerClassName = transformerClassName;\n     this.storeManager = storeManager;\n     replicaSyncUpManager = clusterParticipant == null ? null : clusterParticipant.getReplicaSyncUpManager();\n-    peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+    partitionLeaderInfo = new PartitionLeaderInfo(storeManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTQ1MA=="}, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU5OTgzMw==", "bodyText": "The write lock should be locked ahead of line 67 (before getReplicaIdsByState() is called).  Otherwise there is a race condition to miss remote leadership change.", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429599833", "createdAt": "2020-05-24T05:12:02Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+  private final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private static final Logger logger = LoggerFactory.getLogger(PartitionLeaderInfo.class);\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    this.storeManager = storeManager;\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas (this method is only by ReplicationTest for now)\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // 2. Get the peer leader replicas from all data centers for this partition\n+    List<? extends ReplicaId> leaderReplicas =\n+        localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+    // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+    List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+    for (ReplicaId leaderReplica : leaderReplicas) {\n+      if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+        peerLeaderReplicas.add(leaderReplica);\n+        logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+            getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+            leaderReplica.getDataNodeId().getDatacenterName());\n+      }\n+    }\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU5OTkzNw==", "bodyText": "Just wonder how do we know existingPartition initially has a standby replica on local node?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r429599937", "createdAt": "2020-05-24T05:13:33Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/test/java/com/github/ambry/replication/ReplicationTest.java", "diffHunk": "@@ -436,6 +437,67 @@ public void onReplicaAddedOrRemovedCallbackTest() throws Exception {\n     storageManager.shutdown();\n   }\n \n+  /**\n+   * Test cluster map change callback in {@link ReplicationManager} for routing table updates.\n+   * Test setup: When creating partitions, have one replica in LEADER state and rest in STANDBY states on each data center and\n+   * later switch the states of replicas (LEADER to STANDBY and STANDBY to LEADER) on one of the DCs during the test\n+   * Test condition: When replication manager receives onRoutingTableUpdate() indication after the remote replica states were updated,\n+   * map of partition to peer leader replicas stored in replication manager should be updated correctly\n+   * @throws Exception\n+   */\n+  @Test\n+  public void onRoutingTableUpdateCallbackTest() throws Exception {\n+    MockClusterMap clusterMap = new MockClusterMap();\n+    ClusterMapConfig clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n+    MockHelixParticipant.metricRegistry = new MetricRegistry();\n+    MockHelixParticipant mockHelixParticipant = new MockHelixParticipant(clusterMapConfig);\n+    Pair<StorageManager, ReplicationManager> managers =\n+        createStorageManagerAndReplicationManager(clusterMap, clusterMapConfig, mockHelixParticipant);\n+    StorageManager storageManager = managers.getFirst();\n+    MockReplicationManager replicationManager = (MockReplicationManager) managers.getSecond();\n+    MockPartitionId existingPartition =\n+        (MockPartitionId) replicationManager.partitionToPartitionInfo.keySet().iterator().next();\n+    String currentDataCenter =\n+        storageManager.getReplica(existingPartition.toString()).getDataNodeId().getDatacenterName();\n+\n+    //Trigger PartitionStateChangeListener callback to replication manager to notify that a local replica state has changed from STANDBY to LEADER\n+    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(existingPartition.toPathString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "101c17c35420bc6b2062568bbc3374d34ff8f2cd", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/101c17c35420bc6b2062568bbc3374d34ff8f2cd", "committedDate": "2020-05-27T00:11:21Z", "message": "Add safety latch in onRoutingTableChange() to wait until replication manager starts before processing any routing table updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjE5NTMx", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-418619531", "createdAt": "2020-05-26T19:35:38Z", "commit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTozNTozOVrOGatUUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMjo1MToyM1rOGa3sIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1ODY0Mw==", "bodyText": "maybe this class and its methods can be package-private (public class -> class)?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r430658643", "createdAt": "2020-05-26T19:35:39Z", "author": {"login": "cgtz"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46f82e06fbc3c278f0f30f18ce552a2cb9a5eb0a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgxOTg0Mw==", "bodyText": "How about making peerLeaderReplicas into a HashSet so that it doesn't have to be copied into a set on line 88?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r430819843", "createdAt": "2020-05-27T02:16:16Z", "author": {"login": "cgtz"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+  private final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private static final Logger logger = LoggerFactory.getLogger(PartitionLeaderInfo.class);\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    this.storeManager = storeManager;\n+\n+    // We can't initialize the peerLeaderReplicasByPartition here because we don't know the leader partitions on local node (server) until it has finished participating with Helix.\n+    // peerLeaderReplicasByPartition map will be updated after server participates with Helix and state of replicas transition to LEADER (via onPartitionBecomeLeaderFromStandby())\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas (this method is only by ReplicationTest for now)\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      // 2. Get the peer leader replicas from all data centers for this partition\n+      List<? extends ReplicaId> leaderReplicas =\n+          localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+      // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+      List<ReplicaId> peerLeaderReplicas = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "101c17c35420bc6b2062568bbc3374d34ff8f2cd"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNzYyNg==", "bodyText": "How will this method be used?", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r430827626", "createdAt": "2020-05-27T02:47:33Z", "author": {"login": "cgtz"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+  private final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private static final Logger logger = LoggerFactory.getLogger(PartitionLeaderInfo.class);\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    this.storeManager = storeManager;\n+\n+    // We can't initialize the peerLeaderReplicasByPartition here because we don't know the leader partitions on local node (server) until it has finished participating with Helix.\n+    // peerLeaderReplicasByPartition map will be updated after server participates with Helix and state of replicas transition to LEADER (via onPartitionBecomeLeaderFromStandby())\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas (this method is only by ReplicationTest for now)\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      // 2. Get the peer leader replicas from all data centers for this partition\n+      List<? extends ReplicaId> leaderReplicas =\n+          localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+      // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+      List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+      for (ReplicaId leaderReplica : leaderReplicas) {\n+        if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+          peerLeaderReplicas.add(leaderReplica);\n+          logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+              getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+              leaderReplica.getDataNodeId().getDatacenterName());\n+        }\n+      }\n+\n+      peerLeaderReplicasByPartition.put(partitionName, new HashSet<>(peerLeaderReplicas));\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove a partition from the map of leader partitions. This method is thread safe.\n+   * @param partitionName name of the partition to be removed\n+   */\n+  public void removePartition(String partitionName) {\n+    // Read-write lock avoids contention from threads adding new leaders (addPartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.remove(partitionName);\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the list of remote leaders for all leader partitions by querying the latest information from RoutingTableSnapshots of all data centers.\n+   * This method is thread safe.\n+   */\n+  public void refreshPeerLeadersForAllPartitions() {\n+\n+    // Read-write lock usage: Avoids contention between threads doing the following activities:\n+    // 1. Adding new leaders (in addPeerLeadersByPartition())\n+    // 2. Removing old leaders (in removePartition())\n+    // 3. Refreshing remote leader set for existing leaders (current method).\n+    // Explanation for point 3: Multiple threads from different cluster change handlers (we have one cluster change handler for each DC) can trigger onRoutingTableUpdate() in parallel which calls this method to refresh leader partitions.\n+    // We need to make sure that the sequence of gathering remote leaders (from RoutingTableSnapshot of each DC) and updating the map is an atomic operation.\n+\n+    rwLock.writeLock().lock();\n+    try {\n+      for (Map.Entry<String, Set<ReplicaId>> entry : peerLeaderReplicasByPartition.entrySet()) {\n+        String partitionName = entry.getKey();\n+        ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+        PartitionId partition = localLeaderReplica.getPartitionId();\n+        Set<ReplicaId> previousRemoteLeaderReplicas = entry.getValue();\n+        Set<ReplicaId> currentRemoteLeaderReplicas =\n+            new HashSet<>(partition.getReplicaIdsByState(ReplicaState.LEADER, null));\n+        currentRemoteLeaderReplicas.remove(localLeaderReplica);\n+        if (!previousRemoteLeaderReplicas.equals(currentRemoteLeaderReplicas)) {\n+          peerLeaderReplicasByPartition.put(partitionName, currentRemoteLeaderReplicas);\n+        }\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Checks if a remote replica is a leader for a partition (Pre-requisite: the partition itself should be a leader locally).\n+   * @param partitionName name of local leader partition\n+   * @param replicaId remote replica to be checked\n+   * @return true if remote replica is a leader for a partition (Pre-requisite: the partition itself should be a leader locally).\n+   */\n+  public boolean isPeerReplicaLeaderForPartition(String partitionName, ReplicaId replicaId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "101c17c35420bc6b2062568bbc3374d34ff8f2cd"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyODU3OA==", "bodyText": "nit: to collapse two map lookups into one, you can change this to:\nSet<ReplicaId> peerLeaders = peerLeaderReplicasByPartition.get(partitionName);\nreturn peerLeaders != null && peerLeaders.contains(replicaId);\nor\nreturn peerLeaders.getOrDefault(partitionName, Collections.emptySet()).contains(replicaId);", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r430828578", "createdAt": "2020-05-27T02:51:23Z", "author": {"login": "cgtz"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+\n+\n+/**\n+ * Maintains the list of leader partitions on local node and their corresponding peer leaders in remote data centers\n+ */\n+public class PartitionLeaderInfo {\n+\n+  private final Map<String, Set<ReplicaId>> peerLeaderReplicasByPartition = new ConcurrentHashMap<>();\n+  private final StoreManager storeManager;\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private static final Logger logger = LoggerFactory.getLogger(PartitionLeaderInfo.class);\n+\n+  public PartitionLeaderInfo(StoreManager storeManager) {\n+    this.storeManager = storeManager;\n+\n+    // We can't initialize the peerLeaderReplicasByPartition here because we don't know the leader partitions on local node (server) until it has finished participating with Helix.\n+    // peerLeaderReplicasByPartition map will be updated after server participates with Helix and state of replicas transition to LEADER (via onPartitionBecomeLeaderFromStandby())\n+  }\n+\n+  /**\n+   * Get a map of partitions to their sets of peer leader replicas (this method is only by ReplicationTest for now)\n+   * @return an unmodifiable map of peer leader replicas stored by partition {@link PartitionLeaderInfo#peerLeaderReplicasByPartition}\n+   */\n+  public Map<String, Set<ReplicaId>> getPeerLeaderReplicasByPartition() {\n+    return Collections.unmodifiableMap(peerLeaderReplicasByPartition);\n+  }\n+\n+  /**\n+   * Add a leader partition and its set of peer leader replicas. This method is thread safe.\n+   * @param partitionName name of the partition to be added\n+   */\n+  public void addPartition(String partitionName) {\n+\n+    // 1. get local replica from store manager\n+    ReplicaId localReplica = storeManager.getReplica(partitionName);\n+\n+    // Read-write lock avoids contention from threads removing old leader partitions (removePartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      // 2. Get the peer leader replicas from all data centers for this partition\n+      List<? extends ReplicaId> leaderReplicas =\n+          localReplica.getPartitionId().getReplicaIdsByState(ReplicaState.LEADER, null);\n+\n+      // 3. Log the list of leader replicas associated with this partition (will be used later for leadership based replication)\n+      List<ReplicaId> peerLeaderReplicas = new ArrayList<>();\n+      for (ReplicaId leaderReplica : leaderReplicas) {\n+        if (leaderReplica.getDataNodeId() != localReplica.getDataNodeId()) {\n+          peerLeaderReplicas.add(leaderReplica);\n+          logger.info(\"Partition {} on node instance {} is leader in remote dc {}\", partitionName,\n+              getInstanceName(leaderReplica.getDataNodeId().getHostname(), leaderReplica.getDataNodeId().getPort()),\n+              leaderReplica.getDataNodeId().getDatacenterName());\n+        }\n+      }\n+\n+      peerLeaderReplicasByPartition.put(partitionName, new HashSet<>(peerLeaderReplicas));\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove a partition from the map of leader partitions. This method is thread safe.\n+   * @param partitionName name of the partition to be removed\n+   */\n+  public void removePartition(String partitionName) {\n+    // Read-write lock avoids contention from threads adding new leaders (addPartition()) and threads updating existing leader partitions (refreshPeerLeadersForAllPartitions())\n+    rwLock.writeLock().lock();\n+    try {\n+      peerLeaderReplicasByPartition.remove(partitionName);\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Refreshes the list of remote leaders for all leader partitions by querying the latest information from RoutingTableSnapshots of all data centers.\n+   * This method is thread safe.\n+   */\n+  public void refreshPeerLeadersForAllPartitions() {\n+\n+    // Read-write lock usage: Avoids contention between threads doing the following activities:\n+    // 1. Adding new leaders (in addPeerLeadersByPartition())\n+    // 2. Removing old leaders (in removePartition())\n+    // 3. Refreshing remote leader set for existing leaders (current method).\n+    // Explanation for point 3: Multiple threads from different cluster change handlers (we have one cluster change handler for each DC) can trigger onRoutingTableUpdate() in parallel which calls this method to refresh leader partitions.\n+    // We need to make sure that the sequence of gathering remote leaders (from RoutingTableSnapshot of each DC) and updating the map is an atomic operation.\n+\n+    rwLock.writeLock().lock();\n+    try {\n+      for (Map.Entry<String, Set<ReplicaId>> entry : peerLeaderReplicasByPartition.entrySet()) {\n+        String partitionName = entry.getKey();\n+        ReplicaId localLeaderReplica = storeManager.getReplica(partitionName);\n+        PartitionId partition = localLeaderReplica.getPartitionId();\n+        Set<ReplicaId> previousRemoteLeaderReplicas = entry.getValue();\n+        Set<ReplicaId> currentRemoteLeaderReplicas =\n+            new HashSet<>(partition.getReplicaIdsByState(ReplicaState.LEADER, null));\n+        currentRemoteLeaderReplicas.remove(localLeaderReplica);\n+        if (!previousRemoteLeaderReplicas.equals(currentRemoteLeaderReplicas)) {\n+          peerLeaderReplicasByPartition.put(partitionName, currentRemoteLeaderReplicas);\n+        }\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Checks if a remote replica is a leader for a partition (Pre-requisite: the partition itself should be a leader locally).\n+   * @param partitionName name of local leader partition\n+   * @param replicaId remote replica to be checked\n+   * @return true if remote replica is a leader for a partition (Pre-requisite: the partition itself should be a leader locally).\n+   */\n+  public boolean isPeerReplicaLeaderForPartition(String partitionName, ReplicaId replicaId) {\n+    rwLock.readLock().lock();\n+    try {\n+      return peerLeaderReplicasByPartition.containsKey(partitionName) && peerLeaderReplicasByPartition.get(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "101c17c35420bc6b2062568bbc3374d34ff8f2cd"}, "originalPosition": 149}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50010713de5d43efedf0727586c2a90d909d6a3f", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/50010713de5d43efedf0727586c2a90d909d6a3f", "committedDate": "2020-05-27T03:56:58Z", "message": "Making PartitionLeaderInfo to package-private and collapsing two map lookups to one"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODU2MzA0", "url": "https://github.com/linkedin/ambry/pull/1518#pullrequestreview-418856304", "createdAt": "2020-05-27T04:55:55Z", "commit": {"oid": "50010713de5d43efedf0727586c2a90d909d6a3f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDo1NTo1NVrOGa5Zxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDo1NTo1NVrOGa5Zxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NjY0Ng==", "bodyText": "minor: can be removed", "url": "https://github.com/linkedin/ambry/pull/1518#discussion_r430856646", "createdAt": "2020-05-27T04:55:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-replication/src/main/java/com/github/ambry/replication/PartitionLeaderInfo.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.clustermap.ReplicaState;\n+import com.github.ambry.server.StoreManager;\n+import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50010713de5d43efedf0727586c2a90d909d6a3f"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8c28c4202794996b0f69f310ce0778beef47fe5", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/f8c28c4202794996b0f69f310ce0778beef47fe5", "committedDate": "2020-05-27T05:11:20Z", "message": "Minor: removed unused import package"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1487, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}