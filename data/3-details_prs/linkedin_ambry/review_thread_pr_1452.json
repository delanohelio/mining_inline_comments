{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MzY1MTYw", "number": 1452, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDozNDo1MVrODvWseA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MzozNlrODvWyvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgxNDk2OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDozNDo1MVrOGBu1Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDozNDo1MVrOGBu1Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2OTAwMw==", "bodyText": "minor: logger.warn maybe?", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404469003", "createdAt": "2020-04-07T00:34:51Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java", "diffHunk": "@@ -333,7 +333,8 @@ private void addOrUpdateInstanceInfos(List<InstanceConfig> instanceConfigs) thro\n       Map<String, String> diskInfo = entry.getValue();\n       AmbryDisk disk = mountPathToDisk.getOrDefault(mountPath, null);\n       if (disk == null) {\n-        logger.info(\"Temporarily don't support adding new disk to existing node.\");\n+        logger.info(\"{} is a new disk or unrecognizable disk which is not supported on existing node {}.\", mountPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgyNTcyOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MDo0NlrOGBu7dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MDo0NlrOGBu7dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDY0Nw==", "bodyText": "For all the metrics related changes in this file, it might be cleaner to update the participantMetrics in finally block.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470647", "createdAt": "2020-04-07T00:40:46Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgyNjEzOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MTowMVrOGBu7tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MTowMVrOGBu7tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDcxMQ==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470711", "createdAt": "2020-04-07T00:41:01Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.bootstrapCount.addAndGet(-1);\n+    participantMetrics.standbyCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeLeaderFromStandby(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.standbyCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgyNjI2OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MTowN1rOGBu7zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MTowN1rOGBu7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDczMw==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470733", "createdAt": "2020-04-07T00:41:07Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.bootstrapCount.addAndGet(-1);\n+    participantMetrics.standbyCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeLeaderFromStandby(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.standbyCount.addAndGet(-1);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);\n+    participantMetrics.leaderCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromLeader(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeStandbyFromLeader(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeStandbyFromLeader(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.leaderCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgyOTcwOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0Mjo1MVrOGBu9ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0Mjo1MVrOGBu9ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTIzNQ==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471235", "createdAt": "2020-04-07T00:42:51Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgyOTg5OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0Mjo1N1rOGBu93w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0Mjo1N1rOGBu93w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTI2Mw==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471263", "createdAt": "2020-04-07T00:42:57Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n-      // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n-      // replicas have caught up with last PUT in local store.\n       try {\n+        replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+        // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n+        // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgzMDcxOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MzoyOVrOGBu-Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MzoyOVrOGBu-Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTM5NQ==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471395", "createdAt": "2020-04-07T00:43:29Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n-      // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n-      // replicas have caught up with last PUT in local store.\n       try {\n+        replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+        // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n+        // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);\n+    participantMetrics.inactiveCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeOfflineFromInactive(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      // 1. take actions in replication manager\n-      //    (1) set local store state to OFFLINE\n-      //    (2) initiate disconnection in ReplicaSyncUpManager\n-      replicationManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n-      // 2. wait until peer replicas have caught up with local replica\n       try {\n+        // 1. take actions in replication manager\n+        //    (1) set local store state to OFFLINE\n+        //    (2) initiate disconnection in ReplicaSyncUpManager\n+        replicationManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+        // 2. wait until peer replicas have caught up with local replica\n         // TODO considering moving wait disconnection logic into replication manager listener\n         replicaSyncUpManager.waitDisconnectionCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Disconnection was interrupted on partition {}\", partitionName);\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Disconnection failed or was interrupted\", DisconnectionFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Disconnection didn't complete \", e);\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n     // 3. take actions in storage manager (stop the store and update instanceConfig)\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n+    participantMetrics.inactiveCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTgzMTAyOnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MzozNlrOGBu-kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDo0MzozNlrOGBu-kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTQ0MA==", "bodyText": "see above about finally.", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471440", "createdAt": "2020-04-07T00:43:36Z", "author": {"login": "ankagrawal"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -576,7 +639,32 @@ public void onPartitionBecomeDroppedFromOffline(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeDroppedFromOffline(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeDroppedFromOffline(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.offlineCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n+    participantMetrics.offlineCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85"}, "originalPosition": 289}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1458, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}