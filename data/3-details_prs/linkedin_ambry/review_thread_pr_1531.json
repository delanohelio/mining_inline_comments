{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDczNDgw", "number": 1531, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTowMFrOD_zvYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTo0OFrOD_zwYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjM0NTk0OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTowMFrOGasRJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNToxMjozOFrOGa5p2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ0NA==", "bodyText": "when continuation is true, we just try again with the same list of blob IDs. Is the stored procedure idempotent?", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641444", "createdAt": "2020-05-26T19:05:00Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MDc2Mg==", "bodyText": "Yes.  It's idempotent because the sproc first runs the query to get records matching the IN filter, which will simply be smaller if some records have been deleted on prior executions.  Though I was not able to trigger this case during testing, likely because the batch size was small.", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430860762", "createdAt": "2020-05-27T05:12:38Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ0NA=="}, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjM0ODUxOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTowNTo0OFrOGasS0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNToxMzozNVrOGa5qzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTg3NQ==", "bodyText": "does this count include blobs that were already deleted from previous iterations?", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641875", "createdAt": "2020-05-26T19:05:48Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();\n+        requestCharge += response.getRequestCharge();\n+        Document responseDoc = response.getResponseAsDocument();\n+        more = responseDoc.getBoolean(PROPERTY_CONTINUATION);\n+        deleteCount += responseDoc.getInt(PROPERTY_DELETED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MTAwNg==", "bodyText": "It should not.", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430861006", "createdAt": "2020-05-27T05:13:35Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();\n+        requestCharge += response.getRequestCharge();\n+        Document responseDoc = response.getResponseAsDocument();\n+        more = responseDoc.getBoolean(PROPERTY_CONTINUATION);\n+        deleteCount += responseDoc.getInt(PROPERTY_DELETED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTg3NQ=="}, "originalCommit": {"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1615, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}