{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTEwMTQ5", "number": 1358, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjo0MDozNFrODYPRqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTowNDo0OVrODY6QAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzQyNjk2OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjo0MDozNFrOFd-1zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoxMjo1MVrOFeJcyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MjYwNA==", "bodyText": "could you explain the purpose of these constructors? Would the value passed in always be CloudBlobMetadata.class?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982604", "createdAt": "2020-01-15T16:40:34Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NjQyNQ==", "bodyText": "I removed this constructor.  It was in an example I looked at but doesn't seem to be needed here.  I guess it's used for base classes that have multiple derived classes with different serializations?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367156425", "createdAt": "2020-01-15T23:12:51Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MjYwNA=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzQyNzg5OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjo0MDo1MFrOFd-2Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzowNzo1OVrOFeJXZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Mjc1MA==", "bodyText": "what does passing a null type in mean?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982750", "createdAt": "2020-01-15T16:40:50Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTA0Nw==", "bodyText": "The default constructor is required by the Jackson serializer.  The value passed to the super class doesn't seem to be used.  Regardless, I changed it to pass the actual class type.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367155047", "createdAt": "2020-01-15T23:07:59Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Mjc1MA=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzUyNjUzOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzowOTo1NlrOFd_z8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0MDo1MVrOFeEKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5ODUxNA==", "bodyText": "The javadocs for ObjectMapper say that the instance is thread safe and should be reused: https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/ObjectMapper.html. Could you make the ObjectMapper instance private static final?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366998514", "createdAt": "2020-01-15T17:09:56Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2OTc4Mg==", "bodyText": "Yes, forgot to do that.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367069782", "createdAt": "2020-01-15T19:40:51Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5ODUxNA=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzU0NDQ1OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzoxNTo0N1rOFd__Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMzowOTo1M1rOFeqahA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw==", "bodyText": "This also seems a little inefficient that you have to convert to a json node and then iterate through it to go back to the map. I guess the alternative is manually constructing the map, but that has the tradeoff of more duplicate code.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367001427", "createdAt": "2020-01-15T17:15:47Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNTcwNA==", "bodyText": "I changed it to convert directly to a map.  It still does json serialization internally, so not as efficient as handcrafting the map.  But I prefer to avoid handcrafting since it's easy to forget to keep it in sync.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367135704", "createdAt": "2020-01-15T22:14:59Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NjUxNg==", "bodyText": "cool, that TypeReference serializer seems useful.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367696516", "createdAt": "2020-01-16T23:09:53Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzYzMTE3OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MzozM1rOFeA1bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0MTo0NVrOFeEL1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNTI3Ng==", "bodyText": "I wonder if there is any reason to set FIELD_ENCRYPTION_ORIGIN if the value is EncryptionOrigin.ROUTER? I can't think of an immediate need other than being able to write analytics queries to count # of encrypted blobs.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367015276", "createdAt": "2020-01-15T17:43:33Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {\n+        gen.writeNumberField(FIELD_DELETION_TIME, value.deletionTime);\n+      }\n+      if (value.expirationTime > 0) {\n+        gen.writeNumberField(FIELD_EXPIRATION_TIME, value.expirationTime);\n+      }\n+      if (value.namingScheme > 0) {\n+        gen.writeNumberField(FIELD_NAMING_SCHEME, value.namingScheme);\n+      }\n+      // Encryption fields that may or may not apply\n+      if (value.encryptionOrigin == EncryptionOrigin.VCR) {\n+        gen.writeStringField(FIELD_ENCRYPTION_ORIGIN, value.encryptionOrigin.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MDE2Nw==", "bodyText": "Good point, I'll include that.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367070167", "createdAt": "2020-01-15T19:41:45Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {\n+        gen.writeNumberField(FIELD_DELETION_TIME, value.deletionTime);\n+      }\n+      if (value.expirationTime > 0) {\n+        gen.writeNumberField(FIELD_EXPIRATION_TIME, value.expirationTime);\n+      }\n+      if (value.namingScheme > 0) {\n+        gen.writeNumberField(FIELD_NAMING_SCHEME, value.namingScheme);\n+      }\n+      // Encryption fields that may or may not apply\n+      if (value.encryptionOrigin == EncryptionOrigin.VCR) {\n+        gen.writeStringField(FIELD_ENCRYPTION_ORIGIN, value.encryptionOrigin.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNTI3Ng=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzcxNDUwOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoxMjo1M1rOFeBqSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0Mjo0MFrOFeENfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyODgxMQ==", "bodyText": "Instead of adding a new constructor to CloudBlobMetadata just for this purpose, could you just call getClusterAwareAzureContainerName(blobID.getPartitionId().toPathString())?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367028811", "createdAt": "2020-01-15T18:12:53Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,55 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {\n+    return getAzureContainerName(new CloudBlobMetadata(blobId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MDU4OQ==", "bodyText": "I want to make the implementation more flexible, to use partition, account/container, etc.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367070589", "createdAt": "2020-01-15T19:42:40Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,55 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {\n+    return getAzureContainerName(new CloudBlobMetadata(blobId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyODgxMQ=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzcxNjg0OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoxMzozOVrOFeBrwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0Njo0M1rOFeEUhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyOTE4NA==", "bodyText": "Is this constructor only for the getAzureContainerName method?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367029184", "createdAt": "2020-01-15T18:13:39Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -75,6 +97,14 @@\n   public CloudBlobMetadata() {\n   }\n \n+  /**\n+   * Constructor from {@link BlobId}.  All other metadata are ignored.\n+   * @param blobId The BlobId for metadata record.\n+   */\n+  public CloudBlobMetadata(BlobId blobId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjM5MQ==", "bodyText": "Yes, it might be overkill.  I can remove it.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367072391", "createdAt": "2020-01-15T19:46:43Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -75,6 +97,14 @@\n   public CloudBlobMetadata() {\n   }\n \n+  /**\n+   * Constructor from {@link BlobId}.  All other metadata are ignored.\n+   * @param blobId The BlobId for metadata record.\n+   */\n+  public CloudBlobMetadata(BlobId blobId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyOTE4NA=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzg0NjcxOnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo1ODo1MlrOFeC-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo1NzoyOVrOFfAwRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw==", "bodyText": "minor, but it may be worth making these constants into an unmodifiable list so they won't be tampered with.\npublic static final List<String> REQUIRED_FIELDS = Collections.unmodifiableList(Arrays.asList(FIELD_ID, FIELD_ACCOUNT_ID, ...))", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367050333", "createdAt": "2020-01-15T18:58:52Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjcyOA==", "bodyText": "Can a final array be tampered with?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367072728", "createdAt": "2020-01-15T19:47:33Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5ODgzNg==", "bodyText": "Yep, only the reference to the array is immutable but the items inside the array may be changed.\npublic class FinalArray {\n  private static class ArrayHolder {\n    static final String[] ARRAY = {\"a\", \"b\", \"c\"};\n  }\n  public static void main(String[] args) {\n    System.out.println(Arrays.toString(ArrayHolder.ARRAY));\n    ArrayHolder.ARRAY[2] = \"d\";\n    System.out.println(Arrays.toString(ArrayHolder.ARRAY));\n  }\n}\nOutput:\n[a, b, c]\n[a, b, d]", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367698836", "createdAt": "2020-01-16T23:17:11Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MjUzMg==", "bodyText": "Yeah, that's true.  For now, I moved these arrays to the test class since they weren't being used anywhere else.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368062532", "createdAt": "2020-01-17T17:57:29Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzg1MjI2OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTowMDo0OFrOFeDBww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODoxMzowNlrOFfBILw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw==", "bodyText": "should these time fields be >= 0, since technically 0 could be a valid timestamp?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367051203", "createdAt": "2020-01-15T19:00:48Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjA5Nw==", "bodyText": "I don't see any practical use case for 0 to be a valid timestamp.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367136097", "createdAt": "2020-01-15T22:15:51Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2ODY1NQ==", "bodyText": "That is true, unless a time traveler from 1970 uploads a blob. We can keep this as is", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368068655", "createdAt": "2020-01-17T18:13:06Z", "author": {"login": "cgtz"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw=="}, "originalCommit": {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDQzODk4OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1MzozMVrOFfCIMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1MzozMVrOFfCIMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTA0MQ==", "bodyText": "javadocs missing.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085041", "createdAt": "2020-01-17T18:53:31Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDQ0MTk3OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1NDozOVrOFfCKCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1NDozOVrOFfCKCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTUxNQ==", "bodyText": "javadocs missing.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085515", "createdAt": "2020-01-17T18:54:39Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {\n+    return namingScheme;\n   }\n \n-  /**\n-   * Sets blob's name in cloud.\n-   * @param cloudBlobName the blob's name in cloud.\n-   * @return this instance.\n-   */\n-  public CloudBlobMetadata setCloudBlobName(String cloudBlobName) {\n-    this.cloudBlobName = cloudBlobName;\n+  public CloudBlobMetadata setNamingScheme(int namingScheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDQ0OTA0OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo1NzoxNlrOFfCOcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjowMjozMFrOFfGYhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NjY0Mw==", "bodyText": "what does namingScheme represent?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368086643", "createdAt": "2020-01-17T18:57:16Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -43,12 +63,12 @@\n   private long size;\n   private int accountId;\n   private int containerId;\n-  private long expirationTime;\n-  private long deletionTime;\n-  private EncryptionOrigin encryptionOrigin;\n+  private long expirationTime = Utils.Infinite_Time;\n+  private long deletionTime = Utils.Infinite_Time;\n+  private int namingScheme = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1NDc1OA==", "bodyText": "Renaming to nameSchemeVersion.  It's the version of the scheme used to derive the blob name in Azure storage.  Version 0 (default) will be the scheme we use now.  It lets us remove cloudBlobName from the metadata record which take up a lot of space.", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368154758", "createdAt": "2020-01-17T22:02:30Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -43,12 +63,12 @@\n   private long size;\n   private int accountId;\n   private int containerId;\n-  private long expirationTime;\n-  private long deletionTime;\n-  private EncryptionOrigin encryptionOrigin;\n+  private long expirationTime = Utils.Infinite_Time;\n+  private long deletionTime = Utils.Infinite_Time;\n+  private int namingScheme = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NjY0Mw=="}, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDQ2Nzg1OnYy", "diffSide": "RIGHT", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTowNDo0OVrOFfCaJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMjowMDo1N1rOFfGWrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4OTYzNw==", "bodyText": "Looks like we are passing blobid to this method now (instead of partitionID as earlier), and then creating CloudBlobMetadata object out of it, but only really using partitionId eventually. Unless I missed something, do we really need these changes?", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368089637", "createdAt": "2020-01-17T19:04:49Z", "author": {"login": "ankagrawal"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,56 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1NDI4NQ==", "bodyText": "This is to support deriving the Azure container name from either the blob's partition (for backup) or the account/container (for live).", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368154285", "createdAt": "2020-01-17T22:00:57Z", "author": {"login": "lightningrob"}, "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,56 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4OTYzNw=="}, "originalCommit": {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1651, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}