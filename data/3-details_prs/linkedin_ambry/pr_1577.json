{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5NTQ1NzU3", "number": 1577, "title": "Use DataNodeConfigSource in participant", "bodyText": "Use DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready.", "createdAt": "2020-06-24T22:11:06Z", "url": "https://github.com/linkedin/ambry/pull/1577", "merged": true, "mergeCommit": {"oid": "89871657c20e68a4784995db953bd578c24a7c8a"}, "closed": true, "closedAt": "2020-07-21T01:45:47Z", "author": {"login": "cgtz"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuhm6TABqjM0Nzk1OTIxMjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc28LFMAFqTQ1MjA2OTQzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3a4a264aac344d231ec11072e9f01a75fa50a85", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/b3a4a264aac344d231ec11072e9f01a75fa50a85", "committedDate": "2020-06-24T22:07:08Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}, "afterCommit": {"oid": "722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "committedDate": "2020-06-24T22:15:51Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "committedDate": "2020-06-24T22:15:51Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}, "afterCommit": {"oid": "e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "committedDate": "2020-07-01T00:37:04Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "committedDate": "2020-07-01T00:37:04Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}, "afterCommit": {"oid": "403650eac329d767ad651d9a2e13a9e4328ac7c4", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/403650eac329d767ad651d9a2e13a9e4328ac7c4", "committedDate": "2020-07-13T17:21:14Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "403650eac329d767ad651d9a2e13a9e4328ac7c4", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/403650eac329d767ad651d9a2e13a9e4328ac7c4", "committedDate": "2020-07-13T17:21:14Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits."}, "afterCommit": {"oid": "684a4f90a115b29110839b5529a6534f80677cd1", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/684a4f90a115b29110839b5529a6534f80677cd1", "committedDate": "2020-07-16T21:34:34Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "684a4f90a115b29110839b5529a6534f80677cd1", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/684a4f90a115b29110839b5529a6534f80677cd1", "committedDate": "2020-07-16T21:34:34Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}, "afterCommit": {"oid": "5a8c5e329053687b3569f64e3306666982bd25e1", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/5a8c5e329053687b3569f64e3306666982bd25e1", "committedDate": "2020-07-16T21:52:08Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a8c5e329053687b3569f64e3306666982bd25e1", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/5a8c5e329053687b3569f64e3306666982bd25e1", "committedDate": "2020-07-16T21:52:08Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}, "afterCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/22705eeb8f9c757bc367e4a626171842f9029e29", "committedDate": "2020-07-16T22:27:04Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzY4NjY5", "url": "https://github.com/linkedin/ambry/pull/1577#pullrequestreview-450368669", "createdAt": "2020-07-17T04:43:25Z", "commit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDo0MzoyNVrOGzFKAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNToyODoxMlrOGzF0ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ==", "bodyText": "I was thinking to use concurrent hashmap for this part but then realized that handling exception in lambda expression would be complicated (we might have to implement ThrowBiFunction and convert exception to runtime exception which is not elegant).", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456215041", "createdAt": "2020-07-17T04:43:25Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -33,15 +40,73 @@\n    */\n   public HelixManager getZKHelixManager(String clusterName, String instanceName, InstanceType instanceType,\n       String zkAddr) {\n-    return HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    ManagerKey managerKey = new ManagerKey(clusterName, instanceName, instanceType, zkAddr);\n+    return helixManagers.computeIfAbsent(managerKey,\n+        k -> HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr));\n   }\n \n   /**\n-   * Get a reference to a {@link HelixAdmin}\n+   * Get a reference to a {@link HelixManager} and connect to it, if not already connected\n+   * @param clusterName the name of the cluster for which the manager is to be gotten.\n+   * @param instanceName the name of the instance on whose behalf the manager is to be gotten.\n+   * @param instanceType the {@link InstanceType} of the requester.\n    * @param zkAddr the address identifying the zk service to which this request is to be made.\n-   * @return the constructed {@link HelixAdmin}.\n+   * @return the constructed and connected {@link HelixManager}.\n+   * @throws Exception if connecting failed.\n+   */\n+  public HelixManager getZkHelixManagerAndConnect(String clusterName, String instanceName, InstanceType instanceType,\n+      String zkAddr) throws Exception {\n+    HelixManager manager = getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    synchronized (manager) {\n+      if (!manager.isConnected()) {\n+        LOGGER.info(\"Connecting to HelixManager at {}\", zkAddr);\n+        manager.connect();\n+        LOGGER.info(\"Established connection to HelixManager at {}\", zkAddr);\n+      } else {\n+        LOGGER.info(\"HelixManager at {} already connected\", zkAddr);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjk0NQ==", "bodyText": "Is there any case where two threads are attempting connecting same HelixManager concurrently?", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456216945", "createdAt": "2020-07-17T04:51:03Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -33,15 +40,73 @@\n    */\n   public HelixManager getZKHelixManager(String clusterName, String instanceName, InstanceType instanceType,\n       String zkAddr) {\n-    return HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    ManagerKey managerKey = new ManagerKey(clusterName, instanceName, instanceType, zkAddr);\n+    return helixManagers.computeIfAbsent(managerKey,\n+        k -> HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr));\n   }\n \n   /**\n-   * Get a reference to a {@link HelixAdmin}\n+   * Get a reference to a {@link HelixManager} and connect to it, if not already connected\n+   * @param clusterName the name of the cluster for which the manager is to be gotten.\n+   * @param instanceName the name of the instance on whose behalf the manager is to be gotten.\n+   * @param instanceType the {@link InstanceType} of the requester.\n    * @param zkAddr the address identifying the zk service to which this request is to be made.\n-   * @return the constructed {@link HelixAdmin}.\n+   * @return the constructed and connected {@link HelixManager}.\n+   * @throws Exception if connecting failed.\n+   */\n+  public HelixManager getZkHelixManagerAndConnect(String clusterName, String instanceName, InstanceType instanceType,\n+      String zkAddr) throws Exception {\n+    HelixManager manager = getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    synchronized (manager) {\n+      if (!manager.isConnected()) {\n+        LOGGER.info(\"Connecting to HelixManager at {}\", zkAddr);\n+        manager.connect();\n+        LOGGER.info(\"Established connection to HelixManager at {}\", zkAddr);\n+      } else {\n+        LOGGER.info(\"HelixManager at {} already connected\", zkAddr);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ=="}, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNzI4OQ==", "bodyText": "nit: formate this file, thanks", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456217289", "createdAt": "2020-07-17T04:52:40Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -21,7 +21,6 @@\n import com.github.ambry.utils.Utils;\n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNDA1Ng==", "bodyText": "minor: skipping removing it from config in Helix.\"", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456224056", "createdAt": "2020-07-17T05:20:54Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -279,135 +278,81 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n \n       // 3. set InstanceConfig in Helix to persist replica disabled state\n       helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+      // TODO Have this method use DataNodeConfig for disabled replicas and InstanceConfig for enabled instances.\n       logger.info(\"Disabled state of partition {} is updated\", partitionName);\n     }\n   }\n \n   /**\n+   * Exposed for testing\n    * @return {@link HelixAdmin} that manages current data node.\n    */\n   public HelixAdmin getHelixAdmin() {\n     return helixAdmin;\n   }\n \n   /**\n-   * Add new replica info into {@link InstanceConfig} of current data node.\n-   * @param replicaId new replica whose info should be added into {@link InstanceConfig}.\n-   * @param instanceConfig the {@link InstanceConfig} to update.\n+   * Add new replica info into {@link DataNodeConfig} of current data node.\n+   * @param replicaId new replica whose info should be added into {@link DataNodeConfig}.\n+   * @param dataNodeConfig the {@link DataNodeConfig} to update.\n    * @return {@code true} replica info is successfully added. {@code false} otherwise.\n    */\n-  private boolean addNewReplicaInfo(ReplicaId replicaId, InstanceConfig instanceConfig) {\n+  private boolean addNewReplicaInfo(ReplicaId replicaId, DataNodeConfig dataNodeConfig) {\n     boolean additionResult = true;\n     String partitionName = replicaId.getPartitionId().toPathString();\n-    String newReplicaInfo =\n-        String.join(REPLICAS_STR_SEPARATOR, partitionName, String.valueOf(replicaId.getCapacityInBytes()),\n-            replicaId.getPartitionId().getPartitionClass()) + REPLICAS_DELIM_STR;\n-    Map<String, Map<String, String>> mountPathToDiskInfos = instanceConfig.getRecord().getMapFields();\n-    Map<String, String> diskInfo = mountPathToDiskInfos.get(replicaId.getMountPath());\n+    DataNodeConfig.ReplicaConfig replicaConfigToAdd = new DataNodeConfig.ReplicaConfig(replicaId.getCapacityInBytes(),\n+        replicaId.getPartitionId().getPartitionClass());\n+    DataNodeConfig.DiskConfig diskConfig = dataNodeConfig.getDiskConfigs().get(replicaId.getMountPath());\n     boolean newReplicaInfoAdded = false;\n-    boolean duplicateFound = false;\n-    if (diskInfo != null) {\n-      // add replica to an existing disk (need to sort replicas by partition id)\n-      String replicasStr = diskInfo.get(REPLICAS_STR);\n-      String[] replicaInfos = replicasStr.split(REPLICAS_DELIM_STR);\n-      StringBuilder replicasStrBuilder = new StringBuilder();\n-      long idToAdd = Long.parseLong(partitionName);\n-      for (String replicaInfo : replicaInfos) {\n-        String[] infos = replicaInfo.split(REPLICAS_STR_SEPARATOR);\n-        long currentId = Long.parseLong(infos[0]);\n-        if (currentId == idToAdd) {\n-          logger.info(\"Partition {} is already on instance {}, skipping adding it into InstanceConfig in Helix.\",\n-              partitionName, instanceName);\n-          duplicateFound = true;\n-          break;\n-        } else if (currentId < idToAdd || newReplicaInfoAdded) {\n-          replicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-        } else {\n-          // newReplicaInfo already contains delimiter, no need to append REPLICAS_DELIM_STR\n-          replicasStrBuilder.append(newReplicaInfo);\n-          replicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-          newReplicaInfoAdded = true;\n-        }\n-      }\n-      if (!duplicateFound && !newReplicaInfoAdded) {\n-        // this means new replica id is larger than all existing replicas' ids\n-        replicasStrBuilder.append(newReplicaInfo);\n+    if (diskConfig != null) {\n+      // add replica to an existing disk\n+      if (diskConfig.getReplicaConfigs().containsKey(partitionName)) {\n+        logger.info(\"Partition {} is already on instance {}, skipping adding it into configs in Helix.\", partitionName,\n+            instanceName);\n+      } else {\n+        diskConfig.getReplicaConfigs().put(partitionName, replicaConfigToAdd);\n         newReplicaInfoAdded = true;\n       }\n-      if (newReplicaInfoAdded) {\n-        diskInfo.put(REPLICAS_STR, replicasStrBuilder.toString());\n-        mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfo);\n-      }\n     } else {\n       // add replica onto a brand new disk\n       logger.info(\"Adding info of new replica {} to the new disk {}\", replicaId.getPartitionId().toPathString(),\n           replicaId.getDiskId());\n-      Map<String, String> diskInfoToAdd = new HashMap<>();\n-      diskInfoToAdd.put(DISK_CAPACITY_STR, Long.toString(replicaId.getDiskId().getRawCapacityInBytes()));\n-      diskInfoToAdd.put(DISK_STATE, AVAILABLE_STR);\n-      diskInfoToAdd.put(REPLICAS_STR, newReplicaInfo);\n-      mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfoToAdd);\n+      DataNodeConfig.DiskConfig diskConfigToAdd =\n+          new DataNodeConfig.DiskConfig(HardwareState.AVAILABLE, replicaId.getDiskId().getRawCapacityInBytes());\n+      diskConfigToAdd.getReplicaConfigs().put(partitionName, replicaConfigToAdd);\n+      dataNodeConfig.getDiskConfigs().put(replicaId.getMountPath(), diskConfigToAdd);\n       newReplicaInfoAdded = true;\n     }\n     if (newReplicaInfoAdded) {\n-      // we update InstanceConfig only when new replica info is added (skip updating if replica is already present)\n-      instanceConfig.getRecord().setMapFields(mountPathToDiskInfos);\n-      logger.info(\"Updating config: {} in Helix by adding partition {}\", instanceConfig, partitionName);\n-      additionResult = helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+      logger.info(\"Updating config: {} in Helix by adding partition {}\", dataNodeConfig, partitionName);\n+      additionResult = dataNodeConfigSource.set(dataNodeConfig);\n     }\n     return additionResult;\n   }\n \n   /**\n-   * Remove old/existing replica info from {@link InstanceConfig} that associates with current data node.\n+   * Remove old/existing replica info from {@link DataNodeConfig} that associates with current data node.\n    * @param replicaId the {@link ReplicaId} whose info should be removed.\n-   * @param instanceConfig {@link InstanceConfig} to update.\n+   * @param dataNodeConfig {@link DataNodeConfig} to update.\n    * @return {@code true} replica info is successfully removed. {@code false} otherwise.\n    */\n-  private boolean removeOldReplicaInfo(ReplicaId replicaId, InstanceConfig instanceConfig) {\n+  private boolean removeOldReplicaInfo(ReplicaId replicaId, DataNodeConfig dataNodeConfig) {\n     boolean removalResult = true;\n-    boolean instanceConfigUpdated = false;\n-    boolean replicaFound;\n+    boolean dataNodeConfigUpdated = false;\n     String partitionName = replicaId.getPartitionId().toPathString();\n-    List<String> stoppedReplicas = instanceConfig.getRecord().getListField(STOPPED_REPLICAS_STR);\n-    List<String> sealedReplicas = instanceConfig.getRecord().getListField(SEALED_STR);\n-    stoppedReplicas = stoppedReplicas == null ? new ArrayList<>() : stoppedReplicas;\n-    sealedReplicas = sealedReplicas == null ? new ArrayList<>() : sealedReplicas;\n-    if (stoppedReplicas.remove(partitionName) || sealedReplicas.remove(partitionName)) {\n+    boolean removedFromStopped = dataNodeConfig.getStoppedReplicas().remove(partitionName);\n+    boolean removedFromSealed = dataNodeConfig.getSealedReplicas().remove(partitionName);\n+    if (removedFromStopped || removedFromSealed) {\n       logger.info(\"Removing partition {} from stopped and sealed list\", partitionName);\n-      instanceConfig.getRecord().setListField(STOPPED_REPLICAS_STR, stoppedReplicas);\n-      instanceConfig.getRecord().setListField(SEALED_STR, sealedReplicas);\n-      instanceConfigUpdated = true;\n+      dataNodeConfigUpdated = true;\n     }\n-    Map<String, Map<String, String>> mountPathToDiskInfos = instanceConfig.getRecord().getMapFields();\n-    Map<String, String> diskInfo = mountPathToDiskInfos.get(replicaId.getMountPath());\n-    if (diskInfo != null) {\n-      String replicasStr = diskInfo.get(REPLICAS_STR);\n-      if (!replicasStr.isEmpty()) {\n-        List<String> replicaInfos = new ArrayList<>(Arrays.asList(replicasStr.split(REPLICAS_DELIM_STR)));\n-        // if any element is removed, that means old replica is found in replicasStr.\n-        replicaFound = replicaInfos.removeIf(info -> (info.split(REPLICAS_STR_SEPARATOR)[0]).equals(partitionName));\n-\n-        // We update InstanceConfig only when replica is found in current instanceConfig. (This is to avoid unnecessary\n-        // notification traffic due to InstanceConfig change)\n-        if (replicaFound) {\n-          StringBuilder newReplicasStrBuilder = new StringBuilder();\n-          // note that old replica info has been removed from \"replicaInfos\"\n-          for (String replicaInfo : replicaInfos) {\n-            newReplicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-          }\n-          // update diskInfo and MountPathToDisk map\n-          diskInfo.put(REPLICAS_STR, newReplicasStrBuilder.toString());\n-          mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfo);\n-          // update InstanceConfig\n-          instanceConfig.getRecord().setMapFields(mountPathToDiskInfos);\n-          instanceConfigUpdated = true;\n-        }\n-      }\n+    DataNodeConfig.DiskConfig diskConfig = dataNodeConfig.getDiskConfigs().get(replicaId.getMountPath());\n+    if (diskConfig != null) {\n+      dataNodeConfigUpdated = diskConfig.getReplicaConfigs().remove(partitionName) != null;\n     }\n-    if (instanceConfigUpdated) {\n-      logger.info(\"Updating config: {} in Helix by removing partition {}\", instanceConfig, partitionName);\n-      removalResult = helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+    if (dataNodeConfigUpdated) {\n+      logger.info(\"Updating config: {} in Helix by removing partition {}\", dataNodeConfig, partitionName);\n+      removalResult = dataNodeConfigSource.set(dataNodeConfig);\n     } else {\n       logger.warn(\"Partition {} is not found on instance {}, skipping removing it from InstanceConfig in Helix.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNTU1Nw==", "bodyText": "minor: new line", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456225557", "createdAt": "2020-07-17T05:26:22Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java", "diffHunk": "@@ -109,10 +108,5 @@ public void testSetGetListener() throws Exception {\n       assertEquals(\"get() call returned incorrect result\", config, source.get(config.getInstanceName()));\n     }\n     assertNull(\"Should not receive non-existent instance\", source.get(\"abc\"));\n-\n-    source.setHelixAdmin(null);\n-    TestUtils.assertException(NullPointerException.class, () -> source.set(createConfig(1, 1)), null);\n-    String firstInstance = allConfigs.iterator().next().getInstanceName();\n-    TestUtils.assertException(NullPointerException.class, () -> source.get(firstInstance), null);\n   }\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNTk4Nw==", "bodyText": "Package private? (If this method will be called in int-test, just ignore this comment)", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456225987", "createdAt": "2020-07-17T05:28:12Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java", "diffHunk": "@@ -398,6 +400,13 @@ long getTotalDiskCapacity() {\n     return totalDiskCapacity;\n   }\n \n+  /**\n+   * @return the number of calls to the {@link #setInstanceConfig} method.\n+   */\n+  public int getSetInstanceConfigCallCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "committedDate": "2020-07-17T19:13:16Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "committedDate": "2020-07-17T19:34:00Z", "message": "Address Yingyi's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/22705eeb8f9c757bc367e4a626171842f9029e29", "committedDate": "2020-07-16T22:27:04Z", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready."}, "afterCommit": {"oid": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "committedDate": "2020-07-17T19:34:00Z", "message": "Address Yingyi's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/e14164eba031e90a8f4abf01072d45eadcae385e", "committedDate": "2020-07-20T20:15:47Z", "message": "Fix erasure of HELIX_DISABLED_PARTITIONS field"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b68a42ed34947812df3f4483910108cd6473a51", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/6b68a42ed34947812df3f4483910108cd6473a51", "committedDate": "2020-07-20T20:13:53Z", "message": "Fix erasure of HELIX_DISABLED_PARTITIONS field"}, "afterCommit": {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/e14164eba031e90a8f4abf01072d45eadcae385e", "committedDate": "2020-07-20T20:15:47Z", "message": "Fix erasure of HELIX_DISABLED_PARTITIONS field"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDAxMDUy", "url": "https://github.com/linkedin/ambry/pull/1577#pullrequestreview-452001052", "createdAt": "2020-07-20T22:24:43Z", "commit": {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDY5NDMw", "url": "https://github.com/linkedin/ambry/pull/1577#pullrequestreview-452069430", "createdAt": "2020-07-21T01:44:25Z", "commit": {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1159, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}