{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMDA4Mjc5", "number": 1407, "title": "Change blob type from java.nio.ByteBuffer to netty ByteBuf in PutRequest", "bodyText": "Change the blob's type in PutRequest from ByteBuffer to ByteBuf.\nLater will make the change to pass a ByteBuf from PutOperation to PutRequest.", "createdAt": "2020-03-01T07:08:24Z", "url": "https://github.com/linkedin/ambry/pull/1407", "merged": true, "mergeCommit": {"oid": "8742f3fc5ed7a86f13736081b11187f02141c498"}, "closed": true, "closedAt": "2020-03-04T19:57:17Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJTrBHgH2gAyMzgyMDA4Mjc5Ojk5YjQ5MjcyZjg0YzQzMWMwYTViMjJlYjNjYTk2MGNmYzFjMWNmZDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKbz7igH2gAyMzgyMDA4Mjc5Ojg2NjM0MWU3ODRhZjIxNTJmNGJlZGQxMjVkMmY5YmY2ZDNmMTFiNWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8", "committedDate": "2020-03-01T07:06:35Z", "message": "Change blob type from java.nio.ByteBuffer to netty ByteBuf in PutRequest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjE4Nzkw", "url": "https://github.com/linkedin/ambry/pull/1407#pullrequestreview-367618790", "createdAt": "2020-03-03T00:04:39Z", "commit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDowNDozOVrOFwz25w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDowNDozOVrOFwz25w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTYwNw==", "bodyText": "Is it possible to convert BlobProperties and userMeatadata to bytebuf first, and then use Bytebuf bufferToSend?", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r386725607", "createdAt": "2020-03-03T00:04:39Z", "author": {"login": "zzmao"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjE5MDk2", "url": "https://github.com/linkedin/ambry/pull/1407#pullrequestreview-367619096", "createdAt": "2020-03-03T00:05:33Z", "commit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDowNTozM1rOFwz36A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDowNTozM1rOFwz36A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyNTg2NA==", "bodyText": "Unpooled.wrappedBuffer(chunkUserMetadata)?", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r386725864", "createdAt": "2020-03-03T00:05:33Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1346,8 +1347,8 @@ private void fetchRequests(RequestRegistrationCallback<PutOperation> requestRegi\n      */\n     protected PutRequest createPutRequest() {\n       return new PutRequest(NonBlockingRouter.correlationIdGenerator.incrementAndGet(), routerConfig.routerHostname,\n-          chunkBlobId, chunkBlobProperties, ByteBuffer.wrap(chunkUserMetadata), buf.duplicate(), buf.remaining(),\n-          BlobType.DataBlob, encryptedPerBlobKey != null ? encryptedPerBlobKey.duplicate() : null);\n+          chunkBlobId, chunkBlobProperties, ByteBuffer.wrap(chunkUserMetadata), Unpooled.wrappedBuffer(buf.duplicate()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTk4NDI1", "url": "https://github.com/linkedin/ambry/pull/1407#pullrequestreview-368998425", "createdAt": "2020-03-04T17:59:28Z", "commit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDE2OTEw", "url": "https://github.com/linkedin/ambry/pull/1407#pullrequestreview-369016910", "createdAt": "2020-03-04T18:26:55Z", "commit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyNjo1NVrOFx4k7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1NTo1OFrOFx5iGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTUwMA==", "bodyText": "optional:  I would suggest renaming this method and moving the \"if\" statement out of method. Something like this:\nif (bufferToSend == null) {\n // this is the first time this method was called, prepare the buffer to send the header and other metadata\n   prepareBufferToSend();\n}", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387851500", "createdAt": "2020-03-04T18:26:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n+      bufferToSend.putInt(usermetadata.capacity());\n+      bufferToSend.put(usermetadata);\n+      bufferToSend.putShort((short) blobType.ordinal());\n+      short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n+      bufferToSend.putShort(keyLength);\n+      if (keyLength > 0) {\n+        bufferToSend.put(blobEncryptionKey);\n+      }\n+      bufferToSend.putLong(blobSize);\n+      crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n+      nioBuffersFromBlob = blob.nioBuffers();\n+      for (ByteBuffer bb : nioBuffersFromBlob) {\n+        crc.update(bb);\n+        // change it back to 0 since we are going to write it to the channel later.\n+        bb.position(0);\n+      }\n+      crcBuf.putLong(crc.getValue());\n+      crcBuf.flip();\n+      bufferToSend.flip();\n+    }\n+  }\n+\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (sentBytes < sizeInBytes()) {\n-      if (bufferToSend == null) {\n-        // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-        // (everything except the blob content).\n-        bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n-        writeHeader();\n-        int crcStart = bufferToSend.position();\n-        bufferToSend.put(blobId.toBytes());\n-        BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-        bufferToSend.putInt(usermetadata.capacity());\n-        bufferToSend.put(usermetadata);\n-        bufferToSend.putShort((short) blobType.ordinal());\n-        short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-        bufferToSend.putShort(keyLength);\n-        if (keyLength > 0) {\n-          bufferToSend.put(blobEncryptionKey);\n+    try {\n+      if (sentBytes < sizeInBytes()) {\n+        prepareBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NzE2MA==", "bodyText": "Could you rename n to something like oneTimeBytesWritten?  This indicates that, when current method is invoked, how many bytes have been written during this call. This may contain one or more nio buffers that are successfully written into channel.", "url": "https://github.com/linkedin/ambry/pull/1407#discussion_r387867160", "createdAt": "2020-03-04T18:55:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/PutRequest.java", "diffHunk": "@@ -168,51 +171,80 @@ private int sizeExcludingBlobAndCrcSize() {\n     return sizeExcludingBlobAndCrc;\n   }\n \n+  private void prepareBuffer() {\n+    if (bufferToSend == null) {\n+      // this is the first time this method was called, prepare the buffer to send the header and other metadata\n+      // (everything except the blob content).\n+      bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+      writeHeader();\n+      int crcStart = bufferToSend.position();\n+      bufferToSend.put(blobId.toBytes());\n+      BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n+      bufferToSend.putInt(usermetadata.capacity());\n+      bufferToSend.put(usermetadata);\n+      bufferToSend.putShort((short) blobType.ordinal());\n+      short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n+      bufferToSend.putShort(keyLength);\n+      if (keyLength > 0) {\n+        bufferToSend.put(blobEncryptionKey);\n+      }\n+      bufferToSend.putLong(blobSize);\n+      crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n+      nioBuffersFromBlob = blob.nioBuffers();\n+      for (ByteBuffer bb : nioBuffersFromBlob) {\n+        crc.update(bb);\n+        // change it back to 0 since we are going to write it to the channel later.\n+        bb.position(0);\n+      }\n+      crcBuf.putLong(crc.getValue());\n+      crcBuf.flip();\n+      bufferToSend.flip();\n+    }\n+  }\n+\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (sentBytes < sizeInBytes()) {\n-      if (bufferToSend == null) {\n-        // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-        // (everything except the blob content).\n-        bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n-        writeHeader();\n-        int crcStart = bufferToSend.position();\n-        bufferToSend.put(blobId.toBytes());\n-        BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-        bufferToSend.putInt(usermetadata.capacity());\n-        bufferToSend.put(usermetadata);\n-        bufferToSend.putShort((short) blobType.ordinal());\n-        short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-        bufferToSend.putShort(keyLength);\n-        if (keyLength > 0) {\n-          bufferToSend.put(blobEncryptionKey);\n+    try {\n+      if (sentBytes < sizeInBytes()) {\n+        prepareBuffer();\n+        // If the header and metadata are not yet written out completely, try and write out as much of it now.\n+        if (bufferToSend.hasRemaining()) {\n+          written = channel.write(bufferToSend);\n         }\n-        bufferToSend.putLong(blobSize);\n-        crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-        crc.update(blob.array(), blob.arrayOffset(), blob.remaining());\n-        crcBuf.putLong(crc.getValue());\n-        crcBuf.flip();\n-        bufferToSend.flip();\n-      }\n \n-      // If the header and metadata are not yet written out completely, try and write out as much of it now.\n-      if (bufferToSend.hasRemaining()) {\n-        written = channel.write(bufferToSend);\n-      }\n+        // If the header and metadata were written out completely (in this call or a previous call),\n+        // try and write out as much of the blob now.\n+        if (!bufferToSend.hasRemaining() && blob != null) {\n+          int n = 0, currentWritten = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99b49272f84c431c0a5b22eb3ca960cfc1c1cfd8"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "866341e784af2152f4bedd125d2f9bf6d3f11b5a", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/866341e784af2152f4bedd125d2f9bf6d3f11b5a", "committedDate": "2020-03-04T19:09:29Z", "message": "Comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1659, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}