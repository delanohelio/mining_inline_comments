{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2ODkwOTQ2", "number": 1548, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNDo1ODoyOVrOECABaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjoyNDowMFrOECOtoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTMyOTcxOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNDo1ODoyOVrOGeMDsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNDo1ODoyOVrOGeMDsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwODAxOQ==", "bodyText": "Why not idToDelete = liveKeys.iterator().next(); ?", "url": "https://github.com/linkedin/ambry/pull/1548#discussion_r434308019", "createdAt": "2020-06-03T04:58:29Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -643,6 +643,59 @@ public void concurrentDeleteTest() throws Exception {\n     verifyDeleteFutures(deleters, futures);\n   }\n \n+  /**\n+   * Test when deleting the same blob at the same time. Only one delete can go through and only one log and index\n+   * record should be persisted.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteTestOnSameBlob() throws Exception {\n+    MockId idToDelete = null;\n+    for (MockId id : liveKeys) {\n+      idToDelete = id;\n+      break;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80adfceffc1cd3e1f5451f51af9933cca84ed2f4"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTMzODQxOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTowMzozNlrOGeMI0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTowMzozNlrOGeMI0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwOTMzMA==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1548#discussion_r434309330", "createdAt": "2020-06-03T05:03:36Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -678,6 +731,59 @@ public void concurrentUndeleteTest() throws Exception {\n     verifyUndeleteFutures(undeleters, futures);\n   }\n \n+  /**\n+   * Test when undeleting the same blob at the same time. Only one undelete can go through and only one log and index\n+   * record should be persisted.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentUndeleteTestOnSameBlob() throws Exception {\n+    MockId idToUndelete = null;\n+    for (MockId id : deletedKeys) {\n+      idToUndelete = id;\n+      break;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80adfceffc1cd3e1f5451f51af9933cca84ed2f4"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzczNjY0OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjoyNDowMFrOGejwdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjoyNDowMFrOGejwdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NjMxMQ==", "bodyText": "Sleep indeed can mock the situation but the time seems a little bit long here. Can we use latch instead?", "url": "https://github.com/linkedin/ambry/pull/1548#discussion_r434696311", "createdAt": "2020-06-03T16:24:00Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -643,6 +643,61 @@ public void concurrentDeleteTest() throws Exception {\n     verifyDeleteFutures(deleters, futures);\n   }\n \n+  /**\n+   * Test when deleting the same blob at the same time. Only one delete can go through and only one log and index\n+   * record should be persisted.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void concurrentDeleteTestOnSameBlob() throws Exception {\n+    final MockId idToDelete = liveKeys.iterator().next();\n+    assertNotNull(idToDelete);\n+    ((MockBlobStore) store).setOperationBeforeSynchronizationFunc(() -> {\n+      try {\n+        Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6c6cc713a07a45bcc976b8b1ff930c54c1e6965"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1227, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}