{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTM2Njc0", "number": 1384, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMzoyMjozN1rODgMJ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMzozODozOVrODiHMPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDgwMTY5OnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMzoyMjozN1rOFqRjQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTozNzo1MVrOFr4imw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ==", "bodyText": "Could you call this Http2ClientChannelInitializer and replace the one used for Http2BlockingChannel with this one?", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872065", "createdAt": "2020-02-16T03:22:37Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzgwNQ==", "bodyText": "Http2ClientChannelInitializer is Channelnitializer, which is not a AbstractChannelPoolHandler.\nWe probably need to keep two classes.\nI can rename this(Http2ChannelInitializer) to Http2ChannelPoolHanlder and try to avoid dup code.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381553805", "createdAt": "2020-02-19T21:26:22Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1OTQ1MQ==", "bodyText": "Http2ClientChannelInitializer class is removed. Do inline initialization in Http2BlockingChannel::channel().", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381559451", "createdAt": "2020-02-19T21:37:51Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDgwMjE5OnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMzoyMzo0N1rOFqRjdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyNjozNlrOFr4NDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjExOA==", "bodyText": "You should only need one shared sslFactory for all channels. I would prefer only parsing the configs once", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872118", "createdAt": "2020-02-16T03:23:47Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {\n+  private final SSLConfig sslConfig;\n+  private final String host;\n+  private final int port;\n+\n+  /**\n+   * Construct a {@link Http2ChannelInitializer}.\n+   * @param sslConfig the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public Http2ChannelInitializer(SSLConfig sslConfig, RequestInfo requestInfo) {\n+    this.sslConfig = sslConfig;\n+    this.host = requestInfo.getHost();\n+    this.port = requestInfo.getPort().getPort();\n+  }\n+\n+  @Override\n+  public void channelCreated(Channel ch) throws Exception {\n+    ChannelPipeline pipeline = ch.pipeline();\n+    SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzkzNA==", "bodyText": "ok", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381553934", "createdAt": "2020-02-19T21:26:36Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {\n+  private final SSLConfig sslConfig;\n+  private final String host;\n+  private final int port;\n+\n+  /**\n+   * Construct a {@link Http2ChannelInitializer}.\n+   * @param sslConfig the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public Http2ChannelInitializer(SSLConfig sslConfig, RequestInfo requestInfo) {\n+    this.sslConfig = sslConfig;\n+    this.host = requestInfo.getHost();\n+    this.port = requestInfo.getPort().getPort();\n+  }\n+\n+  @Override\n+  public void channelCreated(Channel ch) throws Exception {\n+    ChannelPipeline pipeline = ch.pipeline();\n+    SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjExOA=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDgwNDc2OnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ClientChannelInitializer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMzozMjoyMFrOFqRkqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0MDoxNFrOFr4m6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw==", "bodyText": "looks like this is not used with Http2ChannelPoolMap", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872427", "createdAt": "2020-02-16T03:32:20Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ClientChannelInitializer.java", "diffHunk": "@@ -26,8 +26,7 @@\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NDUzNA==", "bodyText": "fixed. For Http2BlockingChannel", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381554534", "createdAt": "2020-02-19T21:27:41Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ClientChannelInitializer.java", "diffHunk": "@@ -26,8 +26,7 @@\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDU1NA==", "bodyText": "This class is removed.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381560554", "createdAt": "2020-02-19T21:40:14Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ClientChannelInitializer.java", "diffHunk": "@@ -26,8 +26,7 @@\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDgwNTMxOnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMzozNDoxMVrOFqRk7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0MDoyOVrOFr4nXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQ5NQ==", "bodyText": "Maybe construct SSLFactory outside (i.e. in the NetworkClientFactory impl) and pass it into this constructor since it should be able to shared across all instances.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872495", "createdAt": "2020-02-16T03:34:11Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {\n+  private final EventLoopGroup eventLoopGroup;\n+  private final SSLConfig sslConfig;\n+\n+  public Http2ChannelPoolMap(SSLConfig sslConfig, EventLoopGroup eventLoopGroup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDY2OA==", "bodyText": "SSLFactory is used.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381560668", "createdAt": "2020-02-19T21:40:29Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {\n+  private final EventLoopGroup eventLoopGroup;\n+  private final SSLConfig sslConfig;\n+\n+  public Http2ChannelPoolMap(SSLConfig sslConfig, EventLoopGroup eventLoopGroup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQ5NQ=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDM0NzE5OnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMDowODowMFrOFqx83Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo1OToxN1rOFr5Ljw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQwMjkwOQ==", "bodyText": "It seems that RequestInfo isn't exactly the right key to use for Http2ChannelPoolMap and Http2ChannelInitializer for a couple reasons:\n\nIt doesn't have hashcode and equals defined, and a separate object is created for each request, so a new pool will created for each request, instead of each host:port combo\nIt includes info about the request body, which is not relevant to the pool (i think).\n\nInstead, you could use InetSocketAddress and pass this directly into Bootstrap::remoteAddress. The impl of Bootstrap::remoteAddress(String inetHost, int inetPort) would call InetSocketAddress.createUnresolved(inetHost, inetPort) anyways.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r380402909", "createdAt": "2020-02-18T00:08:00Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2OTkzNQ==", "bodyText": "InetSocketAddress is used.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381569935", "createdAt": "2020-02-19T21:59:17Z", "author": {"login": "zzmao"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQwMjkwOQ=="}, "originalCommit": {"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MjEzNjE2OnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/GoAwayException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMDoyNzo0MVrOFr8jCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMDoyNzo0MVrOFr8jCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNTA5OA==", "bodyText": "I am wondering if it's easier to create a sub package under ambry.rest like ambry.rest.http2 so we can put all the http2 related files under this package.", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381625098", "createdAt": "2020-02-20T00:27:41Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/GoAwayException.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0038c71bc55118e38e48fe08d810b7936a6701f8"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjI1MjAyOnYy", "diffSide": "RIGHT", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDowOToxMVrOFshhmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDowOToxMVrOFshhmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMDkzOQ==", "bodyText": "should be ChannelPoolHandler", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382230939", "createdAt": "2020-02-20T20:09:11Z", "author": {"login": "cgtz"}, "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolHandler.java", "diffHunk": "@@ -15,42 +15,39 @@\n package com.github.ambry.rest;\n \n import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.Channel;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0038c71bc55118e38e48fe08d810b7936a6701f8"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDkyNDEzOnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/NettyUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxMzo1M1rOFtNJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxNToyN1rOFtNJmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTU5Mg==", "bodyText": "I guess this method requires assertions to be disabled for l158-163 to even take effect?", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945592", "createdAt": "2020-02-22T22:13:53Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/NettyUtils.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2010-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * Modifications copyright (C) 2020 <Linkedin/zzmao>\n+ */\n+\n+package com.github.ambry.commons;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.SucceededFuture;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class NettyUtils {\n+  /**\n+   * Completed succeed future.\n+   */\n+  public static final SucceededFuture<?> SUCCEEDED_FUTURE = new SucceededFuture<>(null, null);\n+\n+  private static final Logger log = LoggerFactory.getLogger(NettyUtils.class);\n+\n+  private NettyUtils() {\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the {@link Throwable} passed into the\n+   * BiConsumer of as a result of running the successFunction.\n+   *\n+   * @param successFunction Function called to process the successful result and map it into the result to notify the promise\n+   * with.\n+   * @param promise Promise to notify of success or failure.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> promiseNotifyingBiConsumer(\n+      Function<SuccessT, PromiseT> successFunction, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          promise.setSuccess(successFunction.apply(success));\n+        } catch (Throwable e) {\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the throwable passed into the BiConsumer\n+   * or as a result of running the successConsumer. This assumes that the successConsumer will notify the promise when it\n+   * completes successfully.\n+   *\n+   * @param successConsumer BiConsumer to call if the result is successful. Promise is also passed and must be notified on\n+   * success.\n+   * @param promise Promise to notify.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the Promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> asyncPromiseNotifyingBiConsumer(\n+      BiConsumer<SuccessT, Promise<PromiseT>> successConsumer, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          successConsumer.accept(success, promise);\n+        } catch (Throwable e) {\n+          // If the successConsumer fails synchronously then we can notify the promise. If it fails asynchronously\n+          // it's up to the successConsumer to notify.\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Create a {@link GenericFutureListener} that will notify the provided {@link Promise} on success and failure.\n+   *\n+   * @param channelPromise Promise to notify.\n+   * @return GenericFutureListener\n+   */\n+  public static <T> GenericFutureListener<Future<T>> promiseNotifyingListener(Promise<T> channelPromise) {\n+    return future -> {\n+      if (future.isSuccess()) {\n+        channelPromise.setSuccess(future.getNow());\n+      } else {\n+        channelPromise.setFailure(future.cause());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable) {\n+    if (eventExecutor.inEventLoop()) {\n+      runnable.run();\n+    } else {\n+      eventExecutor.submit(runnable);\n+    }\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor. Notifies the given {@link Promise} if a failure occurs.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   * @param promise Promise to notify if failure occurs.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable, Promise<?> promise) {\n+    try {\n+      if (eventExecutor.inEventLoop()) {\n+        runnable.run();\n+      } else {\n+        eventExecutor.submit(() -> {\n+          try {\n+            runnable.run();\n+          } catch (Throwable e) {\n+            promise.setFailure(e);\n+          }\n+        });\n+      }\n+    } catch (Throwable e) {\n+      promise.setFailure(e);\n+    }\n+  }\n+\n+  public static void warnIfNotInEventLoop(EventLoop loop) {\n+    assert loop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTY5MA==", "bodyText": "Ah, I see that assertions are disabled by default for production code, so this makes sense: https://stackoverflow.com/questions/29120928/why-is-assert-not-enabled-by-default-in-java", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945690", "createdAt": "2020-02-22T22:15:27Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/NettyUtils.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2010-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * Modifications copyright (C) 2020 <Linkedin/zzmao>\n+ */\n+\n+package com.github.ambry.commons;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.SucceededFuture;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class NettyUtils {\n+  /**\n+   * Completed succeed future.\n+   */\n+  public static final SucceededFuture<?> SUCCEEDED_FUTURE = new SucceededFuture<>(null, null);\n+\n+  private static final Logger log = LoggerFactory.getLogger(NettyUtils.class);\n+\n+  private NettyUtils() {\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the {@link Throwable} passed into the\n+   * BiConsumer of as a result of running the successFunction.\n+   *\n+   * @param successFunction Function called to process the successful result and map it into the result to notify the promise\n+   * with.\n+   * @param promise Promise to notify of success or failure.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> promiseNotifyingBiConsumer(\n+      Function<SuccessT, PromiseT> successFunction, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          promise.setSuccess(successFunction.apply(success));\n+        } catch (Throwable e) {\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the throwable passed into the BiConsumer\n+   * or as a result of running the successConsumer. This assumes that the successConsumer will notify the promise when it\n+   * completes successfully.\n+   *\n+   * @param successConsumer BiConsumer to call if the result is successful. Promise is also passed and must be notified on\n+   * success.\n+   * @param promise Promise to notify.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the Promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> asyncPromiseNotifyingBiConsumer(\n+      BiConsumer<SuccessT, Promise<PromiseT>> successConsumer, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          successConsumer.accept(success, promise);\n+        } catch (Throwable e) {\n+          // If the successConsumer fails synchronously then we can notify the promise. If it fails asynchronously\n+          // it's up to the successConsumer to notify.\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Create a {@link GenericFutureListener} that will notify the provided {@link Promise} on success and failure.\n+   *\n+   * @param channelPromise Promise to notify.\n+   * @return GenericFutureListener\n+   */\n+  public static <T> GenericFutureListener<Future<T>> promiseNotifyingListener(Promise<T> channelPromise) {\n+    return future -> {\n+      if (future.isSuccess()) {\n+        channelPromise.setSuccess(future.getNow());\n+      } else {\n+        channelPromise.setFailure(future.cause());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable) {\n+    if (eventExecutor.inEventLoop()) {\n+      runnable.run();\n+    } else {\n+      eventExecutor.submit(runnable);\n+    }\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor. Notifies the given {@link Promise} if a failure occurs.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   * @param promise Promise to notify if failure occurs.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable, Promise<?> promise) {\n+    try {\n+      if (eventExecutor.inEventLoop()) {\n+        runnable.run();\n+      } else {\n+        eventExecutor.submit(() -> {\n+          try {\n+            runnable.run();\n+          } catch (Throwable e) {\n+            promise.setFailure(e);\n+          }\n+        });\n+      }\n+    } catch (Throwable e) {\n+      promise.setFailure(e);\n+    }\n+  }\n+\n+  public static void warnIfNotInEventLoop(EventLoop loop) {\n+    assert loop.inEventLoop();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTU5Mg=="}, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDkyNTYxOnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/test/java/com.github.ambry.commons/NettySslHttp2FactoryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxNjozNlrOFtNKAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxNjozNlrOFtNKAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTc5Mw==", "bodyText": "sSLEngine -> sslEngine", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945793", "createdAt": "2020-02-22T22:16:36Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/test/java/com.github.ambry.commons/NettySslHttp2FactoryTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.utils.Utils;\n+import java.io.File;\n+import javax.net.ssl.SSLEngine;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test {@link NettySslFactory}\n+ */\n+public class NettySslHttp2FactoryTest {\n+\n+  /**\n+   * Run sanity checks for {@link NettySslHttp2Factory}. Make sure no exception.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testHttp2SSLFactory() throws Exception {\n+    //server\n+    File trustStoreFile = File.createTempFile(\"truststore\", \".jks\");\n+    SSLConfig serverSslConfig =\n+        new SSLConfig(TestSSLUtils.createHttp2Props(\"DC1,DC2,DC3\", SSLFactory.Mode.SERVER, trustStoreFile, \"server\"));\n+    NettySslHttp2Factory sslFactory = Utils.getObj(NettySslHttp2Factory.class.getName(), serverSslConfig);\n+    SSLEngine sSLEngine = sslFactory.createSSLEngine(\"localhost\", 9095, SSLFactory.Mode.SERVER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDkyNjI4OnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/test/java/com.github.ambry.commons/TestSSLUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxODoxNlrOFtNKVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoxODoxNlrOFtNKVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTg3OQ==", "bodyText": "remove println", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945879", "createdAt": "2020-02-22T22:18:16Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/test/java/com.github.ambry.commons/TestSSLUtils.java", "diffHunk": "@@ -320,6 +350,7 @@ public static void testSSLFactoryImpl(String factoryClassName) throws Exception\n     SSLServerSocketFactory serverSocketFactory = sslContext.getServerSocketFactory();\n     Assert.assertNotNull(serverSocketFactory);\n     SSLEngine serverSideSSLEngine = sslFactory.createSSLEngine(\"localhost\", 9095, SSLFactory.Mode.SERVER);\n+    System.out.println(serverSideSSLEngine.getWantClientAuth());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDkyODE0OnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/GoAwayException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoyMzowOVrOFtNLQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjoyMzowOVrOFtNLQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NjExMw==", "bodyText": "add newline", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382946113", "createdAt": "2020-02-22T22:23:09Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com.github.ambry.network/http2/GoAwayException.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2010-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * Modifications copyright (C) 2020 <Linkedin/zzmao>\n+ */\n+package com.github.ambry.network.http2;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+\n+/**\n+ * Exception thrown when a GOAWAY frame is sent by the service.\n+ */\n+class GoAwayException extends IOException {\n+  private final String message;\n+\n+  GoAwayException(long errorCode, ByteBuf debugData) {\n+    this.message = String.format(\n+        \"GOAWAY received from service, requesting this stream be closed. \" + \"Error Code = %d, Debug Data = %s\",\n+        errorCode, debugData.toString(StandardCharsets.UTF_8));\n+  }\n+\n+  @Override\n+  public String getMessage() {\n+    return message;\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDkzNTgxOnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ChannelPoolHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjo0MDowN1rOFtNPGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMjo0MDowN1rOFtNPGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NzA5Ng==", "bodyText": "change doc to say ChannelPoolHandler", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382947096", "createdAt": "2020-02-22T22:40:07Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -12,45 +12,42 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n-package com.github.ambry.rest;\n+package com.github.ambry.network.http2;\n \n import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.Channel;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDk1OTk2OnYy", "diffSide": "RIGHT", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/ServerTestUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMzozODozOVrOFtNanA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMzozODozOVrOFtNanA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MDA0NA==", "bodyText": "Is this import needed?", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382950044", "createdAt": "2020-02-22T23:38:39Z", "author": {"login": "cgtz"}, "path": "ambry-server/src/integration-test/java/com.github.ambry.server/ServerTestUtil.java", "diffHunk": "@@ -122,6 +124,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n import javax.net.ssl.SSLSocketFactory;\n import org.junit.Assert;\n+import org.junit.Test;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c209845b0a6ec10ac72813c34b1eddb58162a9f"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1710, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}