{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTIxMTYz", "number": 1467, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozMzozN1rODwqU0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNzo0OFrODz9t8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzUxNjk3OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozMzozN1rOGDyVKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozMzozN1rOGDyVKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzUzMA==", "bodyText": "Java Doc", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406623530", "createdAt": "2020-04-10T06:33:37Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -287,6 +287,30 @@ private OperationController getOperationController() {\n     return futureResult;\n   }\n \n+  @Override\n+  public Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzUyMDk0OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozNTo1MFrOGDyXYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoxNjo1OFrOGEB-dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDA5Nw==", "bodyText": "???\nLooks like the implementation is also for GET?", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624097", "createdAt": "2020-04-10T06:35:50Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +746,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3OTg2MA==", "bodyText": "well, I have to do a GET to fetch all the blob ids for this blob if it's a composite blob.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406879860", "createdAt": "2020-04-10T18:16:58Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +746,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDA5Nw=="}, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzUyNzI5OnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNjozOTowN1rOGDya3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoxNzoxMFrOGEB-wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDk5MQ==", "bodyText": "Based on my recent experience, default may cause some test issues because it brings in a default implementation. Prefer to have same interface as updateBlobTtl .", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624991", "createdAt": "2020-04-10T06:39:07Z", "author": {"login": "zzmao"}, "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -88,6 +88,22 @@\n    */\n   Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs, Callback<Void> callback);\n \n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+   * @param blobId The ID of the blob that needs to be undeleted.\n+   * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+   * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+   * @return A future that would contain information about whether the undelete succeeded or not, eventually.\n+   */\n+  default Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3OTkzNw==", "bodyText": "I can remove it.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406879937", "createdAt": "2020-04-10T18:17:10Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -88,6 +88,22 @@\n    */\n   Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs, Callback<Void> callback);\n \n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+   * @param blobId The ID of the blob that needs to be undeleted.\n+   * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+   * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+   * @return A future that would contain information about whether the undelete succeeded or not, eventually.\n+   */\n+  default Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDk5MQ=="}, "originalCommit": {"oid": "56586050df9da58b9ae55c58deba855cd6b5af80"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDczMzEzOnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozOTo1NVrOGG4JRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTozOTo1NVrOGG4JRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NDUxOQ==", "bodyText": "minor: there is no Callback to be invoked. Rephrase this comment please.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409864519", "createdAt": "2020-04-16T21:39:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -167,4 +176,14 @@\n   default Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs) {\n     return updateBlobTtl(blobId, serviceId, expiresAtMs, null);\n   }\n+\n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDczOTU0OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTo0MjoxM1rOGG4NVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTo0MjoxM1rOGG4NVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NTU1Nw==", "bodyText": "nit: format this file", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409865557", "createdAt": "2020-04-16T21:42:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob\n+ */\n+class BatchOperationCallbackTracker {\n+  static final FutureResult<Void> DUMMY_FUTURE = new FutureResult<>();\n+\n+  private final FutureResult<Void> futureResult;\n+  private final Callback<Void> callback;\n+  private final long numBlobIds;\n+  private final ConcurrentMap<BlobId, Boolean> blobIdToAck = new ConcurrentHashMap<>();\n+  private final AtomicLong ackedCount = new AtomicLong(0);\n+  private final AtomicBoolean completed = new AtomicBoolean(false);\n+\n+  /**\n+   * Constructor\n+   * @param blobIds the {@link BlobId}s being tracked\n+   * @param futureResult the {@link FutureResult} to be triggered once acks are received for all blobs\n+   * @param callback the {@link Callback} to be triggered once acks are received for all blobs\n+   */\n+  BatchOperationCallbackTracker(List<BlobId> blobIds, FutureResult<Void> futureResult,\n+      Callback<Void> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDk5NjA3OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzoyMzowMVrOGG6lpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzoyMzowMVrOGG6lpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwNDU0OA==", "bodyText": "minor: for TtlUpdate and Undelete operations", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409904548", "createdAt": "2020-04-16T23:23:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzM1MDQxOnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTozMjoxN1rOGIkRtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1MToxNVrOGInKEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ==", "bodyText": "should be completeUndeleteBlobOperation", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636151", "createdAt": "2020-04-20T19:32:17Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNzg5NA==", "bodyText": "And try to write a test that covers this case.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411637894", "createdAt": "2020-04-20T19:35:19Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzM0NQ==", "bodyText": "Tests will be added at next PR, with the real implementation of UndeleteOperation.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683345", "createdAt": "2020-04-20T20:51:15Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzM1NTk5OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTozMzo0NVrOGIkU_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1MToyNFrOGInKYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjk4OA==", "bodyText": "you probably need a dedicated metric routerMetrics.ageAtUndelete", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636988", "createdAt": "2020-04-20T19:33:45Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzQyNQ==", "bodyText": "good catch.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683425", "createdAt": "2020-04-20T20:51:24Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjk4OA=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzUwMTcwOnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxMDoyMFrOGIlqzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0OTozNlrOGInGNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1ODk1OQ==", "bodyText": "completeUpdateBlobUndeleteOperation", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411658959", "createdAt": "2020-04-20T20:10:20Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MjM1Ng==", "bodyText": "good catch.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411682356", "createdAt": "2020-04-20T20:49:36Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1ODk1OQ=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzUwODYxOnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxMjoxNVrOGIlvEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo1MjozM1rOGIsbhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA==", "bodyText": "The code looks like similar to updateBlobTtl. Is it possible to unify them?", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660050", "createdAt": "2020-04-20T20:12:15Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzAwNQ==", "bodyText": "I've tried to reuse most of them. The tricky. part is about those metrics and compete methods. I suppose there is way to reuse them but it seems not really necessary.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683005", "createdAt": "2020-04-20T20:50:39Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTczMw==", "bodyText": "The code looks like similar to updateBlobTtl. Is it possible to unify them?\n\nI made some new change, will this make you happy?", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411769733", "createdAt": "2020-04-20T23:52:33Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzUxNDA3OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxMzo0N1rOGIlyWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1MDo0NlrOGInI8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDg4OA==", "bodyText": "Tracks callbacks for update operations(TtlUpdate, Undelete)....", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660888", "createdAt": "2020-04-20T20:13:47Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzA1OQ==", "bodyText": "updated.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683059", "createdAt": "2020-04-20T20:50:46Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDg4OA=="}, "originalCommit": {"oid": "eb0e436fe160467c36ad52254d568602ae811fee"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA5NjA2OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Nzo1MlrOGIrB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo1MTo1MlrOGIsapw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5NQ==", "bodyText": "I know the logic is mostly from TtlUpdate but let's be careful on Undelete own logic here. Note that GetOption.None returns all blobs that are not expired and not deleted.  I wonder if we should use Include_Deleted_Blobs for undelete operation. Please double check GetOption enum.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411746795", "createdAt": "2020-04-20T22:57:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -706,6 +752,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before undelete)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTUxMQ==", "bodyText": "you are right, that was a mistake. updated.", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411769511", "createdAt": "2020-04-20T23:51:52Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -706,6 +752,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before undelete)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5NQ=="}, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwMjk4OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OTo1NVrOGIrFqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1OTo1NVrOGIrFqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzc1Mg==", "bodyText": "should beUndeleteOperation.class", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747752", "createdAt": "2020-04-20T22:59:55Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -243,6 +250,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentOperationRate\"));\n     deleteBlobOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationRate\"));\n+    undeleteBlobOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationRate\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwMzY4OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoxMlrOGIrGGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoxMlrOGIrGGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzg2Ng==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747866", "createdAt": "2020-04-20T23:00:12Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -252,6 +261,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetBlobNotOriginateLocalOperationRate\"));\n     deleteBlobNotOriginateLocalOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobNotOriginateLocalOperationRate\"));\n+    undeleteBlobNotOriginateLocalOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobNotOriginateLocalOperationRate\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwMzk3OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoyMFrOGIrGRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMDoyMFrOGIrGRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzkxMA==", "bodyText": "same here", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747910", "createdAt": "2020-04-20T23:00:20Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -282,6 +293,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.histogram(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobOperationTotalTimeMs\"));\n     deleteBlobOperationLatencyMs =\n         metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationLatencyMs\"));\n+    undeleteBlobOperationLatencyMs =\n+        metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationLatencyMs\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEwNzExOnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMToyNlrOGIrICA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowMToyNlrOGIrICA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0ODM2MA==", "bodyText": "make sure all recently added metrics in this file have been updated to either UndeleteOperation.class or UndeleteManager.class", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411748360", "createdAt": "2020-04-20T23:01:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -312,6 +325,7 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n     getEncryptedBlobWithSegmentErrorCount =\n         metricRegistry.counter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentErrorCount\"));\n     deleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobErrorCount\"));\n+    undeleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobErrorCount\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODE1MTU0OnYy", "diffSide": "RIGHT", "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNzo0OFrOGIrg8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNzo0OFrOGIrg8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDczOA==", "bodyText": "redundant cast, can remove (UndeleteRequest)", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411754738", "createdAt": "2020-04-20T23:17:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountService;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import com.github.ambry.clustermap.ClusterMapUtils;\n+import com.github.ambry.commons.BlobId;\n+import com.github.ambry.commons.ResponseHandler;\n+import com.github.ambry.config.RouterConfig;\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.notification.NotificationSystem;\n+import com.github.ambry.protocol.UndeleteRequest;\n+import com.github.ambry.protocol.UndeleteResponse;\n+import com.github.ambry.utils.Pair;\n+import com.github.ambry.utils.Time;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\n+/**\n+ * Handles {@link UndeleteOperation}. A {@code UndeleteManager} keeps track of all the Undelete\n+ * operations that are assigned to it, and manages their states and life cycles.\n+ */\n+public class UndeleteManager {\n+  private final ClusterMap clusterMap;\n+  private final NotificationSystem notificationSystem;\n+  private final Time time;\n+  private final ResponseHandler responseHandler;\n+  private final AccountService accountService;\n+  private final NonBlockingRouterMetrics routerMetrics;\n+  private final RouterConfig routerConfig;\n+  private final Set<UndeleteOperation> undeleteOperations = ConcurrentHashMap.newKeySet();\n+  private final Map<Integer, UndeleteOperation> correlationIdToUndeleteOperation = new HashMap<>();\n+  private final RequestRegistrationCallback<UndeleteOperation> requestRegistrationCallback =\n+      new RequestRegistrationCallback<>(correlationIdToUndeleteOperation);\n+\n+  /**\n+   * Creates a UndeleteManager.\n+   * @param clusterMap The {@link ClusterMap} of the cluster.\n+   * @param responseHandler The {@link ResponseHandler} used to notify failures for failure detection.\n+   * @param notificationSystem The {@link NotificationSystem} used for notifying undelete for blobs.\n+   * @param accountService The {@link AccountService} used for account/container id and name mapping.\n+   * @param routerConfig The {@link RouterConfig} containing the configs for the UndeleteManager.\n+   * @param routerMetrics The {@link NonBlockingRouterMetrics} to be used for reporting metrics.\n+   * @param time The {@link Time} instance to use.\n+   */\n+  UndeleteManager(ClusterMap clusterMap, ResponseHandler responseHandler, NotificationSystem notificationSystem,\n+      AccountService accountService, RouterConfig routerConfig, NonBlockingRouterMetrics routerMetrics, Time time) {\n+    this.clusterMap = clusterMap;\n+    this.responseHandler = responseHandler;\n+    this.notificationSystem = notificationSystem;\n+    this.accountService = accountService;\n+    this.routerConfig = routerConfig;\n+    this.routerMetrics = routerMetrics;\n+    this.time = time;\n+  }\n+\n+  /**\n+   * Submits {@link UndeleteOperation}(s) to this {@link UndeleteManager}.\n+   * @param blobIdStrs The original blobId strings\n+   * @param serviceId The service ID of the service undeleting the blob(s). This can be null if unknown.\n+   * @param futureResult The {@link FutureResult} that will contain the result eventually and exception if any.\n+   * @param callback The {@link Callback} that will be called on completion of the request.\n+   * @throws RouterException if the blobIdStr is invalid.\n+   */\n+  void submitUndeleteOperation(Collection<String> blobIdStrs, String serviceId, FutureResult<Void> futureResult,\n+      Callback<Void> callback) throws RouterException {\n+    List<BlobId> blobIds = new ArrayList<>();\n+    for (String blobIdStr : blobIdStrs) {\n+      BlobId blobId = RouterUtils.getBlobIdFromString(blobIdStr, clusterMap);\n+      if (blobId.getDatacenterId() != ClusterMapUtils.UNKNOWN_DATACENTER_ID\n+          && blobId.getDatacenterId() != clusterMap.getLocalDatacenterId()) {\n+        routerMetrics.undeleteBlobNotOriginateLocalOperationRate.mark();\n+      }\n+      blobIds.add(blobId);\n+    }\n+    if (blobIds.size() == 1) {\n+      UndeleteOperation undeleteOperation =\n+          new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobIds.get(0), serviceId, time.milliseconds(),\n+              callback, time, futureResult);\n+      undeleteOperations.add(undeleteOperation);\n+    } else {\n+      BatchOperationCallbackTracker tracker = new BatchOperationCallbackTracker(blobIds, futureResult, callback);\n+      long operationTimeMs = time.milliseconds();\n+      for (BlobId blobId : blobIds) {\n+        UndeleteOperation undeleteOperation =\n+            new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobId, serviceId, operationTimeMs,\n+                tracker.getCallback(blobId), time, BatchOperationCallbackTracker.DUMMY_FUTURE);\n+        undeleteOperations.add(undeleteOperation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Polls all undelete operations and populates a list of {@link RequestInfo} to be sent to data nodes in order to\n+   * complete undelete operations.\n+   * @param requestsToSend list to be filled with the requests created.\n+   * @param requestsToDrop list to be filled with the requests to drop.\n+   */\n+  void poll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop) {\n+    long startTime = time.milliseconds();\n+    requestRegistrationCallback.setRequestsToSend(requestsToSend);\n+    requestRegistrationCallback.setRequestsToDrop(requestsToDrop);\n+    for (UndeleteOperation op : undeleteOperations) {\n+      boolean exceptionEncountered = false;\n+      try {\n+        op.poll(requestRegistrationCallback);\n+      } catch (Exception e) {\n+        exceptionEncountered = true;\n+        op.setOperationException(new RouterException(\"Undelete poll encountered unexpected error\", e,\n+            RouterErrorCode.UnexpectedInternalError));\n+      }\n+      if (exceptionEncountered || op.isOperationComplete()) {\n+        if (undeleteOperations.remove(op)) {\n+          // In order to ensure that an operation is completed only once, call onComplete() only at the place where the\n+          // operation actually gets removed from the set of operations. See comment within close().\n+          onComplete(op);\n+        }\n+      }\n+    }\n+    routerMetrics.undeleteManagerPollTimeMs.update(time.milliseconds() - startTime);\n+  }\n+\n+  /**\n+   * Handles responses received for each of the {@link UndeleteOperation} within this UndeleteManager.\n+   * @param responseInfo the {@link ResponseInfo} containing the response.\n+   */\n+  void handleResponse(ResponseInfo responseInfo) {\n+    long startTime = time.milliseconds();\n+    UndeleteResponse undeleteResponse =\n+        RouterUtils.extractResponseAndNotifyResponseHandler(responseHandler, routerMetrics, responseInfo,\n+            UndeleteResponse::readFrom, UndeleteResponse::getError);\n+    RequestInfo routerRequestInfo = responseInfo.getRequestInfo();\n+    int correlationId = ((UndeleteRequest) routerRequestInfo.getRequest()).getCorrelationId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1484, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}