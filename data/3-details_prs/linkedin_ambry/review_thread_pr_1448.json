{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTA2MTQy", "number": 1448, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyODoyM1rODtRrnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyODoyM1rODtRrnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODAyMjA0OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/test/java/com.github.ambry.store/HardDeleterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyODoyM1rOF-m97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODo0MjoyNlrOF_Nyiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NDQ3Nw==", "bodyText": "This test is good, after verifying HardDelete doesn't move token forward, can we also verify calling pruneHardDeleteRecoveryRange should clear hardDeleteRecoveryRange?", "url": "https://github.com/linkedin/ambry/pull/1448#discussion_r401194477", "createdAt": "2020-03-31T20:28:23Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com.github.ambry.store/HardDeleterTest.java", "diffHunk": "@@ -378,29 +378,33 @@ public void testHardDelete() {\n         }\n         assertEquals(\"Recovery range size mismatch\", 0, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10*] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d 3u 1u]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10*] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u 10d 8d]\n         tokenMovedForward = index.hardDelete();\n         Assert.assertTrue(tokenMovedForward);\n-        hardDeletedKeys.add(keys.get(9)); // blobId10\n-        hardDeletedKeys.add(keys.get(7)); // blobId08\n         if (!recordContentChecked) {\n           checkRecordHardDeleted(keys, hardDeletedKeys);\n         }\n-        // blobid08 and blobid10\n-        assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d* 3u 1u]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u* 10d 8d]\n         tokenMovedForward = index.hardDelete();\n         Assert.assertTrue(tokenMovedForward);\n+        hardDeletedKeys.add(keys.get(9)); // blobId10\n+        hardDeletedKeys.add(keys.get(7)); // blobId08\n         if (!recordContentChecked) {\n           checkRecordHardDeleted(keys, hardDeletedKeys);\n         }\n+        // blobid08 and blobid10\n+        assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n+        // Persist safeToken here since now we have two items in the recovery range and their startToken is journal-based.\n+        token = (StoreFindToken) index.hardDeleter.getStartTokenSafeToPersistTo();\n+        index.hardDeleter.getHardDeleteRecoveryRange().pruneTill(token);\n+        // After prune we still have two\n         assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d 3u 1u*]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u 10d 8d*]\n         // All caught up, hardDelete should not move token forward.\n         tokenMovedForward = index.hardDelete();\n         Assert.assertFalse(tokenMovedForward);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e6b0f39931df7f3cb969feb6941f8bc61b6352"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzMDUzOQ==", "bodyText": "This is already done. Below I call persistAndAdvanceStartTokenSafeToPersist so trigger the prune and verify that the hardDeleteRecoveryRange is cleared.", "url": "https://github.com/linkedin/ambry/pull/1448#discussion_r401830539", "createdAt": "2020-04-01T18:42:26Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/test/java/com.github.ambry.store/HardDeleterTest.java", "diffHunk": "@@ -378,29 +378,33 @@ public void testHardDelete() {\n         }\n         assertEquals(\"Recovery range size mismatch\", 0, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10*] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d 3u 1u]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10*] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u 10d 8d]\n         tokenMovedForward = index.hardDelete();\n         Assert.assertTrue(tokenMovedForward);\n-        hardDeletedKeys.add(keys.get(9)); // blobId10\n-        hardDeletedKeys.add(keys.get(7)); // blobId08\n         if (!recordContentChecked) {\n           checkRecordHardDeleted(keys, hardDeletedKeys);\n         }\n-        // blobid08 and blobid10\n-        assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d* 3u 1u]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u* 10d 8d]\n         tokenMovedForward = index.hardDelete();\n         Assert.assertTrue(tokenMovedForward);\n+        hardDeletedKeys.add(keys.get(9)); // blobId10\n+        hardDeletedKeys.add(keys.get(7)); // blobId08\n         if (!recordContentChecked) {\n           checkRecordHardDeleted(keys, hardDeletedKeys);\n         }\n+        // blobid08 and blobid10\n+        assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n+        // Persist safeToken here since now we have two items in the recovery range and their startToken is journal-based.\n+        token = (StoreFindToken) index.hardDeleter.getStartTokenSafeToPersistTo();\n+        index.hardDeleter.getHardDeleteRecoveryRange().pruneTill(token);\n+        // After prune we still have two\n         assertEquals(\"Recovery range size mismatch\", 2, index.hardDeleter.getHardDeleteRecoveryRange().getSize());\n \n-        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [8d 10d] [1u 3u]\n-        // journal:                                                     [10d 8d 3u 1u*]\n+        // indexes: [1 2] [3 4] [3d 5] [6 7] [2d 6d] [8 9*] [1d 10] [1u 3u] [8d 10d]\n+        // journal:                                                    [3u 1u 10d 8d*]\n         // All caught up, hardDelete should not move token forward.\n         tokenMovedForward = index.hardDelete();\n         Assert.assertFalse(tokenMovedForward);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NDQ3Nw=="}, "originalCommit": {"oid": "e0e6b0f39931df7f3cb969feb6941f8bc61b6352"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1455, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}