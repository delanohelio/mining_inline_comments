{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNTkxODk3", "number": 1536, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzo0NDoxOFrOEAT_7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzo0NDoxOFrOEAT_7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzYzMTE5OnYy", "diffSide": "RIGHT", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipantMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzo0NDoxOFrOGbg7Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwMzoxNjo0OVrOGbkRjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwNDIxNA==", "bodyText": "This definitely is cleaner logic wise.\nMy only concern is that the gauge readings will result in 6 full scans of the map every minute (or whatever frequency), which could get expensive if the number of replicas is large.  A possible optimization would be to do a single scan periodically and update local counters for each state, which the gauges could read as before.  But the performance benefit may be too small to justify this.", "url": "https://github.com/linkedin/ambry/pull/1536#discussion_r431504214", "createdAt": "2020-05-27T23:44:18Z", "author": {"login": "lightningrob"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipantMetrics.java", "diffHunk": "@@ -16,55 +16,47 @@\n import com.codahale.metrics.Counter;\n import com.codahale.metrics.Gauge;\n import com.codahale.metrics.MetricRegistry;\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.concurrent.atomic.AtomicInteger;\n \n \n /**\n  * Metrics for {@link HelixParticipant} to monitor partition state transitions.\n  */\n class HelixParticipantMetrics {\n-  final AtomicInteger bootstrapCount = new AtomicInteger();\n-  final AtomicInteger standbyCount = new AtomicInteger();\n-  final AtomicInteger leaderCount = new AtomicInteger();\n-  final AtomicInteger inactiveCount = new AtomicInteger();\n   final AtomicInteger offlineCount = new AtomicInteger();\n-  final AtomicInteger errorStateCount = new AtomicInteger();\n   // no need to record exact number of \"dropped\" partition, a counter to track partition-dropped events would suffice\n   final Counter partitionDroppedCount;\n \n-  HelixParticipantMetrics(MetricRegistry metricRegistry, String zkConnectStr) {\n+  HelixParticipantMetrics(MetricRegistry metricRegistry, String zkConnectStr,\n+      Map<String, ReplicaState> localPartitionAndState) {\n     String zkSuffix = zkConnectStr == null ? \"\" : \"-\" + zkConnectStr;\n-    Gauge<Integer> bootstrapPartitionCount = bootstrapCount::get;\n+    Gauge<Integer> bootstrapPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.BOOTSTRAP);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"bootstrapPartitionCount\" + zkSuffix),\n         bootstrapPartitionCount);\n-    Gauge<Integer> standbyPartitionCount = standbyCount::get;\n+    Gauge<Integer> standbyPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.STANDBY);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"standbyPartitionCount\" + zkSuffix),\n         standbyPartitionCount);\n-    Gauge<Integer> leaderPartitionCount = leaderCount::get;\n+    Gauge<Integer> leaderPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.LEADER);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"leaderPartitionCount\" + zkSuffix),\n         leaderPartitionCount);\n-    Gauge<Integer> inactivePartitionCount = inactiveCount::get;\n+    Gauge<Integer> inactivePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.INACTIVE);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"inactivePartitionCount\" + zkSuffix),\n         inactivePartitionCount);\n-    Gauge<Integer> offlinePartitionCount = offlineCount::get;\n+    Gauge<Integer> offlinePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.OFFLINE);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"offlinePartitionCount\" + zkSuffix),\n         offlinePartitionCount);\n-    Gauge<Integer> errorStatePartitionCount = errorStateCount::get;\n+    Gauge<Integer> errorStatePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75a3544e530bc785ff9d89611282001533e3b681"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU1OTA1NQ==", "bodyText": "Fair point, I will try to scan once and cache the result for other 5 metrics.", "url": "https://github.com/linkedin/ambry/pull/1536#discussion_r431559055", "createdAt": "2020-05-28T03:16:49Z", "author": {"login": "jsjtzyy"}, "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipantMetrics.java", "diffHunk": "@@ -16,55 +16,47 @@\n import com.codahale.metrics.Counter;\n import com.codahale.metrics.Gauge;\n import com.codahale.metrics.MetricRegistry;\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.concurrent.atomic.AtomicInteger;\n \n \n /**\n  * Metrics for {@link HelixParticipant} to monitor partition state transitions.\n  */\n class HelixParticipantMetrics {\n-  final AtomicInteger bootstrapCount = new AtomicInteger();\n-  final AtomicInteger standbyCount = new AtomicInteger();\n-  final AtomicInteger leaderCount = new AtomicInteger();\n-  final AtomicInteger inactiveCount = new AtomicInteger();\n   final AtomicInteger offlineCount = new AtomicInteger();\n-  final AtomicInteger errorStateCount = new AtomicInteger();\n   // no need to record exact number of \"dropped\" partition, a counter to track partition-dropped events would suffice\n   final Counter partitionDroppedCount;\n \n-  HelixParticipantMetrics(MetricRegistry metricRegistry, String zkConnectStr) {\n+  HelixParticipantMetrics(MetricRegistry metricRegistry, String zkConnectStr,\n+      Map<String, ReplicaState> localPartitionAndState) {\n     String zkSuffix = zkConnectStr == null ? \"\" : \"-\" + zkConnectStr;\n-    Gauge<Integer> bootstrapPartitionCount = bootstrapCount::get;\n+    Gauge<Integer> bootstrapPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.BOOTSTRAP);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"bootstrapPartitionCount\" + zkSuffix),\n         bootstrapPartitionCount);\n-    Gauge<Integer> standbyPartitionCount = standbyCount::get;\n+    Gauge<Integer> standbyPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.STANDBY);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"standbyPartitionCount\" + zkSuffix),\n         standbyPartitionCount);\n-    Gauge<Integer> leaderPartitionCount = leaderCount::get;\n+    Gauge<Integer> leaderPartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.LEADER);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"leaderPartitionCount\" + zkSuffix),\n         leaderPartitionCount);\n-    Gauge<Integer> inactivePartitionCount = inactiveCount::get;\n+    Gauge<Integer> inactivePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.INACTIVE);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"inactivePartitionCount\" + zkSuffix),\n         inactivePartitionCount);\n-    Gauge<Integer> offlinePartitionCount = offlineCount::get;\n+    Gauge<Integer> offlinePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.OFFLINE);\n     metricRegistry.register(MetricRegistry.name(HelixParticipant.class, \"offlinePartitionCount\" + zkSuffix),\n         offlinePartitionCount);\n-    Gauge<Integer> errorStatePartitionCount = errorStateCount::get;\n+    Gauge<Integer> errorStatePartitionCount =\n+        () -> Collections.frequency(localPartitionAndState.values(), ReplicaState.ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwNDIxNA=="}, "originalCommit": {"oid": "75a3544e530bc785ff9d89611282001533e3b681"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1624, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}