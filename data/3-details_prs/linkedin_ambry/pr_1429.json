{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NDkzMjYz", "number": 1429, "title": "Introduce CompositeNetworkClient and factory", "bodyText": "This will allow requests to be routed to either an ambry-server or cloud\ndestination based on replica type for hybrid deployments of Ambry. It\ntakes in a map from replica type to client factory and chooses which\nrequests to send to which client.", "createdAt": "2020-03-16T21:02:21Z", "url": "https://github.com/linkedin/ambry/pull/1429", "merged": true, "mergeCommit": {"oid": "b0e5ab6d48c69dfe7b15022e436b339e9d94f49d"}, "closed": true, "closedAt": "2020-03-24T23:43:35Z", "author": {"login": "cgtz"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOUm9wgH2gAyMzg5NDkzMjYzOjBjY2JmYWZmNDEzOGIyNmI5MzdkMmE2OWU2YjA5N2Q1NDVmYzYwZTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQ7tYJAFqTM4MDc3MjA0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0ccbfaff4138b26b937d2a69e6b097d545fc60e8", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/0ccbfaff4138b26b937d2a69e6b097d545fc60e8", "committedDate": "2020-03-16T21:01:41Z", "message": "Introduce CompositeNetworkClient and factory\n\nThis will allow requests to be routed to either an ambry-server or cloud\ndestination based on replica type for hybrid deployments of Ambry. It\ntakes in a map from replica type to client factory and chooses which\nrequests to send to which client."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NTg1NTk4", "url": "https://github.com/linkedin/ambry/pull/1429#pullrequestreview-375585598", "createdAt": "2020-03-16T21:11:39Z", "commit": {"oid": "0ccbfaff4138b26b937d2a69e6b097d545fc60e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxMTozOVrOF3F6eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMToxMTozOVrOF3F6eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMjg4OA==", "bodyText": "will finish this test case", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r393312888", "createdAt": "2020-03-16T21:11:39Z", "author": {"login": "cgtz"}, "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  int nextCorrelationId = 0;\n+\n+  @Test\n+  public void testDelegation() throws IOException {\n+    Map<ReplicaType, NetworkClientFactory> childFactories = new HashMap<>();\n+    Pair<NetworkClientFactory, NetworkClient> mockOne = getMocks();\n+    childFactories.put(ReplicaType.DISK_BACKED, mockOne.getFirst());\n+    Pair<NetworkClientFactory, NetworkClient> mockTwo = getMocks();\n+    childFactories.put(ReplicaType.CLOUD_BACKED, mockTwo.getFirst());\n+\n+    CompositeNetworkClientFactory factory = new CompositeNetworkClientFactory(childFactories);\n+    factory.getNetworkClient();\n+    // the second call should call the underlying factories again\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    verify(mockOne.getFirst(), times(2)).getNetworkClient();\n+    verify(mockTwo.getFirst(), times(2)).getNetworkClient();\n+\n+    // warmUpConnections", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ccbfaff4138b26b937d2a69e6b097d545fc60e8"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314", "committedDate": "2020-03-18T19:22:09Z", "message": "Fixed test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDc4MzM3", "url": "https://github.com/linkedin/ambry/pull/1429#pullrequestreview-377478337", "createdAt": "2020-03-19T07:35:53Z", "commit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzozNTo1M1rOF4i3WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNzo1ODowNlrOF4jbRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNTgwMQ==", "bodyText": "Javadocs please.", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394835801", "createdAt": "2020-03-19T07:35:53Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgzNjgxMA==", "bodyText": "This seems pretty late in the method to throw an exception like this.  Could we catch it earlier?", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394836810", "createdAt": "2020-03-19T07:38:24Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {\n+  /**\n+   * Used to properly route requests to drop.\n+   */\n+  private final Map<Integer, ReplicaType> correlationIdToReplicaType = new HashMap<>();\n+  private final EnumMap<ReplicaType, NetworkClient> childNetworkClients;\n+\n+  CompositeNetworkClient(EnumMap<ReplicaType, NetworkClient> childNetworkClients) {\n+    this.childNetworkClients = childNetworkClients;\n+  }\n+\n+  @Override\n+  public List<ResponseInfo> sendAndPoll(List<RequestInfo> allRequestsToSend, Set<Integer> allRequestsToDrop,\n+      int pollTimeoutMs) {\n+    // the first item of the pair is requests to send, the second is correlation IDs to drop\n+    Function<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> pairBuilder =\n+        replicaType -> new Pair<>(new ArrayList<>(), new HashSet<>());\n+    EnumMap<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> requestsToSendAndDropByType =\n+        new EnumMap<>(ReplicaType.class);\n+    for (RequestInfo requestInfo : allRequestsToSend) {\n+      ReplicaType replicaType = requestInfo.getReplicaId().getReplicaType();\n+      requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getFirst().add(requestInfo);\n+      correlationIdToReplicaType.put(requestInfo.getRequest().getCorrelationId(), replicaType);\n+    }\n+    for (Integer correlationId : allRequestsToDrop) {\n+      ReplicaType replicaType = correlationIdToReplicaType.get(correlationId);\n+      if (replicaType != null) {\n+        requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getSecond().add(correlationId);\n+      }\n+    }\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    requestsToSendAndDropByType.forEach((replicaType, requestsToSendAndDrop) -> {\n+      NetworkClient client = childNetworkClients.get(replicaType);\n+      if (client == null) {\n+        throw new IllegalStateException(\"No NetworkClient configured for replica type: \" + replicaType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjA5MQ==", "bodyText": "This doesn't seem possible.  Can't we just call the method for all clients?  LocalNetworkClient returns 0 anyway.", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394842091", "createdAt": "2020-03-19T07:51:17Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClient.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import com.github.ambry.utils.Pair;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+\n+public class CompositeNetworkClient implements NetworkClient {\n+  /**\n+   * Used to properly route requests to drop.\n+   */\n+  private final Map<Integer, ReplicaType> correlationIdToReplicaType = new HashMap<>();\n+  private final EnumMap<ReplicaType, NetworkClient> childNetworkClients;\n+\n+  CompositeNetworkClient(EnumMap<ReplicaType, NetworkClient> childNetworkClients) {\n+    this.childNetworkClients = childNetworkClients;\n+  }\n+\n+  @Override\n+  public List<ResponseInfo> sendAndPoll(List<RequestInfo> allRequestsToSend, Set<Integer> allRequestsToDrop,\n+      int pollTimeoutMs) {\n+    // the first item of the pair is requests to send, the second is correlation IDs to drop\n+    Function<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> pairBuilder =\n+        replicaType -> new Pair<>(new ArrayList<>(), new HashSet<>());\n+    EnumMap<ReplicaType, Pair<List<RequestInfo>, Set<Integer>>> requestsToSendAndDropByType =\n+        new EnumMap<>(ReplicaType.class);\n+    for (RequestInfo requestInfo : allRequestsToSend) {\n+      ReplicaType replicaType = requestInfo.getReplicaId().getReplicaType();\n+      requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getFirst().add(requestInfo);\n+      correlationIdToReplicaType.put(requestInfo.getRequest().getCorrelationId(), replicaType);\n+    }\n+    for (Integer correlationId : allRequestsToDrop) {\n+      ReplicaType replicaType = correlationIdToReplicaType.get(correlationId);\n+      if (replicaType != null) {\n+        requestsToSendAndDropByType.computeIfAbsent(replicaType, pairBuilder).getSecond().add(correlationId);\n+      }\n+    }\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    requestsToSendAndDropByType.forEach((replicaType, requestsToSendAndDrop) -> {\n+      NetworkClient client = childNetworkClients.get(replicaType);\n+      if (client == null) {\n+        throw new IllegalStateException(\"No NetworkClient configured for replica type: \" + replicaType);\n+      }\n+      responses.addAll(\n+          client.sendAndPoll(requestsToSendAndDrop.getFirst(), requestsToSendAndDrop.getSecond(), pollTimeoutMs));\n+    });\n+    // clean up correlation ids for completed requests\n+    responses.forEach(\n+        response -> correlationIdToReplicaType.remove(response.getRequestInfo().getRequest().getCorrelationId()));\n+    return responses;\n+  }\n+\n+  @Override\n+  public int warmUpConnections(List<DataNodeId> dataNodeIds, int connectionWarmUpPercentagePerDataNode,\n+      long timeForWarmUp, List<ResponseInfo> responseInfoList) {\n+    // currently warm-up is only supported for connections to ambry-server.\n+    NetworkClient client = childNetworkClients.get(ReplicaType.DISK_BACKED);\n+    if (client != null) {\n+      return client.warmUpConnections(dataNodeIds, connectionWarmUpPercentagePerDataNode, timeForWarmUp,\n+          responseInfoList);\n+    } else {\n+      return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MjE5OA==", "bodyText": "javadoc", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394842198", "createdAt": "2020-03-19T07:51:36Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/main/java/com.github.ambry.network/CompositeNetworkClientFactory.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.ReplicaType;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+\n+public class CompositeNetworkClientFactory implements NetworkClientFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0MzMwNg==", "bodyText": "new line", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394843306", "createdAt": "2020-03-19T07:54:09Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  private final Mocks mockOne = new Mocks();\n+  private final Mocks mockTwo = new Mocks();\n+  private final CompositeNetworkClientFactory factory;\n+  private int nextCorrelationId = 0;\n+\n+  public CompositeNetworkClientTest() {\n+    Map<ReplicaType, NetworkClientFactory> childFactories = new HashMap<>();\n+    childFactories.put(ReplicaType.DISK_BACKED, mockOne.factory);\n+    childFactories.put(ReplicaType.CLOUD_BACKED, mockTwo.factory);\n+    factory = new CompositeNetworkClientFactory(childFactories);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClientFactory}\n+   */\n+  @Test\n+  public void testFactory() throws IOException {\n+    CompositeNetworkClient compositeClientOne = (CompositeNetworkClient) factory.getNetworkClient();\n+    CompositeNetworkClient compositeClientTwo = (CompositeNetworkClient) factory.getNetworkClient();\n+    assertNotNull(\"Client is null\", compositeClientOne);\n+    assertNotNull(\"Client is null\", compositeClientTwo);\n+    verify(mockOne.factory, times(2)).getNetworkClient();\n+    verify(mockTwo.factory, times(2)).getNetworkClient();\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#warmUpConnections}\n+   */\n+  @Test\n+  public void testWarmUp() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    when(mockOne.client.warmUpConnections(any(), anyInt(), anyLong(), any())).thenReturn(25);\n+    List<DataNodeId> nodesToWarmUp = Collections.nCopies(3, mock(DataNodeId.class));\n+    assertEquals(\"Unexpected number of connections warmed up\", 25,\n+        compositeClient.warmUpConnections(nodesToWarmUp, 100, 1000, Collections.emptyList()));\n+    verify(mockOne.client).warmUpConnections(nodesToWarmUp, 100, 1000, Collections.emptyList());\n+    verifyZeroInteractions(mockTwo.client);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#sendAndPoll}\n+   */\n+  @Test\n+  public void testSendAndPoll() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+\n+    // a couple for the first client and one request for the second client\n+    List<RequestInfo> requestsToSendOne =\n+        Arrays.asList(getRequestInfo(ReplicaType.DISK_BACKED), getRequestInfo(ReplicaType.CLOUD_BACKED),\n+            getRequestInfo(ReplicaType.DISK_BACKED));\n+    // try dropping unknown correlation ID, this should not cause issues\n+    Set<Integer> requestsToDrop = Collections.singleton(77);\n+    int pollTimeoutMs = 1000;\n+    List<ResponseInfo> responsesOne =\n+        Collections.singletonList(new ResponseInfo(requestsToSendOne.get(0), null, Unpooled.EMPTY_BUFFER));\n+    List<ResponseInfo> responsesTwo = Collections.emptyList();\n+    when(mockOne.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesOne);\n+    when(mockTwo.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesTwo);\n+    List<ResponseInfo> responses = compositeClient.sendAndPoll(requestsToSendOne, requestsToDrop, pollTimeoutMs);\n+    assertEquals(\"Unexpected response list\", responsesOne, responses);\n+    verify(mockOne.client).sendAndPoll(Arrays.asList(requestsToSendOne.get(0), requestsToSendOne.get(2)),\n+        Collections.emptySet(), pollTimeoutMs);\n+    verify(mockTwo.client).sendAndPoll(Collections.singletonList(requestsToSendOne.get(1)), Collections.emptySet(),\n+        pollTimeoutMs);\n+    verifyNoMoreInteractions(mockOne.client);\n+    verifyNoMoreInteractions(mockTwo.client);\n+\n+    mockOne.resetMocks();\n+    mockTwo.resetMocks();\n+    // two requests for the second client\n+    List<RequestInfo> requestsToSendTwo =\n+        Arrays.asList(getRequestInfo(ReplicaType.CLOUD_BACKED), getRequestInfo(ReplicaType.CLOUD_BACKED));\n+    // drop one request from the current iteration and one from the last\n+    requestsToDrop = Stream.of(requestsToSendOne.get(2), requestsToSendTwo.get(0))\n+        .map(r -> r.getRequest().getCorrelationId())\n+        .collect(Collectors.toSet());\n+    responsesOne = Collections.singletonList(new ResponseInfo(requestsToSendOne.get(2), null, Unpooled.EMPTY_BUFFER));\n+    responsesTwo = Collections.singletonList(new ResponseInfo(requestsToSendTwo.get(1), null, Unpooled.EMPTY_BUFFER));\n+    when(mockOne.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesOne);\n+    when(mockTwo.client.sendAndPoll(any(), any(), anyInt())).thenReturn(responsesTwo);\n+    responses = compositeClient.sendAndPoll(requestsToSendTwo, requestsToDrop, pollTimeoutMs);\n+    assertEquals(\"Unexpected response list\",\n+        Stream.of(responsesOne, responsesTwo).flatMap(List::stream).collect(Collectors.toList()), responses);\n+    verify(mockOne.client).sendAndPoll(Collections.emptyList(),\n+        Collections.singleton(requestsToSendOne.get(2).getRequest().getCorrelationId()), pollTimeoutMs);\n+    verify(mockTwo.client).sendAndPoll(requestsToSendTwo,\n+        Collections.singleton(requestsToSendTwo.get(0).getRequest().getCorrelationId()), pollTimeoutMs);\n+    verifyNoMoreInteractions(mockOne.client);\n+    verifyNoMoreInteractions(mockTwo.client);\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#wakeup}\n+   */\n+  @Test\n+  public void testWakeup() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    compositeClient.wakeup();\n+    verify(mockOne.client).wakeup();\n+    verify(mockTwo.client).wakeup();\n+  }\n+\n+  /**\n+   * Test {@link CompositeNetworkClient#close}\n+   */\n+  @Test\n+  public void testClose() throws IOException {\n+    NetworkClient compositeClient = factory.getNetworkClient();\n+    compositeClient.close();\n+    verify(mockOne.client).close();\n+    verify(mockTwo.client).close();\n+  }\n+\n+  /**\n+   * @param replicaType the {@link ReplicaType} for the request.\n+   * @return a new {@link RequestInfo} with a new correlation ID.\n+   */\n+  private RequestInfo getRequestInfo(ReplicaType replicaType) {\n+    return new RequestInfo(\"a\", new Port(1, PortType.SSL), new MockSend(nextCorrelationId++),\n+        new MockReplicaId(replicaType));\n+  }\n+\n+  private static class Mocks {\n+    private final NetworkClientFactory factory;\n+    private final NetworkClient client;\n+\n+    Mocks() {\n+      factory = mock(NetworkClientFactory.class);\n+      client = mock(NetworkClient.class);\n+      resetMocks();\n+    }\n+\n+    private void resetMocks() {\n+      try {\n+        reset(factory, client);\n+        when(factory.getNetworkClient()).thenReturn(client);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg0NDk5Ng==", "bodyText": "I had trouble following the mock usage.  Could we rename them diskMock and cloudMock to make it clearer?", "url": "https://github.com/linkedin/ambry/pull/1429#discussion_r394844996", "createdAt": "2020-03-19T07:58:06Z", "author": {"login": "lightningrob"}, "path": "ambry-network/src/test/java/com/github/ambry/network/CompositeNetworkClientTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.network;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockReplicaId;\n+import com.github.ambry.clustermap.ReplicaType;\n+import io.netty.buffer.Unpooled;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Test {@link CompositeNetworkClient} and {@link CompositeNetworkClientFactory}.\n+ */\n+public class CompositeNetworkClientTest {\n+  private final Mocks mockOne = new Mocks();\n+  private final Mocks mockTwo = new Mocks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ccff38e3b1fbbd08a22e543f6bdaaf8483e7314"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fadd0249ab481a828de1ee6ef8277c481688fdb8", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/fadd0249ab481a828de1ee6ef8277c481688fdb8", "committedDate": "2020-03-19T17:59:09Z", "message": "Address Rob's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dee8560c49be1a0b21b7fc77392f1903a07bb121", "author": {"user": {"login": "cgtz", "name": "Casey Getz"}}, "url": "https://github.com/linkedin/ambry/commit/dee8560c49be1a0b21b7fc77392f1903a07bb121", "committedDate": "2020-03-19T19:48:07Z", "message": "Add test for uncovered case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNjg4NDUz", "url": "https://github.com/linkedin/ambry/pull/1429#pullrequestreview-380688453", "createdAt": "2020-03-24T20:54:16Z", "commit": {"oid": "dee8560c49be1a0b21b7fc77392f1903a07bb121"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzcyMDQ5", "url": "https://github.com/linkedin/ambry/pull/1429#pullrequestreview-380772049", "createdAt": "2020-03-24T23:42:50Z", "commit": {"oid": "dee8560c49be1a0b21b7fc77392f1903a07bb121"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1304, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}