{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNDk0NjU0", "number": 1459, "title": "Add some metrics for cloud replication feed", "bodyText": "Add metrics to check cosmos change feed cache hit, miss and refresh rate.\nAdd metrics to check time taken for cloud replication feed query.", "createdAt": "2020-04-07T20:48:23Z", "url": "https://github.com/linkedin/ambry/pull/1459", "merged": true, "mergeCommit": {"oid": "a2804620c002dcf2777db86f3fa257af69da5f18"}, "closed": true, "closedAt": "2020-04-09T04:06:59Z", "author": {"login": "ankagrawal"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVuJTOgFqTM5MDMxMzUwMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVwCMiABqjMyMTYxNDM4NjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzEzNTAy", "url": "https://github.com/linkedin/ambry/pull/1459#pullrequestreview-390313502", "createdAt": "2020-04-08T20:38:16Z", "commit": {"oid": "f8badb8f8c13165b2bd15ab1e45a7846ceba3b23"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMDozODoxNlrOGDAC9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMDozODoxNlrOGDAC9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5OTY2OA==", "bodyText": "I probably misunderstand this but I am thinking if there is a case where cacheHit is true before entering the while(true) loop.  The first time code enters in while loop, index  == fetchedEntries.size() and jumps to else branch. It does fetch new changes and index is reset to 0. Then it goes back to beginning of while(true) and azureMetrics.changeFeedCacheHitRate.mark(); will be called. I just want to confirm this is a possible case and updating changeFeedCacheHitRate is what we expect.", "url": "https://github.com/linkedin/ambry/pull/1459#discussion_r405799668", "createdAt": "2020-04-08T20:38:16Z", "author": {"login": "jsjtzyy"}, "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosChangeFeedBasedReplicationFeed.java", "diffHunk": "@@ -169,49 +170,64 @@ public CosmosChangeFeedBasedReplicationFeed(CosmosDataAccessor cosmosDataAccesso\n   @Override\n   public FindResult getNextEntriesAndUpdatedToken(FindToken curFindToken, long maxTotalSizeOfEntries,\n       String partitionPath) throws DocumentClientException {\n-    List<CloudBlobMetadata> nextEntries = new ArrayList<>();\n-    CosmosChangeFeedFindToken cosmosChangeFeedFindToken = (CosmosChangeFeedFindToken) curFindToken;\n-    int index = cosmosChangeFeedFindToken.getIndex();\n-    ChangeFeedCacheEntry changeFeedCacheEntry = changeFeedCache.get(cosmosChangeFeedFindToken.getCacheSessionId());\n-    if (changeFeedCacheEntry == null || !isCacheValid(partitionPath, cosmosChangeFeedFindToken, changeFeedCacheEntry)) {\n-      // the cache may not be valid. So we cannot use session id\n-      changeFeedCacheEntry = getNextChangeFeed(partitionPath, cosmosChangeFeedFindToken.getStartContinuationToken());\n-      // invalidate the previous token's cache\n-      changeFeedCache.remove(cosmosChangeFeedFindToken.getCacheSessionId());\n-      index = 0;\n-    }\n+    Timer.Context operationTimer = azureMetrics.replicationFeedQueryTime.time();\n+    try {\n+      List<CloudBlobMetadata> nextEntries = new ArrayList<>();\n+      CosmosChangeFeedFindToken cosmosChangeFeedFindToken = (CosmosChangeFeedFindToken) curFindToken;\n+      int index = cosmosChangeFeedFindToken.getIndex();\n+      ChangeFeedCacheEntry changeFeedCacheEntry = changeFeedCache.get(cosmosChangeFeedFindToken.getCacheSessionId());\n+      boolean cacheHit = true;\n+      if (changeFeedCacheEntry == null || !isCacheValid(partitionPath, cosmosChangeFeedFindToken,\n+          changeFeedCacheEntry)) {\n+        // the cache may not be valid. So we cannot use session id\n+        azureMetrics.changeFeedCacheMissRate.mark();\n+        cacheHit = false;\n+        changeFeedCacheEntry = getNextChangeFeed(partitionPath, cosmosChangeFeedFindToken.getStartContinuationToken());\n+        // invalidate the previous token's cache\n+        changeFeedCache.remove(cosmosChangeFeedFindToken.getCacheSessionId());\n+        index = 0;\n+      }\n \n-    long resultSize = 0;\n+      long resultSize = 0;\n \n-    List<CloudBlobMetadata> fetchedEntries = changeFeedCacheEntry.getFetchedEntries();\n-    while (true) {\n-      if (index < fetchedEntries.size()) {\n-        if (resultSize + fetchedEntries.get(index).getSize() < maxTotalSizeOfEntries || resultSize == 0) {\n-          nextEntries.add(fetchedEntries.get(index));\n-          resultSize = resultSize + fetchedEntries.get(index).getSize();\n-          index++;\n+      List<CloudBlobMetadata> fetchedEntries = changeFeedCacheEntry.getFetchedEntries();\n+      while (true) {\n+        if (index < fetchedEntries.size()) {\n+          if (cacheHit) {\n+            azureMetrics.changeFeedCacheHitRate.mark();\n+            cacheHit = false;\n+          }\n+          if (resultSize + fetchedEntries.get(index).getSize() < maxTotalSizeOfEntries || resultSize == 0) {\n+            nextEntries.add(fetchedEntries.get(index));\n+            resultSize = resultSize + fetchedEntries.get(index).getSize();\n+            index++;\n+          } else {\n+            break;\n+          }\n         } else {\n-          break;\n-        }\n-      } else {\n-        // we can reuse the session id in this case, because we know that the cache ran out of new items.\n-        changeFeedCacheEntry = getNextChangeFeed(partitionPath, changeFeedCacheEntry.getEndContinuationToken(),\n-            changeFeedCacheEntry.getCacheSessionId());\n-        fetchedEntries = changeFeedCacheEntry.getFetchedEntries();\n-        if (fetchedEntries.isEmpty()) {\n-          // this means that there are no new changes\n-          break;\n+          // we can reuse the session id in this case, because we know that the cache ran out of new items.\n+          changeFeedCacheEntry = getNextChangeFeed(partitionPath, changeFeedCacheEntry.getEndContinuationToken(),\n+              changeFeedCacheEntry.getCacheSessionId());\n+          fetchedEntries = changeFeedCacheEntry.getFetchedEntries();\n+          if (fetchedEntries.isEmpty()) {\n+            // this means that there are no new changes\n+            break;\n+          } else {\n+            azureMetrics.changeFeedCacheRefreshRate.mark();\n+          }\n+          index = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8badb8f8c13165b2bd15ab1e45a7846ceba3b23"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzc2NDU4", "url": "https://github.com/linkedin/ambry/pull/1459#pullrequestreview-390376458", "createdAt": "2020-04-08T22:31:48Z", "commit": {"oid": "f8badb8f8c13165b2bd15ab1e45a7846ceba3b23"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58770f91a547d5708ddad00850f744a041401fb3", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/58770f91a547d5708ddad00850f744a041401fb3", "committedDate": "2020-04-08T22:42:36Z", "message": "Implementation of metrics for cloud replication feed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5c86d9e6875265d9a58a5b1f47864658982014", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/1c5c86d9e6875265d9a58a5b1f47864658982014", "committedDate": "2020-04-08T22:42:36Z", "message": "Add tests for metrics."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8badb8f8c13165b2bd15ab1e45a7846ceba3b23", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/f8badb8f8c13165b2bd15ab1e45a7846ceba3b23", "committedDate": "2020-04-07T20:34:50Z", "message": "Add tests for metrics."}, "afterCommit": {"oid": "1c5c86d9e6875265d9a58a5b1f47864658982014", "author": {"user": null}, "url": "https://github.com/linkedin/ambry/commit/1c5c86d9e6875265d9a58a5b1f47864658982014", "committedDate": "2020-04-08T22:42:36Z", "message": "Add tests for metrics."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1358, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}