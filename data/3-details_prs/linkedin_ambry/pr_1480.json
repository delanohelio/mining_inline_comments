{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2Mzk3Njg2", "number": 1480, "title": "Complete UndeleteOperation and add UndeleteOperationTracker", "bodyText": "Finish the implementation of UndeleteOperation.\n\nAdd handleResponse and poll method\nAdd UndeleteOperationTracker\nAdd tests for UndeleteOperation and UndeleteOperationTracker.", "createdAt": "2020-04-21T02:16:39Z", "url": "https://github.com/linkedin/ambry/pull/1480", "merged": true, "mergeCommit": {"oid": "fc66d2aa784db58f142ff01ab50a4b7493851ad0"}, "closed": true, "closedAt": "2020-04-29T22:00:49Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcafUx4AFqTM5OTI2Mjc4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABccfIDggFqTQwMzA0MjkzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MjYyNzg4", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-399262788", "createdAt": "2020-04-23T16:17:48Z", "commit": {"oid": "5125da1335c70af075d5781b916db638cbed56f9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjoxNzo0OFrOGKwo1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjoxNzo0OFrOGKwo1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNTgzMA==", "bodyText": "According to the design doc, the quorum target for the UNDELETE should be 2 per DC. Is there a follow up PR for this?", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r413935830", "createdAt": "2020-04-23T16:17:48Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -121,8 +122,9 @@\n    * |     PUT          |           N                     |       N - 1      |\n    * |    DELETE        |          3~N                    |         2        |\n    * |   TTLUpdate      |          3~N                    |         2        |\n+   * |   UNDELETE       |          3~N                    |         2        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5125da1335c70af075d5781b916db638cbed56f9"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5125da1335c70af075d5781b916db638cbed56f9", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/5125da1335c70af075d5781b916db638cbed56f9", "committedDate": "2020-04-22T18:26:05Z", "message": "more tests"}, "afterCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/88eaa9baa670727d7b08315c8e2232854c9e6378", "committedDate": "2020-04-23T18:23:22Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjQzOTkx", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-401243991", "createdAt": "2020-04-27T19:05:35Z", "commit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTowNTozNVrOGMzL7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTowNTozNVrOGMzL7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA3NDczNQ==", "bodyText": "if there are machines that are offline, they won't be included in this set. Is it okay to ignore them? I believe this policy currently says that an undelete needs 100% success from replicas that are currently up.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416074735", "createdAt": "2020-04-27T19:05:35Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -176,6 +179,15 @@\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n+      case UndeleteOperation:\n+        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        crossColoEnabled = true;\n+        eligibleReplicas = getEligibleReplicas(partitionId, null,\n+            EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMTM0NTA5", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-401134509", "createdAt": "2020-04-27T16:43:26Z", "commit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0MzoyN1rOGMtDuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxODozN1rOGMun7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NDMyOQ==", "bodyText": "Is this parallelism for each dc or all dcs (that is, total # of inflight requests in all colos <= parallelism)?", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415974329", "createdAt": "2020-04-27T16:43:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/config/RouterConfig.java", "diffHunk": "@@ -324,6 +325,13 @@\n   @Default(\"2\")\n   public final int routerTtlUpdateSuccessTarget;\n \n+  /**\n+   * The maximum number of parallel requests issued at a time by the undelete manager for a blob.\n+   */\n+  @Config(ROUTER_UNDELETE_REQUEST_PARALLELISM)\n+  @Default(\"3\")\n+  public final int routerUndeleteRequestParallelism;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4Mzc5NQ==", "bodyText": "Is this if required? Seems it can removed.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415983795", "createdAt": "2020-04-27T16:56:03Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      if (numEligibleReplicasInDcs.containsKey(dcName)) {\n+        int eligibleNum = numEligibleReplicasInDcs.get(dcName);\n+        if (eligibleNum != totalNum) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NTM2MQ==", "bodyText": "nit: has reached", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415985361", "createdAt": "2020-04-27T16:58:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      if (numEligibleReplicasInDcs.containsKey(dcName)) {\n+        int eligibleNum = numEligibleReplicasInDcs.get(dcName);\n+        if (eligibleNum != totalNum) {\n+          numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reaches the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.\n+   * @return true if current numbers reach the global quorum.\n+   */\n+  private static boolean hasReachedGlobalQuorum(Map<String, Integer> totalNumberInDcs,\n+      Map<String, Integer> currentNumberInDcs) {\n+    boolean hasReached = true;\n+    if (totalNumberInDcs.size() == currentNumberInDcs.size()) {\n+      for (String dcName : totalNumberInDcs.keySet()) {\n+        int totalNum = totalNumberInDcs.get(dcName);\n+        int currentNum = currentNumberInDcs.get(dcName);\n+        if (totalNum != 1 && currentNum <= totalNum / 2) {\n+          hasReached = false;\n+          break;\n+        }\n+      }\n+    } else {\n+      hasReached = false;\n+    }\n+    return hasReached;\n+  }\n+\n+  /**\n+   * Return true if any of the {@code currentNumberInDcs}'s value has reaches the quorum of corresponding value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NzAxMg==", "bodyText": "why we need totalNum != 1?  I think currentNum <= totalNum / 2 also applies to video cluster where some colos have only 1 replica.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415997012", "createdAt": "2020-04-27T17:14:27Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      if (numEligibleReplicasInDcs.containsKey(dcName)) {\n+        int eligibleNum = numEligibleReplicasInDcs.get(dcName);\n+        if (eligibleNum != totalNum) {\n+          numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reaches the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.\n+   * @return true if current numbers reach the global quorum.\n+   */\n+  private static boolean hasReachedGlobalQuorum(Map<String, Integer> totalNumberInDcs,\n+      Map<String, Integer> currentNumberInDcs) {\n+    boolean hasReached = true;\n+    if (totalNumberInDcs.size() == currentNumberInDcs.size()) {\n+      for (String dcName : totalNumberInDcs.keySet()) {\n+        int totalNum = totalNumberInDcs.get(dcName);\n+        int currentNum = currentNumberInDcs.get(dcName);\n+        if (totalNum != 1 && currentNum <= totalNum / 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NzQzNQ==", "bodyText": "has reached", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415997435", "createdAt": "2020-04-27T17:15:04Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      if (numEligibleReplicasInDcs.containsKey(dcName)) {\n+        int eligibleNum = numEligibleReplicasInDcs.get(dcName);\n+        if (eligibleNum != totalNum) {\n+          numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reaches the quorum of corresponding value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTk4MA==", "bodyText": "same question here, do we account for the colo with single replica?", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r415999980", "createdAt": "2020-04-27T17:18:37Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      if (numEligibleReplicasInDcs.containsKey(dcName)) {\n+        int eligibleNum = numEligibleReplicasInDcs.get(dcName);\n+        if (eligibleNum != totalNum) {\n+          numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reaches the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.\n+   * @return true if current numbers reach the global quorum.\n+   */\n+  private static boolean hasReachedGlobalQuorum(Map<String, Integer> totalNumberInDcs,\n+      Map<String, Integer> currentNumberInDcs) {\n+    boolean hasReached = true;\n+    if (totalNumberInDcs.size() == currentNumberInDcs.size()) {\n+      for (String dcName : totalNumberInDcs.keySet()) {\n+        int totalNum = totalNumberInDcs.get(dcName);\n+        int currentNum = currentNumberInDcs.get(dcName);\n+        if (totalNum != 1 && currentNum <= totalNum / 2) {\n+          hasReached = false;\n+          break;\n+        }\n+      }\n+    } else {\n+      hasReached = false;\n+    }\n+    return hasReached;\n+  }\n+\n+  /**\n+   * Return true if any of the {@code currentNumberInDcs}'s value has reaches the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.\n+   * @return true if any number reaches the quorum.\n+   */\n+  private static boolean hasReachedAnyLocalQuorum(Map<String, Integer> totalNumberInDcs,\n+      Map<String, Integer> currentNumberInDcs) {\n+    for (String dcName : totalNumberInDcs.keySet()) {\n+      int totalNum = totalNumberInDcs.get(dcName);\n+      if (currentNumberInDcs.containsKey(dcName)) {\n+        int currentNum = currentNumberInDcs.get(dcName);\n+        if (totalNum != 1 && currentNum > totalNum / 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjc0Mjkw", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-401274290", "createdAt": "2020-04-27T19:48:52Z", "commit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTo0ODo1MlrOGM0zww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTo0ODo1MlrOGM0zww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwMTMxNQ==", "bodyText": "final", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416101315", "createdAt": "2020-04-27T19:48:52Z", "author": {"login": "cgtz"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private Map<String, Integer> numReplicasInDcs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88eaa9baa670727d7b08315c8e2232854c9e6378", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/88eaa9baa670727d7b08315c8e2232854c9e6378", "committedDate": "2020-04-23T18:23:22Z", "message": "Comments"}, "afterCommit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e80d4a16672f5f79ea175bc95d6894b9c7ad586f", "committedDate": "2020-04-27T20:33:51Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTA1NTA3", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402105507", "createdAt": "2020-04-28T18:32:21Z", "commit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMjoyMVrOGNhjyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMjoyMVrOGNhjyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNDUwNA==", "bodyText": "total number of replicas?", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416834504", "createdAt": "2020-04-28T18:32:21Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private final Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private final Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private final Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      int eligibleNum = numEligibleReplicasInDcs.getOrDefault(dcName, 0);\n+      numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reached the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTA1ODYw", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402105860", "createdAt": "2020-04-28T18:32:50Z", "commit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMjo1MFrOGNhk1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMjo1MFrOGNhk1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNDc3NA==", "bodyText": "member -> replica?", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416834774", "createdAt": "2020-04-28T18:32:50Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private final Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private final Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private final Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      int eligibleNum = numEligibleReplicasInDcs.getOrDefault(dcName, 0);\n+      numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reached the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTA2NDI3", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402106427", "createdAt": "2020-04-28T18:33:36Z", "commit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMzozNlrOGNhmhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMzozNlrOGNhmhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNTIwNg==", "bodyText": "as discussed, adding some tests will be good.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416835206", "createdAt": "2020-04-28T18:33:36Z", "author": {"login": "zzmao"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperationTracker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.RouterConfig;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An implementation of {@link OperationTracker}. It internally maintains the status of a corresponding operation, and\n+ * returns information that decides if the operation should continue or terminate.\n+ *\n+ * This OperationTracker only works for {@link UndeleteOperation}. Since an {@link UndeleteOperation} requires a global\n+ * quorum for success, a map of datacenter to number of success requests is used to keep track of how many success requests\n+ * tracker has seen in each datacenter. Once it reaches quorum in all the datacenter, it returns true for success. Or if\n+ * any datacenter see failure requests reach the quorum, it return true for failure.\n+ */\n+public class UndeleteOperationTracker extends SimpleOperationTracker {\n+  private final Map<String, Integer> numReplicasInDcs = new HashMap<>();\n+  private final Map<String, Integer> numSuccessInDcs = new HashMap<>();\n+  private final Map<String, Integer> numFailureInDcs = new HashMap<>();\n+\n+  /**\n+   * Constructs an {@link UndeleteOperationTracker}\n+   * @param routerConfig The {@link RouterConfig} containing the configs for operation tracker.\n+   * @param partitionId The partition on which the operation is performed.\n+   * @param originatingDcName name of originating DC whose replicas should be tried first.\n+   */\n+  UndeleteOperationTracker(RouterConfig routerConfig, PartitionId partitionId, String originatingDcName) {\n+    super(routerConfig, RouterOperation.UndeleteOperation, partitionId, originatingDcName, false);\n+    List<? extends ReplicaId> replicas = partitionId.getReplicaIds();\n+    for (ReplicaId replica : replicas) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numReplicasInDcs.put(dcName, numReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+    Map<String, Integer> numEligibleReplicasInDcs = new HashMap<>();\n+    for (ReplicaId replica : replicaPool) {\n+      String dcName = replica.getDataNodeId().getDatacenterName();\n+      numEligibleReplicasInDcs.put(dcName, numEligibleReplicasInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+\n+    if (!hasReachedGlobalQuorum(numReplicasInDcs, numEligibleReplicasInDcs)) {\n+      throw new IllegalArgumentException(\n+          \"Eligible replicas are not sufficient for undelete operation for partition \" + partitionId);\n+    }\n+    // Consider not-eligible hosts as failure\n+    for (String dcName : numReplicasInDcs.keySet()) {\n+      int totalNum = numReplicasInDcs.get(dcName);\n+      int eligibleNum = numEligibleReplicasInDcs.getOrDefault(dcName, 0);\n+      numFailureInDcs.put(dcName, totalNum - eligibleNum);\n+    }\n+  }\n+\n+  @Override\n+  public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequestFinalState) {\n+    super.onResponse(replicaId, trackedRequestFinalState);\n+    String dcName = replicaId.getDataNodeId().getDatacenterName();\n+    if (trackedRequestFinalState == TrackedRequestFinalState.SUCCESS) {\n+      numSuccessInDcs.put(dcName, numSuccessInDcs.getOrDefault(dcName, 0) + 1);\n+    } else {\n+      numFailureInDcs.put(dcName, numFailureInDcs.getOrDefault(dcName, 0) + 1);\n+    }\n+  }\n+\n+  @Override\n+  public boolean hasSucceeded() {\n+    return hasReachedGlobalQuorum(numReplicasInDcs, numSuccessInDcs);\n+  }\n+\n+  @Override\n+  public boolean hasFailed() {\n+    return hasReachedAnyLocalQuorum(numReplicasInDcs, numFailureInDcs);\n+  }\n+\n+  /**\n+   * Return true if the {@code currentNumberInDcs}'s each value has reached the quorum of corresponding value\n+   * in {@code totalNumberInDcs}.\n+   * @param totalNumberInDcs The total number of members in each datacenter.\n+   * @param currentNumberInDcs The current number of members in each datacenter.\n+   * @return true if current numbers reach the global quorum.\n+   */\n+  private static boolean hasReachedGlobalQuorum(Map<String, Integer> totalNumberInDcs,\n+      Map<String, Integer> currentNumberInDcs) {\n+    boolean hasReached = true;\n+    if (totalNumberInDcs.size() == currentNumberInDcs.size()) {\n+      for (String dcName : totalNumberInDcs.keySet()) {\n+        int totalNum = totalNumberInDcs.get(dcName);\n+        int currentNum = currentNumberInDcs.getOrDefault(dcName, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTA2NTM2", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402106536", "createdAt": "2020-04-28T18:33:44Z", "commit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "238bb7f0afe60976001c13c904f7f3dac4d4fb95", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/238bb7f0afe60976001c13c904f7f3dac4d4fb95", "committedDate": "2020-04-28T18:35:29Z", "message": "Complete UndeleteOperation and add UndeleteOperationTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e01804f47efa4f79292ade39307318f9258e310", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/0e01804f47efa4f79292ade39307318f9258e310", "committedDate": "2020-04-28T18:35:29Z", "message": "Add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9715642fb2ce053305890fb7cda77c33d5ca62b3", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/9715642fb2ce053305890fb7cda77c33d5ca62b3", "committedDate": "2020-04-28T18:35:29Z", "message": "more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f062899fc440d0d182da5ca0c222818f959bdc5f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/f062899fc440d0d182da5ca0c222818f959bdc5f", "committedDate": "2020-04-28T18:35:29Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcb5700b6bca6c7a37fc1152350f36813ae826a1", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/dcb5700b6bca6c7a37fc1152350f36813ae826a1", "committedDate": "2020-04-28T18:35:29Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e26f630a4fd3fbe0e1471358b8440b2bbc4c4598", "committedDate": "2020-04-28T20:18:51Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e80d4a16672f5f79ea175bc95d6894b9c7ad586f", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e80d4a16672f5f79ea175bc95d6894b9c7ad586f", "committedDate": "2020-04-27T20:33:51Z", "message": "Comments"}, "afterCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e26f630a4fd3fbe0e1471358b8440b2bbc4c4598", "committedDate": "2020-04-28T20:18:51Z", "message": "Add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTk0MjUx", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402194251", "createdAt": "2020-04-28T20:40:13Z", "commit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjU0Njk5", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-402254699", "createdAt": "2020-04-28T22:22:52Z", "commit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoyMjo1MlrOGNpNVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxMjoxMVrOGOGYqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTgyOA==", "bodyText": "probably copied from TtlUpdateOperation, but resolvedRouterErrorCode at line59 is never used here.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416959828", "createdAt": "2020-04-28T22:22:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -58,6 +61,10 @@\n   private boolean operationCompleted = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MjI2MA==", "bodyText": "nit: these two lines can be combined to single line.", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r416962260", "createdAt": "2020-04-28T22:29:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -83,9 +90,7 @@\n     this.operationTimeMs = operationTimeMs;\n     byte blobDcId = blobId.getDatacenterId();\n     String originatingDcName = clusterMap.getDatacenterName(blobDcId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjk4MQ==", "bodyText": "minor: unnecessary unboxing for lifeVersion.shortValue()", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r417432981", "createdAt": "2020-04-29T16:05:13Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -104,6 +151,89 @@ void poll(RequestRegistrationCallback<UndeleteOperation> requestRegistrationCall\n    * @param undeleteResponse The {@link UndeleteResponse} associated with this response.\n    */\n   void handleResponse(ResponseInfo responseInfo, UndeleteResponse undeleteResponse) {\n+    UndeleteRequest undeleteRequest = (UndeleteRequest) responseInfo.getRequestInfo().getRequest();\n+    UndeleteRequestInfo undeleteRequestInfo = undeleteRequestInfos.remove(undeleteRequest.getCorrelationId());\n+    // undeleteRequestInfo can be null if this request was timed out before this response is received. No\n+    // metric is updated here, as corresponding metrics have been updated when the request was timed out.\n+    if (undeleteRequestInfo == null) {\n+      return;\n+    }\n+    ReplicaId replica = undeleteRequestInfo.replica;\n+    long requestLatencyMs = time.milliseconds() - undeleteRequestInfo.startTimeMs;\n+    routerMetrics.routerRequestLatencyMs.update(requestLatencyMs);\n+    routerMetrics.getDataNodeBasedMetrics(replica.getDataNodeId()).undeleteRequestLatencyMs.update(requestLatencyMs);\n+    // Check the error code from NetworkClient.\n+    if (responseInfo.getError() != null) {\n+      LOGGER.trace(\"UndeleteRequest with response correlationId {} timed out for replica {} \",\n+          undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+      onErrorResponse(replica, new RouterException(\"Operation timed out\", RouterErrorCode.OperationTimedOut));\n+    } else {\n+      if (undeleteResponse == null) {\n+        LOGGER.trace(\n+            \"UndeleteRequest with response correlationId {} received UnexpectedInternalError on response deserialization for replica {} \",\n+            undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+        onErrorResponse(replica, new RouterException(\"Response deserialization received an unexpected error\",\n+            RouterErrorCode.UnexpectedInternalError));\n+      } else {\n+        // The true case below should not really happen. This means a response has been received\n+        // not for its original request. We will immediately fail this operation.\n+        if (undeleteResponse.getCorrelationId() != undeleteRequest.getCorrelationId()) {\n+          LOGGER.error(\"The correlation id in the DeleteResponse \" + undeleteResponse.getCorrelationId()\n+              + \" is not the same as the correlation id in the associated DeleteRequest: \"\n+              + undeleteRequest.getCorrelationId());\n+          routerMetrics.unknownReplicaResponseError.inc();\n+          onErrorResponse(replica,\n+              new RouterException(\"Received wrong response that is not for the corresponding request.\",\n+                  RouterErrorCode.UnexpectedInternalError));\n+        } else {\n+          ServerErrorCode serverError = undeleteResponse.getError();\n+          if (serverError == ServerErrorCode.No_Error) {\n+            operationTracker.onResponse(replica, TrackedRequestFinalState.SUCCESS);\n+            if (RouterUtils.isRemoteReplica(routerConfig, replica)) {\n+              LOGGER.trace(\"Cross colo request successful for remote replica {} in {} \", replica.getDataNodeId(),\n+                  replica.getDataNodeId().getDatacenterName());\n+              routerMetrics.crossColoSuccessCount.inc();\n+            }\n+            if (lifeVersion == null) {\n+              // This is first successful response.\n+              lifeVersion = undeleteResponse.getLifeVersion();\n+              firstResponseReplicaId = replica;\n+            } else {\n+              if (lifeVersion.shortValue() != undeleteResponse.getLifeVersion()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMzE4MQ==", "bodyText": "minor: undelete request", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r417433181", "createdAt": "2020-04-29T16:05:30Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -104,6 +151,89 @@ void poll(RequestRegistrationCallback<UndeleteOperation> requestRegistrationCall\n    * @param undeleteResponse The {@link UndeleteResponse} associated with this response.\n    */\n   void handleResponse(ResponseInfo responseInfo, UndeleteResponse undeleteResponse) {\n+    UndeleteRequest undeleteRequest = (UndeleteRequest) responseInfo.getRequestInfo().getRequest();\n+    UndeleteRequestInfo undeleteRequestInfo = undeleteRequestInfos.remove(undeleteRequest.getCorrelationId());\n+    // undeleteRequestInfo can be null if this request was timed out before this response is received. No\n+    // metric is updated here, as corresponding metrics have been updated when the request was timed out.\n+    if (undeleteRequestInfo == null) {\n+      return;\n+    }\n+    ReplicaId replica = undeleteRequestInfo.replica;\n+    long requestLatencyMs = time.milliseconds() - undeleteRequestInfo.startTimeMs;\n+    routerMetrics.routerRequestLatencyMs.update(requestLatencyMs);\n+    routerMetrics.getDataNodeBasedMetrics(replica.getDataNodeId()).undeleteRequestLatencyMs.update(requestLatencyMs);\n+    // Check the error code from NetworkClient.\n+    if (responseInfo.getError() != null) {\n+      LOGGER.trace(\"UndeleteRequest with response correlationId {} timed out for replica {} \",\n+          undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+      onErrorResponse(replica, new RouterException(\"Operation timed out\", RouterErrorCode.OperationTimedOut));\n+    } else {\n+      if (undeleteResponse == null) {\n+        LOGGER.trace(\n+            \"UndeleteRequest with response correlationId {} received UnexpectedInternalError on response deserialization for replica {} \",\n+            undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+        onErrorResponse(replica, new RouterException(\"Response deserialization received an unexpected error\",\n+            RouterErrorCode.UnexpectedInternalError));\n+      } else {\n+        // The true case below should not really happen. This means a response has been received\n+        // not for its original request. We will immediately fail this operation.\n+        if (undeleteResponse.getCorrelationId() != undeleteRequest.getCorrelationId()) {\n+          LOGGER.error(\"The correlation id in the DeleteResponse \" + undeleteResponse.getCorrelationId()\n+              + \" is not the same as the correlation id in the associated DeleteRequest: \"\n+              + undeleteRequest.getCorrelationId());\n+          routerMetrics.unknownReplicaResponseError.inc();\n+          onErrorResponse(replica,\n+              new RouterException(\"Received wrong response that is not for the corresponding request.\",\n+                  RouterErrorCode.UnexpectedInternalError));\n+        } else {\n+          ServerErrorCode serverError = undeleteResponse.getError();\n+          if (serverError == ServerErrorCode.No_Error) {\n+            operationTracker.onResponse(replica, TrackedRequestFinalState.SUCCESS);\n+            if (RouterUtils.isRemoteReplica(routerConfig, replica)) {\n+              LOGGER.trace(\"Cross colo request successful for remote replica {} in {} \", replica.getDataNodeId(),\n+                  replica.getDataNodeId().getDatacenterName());\n+              routerMetrics.crossColoSuccessCount.inc();\n+            }\n+            if (lifeVersion == null) {\n+              // This is first successful response.\n+              lifeVersion = undeleteResponse.getLifeVersion();\n+              firstResponseReplicaId = replica;\n+            } else {\n+              if (lifeVersion.shortValue() != undeleteResponse.getLifeVersion()) {\n+                String message = String.format(\n+                    \"LifeVersion from Replica {} is different than the lifeVersion from replica {}, {} != {}\",\n+                    firstResponseReplicaId, replica, lifeVersion, undeleteResponse.getLifeVersion());\n+                LOGGER.error(message);\n+                // this is a successful response and one that completes the operation regardless of whether the\n+                // success target has been reached or not.\n+                operationCompleted = true;\n+                onErrorResponse(replica, new RouterException(message, RouterErrorCode.LifeVersionConflict));\n+              }\n+            }\n+          } else if (serverError == ServerErrorCode.Disk_Unavailable) {\n+            LOGGER.trace(\"Replica {} returned Disk_Unavailable for a delete request with correlationId : {} \", replica,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMzM0Mg==", "bodyText": "undelete request", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r417433342", "createdAt": "2020-04-29T16:05:45Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -104,6 +151,89 @@ void poll(RequestRegistrationCallback<UndeleteOperation> requestRegistrationCall\n    * @param undeleteResponse The {@link UndeleteResponse} associated with this response.\n    */\n   void handleResponse(ResponseInfo responseInfo, UndeleteResponse undeleteResponse) {\n+    UndeleteRequest undeleteRequest = (UndeleteRequest) responseInfo.getRequestInfo().getRequest();\n+    UndeleteRequestInfo undeleteRequestInfo = undeleteRequestInfos.remove(undeleteRequest.getCorrelationId());\n+    // undeleteRequestInfo can be null if this request was timed out before this response is received. No\n+    // metric is updated here, as corresponding metrics have been updated when the request was timed out.\n+    if (undeleteRequestInfo == null) {\n+      return;\n+    }\n+    ReplicaId replica = undeleteRequestInfo.replica;\n+    long requestLatencyMs = time.milliseconds() - undeleteRequestInfo.startTimeMs;\n+    routerMetrics.routerRequestLatencyMs.update(requestLatencyMs);\n+    routerMetrics.getDataNodeBasedMetrics(replica.getDataNodeId()).undeleteRequestLatencyMs.update(requestLatencyMs);\n+    // Check the error code from NetworkClient.\n+    if (responseInfo.getError() != null) {\n+      LOGGER.trace(\"UndeleteRequest with response correlationId {} timed out for replica {} \",\n+          undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+      onErrorResponse(replica, new RouterException(\"Operation timed out\", RouterErrorCode.OperationTimedOut));\n+    } else {\n+      if (undeleteResponse == null) {\n+        LOGGER.trace(\n+            \"UndeleteRequest with response correlationId {} received UnexpectedInternalError on response deserialization for replica {} \",\n+            undeleteRequest.getCorrelationId(), replica.getDataNodeId());\n+        onErrorResponse(replica, new RouterException(\"Response deserialization received an unexpected error\",\n+            RouterErrorCode.UnexpectedInternalError));\n+      } else {\n+        // The true case below should not really happen. This means a response has been received\n+        // not for its original request. We will immediately fail this operation.\n+        if (undeleteResponse.getCorrelationId() != undeleteRequest.getCorrelationId()) {\n+          LOGGER.error(\"The correlation id in the DeleteResponse \" + undeleteResponse.getCorrelationId()\n+              + \" is not the same as the correlation id in the associated DeleteRequest: \"\n+              + undeleteRequest.getCorrelationId());\n+          routerMetrics.unknownReplicaResponseError.inc();\n+          onErrorResponse(replica,\n+              new RouterException(\"Received wrong response that is not for the corresponding request.\",\n+                  RouterErrorCode.UnexpectedInternalError));\n+        } else {\n+          ServerErrorCode serverError = undeleteResponse.getError();\n+          if (serverError == ServerErrorCode.No_Error) {\n+            operationTracker.onResponse(replica, TrackedRequestFinalState.SUCCESS);\n+            if (RouterUtils.isRemoteReplica(routerConfig, replica)) {\n+              LOGGER.trace(\"Cross colo request successful for remote replica {} in {} \", replica.getDataNodeId(),\n+                  replica.getDataNodeId().getDatacenterName());\n+              routerMetrics.crossColoSuccessCount.inc();\n+            }\n+            if (lifeVersion == null) {\n+              // This is first successful response.\n+              lifeVersion = undeleteResponse.getLifeVersion();\n+              firstResponseReplicaId = replica;\n+            } else {\n+              if (lifeVersion.shortValue() != undeleteResponse.getLifeVersion()) {\n+                String message = String.format(\n+                    \"LifeVersion from Replica {} is different than the lifeVersion from replica {}, {} != {}\",\n+                    firstResponseReplicaId, replica, lifeVersion, undeleteResponse.getLifeVersion());\n+                LOGGER.error(message);\n+                // this is a successful response and one that completes the operation regardless of whether the\n+                // success target has been reached or not.\n+                operationCompleted = true;\n+                onErrorResponse(replica, new RouterException(message, RouterErrorCode.LifeVersionConflict));\n+              }\n+            }\n+          } else if (serverError == ServerErrorCode.Disk_Unavailable) {\n+            LOGGER.trace(\"Replica {} returned Disk_Unavailable for a delete request with correlationId : {} \", replica,\n+                undeleteRequest.getCorrelationId());\n+            operationTracker.onResponse(replica, TrackedRequestFinalState.DISK_DOWN);\n+            setOperationException(\n+                new RouterException(\"Server returned: \" + serverError, RouterErrorCode.AmbryUnavailable));\n+            routerMetrics.routerRequestErrorCount.inc();\n+            routerMetrics.getDataNodeBasedMetrics(replica.getDataNodeId()).undeleteRequestErrorCount.inc();\n+          } else {\n+            LOGGER.trace(\"Replica {} returned an error {} for a delete request with response correlationId : {} \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNzg2Ng==", "bodyText": "I feel BlobNotDeleted may have higher precedence level than OperationTimedOut", "url": "https://github.com/linkedin/ambry/pull/1480#discussion_r417437866", "createdAt": "2020-04-29T16:12:11Z", "author": {"login": "jsjtzyy"}, "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteOperation.java", "diffHunk": "@@ -141,19 +361,19 @@ private int getPrecedenceLevel(RouterErrorCode routerErrorCode) {\n     switch (routerErrorCode) {\n       case BlobAuthorizationFailure:\n         return 0;\n-      case BlobDeleted:\n+      case LifeVersionConflict:\n         return 1;\n       case BlobExpired:\n         return 2;\n-      case BlobUpdateNotAllowed:\n-        return 3;\n       case AmbryUnavailable:\n-        return 4;\n+        return 3;\n       case UnexpectedInternalError:\n-        return 5;\n+        return 4;\n       case OperationTimedOut:\n-        return 6;\n+        return 5;\n       case BlobDoesNotExist:\n+        return 6;\n+      case BlobNotDeleted:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26f630a4fd3fbe0e1471358b8440b2bbc4c4598"}, "originalPosition": 295}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0246b3d9dbe2b77e2608d72cb133a640b9aeb5f8", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/0246b3d9dbe2b77e2608d72cb133a640b9aeb5f8", "committedDate": "2020-04-29T16:30:28Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDQyOTMz", "url": "https://github.com/linkedin/ambry/pull/1480#pullrequestreview-403042933", "createdAt": "2020-04-29T21:11:49Z", "commit": {"oid": "0246b3d9dbe2b77e2608d72cb133a640b9aeb5f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1406, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}