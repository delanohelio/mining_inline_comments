{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyOTYxNDgx", "number": 1580, "title": "Add Iterator to index segment to reduce memory footprint in blobStoreStats", "bodyText": "Before this PR, in order to iterate through all the entries in an index segment, we have to call findEntriesSince method to get a copy of all index entries, which takes up a huge chunk of heap memory, especially in BlobStoreStats, where we constantly iterate through all the index segments.\nThis PR would reduce the memory footprint by creating an Iterator and a ListIterator for IndexSegment.\nAfter this PR, callers don't have to create a full list of all the entries in the index segment, rather just create an iterator and iterate through all of them one by one.", "createdAt": "2020-07-01T20:09:19Z", "url": "https://github.com/linkedin/ambry/pull/1580", "merged": true, "mergeCommit": {"oid": "140722686227e1547bbb9de9c4181698e3f2b5e2"}, "closed": true, "closedAt": "2020-07-15T21:45:48Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxCkGqgBqjM1MDgxNjQzNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1RlcOgFqTQ0OTM2MDIyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "359696bc8fe7267fb3c3be0e4928200d99d01a40", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/359696bc8fe7267fb3c3be0e4928200d99d01a40", "committedDate": "2020-07-01T20:31:55Z", "message": "change flags"}, "afterCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/628e63b27172545546bfbf91167575b15731e031", "committedDate": "2020-07-02T17:47:31Z", "message": "Remove something"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDcwMzM4", "url": "https://github.com/linkedin/ambry/pull/1580#pullrequestreview-442070338", "createdAt": "2020-07-02T23:31:41Z", "commit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzozMTo0MlrOGsfpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzozMTo0MlrOGsfpSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTAwMA==", "bodyText": "Is the purpose of copying the entries here to create a snapshot and avoid issues with the unsealed segment becoming sealed while iterating through it?", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449309000", "createdAt": "2020-07-02T23:31:42Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);\n         throw new IllegalStateException(message, e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;\n+    }\n+\n+    @Override\n+    public IndexEntry previous() {\n+      try {\n+        int i = cursor - 1;\n+        StoreKey key = getKeyAt(mmap, i);\n+        mmap.get(valueBuf);\n+        return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n+      } catch (Exception e) {\n+        String message = \"Failed to read index entry at \" + cursor;\n+        logger.error(message, e);\n+        throw new IllegalStateException(message, e);\n+      } finally {\n+        cursor--;\n+      }\n+    }\n+\n+    @Override\n+    public int nextIndex() {\n+      return cursor;\n+    }\n+\n+    @Override\n+    public int previousIndex() {\n+      return cursor - 1;\n+    }\n+\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException(\"Remove unsupported\");\n+    }\n+\n+    @Override\n+    public void set(IndexEntry indexEntry) {\n+      throw new UnsupportedOperationException(\"Set unsupported\");\n+    }\n+\n+    @Override\n+    public void add(IndexEntry indexEntry) {\n+      throw new UnsupportedOperationException(\"Add unsupported\");\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link Iterator} for a unsealed {@link IndexSegment}.\n+   */\n+  private class UnsealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected final ArrayList<IndexEntry> entries = new ArrayList<>();\n+    protected final Iterator<IndexEntry> it;\n+\n+    UnsealedIndexSegmentEntryIterator() {\n+      NavigableMap<StoreKey, ConcurrentSkipListSet<IndexValue>> indexMap = index;\n+      StoreKey keyCursor = indexMap.firstKey();\n+      while (keyCursor != null) {\n+        ConcurrentSkipListSet<IndexValue> indexValues = indexMap.get(keyCursor);\n+        Iterator<IndexValue> it = indexValues.iterator();\n+        while (it.hasNext()) {\n+          entries.add(new IndexEntry(keyCursor, it.next()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDcxMjQ0", "url": "https://github.com/linkedin/ambry/pull/1580#pullrequestreview-442071244", "createdAt": "2020-07-02T23:35:18Z", "commit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzozNToxOFrOGsfsig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzo0MTozMlrOGsfyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTgzNA==", "bodyText": "If this exception thrown is caught and logged by the caller already, it may be better to remove these log messages to prevent double logging.", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449309834", "createdAt": "2020-07-02T23:35:18Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMDg3MQ==", "bodyText": "add NoSuchElementCondition check to this method", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449310871", "createdAt": "2020-07-02T23:40:04Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);\n         throw new IllegalStateException(message, e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;\n+    }\n+\n+    @Override\n+    public IndexEntry previous() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMTI4MQ==", "bodyText": "Is cursor < 0 possible?", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449311281", "createdAt": "2020-07-02T23:41:32Z", "author": {"login": "cgtz"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031"}, "originalPosition": 111}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "628e63b27172545546bfbf91167575b15731e031", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/628e63b27172545546bfbf91167575b15731e031", "committedDate": "2020-07-02T17:47:31Z", "message": "Remove something"}, "afterCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "committedDate": "2020-07-13T17:19:04Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjU4OTQy", "url": "https://github.com/linkedin/ambry/pull/1580#pullrequestreview-447658942", "createdAt": "2020-07-13T22:37:51Z", "commit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozNzo1MVrOGw9KCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMTowMjozMVrOGxAJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjgyNQ==", "bodyText": "Not a relevant comment but I feel a bit of confused about getSlice method (maybe you can clarify it for me). It basically does some throttling and returns a MAX_VALUE. I didn't see the reason to return permissible I/O value there (it seems the return value is never used in production code). If it's not used, the method is not straightforward to me.", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r453986825", "createdAt": "2020-07-13T22:37:51Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -427,10 +426,11 @@ public void close() {\n             StoreErrorCodes.Store_Shutting_Down);\n       }\n       long indexSegmentStartProcessTimeMs = time.milliseconds();\n-      forEachValidIndexEntry(indexSegment, getIndexEntries(indexSegment), referenceTimeInMs, deletedKeys, entry -> {\n+      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTM2Ng==", "bodyText": "I still don't quite understand why previously it needs a sort here, in case it's an unsealed index segment?\nAlso KEY_OFFSET_COMPARATOR can be removed.", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454019366", "createdAt": "2020-07-14T00:08:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -484,100 +486,22 @@ public void close() {\n     return validSizePerLogSegment;\n   }\n \n-  /**\n-   * Get all {@link IndexEntry} in a given {@link IndexSegment}. There may be multiple entries for the same key\n-   * @param indexSegment the {@link IndexSegment} to fetch the index entries from\n-   * @return a {@link List} of all {@link IndexEntry} in the given {@link IndexSegment}. The returned list can have\n-   * multiple entries for the same key and is sorted in the ascending order of key,offset\n-   * @throws StoreException\n-   */\n-  private List<IndexEntry> getIndexEntries(IndexSegment indexSegment) throws StoreException {\n-    List<IndexEntry> indexEntries = new ArrayList<>();\n-    try {\n-      indexSegment.getIndexEntriesSince(null, new FindEntriesCondition(Long.MAX_VALUE), indexEntries, new AtomicLong(0),\n-          false);\n-      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,\n-          indexEntries.size());\n-      addPutEntriesForDelete(indexSegment.getStartOffset().getOffset(), indexEntries);\n-      indexEntries.sort(KEY_OFFSET_COMPARATOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyNjc2OQ==", "bodyText": "getPutRecordForDeletedKey can be removed as well", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454026769", "createdAt": "2020-07-14T00:33:26Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -484,100 +486,22 @@ public void close() {\n     return validSizePerLogSegment;\n   }\n \n-  /**\n-   * Get all {@link IndexEntry} in a given {@link IndexSegment}. There may be multiple entries for the same key\n-   * @param indexSegment the {@link IndexSegment} to fetch the index entries from\n-   * @return a {@link List} of all {@link IndexEntry} in the given {@link IndexSegment}. The returned list can have\n-   * multiple entries for the same key and is sorted in the ascending order of key,offset\n-   * @throws StoreException\n-   */\n-  private List<IndexEntry> getIndexEntries(IndexSegment indexSegment) throws StoreException {\n-    List<IndexEntry> indexEntries = new ArrayList<>();\n-    try {\n-      indexSegment.getIndexEntriesSince(null, new FindEntriesCondition(Long.MAX_VALUE), indexEntries, new AtomicLong(0),\n-          false);\n-      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,\n-          indexEntries.size());\n-      addPutEntriesForDelete(indexSegment.getStartOffset().getOffset(), indexEntries);\n-      indexEntries.sort(KEY_OFFSET_COMPARATOR);\n-      updateExpiryTimeForAllPuts(indexEntries);\n-    } catch (StoreException e) {\n-      throw new StoreException(\n-          String.format(\"Exception while getting entries from index segment for store %s : %s\", storeId,\n-              e.getMessage()), e, e.getErrorCode());\n-    }\n-    return indexEntries;\n-  }\n-\n-  /**\n-   * Adds put entries for any delete entries that may have squashed put entries in the same segment. Requires that a\n-   * put entry (if it exists) should occur before a delete entry for the same key in {@code indexEntries}\n-   * @param indexSegmentStartOffset the start offset of the {@link IndexSegment} from which {@code indexEntries} was\n-   *                                obtained\n-   * @param indexEntries the list of {@link IndexEntry} from the same {@link IndexSegment}. This list will be sorted\n-   *                     in the ascending order of key,offset\n-   * @throws StoreException if there are problems accessing the index\n-   */\n-  private void addPutEntriesForDelete(long indexSegmentStartOffset, List<IndexEntry> indexEntries)\n-      throws StoreException {\n-    Set<StoreKey> seenPuts = new HashSet<>();\n-    List<IndexEntry> newEntries = new ArrayList<>();\n-    for (IndexEntry entry : indexEntries) {\n-      IndexValue value = entry.getValue();\n-      if (value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-        if (value.getOriginalMessageOffset() != IndexValue.UNKNOWN_ORIGINAL_MESSAGE_OFFSET\n-            && value.getOriginalMessageOffset() < value.getOffset().getOffset()\n-            && value.getOriginalMessageOffset() >= indexSegmentStartOffset && !seenPuts.contains(entry.getKey())) {\n-          // We need to find the original put (if it has not already been processed)\n-          IndexValue originalPutValue = getPutRecordForDeletedKey(entry.getKey(), value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTk0OA==", "bodyText": "why not cursor > 0 ?", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454035948", "createdAt": "2020-07-14T01:02:31Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,34 +1233,175 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n-        logger.error(message, e);\n-        throw new IllegalStateException(message, e);\n+        throw new IllegalStateException(\n+            \"Failed to read index entry at \" + cursor + \" in index segment file \" + indexFile.getAbsolutePath(), e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n       }\n     }\n   }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "committedDate": "2020-07-14T23:24:11Z", "message": "Add Iterator to index segment to reduce memory footprint in blobstorestats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39e13b4910a177a4c01a184ac11458c6ba792cbb", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/39e13b4910a177a4c01a184ac11458c6ba792cbb", "committedDate": "2020-07-14T23:24:11Z", "message": "change flags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86c3663389bcb440651ef91caf7de55ac85c023e", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/86c3663389bcb440651ef91caf7de55ac85c023e", "committedDate": "2020-07-14T23:24:11Z", "message": "Remove something"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ffbb26b3636b393d400c0f10cc5543bd4aa759c", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/6ffbb26b3636b393d400c0f10cc5543bd4aa759c", "committedDate": "2020-07-14T23:24:11Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/2671631c45460971625a6b89ea0057f405cfb3c2", "committedDate": "2020-07-14T23:47:01Z", "message": "Comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "committedDate": "2020-07-13T17:19:04Z", "message": "Comments"}, "afterCommit": {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/2671631c45460971625a6b89ea0057f405cfb3c2", "committedDate": "2020-07-14T23:47:01Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NTg0OTE4", "url": "https://github.com/linkedin/ambry/pull/1580#pullrequestreview-448584918", "createdAt": "2020-07-15T02:21:23Z", "commit": {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MzYwMjIx", "url": "https://github.com/linkedin/ambry/pull/1580#pullrequestreview-449360221", "createdAt": "2020-07-15T21:33:21Z", "commit": {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1166, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}