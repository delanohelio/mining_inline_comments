{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NjMzNjU1", "number": 1624, "title": "[Container Scalability] Basic implementation of MySqlAccountService ", "bodyText": "Functionalities implemented:\na) Fetch all accounts and container metadata from DB and initialize cache on boot-up,\nb) Implement AccountService interface update APIs to write changes to mysql database and getter APIs to read changes from cache\nc) Scheduler thread to sync changes from DB\nd) Add MySqlAccountServiceFactory and MySqlAccountServiceConfig", "createdAt": "2020-09-12T01:31:18Z", "url": "https://github.com/linkedin/ambry/pull/1624", "merged": true, "mergeCommit": {"oid": "40ccf67cd5ac067a1006f3e8e807732de5f9c490"}, "closed": true, "closedAt": "2020-09-17T05:11:51Z", "author": {"login": "Arun-LinkedIn"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdH73tMgH2gAyNDg1NjMzNjU1OmY4MDQ4Yzk2ZmIzNTEzYjQ0NWIzOTY4ZmVlNTE4OGRkNDcyNzg0MDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJp4uMgFqTQ5MDI0NjgxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/f8048c96fb3513b445b3968fee5188dd47278400", "committedDate": "2020-09-11T20:59:57Z", "message": "Basic implementation of MySqlAccountService with following functionalities.\na) Fetch all accounts and container metadata from DB and initialize cache on boot-up,\nb) Implement AccountService interface update APIs to write changes to mysql database and getter APIs to read changes from cache\nc) Scheduler thread to sync changes from DB\nd) Add MySqlAccountServiceFactory and MySqlAccountServiceConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTk2OTQ3", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-488196947", "createdAt": "2020-09-14T22:24:31Z", "commit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyNDozMVrOHRpQSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMDowNToyMlrOHRrubA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2Mzc1NQ==", "bodyText": "minor: extra blank line", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488263755", "createdAt": "2020-09-14T22:24:31Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountStore.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2ODQ4NA==", "bodyText": "The first three should be required.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488268484", "createdAt": "2020-09-14T22:30:49Z", "author": {"login": "lightningrob"}, "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link MySqlAccountServiceConfig}\n+ */\n+public class MySqlAccountServiceConfig {\n+  public static final String MYSQL_ACCOUNT_SERVICE_PREFIX = \"mysql.account.service.\";\n+  public static final String DB_URL = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.url\";\n+  public static final String DB_USER = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.user\";\n+  public static final String DB_PASSWORD = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.password\";\n+  public static final String UPDATER_POLLING_INTERVAL_MS_KEY =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.polling.interval.ms\";\n+  public static final String UPDATER_SHUT_DOWN_TIMEOUT_MS_KEY =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.shut.down.timeout.ms\";\n+  public static final String BACKUP_DIRECTORY_KEY = MYSQL_ACCOUNT_SERVICE_PREFIX + \"backup.dir\";\n+  public static final String UPDATE_DISABLED = MYSQL_ACCOUNT_SERVICE_PREFIX + \"update.disabled\";\n+\n+  // TODO: Might need to take an array of URLs which would have one write (master) and multiple read urls (backup)\n+  @Config(DB_URL)\n+  @Default(\"\")\n+  public final String dbUrl;\n+\n+  @Config(DB_USER)\n+  @Default(\"\")\n+  public final String dbUser;\n+\n+  @Config(DB_PASSWORD)\n+  @Default(\"\")\n+  public final String dbPassword;\n+\n+  /**\n+   * The time interval in milli seconds between two consecutive account pulling for the background account updater of\n+   * {@code MySqlAccountService}. Setting to 0 will disable it.\n+   */\n+  @Config(UPDATER_POLLING_INTERVAL_MS_KEY)\n+  @Default(\"2 * 1000\")\n+  public final int updaterPollingIntervalMs;\n+\n+  /**\n+   * The timeout in ms to shut down the account updater of {@code MySqlAccountService}.\n+   */\n+  @Config(UPDATER_SHUT_DOWN_TIMEOUT_MS_KEY)\n+  @Default(\"5 * 1000\")\n+  public final int updaterShutDownTimeoutMs;\n+\n+  /**\n+   * The directory on the local machine where account data backups will be stored before updating accounts.\n+   * If this string is empty, backups will be disabled.\n+   */\n+  @Config(BACKUP_DIRECTORY_KEY)\n+  @Default(\"\")\n+  public final String backupDir;\n+\n+  /**\n+   * If true, MySqlAccountService would reject all the requests to update accounts.\n+   */\n+  @Config(UPDATE_DISABLED)\n+  @Default(\"false\")\n+  public final boolean updateDisabled;\n+\n+  public MySqlAccountServiceConfig(VerifiableProperties verifiableProperties) {\n+    dbUrl = verifiableProperties.getString(DB_URL, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MDQwMg==", "bodyText": "If this is rate of querying DB, 2 sec is much too small.  Default should be around 1 minute.  I would change the granularity to be seconds (not ms) for something like this.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488270402", "createdAt": "2020-09-14T22:33:24Z", "author": {"login": "lightningrob"}, "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link MySqlAccountServiceConfig}\n+ */\n+public class MySqlAccountServiceConfig {\n+  public static final String MYSQL_ACCOUNT_SERVICE_PREFIX = \"mysql.account.service.\";\n+  public static final String DB_URL = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.url\";\n+  public static final String DB_USER = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.user\";\n+  public static final String DB_PASSWORD = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.password\";\n+  public static final String UPDATER_POLLING_INTERVAL_MS_KEY =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.polling.interval.ms\";\n+  public static final String UPDATER_SHUT_DOWN_TIMEOUT_MS_KEY =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.shut.down.timeout.ms\";\n+  public static final String BACKUP_DIRECTORY_KEY = MYSQL_ACCOUNT_SERVICE_PREFIX + \"backup.dir\";\n+  public static final String UPDATE_DISABLED = MYSQL_ACCOUNT_SERVICE_PREFIX + \"update.disabled\";\n+\n+  // TODO: Might need to take an array of URLs which would have one write (master) and multiple read urls (backup)\n+  @Config(DB_URL)\n+  @Default(\"\")\n+  public final String dbUrl;\n+\n+  @Config(DB_USER)\n+  @Default(\"\")\n+  public final String dbUser;\n+\n+  @Config(DB_PASSWORD)\n+  @Default(\"\")\n+  public final String dbPassword;\n+\n+  /**\n+   * The time interval in milli seconds between two consecutive account pulling for the background account updater of\n+   * {@code MySqlAccountService}. Setting to 0 will disable it.\n+   */\n+  @Config(UPDATER_POLLING_INTERVAL_MS_KEY)\n+  @Default(\"2 * 1000\")\n+  public final int updaterPollingIntervalMs;\n+\n+  /**\n+   * The timeout in ms to shut down the account updater of {@code MySqlAccountService}.\n+   */\n+  @Config(UPDATER_SHUT_DOWN_TIMEOUT_MS_KEY)\n+  @Default(\"5 * 1000\")\n+  public final int updaterShutDownTimeoutMs;\n+\n+  /**\n+   * The directory on the local machine where account data backups will be stored before updating accounts.\n+   * If this string is empty, backups will be disabled.\n+   */\n+  @Config(BACKUP_DIRECTORY_KEY)\n+  @Default(\"\")\n+  public final String backupDir;\n+\n+  /**\n+   * If true, MySqlAccountService would reject all the requests to update accounts.\n+   */\n+  @Config(UPDATE_DISABLED)\n+  @Default(\"false\")\n+  public final boolean updateDisabled;\n+\n+  public MySqlAccountServiceConfig(VerifiableProperties verifiableProperties) {\n+    dbUrl = verifiableProperties.getString(DB_URL, \"\");\n+    dbUser = verifiableProperties.getString(DB_USER, \"\");\n+    dbPassword = verifiableProperties.getString(DB_PASSWORD, \"\");\n+    updaterPollingIntervalMs =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MTIyNw==", "bodyText": "Test constuctor?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488271227", "createdAt": "2020-09-14T22:34:33Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountServiceFactory.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * MySql based implementation of {@link AccountServiceFactory}.\n+ * <p/>\n+ * Returns a new instance of {@link MySqlAccountService} on {@link #getAccountService()} call.\n+ */\n+public class MySqlAccountServiceFactory implements AccountServiceFactory {\n+  private static final String MYSQL_ACCOUNT_UPDATER_PREFIX = \"mysql-account-updater\";\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountServiceFactory.class);\n+  protected final MySqlAccountServiceConfig accountServiceConfig;\n+  protected final AccountServiceMetrics accountServiceMetrics;\n+\n+  /**\n+   * Constructor.\n+   * @param verifiableProperties The properties to get a {@link MySqlAccountService} instance. Cannot be {@code null}.\n+   * @param metricRegistry The {@link MetricRegistry} for metrics tracking. Cannot be {@code null}.\n+   */\n+  public MySqlAccountServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry) {\n+    this(new MySqlAccountServiceConfig(verifiableProperties), new AccountServiceMetrics(metricRegistry));\n+  }\n+\n+  /**\n+   * Constructor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MjM0Mg==", "bodyText": "What's the advantage of creating the scheduler in the factory instead of in the service itself?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488272342", "createdAt": "2020-09-14T22:35:51Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountServiceFactory.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * MySql based implementation of {@link AccountServiceFactory}.\n+ * <p/>\n+ * Returns a new instance of {@link MySqlAccountService} on {@link #getAccountService()} call.\n+ */\n+public class MySqlAccountServiceFactory implements AccountServiceFactory {\n+  private static final String MYSQL_ACCOUNT_UPDATER_PREFIX = \"mysql-account-updater\";\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountServiceFactory.class);\n+  protected final MySqlAccountServiceConfig accountServiceConfig;\n+  protected final AccountServiceMetrics accountServiceMetrics;\n+\n+  /**\n+   * Constructor.\n+   * @param verifiableProperties The properties to get a {@link MySqlAccountService} instance. Cannot be {@code null}.\n+   * @param metricRegistry The {@link MetricRegistry} for metrics tracking. Cannot be {@code null}.\n+   */\n+  public MySqlAccountServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry) {\n+    this(new MySqlAccountServiceConfig(verifiableProperties), new AccountServiceMetrics(metricRegistry));\n+  }\n+\n+  /**\n+   * Constructor.\n+   * @param accountServiceConfig The {@link MySqlAccountServiceConfig} to use.\n+   * @param accountServiceMetrics The {@link AccountServiceMetrics} to report metrics.\n+   */\n+  protected MySqlAccountServiceFactory(MySqlAccountServiceConfig accountServiceConfig,\n+      AccountServiceMetrics accountServiceMetrics) {\n+    this.accountServiceConfig = accountServiceConfig;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+  }\n+\n+  @Override\n+  public AccountService getAccountService() {\n+    try {\n+      long startTimeMs = System.currentTimeMillis();\n+      logger.info(\"Starting a MySqlAccountService\");\n+      ScheduledExecutorService scheduler =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTA1OA==", "bodyText": "Minor: since this is used to lock accountInfoMap, can we call it infoMapLock?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488299058", "createdAt": "2020-09-14T23:48:21Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTM1Mg==", "bodyText": "Minor: private statics should appear before other privates.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488299352", "createdAt": "2020-09-14T23:49:20Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDU5OA==", "bodyText": "Needs to be volatile since it is lazy-loaded.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488300598", "createdAt": "2020-09-14T23:53:31Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDg4MA==", "bodyText": "Can remove this since the called method logged the same.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488300880", "createdAt": "2020-09-14T23:54:33Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzEyMg==", "bodyText": "I think we can check container name/id conflicts the same as accounts, even without versioning.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488303122", "createdAt": "2020-09-15T00:01:36Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);\n+      // Continue account service creation. Cache will initialized with metadata from backup copy on local disk to serve read requests.\n+      // Write requests will be blocked until MySql DB is up. Connection to MySql DB will be retried in polling thread that fetches new accounts.\n+    }\n+\n+    // TODO: create backup manager to manage local back up copies of Account and container metadata and lastModifiedTime\n+\n+    initialFetchAndSchedule();\n+\n+    // TODO: Subscribe to notifications from ZK\n+  }\n+\n+  /**\n+   * creates MySql Account store which establishes connection to database\n+   * @throws SQLException\n+   */\n+  private void createMySqlAccountStore() throws SQLException {\n+    if (mySqlAccountStore == null) {\n+      try {\n+        mySqlAccountStore = new MySqlAccountStore(config);\n+      } catch (SQLException e) {\n+        // TODO: record failure, parse exception to figure out what we did wrong. If it is a non-transient error like credential issue, we should fail start up\n+        logger.error(\"MySQL account store creation failed\", e);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Initialize in-memory cache by fetching all the {@link Account}s and {@link Container}s metadata records.\n+   * It consists of 2 steps:\n+   * 1. Check local disk for back up copy and load metadata and last modified time of Accounts/Containers into cache.\n+   * 2. Fetch added/modified accounts and containers from mysql database since the last modified time (found in step 1)\n+   *    and load into cache.\n+   */\n+  private void initialFetchAndSchedule() {\n+\n+    // TODO: Check local disk for back up copy and load metadata and last modified time into cache.\n+\n+    // Fetch added/modified accounts and containers from mysql db since LMT and update cache.\n+    fetchAndUpdateCache();\n+\n+    //Also, schedule to execute the logic periodically.\n+    if (scheduler != null) {\n+      scheduler.scheduleAtFixedRate(this::fetchAndUpdateCache, config.updaterPollingIntervalMs,\n+          config.updaterPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\"Background account updater will fetch accounts from mysql db at intervals of {} ms\",\n+          config.updaterPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Fetches all the accounts and containers that have been created or modified since the last sync time and loads into\n+   * cache.\n+   */\n+  private void fetchAndUpdateCache() {\n+    try {\n+      // Retry connection to mysql if we couldn't set up previously\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+      return;\n+    }\n+\n+    // get the last sync time of accounts and containers in cache\n+    long lastModifiedTime = accountInfoMap.getLastModifiedTime();\n+\n+    try {\n+      // Fetch all added/modified accounts and containers from MySql database since LMT\n+      List<Account> accounts = mySqlAccountStore.getNewAccounts(lastModifiedTime);\n+      List<Container> containers = mySqlAccountStore.getNewContainers(lastModifiedTime);\n+      rwLock.writeLock().lock();\n+      try {\n+        accountInfoMap.updateAccounts(accounts);\n+        accountInfoMap.updateContainers(containers);\n+      } finally {\n+        rwLock.writeLock().unlock();\n+      }\n+\n+      // TODO: Find the max LMT in the fetched accounts and containers and update the cache\n+\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountById(accountId);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountByName(accountName);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public boolean updateAccounts(Collection<Account> accounts) {\n+    Objects.requireNonNull(accounts, \"accounts cannot be null\");\n+    if (accounts.isEmpty()) {\n+      logger.debug(\"Empty account collection to update.\");\n+      return false;\n+    }\n+\n+    if (mySqlAccountStore == null) {\n+      logger.info(\"MySql Account DB store is not accessible\");\n+      return false;\n+    }\n+\n+    if (config.updateDisabled) {\n+      logger.info(\"Updates has been disabled\");\n+      return false;\n+    }\n+\n+    if (hasDuplicateAccountIdOrName(accounts)) {\n+      logger.error(\"Duplicate account id or name exist in the accounts to update\");\n+      //accountServiceMetrics.updateAccountErrorCount.inc();\n+      return false;\n+    }\n+\n+    // Make a pre check for conflict between the accounts to update and the accounts in the local cache. Will fail this\n+    // update operation for all the accounts if any conflict exists. For existing accounts, there is a chance that the account to update\n+    // conflicts with the accounts in the local cache, but does not conflict with those in the MySql database. This\n+    // will happen if some accounts are updated but the local cache is not yet refreshed.\n+    // TODO: Once we have APIs (and versioning) for updating containers, we will need to check conflicts for containers as well.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzc0OA==", "bodyText": "I really wish the interface method threw an exception.  The caller has no way to tell if it failed due to bad input or system error.  We should revisit this later.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488303748", "createdAt": "2020-09-15T00:03:47Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);\n+      // Continue account service creation. Cache will initialized with metadata from backup copy on local disk to serve read requests.\n+      // Write requests will be blocked until MySql DB is up. Connection to MySql DB will be retried in polling thread that fetches new accounts.\n+    }\n+\n+    // TODO: create backup manager to manage local back up copies of Account and container metadata and lastModifiedTime\n+\n+    initialFetchAndSchedule();\n+\n+    // TODO: Subscribe to notifications from ZK\n+  }\n+\n+  /**\n+   * creates MySql Account store which establishes connection to database\n+   * @throws SQLException\n+   */\n+  private void createMySqlAccountStore() throws SQLException {\n+    if (mySqlAccountStore == null) {\n+      try {\n+        mySqlAccountStore = new MySqlAccountStore(config);\n+      } catch (SQLException e) {\n+        // TODO: record failure, parse exception to figure out what we did wrong. If it is a non-transient error like credential issue, we should fail start up\n+        logger.error(\"MySQL account store creation failed\", e);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Initialize in-memory cache by fetching all the {@link Account}s and {@link Container}s metadata records.\n+   * It consists of 2 steps:\n+   * 1. Check local disk for back up copy and load metadata and last modified time of Accounts/Containers into cache.\n+   * 2. Fetch added/modified accounts and containers from mysql database since the last modified time (found in step 1)\n+   *    and load into cache.\n+   */\n+  private void initialFetchAndSchedule() {\n+\n+    // TODO: Check local disk for back up copy and load metadata and last modified time into cache.\n+\n+    // Fetch added/modified accounts and containers from mysql db since LMT and update cache.\n+    fetchAndUpdateCache();\n+\n+    //Also, schedule to execute the logic periodically.\n+    if (scheduler != null) {\n+      scheduler.scheduleAtFixedRate(this::fetchAndUpdateCache, config.updaterPollingIntervalMs,\n+          config.updaterPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\"Background account updater will fetch accounts from mysql db at intervals of {} ms\",\n+          config.updaterPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Fetches all the accounts and containers that have been created or modified since the last sync time and loads into\n+   * cache.\n+   */\n+  private void fetchAndUpdateCache() {\n+    try {\n+      // Retry connection to mysql if we couldn't set up previously\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+      return;\n+    }\n+\n+    // get the last sync time of accounts and containers in cache\n+    long lastModifiedTime = accountInfoMap.getLastModifiedTime();\n+\n+    try {\n+      // Fetch all added/modified accounts and containers from MySql database since LMT\n+      List<Account> accounts = mySqlAccountStore.getNewAccounts(lastModifiedTime);\n+      List<Container> containers = mySqlAccountStore.getNewContainers(lastModifiedTime);\n+      rwLock.writeLock().lock();\n+      try {\n+        accountInfoMap.updateAccounts(accounts);\n+        accountInfoMap.updateContainers(containers);\n+      } finally {\n+        rwLock.writeLock().unlock();\n+      }\n+\n+      // TODO: Find the max LMT in the fetched accounts and containers and update the cache\n+\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountById(accountId);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountByName(accountName);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public boolean updateAccounts(Collection<Account> accounts) {\n+    Objects.requireNonNull(accounts, \"accounts cannot be null\");\n+    if (accounts.isEmpty()) {\n+      logger.debug(\"Empty account collection to update.\");\n+      return false;\n+    }\n+\n+    if (mySqlAccountStore == null) {\n+      logger.info(\"MySql Account DB store is not accessible\");\n+      return false;\n+    }\n+\n+    if (config.updateDisabled) {\n+      logger.info(\"Updates has been disabled\");\n+      return false;\n+    }\n+\n+    if (hasDuplicateAccountIdOrName(accounts)) {\n+      logger.error(\"Duplicate account id or name exist in the accounts to update\");\n+      //accountServiceMetrics.updateAccountErrorCount.inc();\n+      return false;\n+    }\n+\n+    // Make a pre check for conflict between the accounts to update and the accounts in the local cache. Will fail this\n+    // update operation for all the accounts if any conflict exists. For existing accounts, there is a chance that the account to update\n+    // conflicts with the accounts in the local cache, but does not conflict with those in the MySql database. This\n+    // will happen if some accounts are updated but the local cache is not yet refreshed.\n+    // TODO: Once we have APIs (and versioning) for updating containers, we will need to check conflicts for containers as well.\n+    rwLock.readLock().lock();\n+    try {\n+      if (accountInfoMap.hasConflictingAccount(accounts)) {\n+        logger.error(\"Accounts={} conflict with the accounts in local cache. Cancel the update operation.\", accounts);\n+        //accountServiceMetrics.updateAccountErrorCount.inc();\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwNDIzNg==", "bodyText": "Minor: have been.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488304236", "createdAt": "2020-09-15T00:05:22Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);\n+      // Continue account service creation. Cache will initialized with metadata from backup copy on local disk to serve read requests.\n+      // Write requests will be blocked until MySql DB is up. Connection to MySql DB will be retried in polling thread that fetches new accounts.\n+    }\n+\n+    // TODO: create backup manager to manage local back up copies of Account and container metadata and lastModifiedTime\n+\n+    initialFetchAndSchedule();\n+\n+    // TODO: Subscribe to notifications from ZK\n+  }\n+\n+  /**\n+   * creates MySql Account store which establishes connection to database\n+   * @throws SQLException\n+   */\n+  private void createMySqlAccountStore() throws SQLException {\n+    if (mySqlAccountStore == null) {\n+      try {\n+        mySqlAccountStore = new MySqlAccountStore(config);\n+      } catch (SQLException e) {\n+        // TODO: record failure, parse exception to figure out what we did wrong. If it is a non-transient error like credential issue, we should fail start up\n+        logger.error(\"MySQL account store creation failed\", e);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Initialize in-memory cache by fetching all the {@link Account}s and {@link Container}s metadata records.\n+   * It consists of 2 steps:\n+   * 1. Check local disk for back up copy and load metadata and last modified time of Accounts/Containers into cache.\n+   * 2. Fetch added/modified accounts and containers from mysql database since the last modified time (found in step 1)\n+   *    and load into cache.\n+   */\n+  private void initialFetchAndSchedule() {\n+\n+    // TODO: Check local disk for back up copy and load metadata and last modified time into cache.\n+\n+    // Fetch added/modified accounts and containers from mysql db since LMT and update cache.\n+    fetchAndUpdateCache();\n+\n+    //Also, schedule to execute the logic periodically.\n+    if (scheduler != null) {\n+      scheduler.scheduleAtFixedRate(this::fetchAndUpdateCache, config.updaterPollingIntervalMs,\n+          config.updaterPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\"Background account updater will fetch accounts from mysql db at intervals of {} ms\",\n+          config.updaterPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Fetches all the accounts and containers that have been created or modified since the last sync time and loads into\n+   * cache.\n+   */\n+  private void fetchAndUpdateCache() {\n+    try {\n+      // Retry connection to mysql if we couldn't set up previously\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+      return;\n+    }\n+\n+    // get the last sync time of accounts and containers in cache\n+    long lastModifiedTime = accountInfoMap.getLastModifiedTime();\n+\n+    try {\n+      // Fetch all added/modified accounts and containers from MySql database since LMT\n+      List<Account> accounts = mySqlAccountStore.getNewAccounts(lastModifiedTime);\n+      List<Container> containers = mySqlAccountStore.getNewContainers(lastModifiedTime);\n+      rwLock.writeLock().lock();\n+      try {\n+        accountInfoMap.updateAccounts(accounts);\n+        accountInfoMap.updateContainers(containers);\n+      } finally {\n+        rwLock.writeLock().unlock();\n+      }\n+\n+      // TODO: Find the max LMT in the fetched accounts and containers and update the cache\n+\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountById(accountId);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountByName(accountName);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public boolean updateAccounts(Collection<Account> accounts) {\n+    Objects.requireNonNull(accounts, \"accounts cannot be null\");\n+    if (accounts.isEmpty()) {\n+      logger.debug(\"Empty account collection to update.\");\n+      return false;\n+    }\n+\n+    if (mySqlAccountStore == null) {\n+      logger.info(\"MySql Account DB store is not accessible\");\n+      return false;\n+    }\n+\n+    if (config.updateDisabled) {\n+      logger.info(\"Updates has been disabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzI4MTMx", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-488328131", "createdAt": "2020-09-15T05:07:43Z", "commit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTowNzo0M1rOHRw3jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDozMToyMFrOHSfqIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4ODQ5Mg==", "bodyText": "minor: format this file to optimize imports.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488388492", "createdAt": "2020-09-15T05:07:43Z", "author": {"login": "jsjtzyy"}, "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -13,15 +13,10 @@\n  */\n package com.github.ambry.account;\n \n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4OTAzMQ==", "bodyText": "looks like Intellij recommends Short.parseShort(idKey)", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r488389031", "createdAt": "2020-09-15T05:09:39Z", "author": {"login": "jsjtzyy"}, "path": "ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.github.ambry.account;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * <p>\n+ *   A class that represents a collection of {@link Account}s, where the ids and names of the\n+ *   {@link Account}s are one-to-one mapped. An {@code AccountInfoMap} guarantees no duplicated account\n+ *   id or name, nor conflict among the {@link Account}s within it.\n+ * </p>\n+ * <p>\n+ *   Based on the properties, a {@code AccountInfoMap} internally builds index for {@link Account}s using both\n+ *   {@link Account}'s id and name as key.\n+ * </p>\n+ */\n+class AccountInfoMap {\n+  private final Map<String, Account> nameToAccountMap;\n+  private final Map<Short, Account> idToAccountMap;\n+  // used to track last modified time of the accounts and containers in this cache\n+  private long lastModifiedTime = 0;\n+  private final static Logger logger = LoggerFactory.getLogger(AccountInfoMap.class);\n+\n+  /**\n+   * Constructor for an empty {@code AccountInfoMap}.\n+   */\n+  AccountInfoMap(AccountServiceMetrics accountServiceMetrics) {\n+    this(accountServiceMetrics, new HashMap<>());\n+  }\n+\n+  /**\n+   * <p>\n+   *   Constructs an {@code AccountInfoMap} from a group of {@link Account}s. The {@link Account}s exists\n+   *   in the form of a string-to-string map, where the key is the string form of an {@link Account}'s id,\n+   *   and the value is the string form of the {@link Account}'s JSON string.\n+   * </p>\n+   * <p>\n+   *   The source {@link Account}s in the {@code accountMap} may duplicate account ids or names, or corrupted\n+   *   JSON strings that cannot be parsed as valid {@link JSONObject}. In such cases, construction of\n+   *   {@code AccountInfoMap} will fail.\n+   * </p>\n+   * @param accountMap A map of {@link Account}s in the form of (accountIdString, accountJSONString).\n+   * @throws JSONException If parsing account data in json fails.\n+   */\n+  AccountInfoMap(AccountServiceMetrics accountServiceMetrics, Map<String, String> accountMap) throws JSONException {\n+    nameToAccountMap = new HashMap<>();\n+    idToAccountMap = new HashMap<>();\n+    for (Map.Entry<String, String> entry : accountMap.entrySet()) {\n+      String idKey = entry.getKey();\n+      String valueString = entry.getValue();\n+      Account account;\n+      JSONObject accountJson = new JSONObject(valueString);\n+      if (idKey == null) {\n+        accountServiceMetrics.remoteDataCorruptionErrorCount.inc();\n+        throw new IllegalStateException(\n+            \"Invalid account record when reading accountMap in ZNRecord because idKey=null\");\n+      }\n+      account = Account.fromJson(accountJson);\n+      if (account.getId() != Short.valueOf(idKey)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE0NTAyNA==", "bodyText": "This seems to be a warn  rather than info.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489145024", "createdAt": "2020-09-16T03:50:48Z", "author": {"login": "jsjtzyy"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);\n+      // Continue account service creation. Cache will initialized with metadata from backup copy on local disk to serve read requests.\n+      // Write requests will be blocked until MySql DB is up. Connection to MySql DB will be retried in polling thread that fetches new accounts.\n+    }\n+\n+    // TODO: create backup manager to manage local back up copies of Account and container metadata and lastModifiedTime\n+\n+    initialFetchAndSchedule();\n+\n+    // TODO: Subscribe to notifications from ZK\n+  }\n+\n+  /**\n+   * creates MySql Account store which establishes connection to database\n+   * @throws SQLException\n+   */\n+  private void createMySqlAccountStore() throws SQLException {\n+    if (mySqlAccountStore == null) {\n+      try {\n+        mySqlAccountStore = new MySqlAccountStore(config);\n+      } catch (SQLException e) {\n+        // TODO: record failure, parse exception to figure out what we did wrong. If it is a non-transient error like credential issue, we should fail start up\n+        logger.error(\"MySQL account store creation failed\", e);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Initialize in-memory cache by fetching all the {@link Account}s and {@link Container}s metadata records.\n+   * It consists of 2 steps:\n+   * 1. Check local disk for back up copy and load metadata and last modified time of Accounts/Containers into cache.\n+   * 2. Fetch added/modified accounts and containers from mysql database since the last modified time (found in step 1)\n+   *    and load into cache.\n+   */\n+  private void initialFetchAndSchedule() {\n+\n+    // TODO: Check local disk for back up copy and load metadata and last modified time into cache.\n+\n+    // Fetch added/modified accounts and containers from mysql db since LMT and update cache.\n+    fetchAndUpdateCache();\n+\n+    //Also, schedule to execute the logic periodically.\n+    if (scheduler != null) {\n+      scheduler.scheduleAtFixedRate(this::fetchAndUpdateCache, config.updaterPollingIntervalMs,\n+          config.updaterPollingIntervalMs, TimeUnit.MILLISECONDS);\n+      logger.info(\"Background account updater will fetch accounts from mysql db at intervals of {} ms\",\n+          config.updaterPollingIntervalMs);\n+    }\n+  }\n+\n+  /**\n+   * Fetches all the accounts and containers that have been created or modified since the last sync time and loads into\n+   * cache.\n+   */\n+  private void fetchAndUpdateCache() {\n+    try {\n+      // Retry connection to mysql if we couldn't set up previously\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+      return;\n+    }\n+\n+    // get the last sync time of accounts and containers in cache\n+    long lastModifiedTime = accountInfoMap.getLastModifiedTime();\n+\n+    try {\n+      // Fetch all added/modified accounts and containers from MySql database since LMT\n+      List<Account> accounts = mySqlAccountStore.getNewAccounts(lastModifiedTime);\n+      List<Container> containers = mySqlAccountStore.getNewContainers(lastModifiedTime);\n+      rwLock.writeLock().lock();\n+      try {\n+        accountInfoMap.updateAccounts(accounts);\n+        accountInfoMap.updateContainers(containers);\n+      } finally {\n+        rwLock.writeLock().unlock();\n+      }\n+\n+      // TODO: Find the max LMT in the fetched accounts and containers and update the cache\n+\n+    } catch (SQLException e) {\n+      logger.error(\"Fetching Accounts from MySql DB failed\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountById(accountId);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    rwLock.readLock().lock();\n+    try {\n+      return accountInfoMap.getAccountByName(accountName);\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  @Override\n+  public boolean updateAccounts(Collection<Account> accounts) {\n+    Objects.requireNonNull(accounts, \"accounts cannot be null\");\n+    if (accounts.isEmpty()) {\n+      logger.debug(\"Empty account collection to update.\");\n+      return false;\n+    }\n+\n+    if (mySqlAccountStore == null) {\n+      logger.info(\"MySql Account DB store is not accessible\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE0NzczNQ==", "bodyText": "Can we change the return type from List to Collection in this file?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489147735", "createdAt": "2020-09-16T04:01:58Z", "author": {"login": "jsjtzyy"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountStore.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.account.mysql.AccountDao;\n+import com.github.ambry.account.mysql.ContainerDao;\n+import com.github.ambry.account.mysql.MySqlDataAccessor;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\n+/**\n+ * Wrapper class to handle MySql store operations on Account and Container tables\n+ */\n+public class MySqlAccountStore {\n+\n+  private final AccountDao accountDao;\n+  private final ContainerDao containerDao;\n+\n+  public MySqlAccountStore(MySqlAccountServiceConfig config) throws SQLException {\n+    MySqlDataAccessor mySqlDataAccessor = new MySqlDataAccessor(config);\n+    accountDao = new AccountDao(mySqlDataAccessor);\n+    containerDao = new ContainerDao(mySqlDataAccessor);\n+  }\n+\n+  /**\n+   * Adds new {@link Account}s to Account table in MySql DB\n+   * @param accounts collection of {@link Account}s to be inserted\n+   * @throws SQLException\n+   */\n+  public void addAccounts(Collection<Account> accounts) throws SQLException {\n+    for (Account account : accounts) {\n+      accountDao.addAccount(account);\n+    }\n+  }\n+\n+  /**\n+   * Adds new {@link Container}s to Container table in MySql DB\n+   * @param containers collection of {@link Container}s to be inserted\n+   * @throws SQLException\n+   */\n+  public void addContainers(Collection<Container> containers) throws SQLException {\n+    for (Container container : containers) {\n+      containerDao.addContainer(container.getParentAccountId(), container);\n+    }\n+  }\n+\n+  /**\n+   * Updates existing {@link Account}s in Account table in MySql DB\n+   * @param accounts collection of {@link Account}s to be updated\n+   * @throws SQLException\n+   */\n+  public void updateAccounts(Collection<Account> accounts) throws SQLException {\n+    for (Account account : accounts) {\n+      accountDao.updateAccount(account);\n+    }\n+  }\n+\n+  /**\n+   * Updates existing {@link Container}s in Container table in MySql DB\n+   * @param containers collection of {@link Account}s to be updated\n+   * @throws SQLException\n+   */\n+  public void updateContainers(Collection<Container> containers) throws SQLException {\n+    for (Container container : containers) {\n+      containerDao.updateContainer(container.getParentAccountId(), container);\n+    }\n+  }\n+\n+  /**\n+   * Gets all {@link Account}s that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Account}s\n+   * @throws SQLException\n+   */\n+  public List<Account> getNewAccounts(long updatedSince) throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1NTEwNQ==", "bodyText": "Just a reminder that, for hadoop frontend, we are using rain which doesn't allow us to back up copy on disk. This can be solved by disabling backup based onBACKUP_DIRECTORY_KEY.  So, when backup is unavailable and MySQL connection failed, I think we should block the startup.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489155105", "createdAt": "2020-09-16T04:31:20Z", "author": {"login": "jsjtzyy"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.account.AccountUtils.*;\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that employs MySql database as its underlying storage.\n+ */\n+public class MySqlAccountService implements AccountService {\n+\n+  private MySqlAccountStore mySqlAccountStore = null;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final MySqlAccountServiceConfig config;\n+  // in-memory cache for storing account and container metadata\n+  private final AccountInfoMap accountInfoMap;\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountService.class);\n+  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n+  private final ScheduledExecutorService scheduler;\n+\n+  public MySqlAccountService(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config,\n+      ScheduledExecutorService scheduler) {\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    this.scheduler = scheduler;\n+    accountInfoMap = new AccountInfoMap(accountServiceMetrics);\n+    try {\n+      createMySqlAccountStore();\n+    } catch (SQLException e) {\n+      logger.error(\"MySQL account store creation failed\", e);\n+      // Continue account service creation. Cache will initialized with metadata from backup copy on local disk to serve read requests.\n+      // Write requests will be blocked until MySql DB is up. Connection to MySql DB will be retried in polling thread that fetches new accounts.\n+    }\n+\n+    // TODO: create backup manager to manage local back up copies of Account and container metadata and lastModifiedTime\n+\n+    initialFetchAndSchedule();\n+\n+    // TODO: Subscribe to notifications from ZK\n+  }\n+\n+  /**\n+   * creates MySql Account store which establishes connection to database\n+   * @throws SQLException\n+   */\n+  private void createMySqlAccountStore() throws SQLException {\n+    if (mySqlAccountStore == null) {\n+      try {\n+        mySqlAccountStore = new MySqlAccountStore(config);\n+      } catch (SQLException e) {\n+        // TODO: record failure, parse exception to figure out what we did wrong. If it is a non-transient error like credential issue, we should fail start up\n+        logger.error(\"MySQL account store creation failed\", e);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Initialize in-memory cache by fetching all the {@link Account}s and {@link Container}s metadata records.\n+   * It consists of 2 steps:\n+   * 1. Check local disk for back up copy and load metadata and last modified time of Accounts/Containers into cache.\n+   * 2. Fetch added/modified accounts and containers from mysql database since the last modified time (found in step 1)\n+   *    and load into cache.\n+   */\n+  private void initialFetchAndSchedule() {\n+\n+    // TODO: Check local disk for back up copy and load metadata and last modified time into cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8048c96fb3513b445b3968fee5188dd47278400"}, "originalPosition": 97}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84a053754a32a525949a916614cab6279258eced", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/84a053754a32a525949a916614cab6279258eced", "committedDate": "2020-09-16T04:48:25Z", "message": "Changes to add unit tests for MySqlAccountService and address Rob's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19ff704ef03da98cbc5e399b67df91e9b8d813af", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/19ff704ef03da98cbc5e399b67df91e9b8d813af", "committedDate": "2020-09-16T05:33:22Z", "message": "Address Yingyi's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc66aa0fe39b75e3c14673f3db652fd0f0c0d5e6", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/bc66aa0fe39b75e3c14673f3db652fd0f0c0d5e6", "committedDate": "2020-09-16T16:50:54Z", "message": "Add missing license for MySqlAccountServiceTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDQwNDcy", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-490040472", "createdAt": "2020-09-16T21:41:09Z", "commit": {"oid": "bc66aa0fe39b75e3c14673f3db652fd0f0c0d5e6"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo0MTowOVrOHTFOLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo0Nzo0MlrOHTFZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3MDU0Mw==", "bodyText": "minor: Configs for {@link MySqlAccountService}", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489770543", "createdAt": "2020-09-16T21:41:09Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link MySqlAccountServiceConfig}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc66aa0fe39b75e3c14673f3db652fd0f0c0d5e6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3MzQyOQ==", "bodyText": "Is 5 seconds sufficient to shutdown the scheduler in MySqlAccountService if there is an ongoing task performing \"fetchAndUpdate\" with Mysql?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489773429", "createdAt": "2020-09-16T21:47:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Config for {@link MySqlAccountServiceConfig}\n+ */\n+public class MySqlAccountServiceConfig {\n+  public static final String MYSQL_ACCOUNT_SERVICE_PREFIX = \"mysql.account.service.\";\n+  public static final String DB_URL = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.url\";\n+  public static final String DB_USER = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.user\";\n+  public static final String DB_PASSWORD = MYSQL_ACCOUNT_SERVICE_PREFIX + \"db.password\";\n+  public static final String UPDATER_POLLING_INTERVAL_SECONDS =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.polling.interval.seconds\";\n+  public static final String UPDATER_SHUT_DOWN_TIMEOUT_SECONDS =\n+      MYSQL_ACCOUNT_SERVICE_PREFIX + \"updater.shut.down.timeout.seconds\";\n+  public static final String BACKUP_DIRECTORY_KEY = MYSQL_ACCOUNT_SERVICE_PREFIX + \"backup.dir\";\n+  public static final String UPDATE_DISABLED = MYSQL_ACCOUNT_SERVICE_PREFIX + \"update.disabled\";\n+\n+  // TODO: Might need to take an array of URLs which would have one write (master) and multiple read urls (backup)\n+  /**\n+   * URL of the mysql database.\n+   */\n+  @Config(DB_URL)\n+  @Default(\"\")\n+  public final String dbUrl;\n+\n+  /**\n+   * Username for the mysql database.\n+   */\n+  @Config(DB_USER)\n+  @Default(\"\")\n+  public final String dbUser;\n+\n+  /**\n+   * Password for the mysql database.\n+   */\n+  @Config(DB_PASSWORD)\n+  @Default(\"\")\n+  public final String dbPassword;\n+\n+  /**\n+   * The time interval in seconds between two consecutive account pulling for the background account updater of\n+   * {@code MySqlAccountService}. Setting to 0 will disable it.\n+   */\n+  @Config(UPDATER_POLLING_INTERVAL_SECONDS)\n+  @Default(\"60\")\n+  public final int updaterPollingIntervalSeconds;\n+\n+  /**\n+   * The timeout in seconds to shut down the account updater of {@code MySqlAccountService}.\n+   */\n+  @Config(UPDATER_SHUT_DOWN_TIMEOUT_SECONDS)\n+  @Default(\"5\")\n+  public final int updaterShutDownTimeoutSeconds;\n+\n+  /**\n+   * The directory on the local machine where account data backups will be stored before updating accounts.\n+   * If this string is empty, backups will be disabled.\n+   */\n+  @Config(BACKUP_DIRECTORY_KEY)\n+  @Default(\"\")\n+  public final String backupDir;\n+\n+  /**\n+   * If true, MySqlAccountService would reject all the requests to update accounts.\n+   */\n+  @Config(UPDATE_DISABLED)\n+  @Default(\"false\")\n+  public final boolean updateDisabled;\n+\n+  public MySqlAccountServiceConfig(VerifiableProperties verifiableProperties) {\n+    dbUrl = verifiableProperties.getString(DB_URL);\n+    dbUser = verifiableProperties.getString(DB_USER);\n+    dbPassword = verifiableProperties.getString(DB_PASSWORD);\n+    updaterPollingIntervalSeconds =\n+        verifiableProperties.getIntInRange(UPDATER_POLLING_INTERVAL_SECONDS, 60, 0, Integer.MAX_VALUE);\n+    updaterShutDownTimeoutSeconds =\n+        verifiableProperties.getIntInRange(UPDATER_SHUT_DOWN_TIMEOUT_SECONDS, 5, 1, Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc66aa0fe39b75e3c14673f3db652fd0f0c0d5e6"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDcxOTI0", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-490071924", "createdAt": "2020-09-16T22:52:47Z", "commit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMjo1Mjo0N1rOHTG2NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMzoxMzo1MVrOHTHP-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5NzE3Mw==", "bodyText": "javadoc (one line okay)", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489797173", "createdAt": "2020-09-16T22:52:47Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/test/java/com/github/ambry/account/MySqlAccountServiceTest.java", "diffHunk": "@@ -0,0 +1,336 @@\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+\n+import static com.github.ambry.config.MySqlAccountServiceConfig.*;\n+import static com.github.ambry.utils.TestUtils.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+public class MySqlAccountServiceTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5NzM2NQ==", "bodyText": "Nit: move private method to bottom.", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489797365", "createdAt": "2020-09-16T22:53:29Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/test/java/com/github/ambry/account/MySqlAccountServiceTest.java", "diffHunk": "@@ -0,0 +1,336 @@\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+\n+import static com.github.ambry.config.MySqlAccountServiceConfig.*;\n+import static com.github.ambry.utils.TestUtils.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+public class MySqlAccountServiceTest {\n+\n+  AccountService mySqlAccountService;\n+  Properties mySqlConfigProps = new Properties();\n+\n+  public MySqlAccountServiceTest() {\n+    resetConfig();\n+  }\n+\n+  private void resetConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5OTgxNg==", "bodyText": "Also, instead of calling this at the end of each method, you could add the @before tag to have it called before each test automatically (probably need to make it public).", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489799816", "createdAt": "2020-09-16T23:01:11Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/test/java/com/github/ambry/account/MySqlAccountServiceTest.java", "diffHunk": "@@ -0,0 +1,336 @@\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.MySqlAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+\n+import static com.github.ambry.config.MySqlAccountServiceConfig.*;\n+import static com.github.ambry.utils.TestUtils.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+public class MySqlAccountServiceTest {\n+\n+  AccountService mySqlAccountService;\n+  Properties mySqlConfigProps = new Properties();\n+\n+  public MySqlAccountServiceTest() {\n+    resetConfig();\n+  }\n+\n+  private void resetConfig() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5NzM2NQ=="}, "originalCommit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwMTk2OA==", "bodyText": "What would value of 0 mean?  Update continuously?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489801968", "createdAt": "2020-09-16T23:08:15Z", "author": {"login": "lightningrob"}, "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -72,13 +81,13 @@\n   public final boolean updateDisabled;\n \n   public MySqlAccountServiceConfig(VerifiableProperties verifiableProperties) {\n-    dbUrl = verifiableProperties.getString(DB_URL, \"\");\n-    dbUser = verifiableProperties.getString(DB_USER, \"\");\n-    dbPassword = verifiableProperties.getString(DB_PASSWORD, \"\");\n-    updaterPollingIntervalMs =\n-        verifiableProperties.getIntInRange(UPDATER_POLLING_INTERVAL_MS_KEY, 2 * 1000, 0, Integer.MAX_VALUE);\n-    updaterShutDownTimeoutMs =\n-        verifiableProperties.getIntInRange(UPDATER_SHUT_DOWN_TIMEOUT_MS_KEY, 5 * 1000, 1, Integer.MAX_VALUE);\n+    dbUrl = verifiableProperties.getString(DB_URL);\n+    dbUser = verifiableProperties.getString(DB_USER);\n+    dbPassword = verifiableProperties.getString(DB_PASSWORD);\n+    updaterPollingIntervalSeconds =\n+        verifiableProperties.getIntInRange(UPDATER_POLLING_INTERVAL_SECONDS, 60, 0, Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwMzc2OQ==", "bodyText": "Can we add the error metrics and check they get incremented in the tests?", "url": "https://github.com/linkedin/ambry/pull/1624#discussion_r489803769", "createdAt": "2020-09-16T23:13:51Z", "author": {"login": "lightningrob"}, "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -187,22 +172,30 @@ public boolean updateAccounts(Collection<Account> accounts) {\n       return false;\n     }\n \n-    // Make a pre check for conflict between the accounts to update and the accounts in the local cache. Will fail this\n-    // update operation for all the accounts if any conflict exists. For existing accounts, there is a chance that the account to update\n-    // conflicts with the accounts in the local cache, but does not conflict with those in the MySql database. This\n-    // will happen if some accounts are updated but the local cache is not yet refreshed.\n-    // TODO: Once we have APIs (and versioning) for updating containers, we will need to check conflicts for containers as well.\n-    rwLock.readLock().lock();\n+    // Check for name/id/version conflicts between the accounts and containers being updated with those in local cache.\n+    // There is a slight chance that we have conflicts local cache, but not with MySql database. This will happen if\n+    // but the local cache is not yet refreshed with latest account info.\n+    infoMapLock.readLock().lock();\n     try {\n       if (accountInfoMap.hasConflictingAccount(accounts)) {\n         logger.error(\"Accounts={} conflict with the accounts in local cache. Cancel the update operation.\", accounts);\n         //accountServiceMetrics.updateAccountErrorCount.inc();\n         return false;\n       }\n+      for (Account account : accounts) {\n+        if (accountInfoMap.hasConflictingContainer(account.getAllContainers(), account.getId())) {\n+          logger.error(\n+              \"Containers={} under Account={} conflict with the containers in local cache. Cancel the update operation.\",\n+              account.getAllContainers(), account.getId());\n+          //accountServiceMetrics.updateAccountErrorCount.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a053754a32a525949a916614cab6279258eced"}, "originalPosition": 192}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eee66f0246dc3d799d980b316347d97fa974358c", "author": {"user": {"login": "Arun-LinkedIn", "name": "Arun Sai Bhima"}}, "url": "https://github.com/linkedin/ambry/commit/eee66f0246dc3d799d980b316347d97fa974358c", "committedDate": "2020-09-17T01:07:47Z", "message": "Address Rob's and Yingyi comments.\n- Updated shutdown timeout of account update background thread to 2 minutes.\n- Added metrics to capture failures in updateAccounts()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTg5NjM2", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-490189636", "createdAt": "2020-09-17T01:52:11Z", "commit": {"oid": "eee66f0246dc3d799d980b316347d97fa974358c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMjQ2ODEw", "url": "https://github.com/linkedin/ambry/pull/1624#pullrequestreview-490246810", "createdAt": "2020-09-17T05:10:37Z", "commit": {"oid": "eee66f0246dc3d799d980b316347d97fa974358c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1249, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}