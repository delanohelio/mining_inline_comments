{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MzI1MDU0", "number": 1509, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1MDoyMVrOD5_ZQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1NDo1M1rOD5_fVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM0MDgzOnYy", "diffSide": "RIGHT", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/AmbrySecurityService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1MDoyMVrOGRk5HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1MDoyMVrOGRk5HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4MzQyMQ==", "bodyText": "nit: not used anywhere.", "url": "https://github.com/linkedin/ambry/pull/1509#discussion_r421083421", "createdAt": "2020-05-06T20:50:21Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/AmbrySecurityService.java", "diffHunk": "@@ -38,6 +38,7 @@\n import java.util.Set;\n import java.util.TreeSet;\n import java.util.stream.Collectors;\n+import jdk.nashorn.internal.codegen.CompilerConstants;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0236b242a0a460935691927feee5b740faf842"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTM1NjM4OnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com/github/ambry/frontend/UrlSigningService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDo1NDo1M1rOGRlC0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTozNTowMVrOGRmTkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NTkwNg==", "bodyText": "I would encourage to be backward compatible here and keep the original method. Something like\nvoid verifySignedRequest(RestRequest restRequest);\n\ndefault void verifySignedRequest(RestRequest restRequest, Callback<Void> callback) {\n    verifySignedRequest(restRequest).\n    callback.onComplete(null, null);\n}\n\ndefault  Future<Void> verifySignedRequest(RestRequest restRequest) {\n    FutureResult<Void> futureResult = new FutureResult<>();\n    verifySignedRequest(restRequest, futureResult::done);\n    return futureResult;\n}", "url": "https://github.com/linkedin/ambry/pull/1509#discussion_r421085906", "createdAt": "2020-05-06T20:54:53Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-api/src/main/java/com/github/ambry/frontend/UrlSigningService.java", "diffHunk": "@@ -38,9 +41,21 @@\n   boolean isRequestSigned(RestRequest restRequest);\n \n   /**\n-   * Verifies that the signature in {@code restRequest} is valid.\n+   * Verifies that the signature in {@code restRequest} is valid. Any remote calls in the implementation should be made\n+   * asynchronously.\n    * @param restRequest the {@link RestRequest} to check.\n-   * @throws RestServiceException if there are problems verifying the URL.\n+   * @param callback the {@link Callback} that will be called after signature verification.\n    */\n-  void verifySignedRequest(RestRequest restRequest) throws RestServiceException;\n+  void verifySignedRequest(RestRequest restRequest, Callback<Void> callback);\n+\n+  /**\n+   * Similar to {@link #verifySignedRequest(RestRequest, Callback)}, but returns a future.\n+   * @param restRequest the {@link RestRequest} to check.\n+   * @return a {@link Future} that will be completed when signature verification is complete.\n+   */\n+  default Future<Void> verifySignedRequest(RestRequest restRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0236b242a0a460935691927feee5b740faf842"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNjU3Ng==", "bodyText": "Agreed, changed it to be backwards compatible, since most implementations won't have the async need anyways. I got rid of the future based method since the method signature collides with void verifySignedRequest(RestRequest restRequest). I think that's okay since there is no need for that method if the blocking method still exists.", "url": "https://github.com/linkedin/ambry/pull/1509#discussion_r421106576", "createdAt": "2020-05-06T21:35:01Z", "author": {"login": "cgtz"}, "path": "ambry-api/src/main/java/com/github/ambry/frontend/UrlSigningService.java", "diffHunk": "@@ -38,9 +41,21 @@\n   boolean isRequestSigned(RestRequest restRequest);\n \n   /**\n-   * Verifies that the signature in {@code restRequest} is valid.\n+   * Verifies that the signature in {@code restRequest} is valid. Any remote calls in the implementation should be made\n+   * asynchronously.\n    * @param restRequest the {@link RestRequest} to check.\n-   * @throws RestServiceException if there are problems verifying the URL.\n+   * @param callback the {@link Callback} that will be called after signature verification.\n    */\n-  void verifySignedRequest(RestRequest restRequest) throws RestServiceException;\n+  void verifySignedRequest(RestRequest restRequest, Callback<Void> callback);\n+\n+  /**\n+   * Similar to {@link #verifySignedRequest(RestRequest, Callback)}, but returns a future.\n+   * @param restRequest the {@link RestRequest} to check.\n+   * @return a {@link Future} that will be completed when signature verification is complete.\n+   */\n+  default Future<Void> verifySignedRequest(RestRequest restRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NTkwNg=="}, "originalCommit": {"oid": "0a0236b242a0a460935691927feee5b740faf842"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1565, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}