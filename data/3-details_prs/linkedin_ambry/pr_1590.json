{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NzYwMzE2", "number": 1590, "title": "Add support for undelete in blobstorestats", "bodyText": "Adding undelete support for blobstore stats in calculating valid entry size for log segment and container.\nRealtime updating valid size is not supported in this PR.", "createdAt": "2020-07-15T21:53:28Z", "url": "https://github.com/linkedin/ambry/pull/1590", "merged": true, "mergeCommit": {"oid": "7fe358c2c375dd2df6683c917e4f5e66db778d3b"}, "closed": true, "closedAt": "2020-07-21T18:55:40Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1tcXpgFqTQ1MDM4NDA3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3K5wPgFqTQ1Mjc0MDk4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzg0MDcw", "url": "https://github.com/linkedin/ambry/pull/1590#pullrequestreview-450384070", "createdAt": "2020-07-17T05:36:51Z", "commit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTozNjo1MVrOGzF9dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNTo1NTozOFrOGzGSag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyODIxMg==", "bodyText": "getting undeleted", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456228212", "createdAt": "2020-07-17T05:36:51Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -383,10 +377,16 @@ void handleNewDeleteEntry(IndexValue deleteValue, IndexValue originalPutValue) {\n    * @param originalPutValue the {@link IndexValue} of the original PUT that is getting updated\n    */\n   void handleNewTtlUpdateEntry(IndexValue ttlUpdateValue, IndexValue originalPutValue) {\n-    if (recentEntryQueueEnabled) {\n-      recentEntryQueue.offer(new Pair<>(ttlUpdateValue, originalPutValue));\n-      metrics.statsRecentEntryQueueSize.update(queueEntryCount.incrementAndGet());\n-    }\n+    enqueueNewValue(ttlUpdateValue, originalPutValue);\n+  }\n+\n+  /**\n+   * Function that handles new UNDELETE after a scan to keep the current {@link ScanResults} relevant.\n+   * @param undeleteValue the {@link IndexValue} of the new UNDELETE\n+   * @param originalPutValue the {@link IndexValue} of the original PUT that is getting deleted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyODU4Mw==", "bodyText": "actually, do we really need originalPutValue parameter here?", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456228583", "createdAt": "2020-07-17T05:38:18Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -383,10 +377,16 @@ void handleNewDeleteEntry(IndexValue deleteValue, IndexValue originalPutValue) {\n    * @param originalPutValue the {@link IndexValue} of the original PUT that is getting updated\n    */\n   void handleNewTtlUpdateEntry(IndexValue ttlUpdateValue, IndexValue originalPutValue) {\n-    if (recentEntryQueueEnabled) {\n-      recentEntryQueue.offer(new Pair<>(ttlUpdateValue, originalPutValue));\n-      metrics.statsRecentEntryQueueSize.update(queueEntryCount.incrementAndGet());\n-    }\n+    enqueueNewValue(ttlUpdateValue, originalPutValue);\n+  }\n+\n+  /**\n+   * Function that handles new UNDELETE after a scan to keep the current {@link ScanResults} relevant.\n+   * @param undeleteValue the {@link IndexValue} of the new UNDELETE\n+   * @param originalPutValue the {@link IndexValue} of the original PUT that is getting deleted\n+   */\n+  void handleNewUndeleteEntry(IndexValue undeleteValue, IndexValue originalPutValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMTAzMw==", "bodyText": "Could you add comment for removeFromStates  ?", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456231033", "createdAt": "2020-07-17T05:47:01Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzQyMQ==", "bodyText": "I might need some clarification, this else means the delete is the last record for certain key in this log segment, how can we know it's final state of whole persistent index? (Is it because we iterate from the very last index segment?)", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456233421", "createdAt": "2020-07-17T05:55:08Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 2. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzU3OA==", "bodyText": "minor: // 3. TTL_UPDATE", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r456233578", "createdAt": "2020-07-17T05:55:38Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +495,73 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 2. TTL_UPDATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9453670890e99a2a1051e2c662e08ce441724e2a"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODM3NzM5", "url": "https://github.com/linkedin/ambry/pull/1590#pullrequestreview-450837739", "createdAt": "2020-07-17T17:32:43Z", "commit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODA4NzY2", "url": "https://github.com/linkedin/ambry/pull/1590#pullrequestreview-451808766", "createdAt": "2020-07-20T17:22:14Z", "commit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzoyMjoxNFrOG0X7iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzozNzo1MlrOG0YezQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3MTIwOQ==", "bodyText": "nit:  put this if after line542", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457571209", "createdAt": "2020-07-20T17:22:14Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU3NTQyMA==", "bodyText": "Maybe I overlooked something but I feel like it doesn't check if final state is delete case when validating the current TtlUpdate, does it? Please point me to the logic if I missed anything.", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457575420", "createdAt": "2020-07-20T17:29:32Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }\n+          if (state.isDelete() || (state.getLifeVersion() != indexValue.getLifeVersion())) {\n+            // This UNDELETE is not valid, when the final state of this storeKey is\n+            // 1. DELETE, or\n+            // 2. the current lifeVersion is not the same\n+            continue;\n+          }\n+        } else {\n           long operationTimeInMs =\n               indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n                   : indexValue.getOperationTimeInMs();\n-          deletedKeys.put(indexEntry.getKey(), operationTimeInMs);\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n+        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+          validIndexEntryAction.accept(indexEntry);\n         }\n       } else if (indexValue.isTtlUpdate()) {\n-        if (isTtlUpdateEntryValid(indexEntry.getKey(), indexValue, referenceTimeInMs, deletedKeys)) {\n+        if (isTtlUpdateEntryValid(key, indexValue, referenceTimeInMs, keyFinalStates)) {\n           validIndexEntryAction.accept(indexEntry);\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MDIzNw==", "bodyText": "I don't understand why we need check inalState.getOperationTime() < referenceTimeInMs.  I think once final state is delete, this put is no longer valid.", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457580237", "createdAt": "2020-07-20T17:37:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -488,40 +494,76 @@ public void close() {\n    * same {@link IndexSegment}.\n    * @param indexSegment the {@link IndexSegment} where the entries came from\n    * @param referenceTimeInMs the reference time in ms until which deletes and expiration are relevant\n-   * @param deletedKeys a {@link Map} of deleted keys to operation time. Used to determine whether a PUT is deleted\n+   * @param keyFinalStates a {@link Map} of key to {@link IndexFinalState}.\n+   * @param removeFromStates if {@code True}, then remove the {@link IndexFinalState} from the given map {@code keyFinalStates}\n+   *                         when encountering PUT IndexValue. This method iterates through IndexValues from most recent one to\n+   *                         earliest one, so PUT IndexValue is the last IndexValue for the same key.\n    * @param validIndexEntryAction the action to take on each valid {@link IndexEntry} found.\n    * @throws StoreException if there are problems reading the index.\n    */\n   private void forEachValidIndexEntry(IndexSegment indexSegment, long referenceTimeInMs,\n-      Map<StoreKey, Long> deletedKeys, IndexEntryAction validIndexEntryAction) throws StoreException {\n+      Map<StoreKey, IndexFinalState> keyFinalStates, boolean removeFromStates, IndexEntryAction validIndexEntryAction)\n+      throws StoreException {\n     ListIterator<IndexEntry> it = indexSegment.listIterator(indexSegment.size());\n     while (it.hasPrevious()) {\n       IndexEntry indexEntry = it.previous();\n       IndexValue indexValue = indexEntry.getValue();\n+      StoreKey key = indexEntry.getKey();\n       if (indexValue.isDelete()) {\n-        // delete record is always valid\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isUndelete() || (state.isDelete() && state.getLifeVersion() != indexValue.getLifeVersion()) || state\n+              .isTtlUpdate()) {\n+            // This DELETE is not valid, when the final state of this storeKey is\n+            // 1. UNDELETE, or\n+            // 2. DELETE, but the current lifeVersion is not the same, or\n+            // 3. TTL_UPDATE\n+            continue;\n+          }\n+        } else {\n+          long operationTimeInMs =\n+              indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n+                  : indexValue.getOperationTimeInMs();\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n         validIndexEntryAction.accept(indexEntry);\n-        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+      } else if (indexValue.isUndelete()) {\n+        if (keyFinalStates.containsKey(key)) {\n+          IndexFinalState state = keyFinalStates.get(key);\n+          if (state.isTtlUpdate()) {\n+            indexValue.setExpiresAtMs(Utils.Infinite_Time);\n+          }\n+          if (state.isDelete() || (state.getLifeVersion() != indexValue.getLifeVersion())) {\n+            // This UNDELETE is not valid, when the final state of this storeKey is\n+            // 1. DELETE, or\n+            // 2. the current lifeVersion is not the same\n+            continue;\n+          }\n+        } else {\n           long operationTimeInMs =\n               indexValue.getOperationTimeInMs() == Utils.Infinite_Time ? indexSegment.getLastModifiedTimeMs()\n                   : indexValue.getOperationTimeInMs();\n-          deletedKeys.put(indexEntry.getKey(), operationTimeInMs);\n+          keyFinalStates.put(indexEntry.getKey(),\n+              new IndexFinalState(indexValue.getFlags(), operationTimeInMs, indexValue.getLifeVersion()));\n+        }\n+        if (!isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n+          validIndexEntryAction.accept(indexEntry);\n         }\n       } else if (indexValue.isTtlUpdate()) {\n-        if (isTtlUpdateEntryValid(indexEntry.getKey(), indexValue, referenceTimeInMs, deletedKeys)) {\n+        if (isTtlUpdateEntryValid(key, indexValue, referenceTimeInMs, keyFinalStates)) {\n           validIndexEntryAction.accept(indexEntry);\n         }\n       } else {\n-        // This is a put record\n-        if (isExpired(indexValue.getExpiresAtMs(), referenceTimeInMs)) {\n-          // try to update the expiration time for this put if there is an ttl update\n-          IndexValue newValue = index.findKey(indexEntry.getKey());\n-          if (newValue != null) {\n-            indexValue.setExpiresAtMs(newValue.getExpiresAtMs());\n-          }\n+        IndexFinalState finalState = removeFromStates ? keyFinalStates.remove(key) : keyFinalStates.get(key);\n+        if (finalState != null && finalState.isDelete() && finalState.getOperationTime() < referenceTimeInMs) {\n+          // Put is deleted before reference time, it's not valid.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c01f01b41461067b2f9c86c4383ed3abe8e109c1", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/c01f01b41461067b2f9c86c4383ed3abe8e109c1", "committedDate": "2020-07-20T22:32:53Z", "message": "Add support for undelete in blobstorestats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44547bcd6f46ed90ca234ee6c7c98c93f91f5a01", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/44547bcd6f46ed90ca234ee6c7c98c93f91f5a01", "committedDate": "2020-07-20T22:32:53Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d1e9ddb15eec45c095250a0b6aa54e7c36d4858", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/4d1e9ddb15eec45c095250a0b6aa54e7c36d4858", "committedDate": "2020-07-20T22:32:53Z", "message": "Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a2c3b086103c64493c8239316f6ed9f6c53165e2", "committedDate": "2020-07-20T22:37:39Z", "message": "comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ef9a2206a34ce7436970565ad1f9fc97fa15e55", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/3ef9a2206a34ce7436970565ad1f9fc97fa15e55", "committedDate": "2020-07-17T06:09:18Z", "message": "Comments"}, "afterCommit": {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/a2c3b086103c64493c8239316f6ed9f6c53165e2", "committedDate": "2020-07-20T22:37:39Z", "message": "comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDEwMDgy", "url": "https://github.com/linkedin/ambry/pull/1590#pullrequestreview-452010082", "createdAt": "2020-07-20T22:46:22Z", "commit": {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjo0NjoyMlrOG0h2nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjo0NjoyMlrOG0h2nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczMzc5MQ==", "bodyText": "why this is not finalState.getOperationTime() > referenceTimeInMs?", "url": "https://github.com/linkedin/ambry/pull/1590#discussion_r457733791", "createdAt": "2020-07-20T22:46:22Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -550,26 +592,20 @@ private boolean isTtlUpdateEntryValid(StoreKey key, IndexValue ttlUpdateValue, l\n       valid = false;\n     } else if (putValue.getOffset().getName().equals(ttlUpdateValue.getOffset().getName())) {\n       // can be invalid if it is in the same log segment and the put is invalid\n-      valid = isPutEntryValid(key, putValue, referenceTimeInMs, deletedKeys);\n+      IndexFinalState finalState = keyFinalStates.get(key);\n+      if (finalState != null && finalState.isDelete() && finalState.getOperationTime() < referenceTimeInMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzQwOTg3", "url": "https://github.com/linkedin/ambry/pull/1590#pullrequestreview-452740987", "createdAt": "2020-07-21T18:54:03Z", "commit": {"oid": "a2c3b086103c64493c8239316f6ed9f6c53165e2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1188, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}