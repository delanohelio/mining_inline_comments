{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NDYyNDU3", "number": 1510, "title": "Allow router to send cross-colo request to dc with most replicas", "bodyText": "There is a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have an unrecognizable dc id. In our current logic, clustermap will treat originating dc of this blob as null and router randomly picks a remote replica to route cross-colo request without accounting for replica distribution. This can be improved by prioritizing remote dc with 3 replicas.\nThis PR introduces a minor change: when request didn't succeed in local dc, operation tracker should be allowed to try on remote dc with most replicas first so as to improve success rate of cross-colo requests(i.e GET/DELETE etc). This is useful in cluster with \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and 1 replica per remote dc).", "createdAt": "2020-05-07T05:08:38Z", "url": "https://github.com/linkedin/ambry/pull/1510", "merged": true, "mergeCommit": {"oid": "db526cb37854da92e2d33710102ae65bc20cc473"}, "closed": true, "closedAt": "2020-05-20T18:17:54Z", "author": {"login": "jsjtzyy"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfUchDgBqjMzMTc1ODU2NTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjNNrKAFqTQxNTU5NjAzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68cf7f40936b305d25eb5ed47980e0725e77a4da", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/68cf7f40936b305d25eb5ed47980e0725e77a4da", "committedDate": "2020-05-07T04:53:58Z", "message": "Allow router to send cross-colo request to dc with most replicas\n\nIn a case where a certain dc is decommissioned and blobs previously uploaded\nto this dc now have a unrecognizable dc id. Clustermap will treat originating dc\nof this blob as null. When request didn't succeed in local dc, operation tracker\nshould be allowed to try on remote dc with most replicas first so as to improve\nsuccess rate of cross-colo requests(i.e GET/DELETE etc). This is useful in cluster\nwith \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and 1 replica\nper remote dc)."}, "afterCommit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "committedDate": "2020-05-08T05:12:13Z", "message": "minor changes and unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjU2NTYz", "url": "https://github.com/linkedin/ambry/pull/1510#pullrequestreview-412256563", "createdAt": "2020-05-14T23:42:08Z", "commit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDU2MTIz", "url": "https://github.com/linkedin/ambry/pull/1510#pullrequestreview-414056123", "createdAt": "2020-05-19T02:20:15Z", "commit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDoxNVrOGXNg7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyNzo0MlrOGXNong==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTg1NQ==", "bodyText": "Minor: please add blank lines before and after this new section for readability.", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426991855", "createdAt": "2020-05-19T02:20:15Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -159,48 +161,66 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n-            routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskReplicaSuccessTarget =\n+            routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+                routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n         crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n-        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case UndeleteOperation:\n-        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        diskReplicaParallelism = routerConfig.routerUndeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         // Undelete operation need to get global quorum. It will require a different criteria for success.\n         // Here set the success target to the number of eligible replicas.\n-        diskSuccessTarget = eligibleReplicas.size();\n+        diskReplicaSuccessTarget = eligibleReplicas.size();\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (diskParallelism < 1 || cloudParallelism < 1) {\n+    if (diskReplicaParallelism < 1 || cloudReplicaParallelism < 1) {\n       throw new IllegalArgumentException(\n-          \"Parallelism has to be > 0. diskParallelism=\" + diskParallelism + \", cloudParallelism=\" + cloudParallelism\n-              + \", routerOperation=\" + routerOperation);\n+          \"Parallelism has to be > 0. diskParallelism=\" + diskReplicaParallelism + \", cloudParallelism=\"\n+              + cloudReplicaParallelism + \", routerOperation=\" + routerOperation);\n     }\n \n     // Order the replicas so that local healthy replicas are ordered and returned first,\n     // then the remote healthy ones, and finally the possibly down ones.\n     List<? extends ReplicaId> replicas =\n         routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas : partitionId.getReplicaIds();\n+    // In a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have a unrecognizable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjE3OQ==", "bodyText": "Minor: operation tracker", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426992179", "createdAt": "2020-05-19T02:21:24Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -159,48 +161,66 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n-            routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskReplicaSuccessTarget =\n+            routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+                routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n         crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n-        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case UndeleteOperation:\n-        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        diskReplicaParallelism = routerConfig.routerUndeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         // Undelete operation need to get global quorum. It will require a different criteria for success.\n         // Here set the success target to the number of eligible replicas.\n-        diskSuccessTarget = eligibleReplicas.size();\n+        diskReplicaSuccessTarget = eligibleReplicas.size();\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (diskParallelism < 1 || cloudParallelism < 1) {\n+    if (diskReplicaParallelism < 1 || cloudReplicaParallelism < 1) {\n       throw new IllegalArgumentException(\n-          \"Parallelism has to be > 0. diskParallelism=\" + diskParallelism + \", cloudParallelism=\" + cloudParallelism\n-              + \", routerOperation=\" + routerOperation);\n+          \"Parallelism has to be > 0. diskParallelism=\" + diskReplicaParallelism + \", cloudParallelism=\"\n+              + cloudReplicaParallelism + \", routerOperation=\" + routerOperation);\n     }\n \n     // Order the replicas so that local healthy replicas are ordered and returned first,\n     // then the remote healthy ones, and finally the possibly down ones.\n     List<? extends ReplicaId> replicas =\n         routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas : partitionId.getReplicaIds();\n+    // In a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have a unrecognizable\n+    // dc id. Current clustermap code will treat originating dc as null if dc id is not identifiable. To improve success\n+    // rate of cross-colo requests(GET/DELETE/TTLUpdate), operation tracker should be allowed to try remote dc with most\n+    // replicas first. This is useful in cluster with \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and\n+    // 1 replica per remote dc)\n+    if (originatingDcName == null && routerConfig.routerCrossColoRequestToDcWithMostReplicas) {\n+      Map<String, Long> dcToReplicaCnt = replicas.stream()\n+          .collect(Collectors.groupingBy(e -> e.getDataNodeId().getDatacenterName(), Collectors.counting()));\n+      List<Map.Entry<String, Long>> entryList = new ArrayList<>(dcToReplicaCnt.entrySet());\n+      entryList.sort(Map.Entry.comparingByValue());\n+      // we assign a dc with most replicas to \"originatingDcName\", which only takes effect when populating replica pool\n+      // (replicas in that colo have higher priority than other remote colos). Note that, \"this.originatingDcName\" still\n+      // keeps the actual originating dc name (which is null). This value forces operation track to go through replicas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzgyMg==", "bodyText": "I recommend using a different variable name than originatingDcName.  Making it different from the class variable is too confusing.", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426993822", "createdAt": "2020-05-19T02:27:42Z", "author": {"login": "lightningrob"}, "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -159,48 +161,66 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n-            routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskReplicaSuccessTarget =\n+            routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+                routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n         crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n-        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case UndeleteOperation:\n-        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        diskReplicaParallelism = routerConfig.routerUndeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         // Undelete operation need to get global quorum. It will require a different criteria for success.\n         // Here set the success target to the number of eligible replicas.\n-        diskSuccessTarget = eligibleReplicas.size();\n+        diskReplicaSuccessTarget = eligibleReplicas.size();\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (diskParallelism < 1 || cloudParallelism < 1) {\n+    if (diskReplicaParallelism < 1 || cloudReplicaParallelism < 1) {\n       throw new IllegalArgumentException(\n-          \"Parallelism has to be > 0. diskParallelism=\" + diskParallelism + \", cloudParallelism=\" + cloudParallelism\n-              + \", routerOperation=\" + routerOperation);\n+          \"Parallelism has to be > 0. diskParallelism=\" + diskReplicaParallelism + \", cloudParallelism=\"\n+              + cloudReplicaParallelism + \", routerOperation=\" + routerOperation);\n     }\n \n     // Order the replicas so that local healthy replicas are ordered and returned first,\n     // then the remote healthy ones, and finally the possibly down ones.\n     List<? extends ReplicaId> replicas =\n         routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas : partitionId.getReplicaIds();\n+    // In a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have a unrecognizable\n+    // dc id. Current clustermap code will treat originating dc as null if dc id is not identifiable. To improve success\n+    // rate of cross-colo requests(GET/DELETE/TTLUpdate), operation tracker should be allowed to try remote dc with most\n+    // replicas first. This is useful in cluster with \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and\n+    // 1 replica per remote dc)\n+    if (originatingDcName == null && routerConfig.routerCrossColoRequestToDcWithMostReplicas) {\n+      Map<String, Long> dcToReplicaCnt = replicas.stream()\n+          .collect(Collectors.groupingBy(e -> e.getDataNodeId().getDatacenterName(), Collectors.counting()));\n+      List<Map.Entry<String, Long>> entryList = new ArrayList<>(dcToReplicaCnt.entrySet());\n+      entryList.sort(Map.Entry.comparingByValue());\n+      // we assign a dc with most replicas to \"originatingDcName\", which only takes effect when populating replica pool\n+      // (replicas in that colo have higher priority than other remote colos). Note that, \"this.originatingDcName\" still\n+      // keeps the actual originating dc name (which is null). This value forces operation track to go through replicas", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjE3OQ=="}, "originalCommit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5bcd422bb5ba845435cd36b686daa82d941b39c", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/e5bcd422bb5ba845435cd36b686daa82d941b39c", "committedDate": "2020-05-19T04:57:38Z", "message": "Allow router to send cross-colo request to dc with most replicas\n\nIn a case where a certain dc is decommissioned and blobs previously uploaded\nto this dc now have a unrecognizable dc id. Clustermap will treat originating dc\nof this blob as null. When request didn't succeed in local dc, operation tracker\nshould be allowed to try on remote dc with most replicas first so as to improve\nsuccess rate of cross-colo requests(i.e GET/DELETE etc). This is useful in cluster\nwith \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and 1 replica\nper remote dc)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5795170e8e1fd8152930dab99c2fe0bf22f33560", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/5795170e8e1fd8152930dab99c2fe0bf22f33560", "committedDate": "2020-05-19T04:57:38Z", "message": "minor changes and unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "committedDate": "2020-05-19T05:16:44Z", "message": "address Rob's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "committedDate": "2020-05-08T05:12:13Z", "message": "minor changes and unit test"}, "afterCommit": {"oid": "29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "author": {"user": {"login": "jsjtzyy", "name": "Yingyi Zhang"}}, "url": "https://github.com/linkedin/ambry/commit/29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "committedDate": "2020-05-19T05:16:44Z", "message": "address Rob's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NTk2MDM2", "url": "https://github.com/linkedin/ambry/pull/1510#pullrequestreview-415596036", "createdAt": "2020-05-20T18:17:08Z", "commit": {"oid": "29676ee2528d2cbb3c138aaf95f3b857e0fd62eb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1467, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}