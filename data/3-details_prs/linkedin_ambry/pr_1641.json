{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MTMwNDYz", "number": 1641, "title": "Fix a NPE in BlobStoreStats", "bodyText": "This should fix NPE in BlobStoreStats\n2020/10/02 16:41:16.343 ERROR [BlobStoreStats] [ambry-scheduler-1] [ambry-server] [] Unexpected exception while running QueueProcessor in store Partition[7813]\njava.lang.NullPointerException: null\n\nThe data flow that causes this NPE goes like this:\n\nFor given StoreKey key, delete method calls findKey to find the latest IndexValue in the persistent index.\nAt the same time, there is a new IndexValue being added to the persistent index. This new IndexValue has nothing to do with key.\n3 After after synchronized block, delete method finds the indexEndOffset is changed because of the IndexValue from step 2, so it calls findKey again and this time findKey method returns null.\n4 Before this PR, delete method would use this null value and set it inIndexValuesPriorToDelete list. That's the reason why we have null value int he blobstorestats.\n5 After this PR, this will be fixed.", "createdAt": "2020-10-02T20:53:45Z", "url": "https://github.com/linkedin/ambry/pull/1641", "merged": true, "mergeCommit": {"oid": "ca515d02bb746284a63b81a16df408bc1035c6b9"}, "closed": true, "closedAt": "2020-10-05T18:36:26Z", "author": {"login": "justinlin-linkedin"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOsWV0AH2gAyNDk3MTMwNDYzOmU4NjQwZWE5YmE0Y2Y4Zjk4ZjAxZGM4NWQ4Nzk5YWI5MjZkM2U2ZWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPoL5nAFqTUwMjMxODMwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef", "committedDate": "2020-10-02T20:52:24Z", "message": "Fix a NPE in BlobStoreStats"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTIwMjg5", "url": "https://github.com/linkedin/ambry/pull/1641#pullrequestreview-501520289", "createdAt": "2020-10-03T04:38:28Z", "commit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDozODoyOFrOHb_lkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwNDo0NzoxNVrOHb_nnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTQwOA==", "bodyText": "nit: IOException is not thrown in this method.", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115408", "createdAt": "2020-10-03T04:38:28Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTgzOQ==", "bodyText": "I think you were trying to reset this in finally block:\n((MockBlobStore) store).setOperationBeforeSynchronization(null);", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115839", "createdAt": "2020-10-03T04:45:35Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {\n+    store.shutdown();\n+    ReplicaId replicaId = getMockReplicaId(tempDirStr);\n+    StoreConfig config = new StoreConfig(new VerifiableProperties(properties));\n+    MetricRegistry registry = new MetricRegistry();\n+    StoreMetrics metrics = new StoreMetrics(registry);\n+    MockBlobStoreStats mockBlobStoreStats = new MockBlobStoreStats(time);\n+    store = new MockBlobStore(replicaId, config, null, metrics, mockBlobStoreStats);\n+    store.start();\n+\n+    MockId id = put(1, PUT_RECORD_SIZE, Utils.Infinite_Time).get(0);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNull(mockBlobStoreStats.originalPutValue);\n+    assertNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isPut());\n+\n+    updateTtl(id);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNotNull(mockBlobStoreStats.originalPutValue);\n+    assertNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.originalPutValue.isPut());\n+\n+    delete(id);\n+    assertNotNull(mockBlobStoreStats.currentValue);\n+    assertNotNull(mockBlobStoreStats.originalPutValue);\n+    assertNotNull(mockBlobStoreStats.previousValue);\n+    assertTrue(mockBlobStoreStats.currentValue.isDelete());\n+    assertTrue(mockBlobStoreStats.currentValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.previousValue.isTtlUpdate());\n+    assertTrue(mockBlobStoreStats.originalPutValue.isTtlUpdate());\n+\n+    // Delete a blob at the same time, put a new blob, make sure the blobstorestats still get everything.\n+    MockId id2 = put(1, PUT_RECORD_SIZE, expiresAtMs).get(0);\n+    final CountDownLatch synchronizationLatch = new CountDownLatch(1);\n+    final CountDownLatch putLatch = new CountDownLatch(1);\n+    ((MockBlobStore) store).setOperationBeforeSynchronization(() -> {\n+      synchronizationLatch.countDown(); // put will wait until delete reach synchronization statement\n+      putLatch.await(); // then delete will wait until put finishes\n+      return null;\n+    });\n+    ExecutorService executorService = Executors.newFixedThreadPool(2);\n+\n+    try {\n+      Future<Void> deleteFuture = executorService.submit(() -> {\n+        delete(id2);\n+        return null;\n+      });\n+      Future<Void> putFuture = executorService.submit(() -> {\n+        // Now make sure delete already gets to synchronization\n+        synchronizationLatch.await();\n+        // Disable synchronization callback so put will not be blocked by it.\n+        ((MockBlobStore) store).setOperationBeforeSynchronization(null);\n+        put(1, PUT_RECORD_SIZE, Utils.Infinite_Time);\n+        // Now make sure the put is inserted into the index before continue delete\n+        putLatch.countDown();\n+        return null;\n+      });\n+      putFuture.get();\n+      deleteFuture.get();\n+\n+      // MockBlobStoreStats should capture delete operation\n+      assertNotNull(mockBlobStoreStats.currentValue);\n+      assertNotNull(mockBlobStoreStats.originalPutValue);\n+      assertNotNull(mockBlobStoreStats.previousValue);\n+      assertTrue(mockBlobStoreStats.currentValue.isDelete());\n+      assertTrue(mockBlobStoreStats.previousValue.isPut());\n+      assertTrue(mockBlobStoreStats.originalPutValue.isPut());\n+    } finally {\n+      ((MockBlobStore) store).setInDeleteBetweenGetEndOffsetAndFindKey(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExNTkzNQ==", "bodyText": "The test name is too general, maybe rename it ? (Also add some java doc)", "url": "https://github.com/linkedin/ambry/pull/1641#discussion_r499115935", "createdAt": "2020-10-03T04:47:15Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/test/java/com/github/ambry/store/BlobStoreTest.java", "diffHunk": "@@ -1044,6 +1044,81 @@ public void concurrentAllTest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testBlobStoreStats() throws StoreException, InterruptedException, IOException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8640ea9ba4cf8f98f01dc85d8799ab926d3e6ef"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07942f62f9d777a0dc4084bb263f9aa69c9c2b76", "author": {"user": {"login": "justinlin-linkedin", "name": "Justin Lin"}}, "url": "https://github.com/linkedin/ambry/commit/07942f62f9d777a0dc4084bb263f9aa69c9c2b76", "committedDate": "2020-10-05T04:04:10Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzE4MzAx", "url": "https://github.com/linkedin/ambry/pull/1641#pullrequestreview-502318301", "createdAt": "2020-10-05T18:35:18Z", "commit": {"oid": "07942f62f9d777a0dc4084bb263f9aa69c9c2b76"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1283, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}