{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNjYzMDY3", "number": 1377, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxMjo1OFrODeqX2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMzozNFrODhMA6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc4MTA3OnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxMjo1OFrOFn7JCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxMjo1OFrOFn7JCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNzc1Mw==", "bodyText": "year should be 2020", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377407753", "createdAt": "2020-02-11T01:12:58Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc4Mjc2OnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxMzoyOVrOFn7J2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxMzoyOVrOFn7J2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwNzk2MA==", "bodyText": "not used anywhere in this file.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377407960", "createdAt": "2020-02-11T01:13:29Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc4NDQ2OnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxNDozMFrOFn7KyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxNDozMFrOFn7KyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODIwMQ==", "bodyText": "change the position of src, just like the write method below.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377408201", "createdAt": "2020-02-11T01:14:30Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc4NTc3OnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToxNToyOVrOFn7Lrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwNToyMjo1OVrOFq1cMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA==", "bodyText": "why do we throw a RestServiceException in the common package? Can we throw some more generic exception here?", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377408430", "createdAt": "2020-02-11T01:15:29Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);\n+      return copy;\n+    }, callback);\n+  }\n+\n+  @Override\n+  public Future<Long> write(ByteBuf src, Callback<Long> callback) {\n+    return writeInternal(() -> {\n+      ByteBuf duplicate = src.retainedDuplicate();\n+      // mark all bytes as read.\n+      src.skipBytes(src.readableBytes());\n+      return duplicate;\n+    }, callback);\n+  }\n+\n+  private Future<Long> writeInternal(Supplier<ByteBuf> retainedBufSupplier, Callback<Long> callback) {\n+    FutureResult<Long> future = new FutureResult<>();\n+    ByteBuf buf = null;\n+    long bytesWritten = 0;\n+    Exception exception = null;\n+    try {\n+      if (!isOpen()) {\n+        throw new ClosedChannelException();\n+      } else if (totalBytesWritten.get() > sizeLimitInBytes) {\n+        throw new RestServiceException(\"Request is larger than allowed size: \" + sizeLimitInBytes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ1ODc5Mg==", "bodyText": "In terms of production code, this is mostly used by the rest/frontend package and throwing RestServiceException directly makes error handling cleaner (correct response code generated without try/catch).", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r380458792", "createdAt": "2020-02-18T05:16:11Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);\n+      return copy;\n+    }, callback);\n+  }\n+\n+  @Override\n+  public Future<Long> write(ByteBuf src, Callback<Long> callback) {\n+    return writeInternal(() -> {\n+      ByteBuf duplicate = src.retainedDuplicate();\n+      // mark all bytes as read.\n+      src.skipBytes(src.readableBytes());\n+      return duplicate;\n+    }, callback);\n+  }\n+\n+  private Future<Long> writeInternal(Supplier<ByteBuf> retainedBufSupplier, Callback<Long> callback) {\n+    FutureResult<Long> future = new FutureResult<>();\n+    ByteBuf buf = null;\n+    long bytesWritten = 0;\n+    Exception exception = null;\n+    try {\n+      if (!isOpen()) {\n+        throw new ClosedChannelException();\n+      } else if (totalBytesWritten.get() > sizeLimitInBytes) {\n+        throw new RestServiceException(\"Request is larger than allowed size: \" + sizeLimitInBytes,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA=="}, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ2MDA4Mg==", "bodyText": "One other option would be to move it to ambry-rest, and get rid of InputStreamReadableStreamChannel, which has no usages (other than a unit test)", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r380460082", "createdAt": "2020-02-18T05:22:59Z", "author": {"login": "cgtz"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/RetainingAsyncWritableChannel.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.rest.RestServiceErrorCode;\n+import com.github.ambry.rest.RestServiceException;\n+import com.github.ambry.router.AsyncWritableChannel;\n+import com.github.ambry.router.Callback;\n+import com.github.ambry.router.FutureResult;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\n+/**\n+ * An implementation of {@link AsyncWritableChannel} that will retain a reference to any {@link ByteBuf}s passed to it.\n+ * It will assemble these buffers into a {@link CompositeByteBuf} that can then be consumed by the user of the channel.\n+ * Meant for interacting with blocking content consumers that would otherwise require a background thread if they did\n+ * not have all of the content available.\n+ */\n+public class RetainingAsyncWritableChannel implements AsyncWritableChannel {\n+  private final long sizeLimitInBytes;\n+  private volatile boolean open = true;\n+  private final AtomicLong totalBytesWritten = new AtomicLong(0);\n+  // accesses/updates to the buffer under construction must be protected by the lock\n+  private final Object bufferLock = new Object();\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Construct a {@link RetainingAsyncWritableChannel} with the size limit set to {@link Long#MAX_VALUE}.\n+   */\n+  public RetainingAsyncWritableChannel() {\n+    this(Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * @param sizeLimitInBytes the maximum number of bytes that can be written to this channel. If this limit is exceeded,\n+   *                         a {@link RestServiceException} will be provided to the write callback.\n+   */\n+  public RetainingAsyncWritableChannel(int sizeLimitInBytes) {\n+    this.sizeLimitInBytes = sizeLimitInBytes;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   *\n+   * This method requires copying\n+   */\n+  @Override\n+  public Future<Long> write(ByteBuffer src, Callback<Long> callback) {\n+    // still need to copy the buffer since the writer may decide to reuse the buffer after the callback is called.\n+    return writeInternal(() -> {\n+      ByteBuf copy = src.isDirect() ? ByteBufAllocator.DEFAULT.directBuffer(src.remaining())\n+          : PooledByteBufAllocator.DEFAULT.heapBuffer(src.remaining());\n+      copy.writeBytes(src);\n+      return copy;\n+    }, callback);\n+  }\n+\n+  @Override\n+  public Future<Long> write(ByteBuf src, Callback<Long> callback) {\n+    return writeInternal(() -> {\n+      ByteBuf duplicate = src.retainedDuplicate();\n+      // mark all bytes as read.\n+      src.skipBytes(src.readableBytes());\n+      return duplicate;\n+    }, callback);\n+  }\n+\n+  private Future<Long> writeInternal(Supplier<ByteBuf> retainedBufSupplier, Callback<Long> callback) {\n+    FutureResult<Long> future = new FutureResult<>();\n+    ByteBuf buf = null;\n+    long bytesWritten = 0;\n+    Exception exception = null;\n+    try {\n+      if (!isOpen()) {\n+        throw new ClosedChannelException();\n+      } else if (totalBytesWritten.get() > sizeLimitInBytes) {\n+        throw new RestServiceException(\"Request is larger than allowed size: \" + sizeLimitInBytes,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwODQzMA=="}, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc5NTYwOnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/test/java/com.github.ambry.commons/InputStreamReadableStreamChannelTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToyMTo1NlrOFn7RhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToyMTo1NlrOFn7RhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwOTkyNQ==", "bodyText": "Can we add nettyByteBufLeakHelper in this test file since we are using retaining async write channel.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377409925", "createdAt": "2020-02-11T01:21:56Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-commons/src/test/java/com.github.ambry.commons/InputStreamReadableStreamChannelTest.java", "diffHunk": "@@ -118,7 +118,7 @@ public void readIntoAWCFailureTest() throws Exception {\n     // Read after close.\n     channel = new InputStreamReadableStreamChannel(stream, EXECUTOR_SERVICE);\n     channel.close();\n-    CopyingAsyncWritableChannel writeChannel = new CopyingAsyncWritableChannel();\n+    RetainingAsyncWritableChannel writeChannel = new RetainingAsyncWritableChannel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDc5ODg5OnYy", "diffSide": "RIGHT", "path": "ambry-utils/src/test/java/com.github.ambry.utils/NettyByteBufLeakHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToyNDozMlrOFn7TkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwMToyNDozMlrOFn7TkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQxMDQ0OA==", "bodyText": "this is not used anywhere.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r377410448", "createdAt": "2020-02-11T01:24:32Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-utils/src/test/java/com.github.ambry.utils/NettyByteBufLeakHelper.java", "diffHunk": "@@ -16,6 +16,8 @@\n import io.netty.buffer.PoolArenaMetric;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.PooledByteBufAllocatorMetric;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import java.lang.reflect.Field;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "341f7388b54b93a80c0d7d9a265670e3a116dbf7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTI2MzgzOnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMzoyN1rOFr0GkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMzoyN1rOFr0GkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjczNw==", "bodyText": "Not used.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r381486737", "createdAt": "2020-02-19T19:13:27Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "diffHunk": "@@ -15,23 +15,32 @@\n \n import com.github.ambry.rest.RestRequest;\n import com.github.ambry.rest.RestResponseChannel;\n+import com.github.ambry.utils.AbstractByteBufHolder;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTI2NDQwOnYy", "diffSide": "RIGHT", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMzozNFrOFr0G3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxMzozNFrOFr0G3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjgxMw==", "bodyText": "not used.", "url": "https://github.com/linkedin/ambry/pull/1377#discussion_r381486813", "createdAt": "2020-02-19T19:13:34Z", "author": {"login": "zzmao"}, "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequest.java", "diffHunk": "@@ -15,23 +15,32 @@\n \n import com.github.ambry.rest.RestRequest;\n import com.github.ambry.rest.RestResponseChannel;\n+import com.github.ambry.utils.AbstractByteBufHolder;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n import java.io.InputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n /**\n  * A wrapper class at the network layer for NettyRequest based RestRequest.\n  */\n-public class NettyServerRequest implements NetworkRequest {\n+public class NettyServerRequest extends AbstractByteBufHolder<NettyServerRequest> implements NetworkRequest {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(NettyServerRequest.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a02435f1b2e051aad50fe4ea4b56a55dcffa7a0"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1694, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}