{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTY2MjQz", "number": 1373, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNDo0MlrODdzKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODoxNjoxOVrODejmEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTczNTIzOnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNDo0MlrOFmnA2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNDo0MlrOFmnA2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyOTQwMA==", "bodyText": "minor: undeleting", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376029400", "createdAt": "2020-02-06T19:14:42Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -57,6 +57,15 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobDeleted(String blobId, String serviceId, Account account, Container container);\n \n+  /**\n+   * Notifies the underlying system when a deleted blob is undeleted.\n+   * @param blobId The id of the blob whose deleted state has been replicated\n+   * @param serviceId The service ID of the service deleting the blob. This can be null if unknown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTczOTExOnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNTo1MlrOFmnDHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNTo1MlrOFmnDHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyOTk4Mw==", "bodyText": "the blob was undeleted", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376029983", "createdAt": "2020-02-06T19:15:52Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -57,6 +57,15 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobDeleted(String blobId, String serviceId, Account account, Container container);\n \n+  /**\n+   * Notifies the underlying system when a deleted blob is undeleted.\n+   * @param blobId The id of the blob whose deleted state has been replicated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTc0MTA3OnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNjoyOFrOFmnESQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToxNjoyOFrOFmnESQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMDI4MQ==", "bodyText": "undeleted state", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376030281", "createdAt": "2020-02-06T19:16:28Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -86,4 +95,13 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobReplicaUpdated(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType,\n       UpdateType updateType, MessageInfo info);\n+\n+  /**\n+   * Notifies the underlying system when a undeleted state of a blob is replicated to a node\n+   * @param sourceHost The source host from where the notification is being invoked\n+   * @param port The port of the source host from where the notification is being invoked.\n+   * @param blobId The id of the blob whose deleted state has been replicated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTc1MjQ5OnYy", "diffSide": "RIGHT", "path": "ambry-api/src/main/java/com.github.ambry/store/Store.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToyMDo0M1rOFmnL0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMDozOVrOFmuWOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMjIxMA==", "bodyText": "Any reason why we don't pass in MessageWriteSet? Is this because we undelete only one blob at a time?", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376032210", "createdAt": "2020-02-06T19:20:43Z", "author": {"login": "jsjtzyy"}, "path": "ambry-api/src/main/java/com.github.ambry/store/Store.java", "diffHunk": "@@ -54,6 +54,13 @@\n    */\n   void delete(MessageWriteSet messageSetToDelete) throws StoreException;\n \n+  /**\n+   * Undelete the blob identified by {@code id}.\n+   * @param info The {@link MessageInfo} that carries some basic information about this operation.\n+   * @return the lifeVersion of the undeleted blob.\n+   */\n+  short undelete(MessageInfo info) throws StoreException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTU2Mg==", "bodyText": "MessgeWriteSet includes a serialized undelete record, which will be persisted on disk in the log. The problem is that this serialized record requires a lifeVersion, but we don't know the lifeVersion before we query the index. So here I pass a MessageInfo instead of MessageWriteSet. You can see in the BlobStore.undelete method, I create a MessageWriteSet in the end, with a lifeVersion.", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376149562", "createdAt": "2020-02-07T00:00:39Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-api/src/main/java/com.github.ambry/store/Store.java", "diffHunk": "@@ -54,6 +54,13 @@\n    */\n   void delete(MessageWriteSet messageSetToDelete) throws StoreException;\n \n+  /**\n+   * Undelete the blob identified by {@code id}.\n+   * @param info The {@link MessageInfo} that carries some basic information about this operation.\n+   * @return the lifeVersion of the undeleted blob.\n+   */\n+  short undelete(MessageInfo info) throws StoreException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMjIxMA=="}, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTc1OTMyOnYy", "diffSide": "RIGHT", "path": "ambry-commons/src/main/java/com.github.ambry.commons/LoggingNotificationSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToyMzowM1rOFmnQQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOToyMzowM1rOFmnQQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMzM0NA==", "bodyText": "good catch", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376033344", "createdAt": "2020-02-06T19:23:03Z", "author": {"login": "jsjtzyy"}, "path": "ambry-commons/src/main/java/com.github.ambry.commons/LoggingNotificationSystem.java", "diffHunk": "@@ -64,22 +64,36 @@ public void onBlobDeleted(String blobId, String serviceId, Account account, Cont\n             : container.getName()) + \", containerId \" + (container == null ? null : container.getId()));\n   }\n \n+  @Override\n+  public void onBlobUndeleted(String blobId, String serviceId, Account account, Container container) {\n+    logger.debug(\"onBlobUndeleted \" + blobId,\n+        \", \" + serviceId + \", accountName \" + (account == null ? null : account.getName()) + \", accountId\" + (\n+            account == null ? null : account.getId()) + \", containerName \" + (container == null ? null\n+            : container.getName()) + \", containerId \" + (container == null ? null : container.getId()));\n+\n+  }\n+\n   @Override\n   public void onBlobReplicaCreated(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType) {\n     logger.debug(\"onBlobReplicaCreated \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);\n   }\n \n   @Override\n   public void onBlobReplicaDeleted(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType) {\n-    logger.debug(\"onBlobReplicaCreated \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);\n+    logger.debug(\"onBlobReplicaDeleted \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTgwOTUyOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxOTozOToxMVrOFmnvyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMjowM1rOFmuX5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTQxOA==", "bodyText": "Note that, other methods (put, ttlUpdate, delete) in BlobStore are also invoked in Replication. When you implement undelete replication part, the LIFE_VERSION_FROM_FRONTEND check here probably needs to change.", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376041418", "createdAt": "2020-02-06T19:39:11Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTk5MQ==", "bodyText": "I actually have to change ttlupdate and delete later to make them aware of undelete in replication.", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376149991", "createdAt": "2020-02-07T00:02:03Z", "author": {"login": "justinlin-linkedin"}, "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTQxOA=="}, "originalCommit": {"oid": "60e973cc974ff3498e07739681bb43ee48bf5d19"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTY4MjYyOnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowMjozOFrOFnMwUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowMjozOFrOFnMwUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0Nzc2Mg==", "bodyText": "Add a TODO here: update blobStoreStats for Undelete.", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376647762", "createdAt": "2020-02-07T23:02:38Z", "author": {"login": "jsjtzyy"}, "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      IndexValue latestValue = values.get(0);\n+      short lifeVersion = (short) (latestValue.getLifeVersion() + 1);\n+      MessageFormatInputStream stream =\n+          new UndeleteMessageFormatInputStream(id, info.getAccountId(), info.getContainerId(),\n+              info.getOperationTimeMs(), lifeVersion);\n+      // Update info to add stream size;\n+      info =\n+          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs());\n+      ArrayList<MessageInfo> infoList = new ArrayList<>();\n+      infoList.add(info);\n+      MessageFormatWriteSet writeSet = new MessageFormatWriteSet(stream, infoList, false);\n+      if (!info.getStoreKey().isAccountContainerMatch(latestValue.getAccountId(), latestValue.getContainerId())) {\n+        if (config.storeValidateAuthorization) {\n+          throw new StoreException(\n+              \"UNDELETE authorization failure. Key: \" + info.getStoreKey() + \" Actually accountId: \"\n+                  + latestValue.getAccountId() + \"Actually containerId: \" + latestValue.getContainerId(),\n+              StoreErrorCodes.Authorization_Failure);\n+        } else {\n+          logger.warn(\"UNDELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+              info.getStoreKey(), latestValue.getAccountId(), latestValue.getContainerId());\n+          metrics.undeleteAuthorizationFailureCount.inc();\n+        }\n+      }\n+      synchronized (storeWriteLock) {\n+        Offset currentIndexEndOffset = index.getCurrentEndOffset();\n+        if (!currentIndexEndOffset.equals(indexEndOffsetBeforeCheck)) {\n+          FileSpan fileSpan = new FileSpan(indexEndOffsetBeforeCheck, currentIndexEndOffset);\n+          IndexValue value =\n+              index.findKey(info.getStoreKey(), fileSpan, EnumSet.allOf(PersistentIndex.IndexEntryType.class));\n+          if (value != null) {\n+            throw new StoreException(\"Cannot undelete id \" + info.getStoreKey() + \" since concurrent operation occurs\",\n+                StoreErrorCodes.Life_Version_Conflict);\n+          }\n+        }\n+        Offset endOffsetOfLastMessage = log.getEndOffset();\n+        writeSet.writeTo(log);\n+        logger.trace(\"Store : {} undelete mark written to log\", dataDir);\n+        FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n+        index.markAsUndeleted(info.getStoreKey(), fileSpan, info.getOperationTimeMs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f054e3905e39cd69280f27be2889c42b360d7c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzY3MDU4OnYy", "diffSide": "RIGHT", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODoxNjoxOVrOFnwbLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODoxNjoxOVrOFnwbLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMjE3NQ==", "bodyText": "It's clear when oldest/latest is used in variable. I would like to suggest also use var oldest/latest in validateSanityForUndelete, instead of first/last. To be consistent.", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r377232175", "createdAt": "2020-02-10T18:16:19Z", "author": {"login": "zzmao"}, "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      IndexValue latestValue = values.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f054e3905e39cd69280f27be2889c42b360d7c"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1685, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}