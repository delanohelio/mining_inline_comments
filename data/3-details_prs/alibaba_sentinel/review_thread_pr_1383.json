{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MTEzOTAx", "number": 1383, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxNjo1M1rOEVPe5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNzo0NzoxMFrOEliW3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA5MjIyOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/test/resources/META-INF/services/com.alibaba.csp.sentinel.spi.TestInterface", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxNjo1M1rOG74pTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDo1Njo1OVrOG8NiWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI0Ng==", "bodyText": "Suggest to beautify the comment. Move it to a separated line maybe.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465447246", "createdAt": "2020-08-05T03:16:53Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/test/resources/META-INF/services/com.alibaba.csp.sentinel.spi.TestInterface", "diffHunk": "@@ -0,0 +1,5 @@\n+# One\n+com.alibaba.csp.sentinel.spi.TestOneProvider\n+com.alibaba.csp.sentinel.spi.TestTwoProvider # Two", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4OTUzMA==", "bodyText": "Yes, normally we use a separated line to write the comment, which is more beautify and clear.\nHere is intended to write the comment like this, to test the robustness of the program in test case.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465789530", "createdAt": "2020-08-05T14:56:59Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/test/resources/META-INF/services/com.alibaba.csp.sentinel.spi.TestInterface", "diffHunk": "@@ -0,0 +1,5 @@\n+# One\n+com.alibaba.csp.sentinel.spi.TestOneProvider\n+com.alibaba.csp.sentinel.spi.TestTwoProvider # Two", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI0Ng=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzEwODgwOnYy", "diffSide": "RIGHT", "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoyNjo1OFrOG74y5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNjo0NTo0M1rOG94qyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA==", "bodyText": "Use constant?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465449700", "createdAt": "2020-08-05T03:26:58Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1MDI1MQ==", "bodyText": "And some slots are stateless while others are stateful. Maybe isSingleton should be specified obviously.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465450251", "createdAt": "2020-08-05T03:29:05Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjAzMw==", "bodyText": "I'm a little confused here,  not very sure and use -4000 temporarily.\nThere are some constants of slot order definitions In Constants class of sentinel-core module:\n/**\n* Order of default processor slots\n*/\npublic static final int ORDER_NODE_SELECTOR_SLOT = -10000;\npublic static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\npublic static final int ORDER_LOG_SLOT = -8000;\npublic static final int ORDER_STATISTIC_SLOT = -7000;\npublic static final int ORDER_AUTHORITY_SLOT = -6000;\npublic static final int ORDER_SYSTEM_SLOT = -5000;\n// order of GatewayFlowSlot -4000\n// order of ParamFlowSlot   -3000\npublic static final int ORDER_FLOW_SLOT = -2000;\npublic static final int ORDER_DEGRADE_SLOT = -1000;\nIf use constant, which is better?\n\n\n\npublic static final int ORDER_GATEWAY_FLOW_SLOT = -4000;\npublic static final int ORDER_PARAM_FLOW_SLOT = -3000;\n\n@Spi(order = Constants.ORDER_SYSTEM_SLOT)\npublic class GatewayFlowSlot {\n\n\n\nNo constant for ORDER_GATEWAY_FLOW_SLOT, ORDER_PARAM_FLOW_SLOT\n@Spi(order = Constants.ORDER_SYSTEM_SLOT + 1000)\npublic class GatewayFlowSlot {", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465796033", "createdAt": "2020-08-05T15:05:56Z", "author": {"login": "cdfive"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMzkyMg==", "bodyText": "Constants.ORDER_SYSTEM_SLOT\n\nYeah whatever you want.\nIf you want to make it reference-able just replace it with a constant in gateway package;\nIf you want to express some kinds of relationship with existing slots just use relative calculation to existed constants;\nIf you insist on pure definition just leave it unchanged.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465803922", "createdAt": "2020-08-05T15:16:53Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxOTM4Mw==", "bodyText": "These three ways speak my heart. I've been struggling with this for a long time.\nNow I think the third way is not very good. Maybe one or two is better.\nFor a selection difficulty person, could you please help to make a good choice?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465819383", "createdAt": "2020-08-05T15:39:05Z", "author": {"login": "cdfive"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMTkyMA==", "bodyText": "These three ways speak my heart. I've been struggling with this for a long time.\nNow I think the third way is not very good. Maybe one or two is better.\nFor a selection difficulty person, could you please help to make a good choice?\n\nGo write a random test and make result confirmed.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465821920", "createdAt": "2020-08-05T15:42:41Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDc3OQ==", "bodyText": "Got it! Using the first way, since it expresses the order of all default slot of sentinel clearly. Maybe the second way is a good choice for user custom slot.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467544779", "createdAt": "2020-08-09T06:45:43Z", "author": {"login": "cdfive"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE0NDg4OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo0ODoxMVrOG75H1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxODoxNlrOG8OesA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ==", "bodyText": "I didn't look backward carefully. What is the reason that we don't use ServiceProvider but load them manually here?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455061", "createdAt": "2020-08-05T03:48:11Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDI4OA==", "bodyText": "JDK's ServiceProvider is convenient to use, since we here want to enrich its functions, support our custom Spi annotation, so load them manually. This implementation refers to ServerProvider.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465800288", "createdAt": "2020-08-05T15:11:59Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNDk3Ng==", "bodyText": "JDK's ServiceProvider is convenient to use, since we here want to enrich its functions, support our custom Spi annotation, so load them manually. This implementation refers to ServerProvider.\n\nOk i get it. It's ok then.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465804976", "createdAt": "2020-08-05T15:18:16Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE0OTYzOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1MTowOFrOG75Kow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOTo0MDozMFrOHU5YSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ==", "bodyText": "private or package default scope is suggested.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455779", "createdAt": "2020-08-05T03:51:08Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4NjU5Nw==", "bodyText": "This method is intend to provide another method to create SpiLoader instance, and inside it just call of method.\nHow about remove it? Maybe of method is enough.\nJust now, I found that in JDK's Optional, apache commons's Pair, they only have of method to create its instance.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465786597", "createdAt": "2020-08-05T14:53:05Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5ODg3Mg==", "bodyText": "Yeah i think this scaffold class should be shorter so just don't be limited by legacy design.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465798872", "createdAt": "2020-08-05T15:10:00Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzY3NQ==", "bodyText": "This unused method has been removed, only of method is remained.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673675", "createdAt": "2020-09-20T09:40:30Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE1ODMzOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1NjozOVrOG75Pww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOTo0MjoxNVrOHU5Y0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ==", "bodyText": "Maybe we should also sychronize it?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457091", "createdAt": "2020-08-05T03:56:39Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzI0OQ==", "bodyText": "And it looks more like resetAndClear()", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457249", "createdAt": "2020-08-05T03:57:14Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODU1Ng==", "bodyText": "Are reset*() only used in unit tests?\nIf so i suggest to comment them obviously and make them package scope is better.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465468556", "createdAt": "2020-08-05T04:42:18Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzgwOA==", "bodyText": "They have been improved, please check.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673808", "createdAt": "2020-09-20T09:42:15Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE2MDYzOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1ODowMFrOG75REA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1ODowMFrOG75REA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzQyNA==", "bodyText": "serviceClass or providerClass is better?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457424", "createdAt": "2020-08-05T03:58:00Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE2MTg1OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1ODo1M1rOG75Ryw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozMzowNlrOG8PHFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzYxMQ==", "bodyText": "Useless?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457611", "createdAt": "2020-08-05T03:58:53Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNTMxOA==", "bodyText": "Yes, it's not used, I'll remove it.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465815318", "createdAt": "2020-08-05T15:33:06Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzYxMQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE2ODQ3OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDowMjo0OVrOG75VpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDowMjo0OVrOG75VpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1ODU5Ng==", "bodyText": "Better to be List load() for short access?\nAnd why we don't invoke internal load()(which is called init() maybe better) in constructor? For lazy load?\nBut i don't think it's a good design here if we target it as lazy load.  Because it has nearly 100% possibility to be initialized.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465458596", "createdAt": "2020-08-05T04:02:49Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE4NDg3OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoxMzoxNFrOG75fgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNjoyNjoyNlrOIKVLKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ==", "bodyText": "Just a suggestion and not a forced request.\nLogics is a bit long. Is it necessary storing both unordered and ordered list? If no only sorted is necessary i think(Maybe loadSorted should be new load()).", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465461121", "createdAt": "2020-08-05T04:13:14Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 448}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMzU5Mw==", "bodyText": "And this one? Remain it this time?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547703593", "createdAt": "2020-12-23T06:26:26Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 448}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzE5MzA1OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoxODoyM1rOG75kLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNjoyMzozMlrOIKVDTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ==", "bodyText": "I suggest to cache all the meta data. For example you can use a more complicated structure in your pre-stored class list.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465462319", "createdAt": "2020-08-05T04:18:23Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMTU4Mw==", "bodyText": "Will it remain for future improvement? About meta caching.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547701583", "createdAt": "2020-12-23T06:23:32Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzIwNzM3OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoyNjo1NVrOG75spg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOToyMjoxOFrOHU5SuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng==", "bodyText": "Maybe len=0 should also be added here for more obvious.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464486", "createdAt": "2020-08-05T04:26:55Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDgwOQ==", "bodyText": "Good idea, it has been added.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467544809", "createdAt": "2020-08-09T06:46:09Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MjI0OA==", "bodyText": "It has been improved.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672248", "createdAt": "2020-09-20T09:22:18Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 509}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzIwODE2OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoyNzoyNlrOG75tJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOToyOTo1NVrOHU5VKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg==", "bodyText": "SPI -> resource ?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464612", "createdAt": "2020-08-05T04:27:26Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNDY5NQ==", "bodyText": "Oh, SPI file may be confusing.\nMay I use error closing SPI resource file or error closing SPI configuration file?\nThis method is used for close InputStream and BufferedReader after reading and parsing configuration file.\nSPI is used to emphasize the operation.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465804695", "createdAt": "2020-08-05T15:17:51Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzU5MQ==", "bodyText": "Oh, SPI file may be confusing.\nMay I use error closing SPI resource file or error closing SPI configuration file?\nThis method is used for close InputStream and BufferedReader after reading and parsing configuration file.\nSPI is used to emphasize the operation.\n\nFile is already a kind of resource. Or do you mean you implemented a method which is more like closeFiles(...)?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465813591", "createdAt": "2020-08-05T15:30:34Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3Mjg3NA==", "bodyText": "The prompt message changed to error closing SPI configuration file, and the exception in closeResources method seems rarely happen.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672874", "createdAt": "2020-09-20T09:29:55Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 517}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzIxMTY5OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDoyOTozOVrOG75vNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyOTowMlrOG8O8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA==", "bodyText": "Maybe logAndRaise or other names can be accurately.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465140", "createdAt": "2020-08-05T04:29:39Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throw {@link SpiLoaderException} with message\n+     *\n+     * @param msg error message\n+     */\n+    private void fail(String msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 527}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwODc4NQ==", "bodyText": "I think fail is concise, while logAndRaise is more accurately.\nThe naming way is copy from ServiceLoader#fail(), besides throw Exception, add a RecordLog.error operation.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465808785", "createdAt": "2020-08-05T15:23:35Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throw {@link SpiLoaderException} with message\n+     *\n+     * @param msg error message\n+     */\n+    private void fail(String msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 527}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMjU1MA==", "bodyText": "I think fail is concise, while logAndRaise is more accurately.\nThe naming way is copy from ServiceLoader#fail(), besides throw Exception, add a RecordLog.error operation.\n\nBecause fail will throw unchecked exception which may lead actual workflow unexpected.\nWhatever just a suggestion it's not required request of change. So you can make the final decision about it.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465812550", "createdAt": "2020-08-05T15:29:02Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throw {@link SpiLoaderException} with message\n+     *\n+     * @param msg error message\n+     */\n+    private void fail(String msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 527}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzIxNjQzOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDozMjoxMFrOG75xyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOTozNzoxMFrOHU5XZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTgwMg==", "bodyText": "Maybe loadOne for short. Is there any other way to get target instance? And surely i am curious that why we need loadLowestPriorityInstance or loadFirstInstance. And talk to isDefault in SPI annotation we can make the default service implementation as lowest priority. Then we can use loadOne() instead of something like loadFirstInstanceOrDefault.\nThus loadInstance loadDefault also don't have any scenario to be applied.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465802", "createdAt": "2020-08-05T04:32:10Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzQ0Ng==", "bodyText": "The loadHighestPriorityInstance,loadFirstInstance keeps same with previous version.\nIn SlotChainProvider, we have DefaultSlotChainBuilder has default implementation.\nslotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();\nIn TokenClientProvider, the difference is no default SPI implementation.\n`ClusterTokenClient resolvedClient = SpiLoader.of(ClusterTokenClient.class).loadFirstInstance();`\nDistinguish them may be more flexible.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673446", "createdAt": "2020-09-20T09:37:10Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTgwMg=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzIzNzE0OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo0MzozMVrOG759qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOTozODo1NVrOHU5X0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODg0MQ==", "bodyText": "No need to change.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465468841", "createdAt": "2020-08-05T04:43:31Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot", "diffHunk": "@@ -3,7 +3,7 @@ com.alibaba.csp.sentinel.slots.nodeselector.NodeSelectorSlot\n com.alibaba.csp.sentinel.slots.clusterbuilder.ClusterBuilderSlot\n com.alibaba.csp.sentinel.slots.logger.LogSlot\n com.alibaba.csp.sentinel.slots.statistic.StatisticSlot\n-com.alibaba.csp.sentinel.slots.system.SystemSlot\n com.alibaba.csp.sentinel.slots.block.authority.AuthoritySlot\n+com.alibaba.csp.sentinel.slots.system.SystemSlot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzU1NA==", "bodyText": "Fixed, now not changed in this PR.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673554", "createdAt": "2020-09-20T09:38:55Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot", "diffHunk": "@@ -3,7 +3,7 @@ com.alibaba.csp.sentinel.slots.nodeselector.NodeSelectorSlot\n com.alibaba.csp.sentinel.slots.clusterbuilder.ClusterBuilderSlot\n com.alibaba.csp.sentinel.slots.logger.LogSlot\n com.alibaba.csp.sentinel.slots.statistic.StatisticSlot\n-com.alibaba.csp.sentinel.slots.system.SystemSlot\n com.alibaba.csp.sentinel.slots.block.authority.AuthoritySlot\n+com.alibaba.csp.sentinel.slots.system.SystemSlot", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODg0MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMTIzOTYyOnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/Constants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQxNjoxNzowOVrOG98JUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwOToyNjozNFrOHU5UCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYwMTc0Nw==", "bodyText": "It's not a good practice setting unrelated constant here. You'd better put it in gateway adapter package. If you feel a little unsure to decide the value of it in separated package you can take it as a user-defined implementation out of sentinel-core.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467601747", "createdAt": "2020-08-09T16:17:09Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/Constants.java", "diffHunk": "@@ -70,5 +70,19 @@\n      */\n     public static volatile boolean ON = true;\n \n+    /**\n+     * Order of default processor slots\n+     */\n+    public static final int ORDER_NODE_SELECTOR_SLOT = -10000;\n+    public static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\n+    public static final int ORDER_LOG_SLOT = -8000;\n+    public static final int ORDER_STATISTIC_SLOT = -7000;\n+    public static final int ORDER_AUTHORITY_SLOT = -6000;\n+    public static final int ORDER_SYSTEM_SLOT = -5000;\n+    public static final int ORDER_GATEWAY_FLOW_SLOT = -4000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MjU4NQ==", "bodyText": "The two constant ORDER_GATEWAY_FLOW_SLOT,ORDER_PARAM_FLOW_SLOT have been removed here.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672585", "createdAt": "2020-09-20T09:26:34Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/Constants.java", "diffHunk": "@@ -70,5 +70,19 @@\n      */\n     public static volatile boolean ON = true;\n \n+    /**\n+     * Order of default processor slots\n+     */\n+    public static final int ORDER_NODE_SELECTOR_SLOT = -10000;\n+    public static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\n+    public static final int ORDER_LOG_SLOT = -8000;\n+    public static final int ORDER_STATISTIC_SLOT = -7000;\n+    public static final int ORDER_AUTHORITY_SLOT = -6000;\n+    public static final int ORDER_SYSTEM_SLOT = -5000;\n+    public static final int ORDER_GATEWAY_FLOW_SLOT = -4000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYwMTc0Nw=="}, "originalCommit": {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzkxODk1OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNzozNTo1MFrOHVDo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNTowNjowNlrOHbhWvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ==", "bodyText": "double check instance = map.get(...) may necessary, avoid class.newInstance() twice or more.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491841785", "createdAt": "2020-09-21T07:35:50Z", "author": {"login": "nickChenyx"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMDg3MQ==", "bodyText": "Yes, thanks for pointing it out!", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498600871", "createdAt": "2020-10-02T03:01:49Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ=="}, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMDA5NQ==", "bodyText": "It has been fixed, please check.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498620095", "createdAt": "2020-10-02T05:06:06Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ=="}, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 473}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Nzk1Njc2OnYy", "diffSide": "RIGHT", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNzo0NzoxMFrOHVD_Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNTowOToxMlrOHbhYhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0NzUxNQ==", "bodyText": "here i find usage only close one stream one time, so this may change for close one.\nif u want to close more, i think for loop should catch each fail and finish all close task, and then return fail message.\nwant your opinion, plz.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491847515", "createdAt": "2020-09-21T07:47:10Z", "author": {"login": "nickChenyx"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMDU1MQ==", "bodyText": "Now it has been changed, record the first exception during close resources, to make it can finish all close task, and then throw exception with fail message. Thanks for your careful review.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498620551", "createdAt": "2020-10-02T05:09:12Z", "author": {"login": "cdfive"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0NzUxNQ=="}, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 492}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4150, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}