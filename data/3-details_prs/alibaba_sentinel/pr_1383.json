{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MTEzOTAx", "number": 1383, "title": "Refactor SpiLoader and enhance its SPI functions", "bodyText": "Describe what this PR does / why we need it\nRefer and compared with some SPI implementations, ServiceLoader of JDK, ExtensionLoader of Dubbo and SOFARPC, I'd like to introduce some of their advantages and try to enhance SpiLoader of Sentinel, to provide more functions to support more scenarios, such as singleton/multiple instance, loaded by alias name, default Provider of SPI, etc.\nDoes this pull request fix one issue?\nFixes #1379\nDescribe how you did it\nAdd @Spi annotation with following fields:\n\n\nvalue\naliasname of concrete Provider\nby default is Provider class name\n\n\nisSingleton\nwhether create singleton Provider instance\nby default is true, since singleton is more common\n\n\nisDefault\nwhether is the default Provider\nby default is false, if it's the default implementation, we explicitly identify it\n\n\norder\norder priority of concrete Provider class\nby default is 0\n\n\nFor Provider class which need create multiple instances, such as NodeSelectorSlot:\n@Spi(isSingleton = false, order = Constants.ORDER_NODE_SELECTOR_SLOT)\npublic class NodeSelectorSlot\nFor Provider class which create singleton instance, such as FlowSlot:\n@Spi(order = Constants.ORDER_FLOW_SLOT)\npublic class FlowSlot\nFor Provider class which is the default Provider, such as DefaultSlotChainBuilder:\n@Spi(isDefault = true)\npublic class DefaultSlotChainBuilder\nI didn't exactly copy the way Dubbo and SOFARPC did, and maybe thought as an upgrade of default JDK's SPI, that isServiceLoader, and enhance its functions.\nAlong this line of thought, the usage is exactly same as JDK's SPI, we can also omit the @Spi annotation if wanted, worked with default behavior.\nFunctions of SpiLoader:\n\n\nLoad Provider instance list\nloadInstanceList/loadInstanceListSorted\n\n\nLoad specific order or default Provider instance\nloadHighestPriorityInstance/loadLowestPriorityInstance/loadDefaultInstance\n\n\nLoad one specific Provider via Class or aliasname\nloadInstance(Class)/loadInstance(String aliasName)\n\n\nSince the order of ProcessorSlot is very important, I add constant variables in Constants class for the order value of @Spi, so we can see the order of system default slots more intuitively. The GatewayFlowSlot and ParamFlowSlot are in other module, so add with comment lines.\nConstants:\n/**\n * Order of default processor slots\n */\npublic static final int ORDER_NODE_SELECTOR_SLOT = -10000;\npublic static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\npublic static final int ORDER_LOG_SLOT = -8000;\npublic static final int ORDER_STATISTIC_SLOT = -7000;\npublic static final int ORDER_AUTHORITY_SLOT = -6000;\npublic static final int ORDER_SYSTEM_SLOT = -5000;\n// order in GatewayFlowSlot -4000\n// order in ParamFlowSlot   -3000\npublic static final int ORDER_FLOW_SLOT = -2000;\npublic static final int ORDER_DEGRADE_SLOT = -1000;\nSpiLoader has been moved to spi package, the same as @Spi.\n@SpiOrder,ServiceLoaderUtil has been removed since SpiLoader include the functions.\nNot add more class like ExtensionClass in SOFARPC, ExtentionLoaderFactory in Dubbo, just one SpiLoder class, to reduce complexity and make it simple.\nAdd SpiLoaderException class for thrown when something goes wrong while loading Provider.\nDescribe how to verify it\nRun test cases.\nSpecial notes for reviews\nAt first I use singleton as field name, when adding default field, found that it's keyword of Java. So modified with isSingleton,isDefault, the is prefix hinted that it's a boolean value with true/false. Maybe there are other better ways to name them, please tell me and I will optimize it.\nNow the implementation may not very perfect, please take a review and I'd like to improve the code step by step.", "createdAt": "2020-04-05T14:47:20Z", "url": "https://github.com/alibaba/Sentinel/pull/1383", "merged": true, "mergeCommit": {"oid": "62efb78d4e26d568d726e27ed833a3a8adea724a"}, "closed": true, "closedAt": "2021-01-27T01:45:57Z", "author": {"login": "cdfive"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccFj8kgH2gAyMzk5MTEzOTAxOjQ3OTUzZjBlOWY4MTdmZGViNGM0MmFjYzFmNmVkZDQ1NTdhZWNmZjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdz73ZmgFqTU3NjM2NTYwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "47953f0e9f817fdeb4c42acc1f6edd4557aecff9", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/47953f0e9f817fdeb4c42acc1f6edd4557aecff9", "committedDate": "2020-04-28T15:24:45Z", "message": "Refactor SpiLoader and enhance its SPI functions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "800eb762cdb5228a619604f12c30e3cc0d51f897", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/800eb762cdb5228a619604f12c30e3cc0d51f897", "committedDate": "2020-04-28T15:24:45Z", "message": "Add isDefault in @Spi, add loadDefaultInstance and improve loadFirstInstanceOrDefault method, improve test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5cc3e766932e6a17b94a4731d21ac21e934bec0", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/d5cc3e766932e6a17b94a4731d21ac21e934bec0", "committedDate": "2020-04-28T15:24:45Z", "message": "Fix no SPI file scene and test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/d3926c4a78df8f1f8e9c2721968450d4f222f59e", "committedDate": "2020-04-28T15:24:45Z", "message": "Improve init and fix comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d958a5b3794847e59b71ccd6accdba486688e564", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/d958a5b3794847e59b71ccd6accdba486688e564", "committedDate": "2020-04-06T12:41:28Z", "message": "Improve init and fix comment"}, "afterCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/d3926c4a78df8f1f8e9c2721968450d4f222f59e", "committedDate": "2020-04-28T15:24:45Z", "message": "Improve init and fix comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzExMDgy", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-461311082", "createdAt": "2020-08-05T03:16:53Z", "commit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxNjo1M1rOG74pTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNDo0MzozMVrOG759qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI0Ng==", "bodyText": "Suggest to beautify the comment. Move it to a separated line maybe.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465447246", "createdAt": "2020-08-05T03:16:53Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/test/resources/META-INF/services/com.alibaba.csp.sentinel.spi.TestInterface", "diffHunk": "@@ -0,0 +1,5 @@\n+# One\n+com.alibaba.csp.sentinel.spi.TestOneProvider\n+com.alibaba.csp.sentinel.spi.TestTwoProvider # Two", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA==", "bodyText": "Use constant?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465449700", "createdAt": "2020-08-05T03:26:58Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1MDI1MQ==", "bodyText": "And some slots are stateless while others are stateful. Maybe isSingleton should be specified obviously.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465450251", "createdAt": "2020-08-05T03:29:05Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ==", "bodyText": "I didn't look backward carefully. What is the reason that we don't use ServiceProvider but load them manually here?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455061", "createdAt": "2020-08-05T03:48:11Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ==", "bodyText": "private or package default scope is suggested.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455779", "createdAt": "2020-08-05T03:51:08Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ==", "bodyText": "Maybe we should also sychronize it?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457091", "createdAt": "2020-08-05T03:56:39Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzI0OQ==", "bodyText": "And it looks more like resetAndClear()", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457249", "createdAt": "2020-08-05T03:57:14Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzQyNA==", "bodyText": "serviceClass or providerClass is better?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457424", "createdAt": "2020-08-05T03:58:00Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzYxMQ==", "bodyText": "Useless?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457611", "createdAt": "2020-08-05T03:58:53Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1ODU5Ng==", "bodyText": "Better to be List load() for short access?\nAnd why we don't invoke internal load()(which is called init() maybe better) in constructor? For lazy load?\nBut i don't think it's a good design here if we target it as lazy load.  Because it has nearly 100% possibility to be initialized.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465458596", "createdAt": "2020-08-05T04:02:49Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ==", "bodyText": "Just a suggestion and not a forced request.\nLogics is a bit long. Is it necessary storing both unordered and ordered list? If no only sorted is necessary i think(Maybe loadSorted should be new load()).", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465461121", "createdAt": "2020-08-05T04:13:14Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 448}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ==", "bodyText": "I suggest to cache all the meta data. For example you can use a more complicated structure in your pre-stored class list.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465462319", "createdAt": "2020-08-05T04:18:23Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng==", "bodyText": "Maybe len=0 should also be added here for more obvious.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464486", "createdAt": "2020-08-05T04:26:55Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg==", "bodyText": "SPI -> resource ?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464612", "createdAt": "2020-08-05T04:27:26Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA==", "bodyText": "Maybe logAndRaise or other names can be accurately.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465140", "createdAt": "2020-08-05T04:29:39Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throw {@link SpiLoaderException} with message\n+     *\n+     * @param msg error message\n+     */\n+    private void fail(String msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 527}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTgwMg==", "bodyText": "Maybe loadOne for short. Is there any other way to get target instance? And surely i am curious that why we need loadLowestPriorityInstance or loadFirstInstance. And talk to isDefault in SPI annotation we can make the default service implementation as lowest priority. Then we can use loadOne() instead of something like loadFirstInstanceOrDefault.\nThus loadInstance loadDefault also don't have any scenario to be applied.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465802", "createdAt": "2020-08-05T04:32:10Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODU1Ng==", "bodyText": "Are reset*() only used in unit tests?\nIf so i suggest to comment them obviously and make them package scope is better.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465468556", "createdAt": "2020-08-05T04:42:18Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODg0MQ==", "bodyText": "No need to change.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465468841", "createdAt": "2020-08-05T04:43:31Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/resources/META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot", "diffHunk": "@@ -3,7 +3,7 @@ com.alibaba.csp.sentinel.slots.nodeselector.NodeSelectorSlot\n com.alibaba.csp.sentinel.slots.clusterbuilder.ClusterBuilderSlot\n com.alibaba.csp.sentinel.slots.logger.LogSlot\n com.alibaba.csp.sentinel.slots.statistic.StatisticSlot\n-com.alibaba.csp.sentinel.slots.system.SystemSlot\n com.alibaba.csp.sentinel.slots.block.authority.AuthoritySlot\n+com.alibaba.csp.sentinel.slots.system.SystemSlot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "974bf09414df4c4e16b07235e9bfa853830e4bcd", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/974bf09414df4c4e16b07235e9bfa853830e4bcd", "committedDate": "2020-08-09T06:38:29Z", "message": "Using constant for the order of GatewayFlowSlot and ParamFlowSlot,improve the log info,remove unused code in SpiLoader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/95097bf7314371d2942b9c177bd5506b80f173a8", "committedDate": "2020-08-09T06:50:20Z", "message": "Make reset method package privilege"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODg2MTQz", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-463886143", "createdAt": "2020-08-09T16:17:09Z", "commit": {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQxNjoxNzowOVrOG98JUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQxNjoxNzowOVrOG98JUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYwMTc0Nw==", "bodyText": "It's not a good practice setting unrelated constant here. You'd better put it in gateway adapter package. If you feel a little unsure to decide the value of it in separated package you can take it as a user-defined implementation out of sentinel-core.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467601747", "createdAt": "2020-08-09T16:17:09Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/Constants.java", "diffHunk": "@@ -70,5 +70,19 @@\n      */\n     public static volatile boolean ON = true;\n \n+    /**\n+     * Order of default processor slots\n+     */\n+    public static final int ORDER_NODE_SELECTOR_SLOT = -10000;\n+    public static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\n+    public static final int ORDER_LOG_SLOT = -8000;\n+    public static final int ORDER_STATISTIC_SLOT = -7000;\n+    public static final int ORDER_AUTHORITY_SLOT = -6000;\n+    public static final int ORDER_SYSTEM_SLOT = -5000;\n+    public static final int ORDER_GATEWAY_FLOW_SLOT = -4000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b4c8ea6e2f9fc9bcc13dfc3e10ccd1729bcc603", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/6b4c8ea6e2f9fc9bcc13dfc3e10ccd1729bcc603", "committedDate": "2020-09-20T07:27:48Z", "message": "Merge remote-tracking branch 'Sentinel/master' into spiloader_enhancement\n\n# Conflicts:\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/init/InitExecutor.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/metric/extension/MetricExtensionProvider.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/slotchain/SlotChainProvider.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/slots/block/degrade/DegradeSlot.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ed6387d90b0ec7a4ce02941ed2335a5b3b6fa3", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/f3ed6387d90b0ec7a4ce02941ed2335a5b3b6fa3", "committedDate": "2020-09-20T07:36:55Z", "message": "Merge from master and improve code based on review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "committedDate": "2020-09-20T08:38:43Z", "message": "Fix merge compile error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMzM5Mjky", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-492339292", "createdAt": "2020-09-21T07:35:49Z", "commit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNzozNTo1MFrOHVDo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNzo0NzoxMFrOHVD_Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ==", "bodyText": "double check instance = map.get(...) may necessary, avoid class.newInstance() twice or more.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491841785", "createdAt": "2020-09-21T07:35:50Z", "author": {"login": "nickChenyx"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0NzUxNQ==", "bodyText": "here i find usage only close one stream one time, so this may change for close one.\nif u want to close more, i think for loop should catch each fail and finish all close task, and then return fail message.\nwant your opinion, plz.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491847515", "createdAt": "2020-09-21T07:47:10Z", "author": {"login": "nickChenyx"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8"}, "originalPosition": 492}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e312d8adcb753c1ab4f485db01a4b1c2fe44ab09", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/e312d8adcb753c1ab4f485db01a4b1c2fe44ab09", "committedDate": "2020-10-02T03:07:19Z", "message": "Fix double check when create instance,and fix close resources when exception occurs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffa8d0ce946f96aec32187bdd5c8dbb9a9c18719", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/ffa8d0ce946f96aec32187bdd5c8dbb9a9c18719", "committedDate": "2020-10-02T03:47:52Z", "message": "Fix sortedClassList added more than once which cause CI error when running test cases."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NDU0NzA3", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-504454707", "createdAt": "2020-10-08T06:12:00Z", "commit": {"oid": "ffa8d0ce946f96aec32187bdd5c8dbb9a9c18719"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d23617169eb1be3d6c104ccf175b1105c8f61cfa", "author": {"user": {"login": "cdfive", "name": null}}, "url": "https://github.com/alibaba/Sentinel/commit/d23617169eb1be3d6c104ccf175b1105c8f61cfa", "committedDate": "2020-10-08T06:27:41Z", "message": "Fix double check when create new instance in SpiLoader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NjY0Mzk0", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-557664394", "createdAt": "2020-12-23T06:23:32Z", "commit": {"oid": "d23617169eb1be3d6c104ccf175b1105c8f61cfa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNjoyMzozMlrOIKVDTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNjoyNjoyNlrOIKVLKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMTU4Mw==", "bodyText": "Will it remain for future improvement? About meta caching.", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547701583", "createdAt": "2020-12-23T06:23:32Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMzU5Mw==", "bodyText": "And this one? Remain it this time?", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547703593", "createdAt": "2020-12-23T06:26:26Z", "author": {"login": "jasonjoo2010"}, "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ=="}, "originalCommit": {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e"}, "originalPosition": 448}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2MjIzOTAw", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-576223900", "createdAt": "2021-01-26T10:40:16Z", "commit": {"oid": "d23617169eb1be3d6c104ccf175b1105c8f61cfa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2MzY1NjA3", "url": "https://github.com/alibaba/Sentinel/pull/1383#pullrequestreview-576365607", "createdAt": "2021-01-26T13:52:17Z", "commit": {"oid": "d23617169eb1be3d6c104ccf175b1105c8f61cfa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3906, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}