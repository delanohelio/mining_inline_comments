{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwNzgzNzU1", "number": 6647, "title": "Convert Offensive/Defensive AA Fire Steps", "bodyText": "This converts the Offensive/Defensive AA Fire steps to the new BattleStep.\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix:  \n[] Other:   \nTesting\nI created a save file before a battle with AA guns, during AA casualty selection, after AA casualty selection, and after the battle.", "createdAt": "2020-06-08T06:05:34Z", "url": "https://github.com/triplea-game/triplea/pull/6647", "merged": true, "mergeCommit": {"oid": "a744b638a5767d084429e0c075abee5069041d19"}, "closed": true, "closedAt": "2020-06-12T23:58:21Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpJnJggH2gAyNDMwNzgzNzU1OmZmNGViYzg5YmFiN2QzMzMzZTk5ZTBlYjRiMjYwMTAyYjM5MGZmNzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqr394gFqTQzMDA4ODMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ff4ebc89bab7d3333e99e0eb4b260102b390ff74", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ff4ebc89bab7d3333e99e0eb4b260102b390ff74", "committedDate": "2020-06-08T05:28:53Z", "message": "Move Offensive/Defensive Aa to BattleStep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cfc5a7fad11bab7ff94c5ccb1edd4030d524aaf", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/9cfc5a7fad11bab7ff94c5ccb1edd4030d524aaf", "committedDate": "2020-06-08T05:51:35Z", "message": "Ensure the step object is created for old steps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6851bef4561e6ce9dc721567cb209560d10c439", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d6851bef4561e6ce9dc721567cb209560d10c439", "committedDate": "2020-06-08T05:58:07Z", "message": "Make sure valid is called as needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "committedDate": "2020-06-08T06:05:23Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTM1NDkx", "url": "https://github.com/triplea-game/triplea/pull/6647#pullrequestreview-425935491", "createdAt": "2020-06-08T06:07:12Z", "commit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjowNzoxMlrOGgQPGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjowNzoxM1rOGgQPHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyNQ==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473625", "createdAt": "2020-06-08T06:07:12Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyNg==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473626", "createdAt": "2020-06-08T06:07:12Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyOA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473628", "createdAt": "2020-06-08T06:07:13Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njk2NzMy", "url": "https://github.com/triplea-game/triplea/pull/6647#pullrequestreview-427696732", "createdAt": "2020-06-10T04:08:28Z", "commit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowODoyOVrOGhkJdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDozMzozNlrOGhkg1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQzOQ==", "bodyText": "This side effect is striking since getter methods tend to not mutate state. It could also be surprising if one caller were to use this class, and then we add another caller that then calls getOffensiveAa and that would change the state in a way the first caller might not be expecting.\nMaking the side-effect of setting the value of offensiveAa generally helps. IE:\noffensiveAa = computeRemainingOffensiveAaUnits();\nreturn offensiveAa;\n\nThat is still odd though, which makes me wonder if instead this problem would be solved by removing all side effects and instead calling the method something like computeRemainingOffensiveAaUnits(). In that case, any place where we call the getter and need those side effects, then we call the method instead. Perhaps this would lead to the offensiveAa variable to no longer be needed at all.\nWhat are your thoughts?", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437848439", "createdAt": "2020-06-10T04:08:29Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -398,6 +380,18 @@ void addDependentUnits(final Map<Unit, Collection<Unit>> dependencies) {\n     return new ArrayList<>(remaining);\n   }\n \n+  @Override\n+  public List<Unit> getOffensiveAa() {\n+    updateOffensiveAaUnits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTYzMA==", "bodyText": "Given we already have the detailed comment above about save-game compatibility, do we very much need the 'if this gets' comment?\nI suspect we could delete it. The 'new' BattleStep mention is also very notable as it makes sense when looking at this diff, but a future maintainer looking at the post-merged code will not necessarily know have context to see the difference between 'new' and 'old'.", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437849630", "createdAt": "2020-06-10T04:13:27Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {\n+      private static final long serialVersionUID = 3802352588499530533L;\n \n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireDefensiveAaGuns();\n-            }\n-          });\n+      @Override\n+      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+        // if this gets deserialized, then forward the work to the new BattleStep", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTk4Ng==", "bodyText": "Ditto, we may not need this comment. Someone modifying a method should be aware of the method contract, which implies they would have at least read the method javadoc. Removing this comment could reduce future maintenance burden (less stuff to keep in sync, code and comments need to always be verified and kept in sync).", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437849986", "createdAt": "2020-06-10T04:15:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {\n+      private static final long serialVersionUID = 3802352588499530533L;\n \n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireDefensiveAaGuns();\n-            }\n-          });\n+      @Override\n+      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+        // if this gets deserialized, then forward the work to the new BattleStep\n+        final BattleStep offensiveAaStep =\n+            new OffensiveAaFire(MustFightBattle.this, MustFightBattle.this);\n+        offensiveAaStep.execute(stack, bridge);\n+      }\n+    };\n+    if (defensiveAaStep.valid()) {\n+      steps.add(defensiveAaStep);\n     }\n+    // see Save Game Compatibility Note on getBattleExecutables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDc4Nw==", "bodyText": "nit, it's a novel contention to name the 'test object' as underTest. Other conventions are sut, testObj, etc..\nFor the most part I think our latest convention is just to use 'natural naming'. IE: DefensiveAaFire defensiveAaFire. A benefit of this naming is you can see an example of how code would read when actually used. IE:\ndefensiveAaFire.isValid()\n\nvs\nunderTest.isValid()\n\nThe latter does not give as good of an indication if methods are well named. As well underTest is not necessarily easy to follow in test.\nDo you have any strong objection to renaming the test variable?", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437850787", "createdAt": "2020-06-10T04:18:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DefensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final DefensiveAaFire underTest = new DefensiveAaFire(battleState, battleActions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MTk1MQ==", "bodyText": "Have a second look at the parameterization if you would. I think it's a clear win if we have ballpark 5 or more variations. With just two, particularly with boolean logic, it might be more straight forward just enumerating the different test cases with individual test blocks. I think in big part parameterized tests should not have if blocks, that indicates really that you have multiple test methods (essentially one is testing too many things at once), secondarily data that changes how a test method behaves I think is arguably a test code-smell. WDYT?", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437851951", "createdAt": "2020-06-10T04:23:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DefensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MjUwMg==", "bodyText": "What do you think of re-grouping this test case with a nested test class to improve the test method naming?\nEG:\n@Nested\nclass IsValid {\n   \n   @Test\n    void notValidWithNoOffensiveAa() {\n\n    }\n\n    @Test\n    void validWithOffensiveAa() {\n\n     }\n\n}", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437852502", "createdAt": "2020-06-10T04:25:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzE3MQ==", "bodyText": "Will we call execute of this action if valid() were ever false? Asked in another way, do we only call execute when valid() is true?", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437853171", "createdAt": "2020-06-10T04:28:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.Collection;\n+\n+/** Offensive Aa units can fire and the player can select their casualties */\n+public class OffensiveAaFire extends AaFireAndCasualtyStep {\n+  private static final long serialVersionUID = 5843852442617511691L;\n+\n+  public OffensiveAaFire(final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (valid()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NDQyMg==", "bodyText": "nit: test prefix is a bit of an old convention (IIRC Junit3 required test methods to begin with 'test'). Latest convention is to focus on describing what is being verified. IE: verifyFireOffensiveAaGunActionInvoked. The example I think also demonstrates a question of \"under which conditions should that be true?\"\nShould there be a second test case, or do we legitimately again assume that isValid() is invoked first? EG:\n@Nested\nclass ExecuteOffensiveAaFire {\n   @Test\n    @DisplayName(\"Execute will not invoke fire Offensive Aa Guns when no offensive AA Exist\")\n   void noOffensiveAa {\n\n   }\n\n   @Test\n    @DisplayName(\"Execute will invoke fire Offensive Aa Guns When Exists Offensive Aa\")\n   void hasOffensiveAa() {\n\n   }\n}\n\n(side-note, reading the display name, and or a un-camel-cased list of the test methods and display names in a test class should practically form a complete spec for the class under test,  eg:\n\nnot valid with no offensive Aa\nvalid with offensive aa\nexecute will not invoke fire Offensive Aa Guns when no offensive AA exist\nexecute will invoke fire Offensive Aa Guns When Exists Offensive Aa\n)", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437854422", "createdAt": "2020-06-10T04:33:36Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final OffensiveAaFire underTest = new OffensiveAaFire(battleState, battleActions);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(3));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"No Offensive Aa\", givenBattleStateBuilder().offensiveAa(List.of()).build(), false),\n+        Arguments.of(\n+            \"Some Offensive Aa\",\n+            givenBattleStateBuilder().offensiveAa(List.of(givenUnitWithTypeAa())).build(),\n+            true));\n+  }\n+\n+  @Test\n+  void testFiringAaGuns() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "918e5ebe8c9e42d8050042e55d8a0cbba41b66c0", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/918e5ebe8c9e42d8050042e55d8a0cbba41b66c0", "committedDate": "2020-06-10T05:08:43Z", "message": "Update aa units explicitly where they were implicitly updated before"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "444a108bcac523e2d63e53b9fd571e82a3c82f9b", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/444a108bcac523e2d63e53b9fd571e82a3c82f9b", "committedDate": "2020-06-10T05:15:46Z", "message": "Remove redundant comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1c3d7809702562bc6905167940fea23fb0c5de2", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b1c3d7809702562bc6905167940fea23fb0c5de2", "committedDate": "2020-06-10T05:15:57Z", "message": "Rename underTest to more natural name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c9d21a6d9513d60093606ba33dccabb2d040075", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/8c9d21a6d9513d60093606ba33dccabb2d040075", "committedDate": "2020-06-10T05:44:09Z", "message": "Remove parameterization and group tests in @Nested tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc6691e00a716f3844dd21cfb71be77368ede709", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/bc6691e00a716f3844dd21cfb71be77368ede709", "committedDate": "2020-06-10T05:48:59Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDg4MzAz", "url": "https://github.com/triplea-game/triplea/pull/6647#pullrequestreview-430088303", "createdAt": "2020-06-12T23:57:57Z", "commit": {"oid": "bc6691e00a716f3844dd21cfb71be77368ede709"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3369, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}