{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0MjQxNTk4", "number": 7606, "title": "Convert unprotected units step", "bodyText": "This converts the step that auto-kills undefended transports and \"unprotected units\" (the original name was \"units that can't roll\").\nIn addition to converting the step, I made two functional changes:\n\n\nIn the detection for undefended units, it didn't actually check if the enemy units were enemy units.  It just assumed that any unit in the battlesite with attack must be the enemy.  I added an Matches.enemyUnit.\n\n\nThe logic to auto-kill the undefended transports and \"unprotected units\" was in two places but used the \"Transport Casualties Restricted\" property slightly differently.  I made both places use the new step.  This means that now they both use the property the same.   I'm fairly certain this will actually not affect anything.  The second case only happens if the non-infrastructure units are 0 and it looks like the \"unprotected units\" auto-kill only kills non-infrastructure units (see RemoveUnprotectedUnitsTest#actionForDefenderIfNoRetreatAndUnitsAndCanNotRollAndOtherSideCanButUnitsAreInfra for a test around that).\n\n\n\nTesting\n\nOpened up some save games.  Played a game where the transports should be auto-killed and ensured they were.\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note", "createdAt": "2020-09-10T19:22:13Z", "url": "https://github.com/triplea-game/triplea/pull/7606", "merged": true, "mergeCommit": {"oid": "c95d5244cc330a6c9677bfeb5bc42492606a10e2"}, "closed": true, "closedAt": "2020-09-12T22:10:47Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHl3WbgH2gAyNDg0MjQxNTk4OmQxODk2ZjkyODExY2M1MzQxZTcxMGMzNGJlZWYyMzZiZmIyZDA5NWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdIRd_BAFqTQ4NzI1OTI1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d1896f92811cc5341e710c34beef236bfb2d095f", "committedDate": "2020-09-10T19:21:39Z", "message": "Convert undefended transports step\n\nActually check that enemy units are present when detecting undefended\ntransports.  Previously, it just assumed that if one side had\ntransports, then any unit with an attack must be on the other side.\n\nAlways check TRANSPORT_CASUALTIES_RESTRICTED for removing units that\nhave no more rolls (aka unprotected units)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NDQ5MTk1", "url": "https://github.com/triplea-game/triplea/pull/7606#pullrequestreview-486449195", "createdAt": "2020-09-11T03:29:16Z", "commit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzoyOToxNlrOHQM_sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzo0MDoxOFrOHQNJ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjE3OA==", "bodyText": "Is it inconsistent to have 'removeUndefendedUnits' and 'removeUnprotectedUnits'?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752178", "createdAt": "2020-09-11T03:29:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -168,13 +181,7 @@ public boolean isAmphibious() {\n     if (defensiveSubsSubmerge.getOrder() == SUB_DEFENSIVE_RETREAT_BEFORE_BATTLE) {\n       steps.addAll(defensiveSubsSubmerge.getNames());\n     }\n-    // See if there any unescorted transports\n-    if (isBattleSiteWater\n-        && Properties.getTransportCasualtiesRestricted(gameData)\n-        && (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n-            || defendingUnits.stream().anyMatch(Matches.unitIsTransport()))) {\n-      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n-    }\n+    steps.addAll(removeUndefendedUnits.getNames());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjU4Nw==", "bodyText": "Do these class variables have to be 'protected', can they be private?\nHaving child classes modify parent state is a bad form of coupling. It makes program flow very hard to reason about as you have to know the program state to know what will execute and how. Having class variables be uniformly private helps with this and avoiding inheritance.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752587", "createdAt": "2020-09-11T03:30:59Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mjc2NQ==", "bodyText": "Nit: Have you considered using a ternary here? Avoiding intermediate variables is often a good thing.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752765", "createdAt": "2020-09-11T03:31:41Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI0NA==", "bodyText": "This being a potential no-op if kinda concerning. I'm also wondering exactly what is meant by 'check', makes for a difficult public API.  Will this method ever be invoked if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) is false? Can we perhaps make it so that this step is never added to begin with? In that case you could assert that state to be true here", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753244", "createdAt": "2020-09-11T03:33:53Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI5Mw==", "bodyText": "nit, obvious comment, mostly restates the code. IMO this one can be removed.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753293", "createdAt": "2020-09-11T03:34:07Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mzg0NQ==", "bodyText": "nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:\nreturn battleState.getUnits(EnumSet.of(side)).stream()\n  .anyMatch(unitIsActive(BattleState.side.OFFENSE));\n\nI believe you can also get rid of the intermediate variable as well and just return the result directly as well.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753845", "createdAt": "2020-09-11T03:36:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDE2NA==", "bodyText": "This is perhaps too much information for a step class to have, to know exactly when a unit is active. I suspect having unit have a method for this would maybe be more appropriate, but failing that, would it make sense to create a Matches for this condition?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754164", "createdAt": "2020-09-11T03:37:31Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(\n+                getActiveUnits()\n+                    .and(\n+                        Matches.unitIsSupporterOrHasCombatAbility(\n+                            side == BattleState.Side.OFFENSE)));\n+    return hasUnitsThatCanRollLeft;\n+  }\n+\n+  private Predicate<Unit> getActiveUnits() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDIzOQ==", "bodyText": "Ditto on direct return, can avoid the intermediate variable.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754239", "createdAt": "2020-09-11T03:37:49Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(\n+                getActiveUnits()\n+                    .and(\n+                        Matches.unitIsSupporterOrHasCombatAbility(\n+                            side == BattleState.Side.OFFENSE)));\n+    return hasUnitsThatCanRollLeft;\n+  }\n+\n+  private Predicate<Unit> getActiveUnits() {\n+    return Matches.unitIsSubmerged()\n+        .negate()\n+        .and(\n+            Matches.territoryIsLand().test(battleState.getBattleSite())\n+                ? Matches.unitIsSea().negate()\n+                : Matches.unitIsLand().negate());\n+  }\n+\n+  private Collection<Unit> getUnprotectedUnits(final BattleState.Side side) {\n+    final Collection<Unit> unitsToKill;\n+    unitsToKill =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(EnumSet.of(side)),\n+            getActiveUnits().and(Matches.unitIsNotInfrastructure()));\n+    return unitsToKill;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDUzMw==", "bodyText": "Seeing this same code 3 times is raising real questions \ud83d\ude01\nWhy does FakeBattleState need to have this implementation? Can we avoid it and perhaps use a true mock? This is kinda concerning code as our test code has implementation that arguably should have a test of its own.\nAre there options where we can remove this method and/or class?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754533", "createdAt": "2020-09-11T03:39:12Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/FakeBattleState.java", "diffHunk": "@@ -82,6 +82,18 @@\n     return dependentUnits;\n   }\n \n+  @Override\n+  public Collection<Unit> getUnits(final EnumSet<Side> sides) {\n+    final Collection<Unit> units = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDgwNA==", "bodyText": "nit, favor using the IsEmptyCollection matcher instead of checking size == 0 for collections.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754804", "createdAt": "2020-09-11T03:40:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsTest.java", "diffHunk": "@@ -0,0 +1,508 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RemoveUnprotectedUnitsTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock Territory battleSite;\n+\n+  @Nested\n+  class GetNames {\n+\n+    @Test\n+    void noNameIfNotWater() {\n+      when(battleSite.isWater()).thenReturn(false);\n+      final BattleState battleState = givenBattleStateBuilder().battleSite(battleSite).build();\n+      final RemoveUnprotectedUnits removeUnprotectedUnits =\n+          new RemoveUnprotectedUnits(battleState, battleActions);\n+      assertThat(removeUnprotectedUnits.getNames(), hasSize(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e770bc21990d8dfa13f1d7433200c4b5e96f605", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/9e770bc21990d8dfa13f1d7433200c4b5e96f605", "committedDate": "2020-09-11T04:56:20Z", "message": "Review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/75ac427e4b993e85cbce7809180972cec6dd59c1", "committedDate": "2020-09-11T23:28:37Z", "message": "Change names and move some matchers to Matches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTgyOTkw", "url": "https://github.com/triplea-game/triplea/pull/7606#pullrequestreview-487182990", "createdAt": "2020-09-12T00:18:47Z", "commit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDoxODo0N1rOHQw8iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0NjoyNVrOHQxNNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw==", "bodyText": "nit, any consideration to make the API generic and allow for EnumSet to passed in as an implementation detail?\nFor example, if I had a Set<Side>, should I really be forced to convert it to an EnumSet to call this method? Is the runtime difference of forcing a collection copy enough that the EnumSet is that much more efficient?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341193", "createdAt": "2020-09-12T00:18:47Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -21,10 +29,12 @@\n \n   Collection<Unit> getAttackingUnits();\n \n-  Collection<Unit> getAttackingWaitingToDie();\n-\n   Collection<Unit> getDefendingUnits();\n \n+  Collection<Unit> getUnits(EnumSet<Side> sides);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTI0Nw==", "bodyText": "nit, have you considered using a ternary here?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341247", "createdAt": "2020-09-12T00:19:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -12,7 +12,15 @@\n \n   enum Side {\n     OFFENSE,\n-    DEFENSE,\n+    DEFENSE;\n+\n+    public Side getOpposite() {\n+      if (this == OFFENSE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTY3NQ==", "bodyText": "Perhaps even better, perhaps a vararg for this? In such a case a caller would not have to create a collection at all. WDYT?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341675", "createdAt": "2020-09-12T00:21:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -21,10 +29,12 @@\n \n   Collection<Unit> getAttackingUnits();\n \n-  Collection<Unit> getAttackingWaitingToDie();\n-\n   Collection<Unit> getDefendingUnits();\n \n+  Collection<Unit> getUnits(EnumSet<Side> sides);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTkyNQ==", "bodyText": "For yet more consideration, any thought to making this a default method?\nIt looks like these methods would give you the data access needed:\n\n  @Override\n  public Collection<Unit> getDefendingUnits() {\n    return Collections.unmodifiableCollection(defendingUnits);\n  }\n\n  @Override\n  public Collection<Unit> getRemainingAttackingUnits() {\n    return Collections.unmodifiableCollection(attackingUnits);\n  }", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341925", "createdAt": "2020-09-12T00:22:51Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -21,10 +29,12 @@\n \n   Collection<Unit> getAttackingUnits();\n \n-  Collection<Unit> getAttackingWaitingToDie();\n-\n   Collection<Unit> getDefendingUnits();\n \n+  Collection<Unit> getUnits(EnumSet<Side> sides);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjAzOA==", "bodyText": "Still more questions.. Should the above two methods be replaced by usages of this getUnits(...) method? Reducing the API surface of such a class would be a good thing, particularly removal of simple getter API methods.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487342038", "createdAt": "2020-09-12T00:23:40Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -21,10 +29,12 @@\n \n   Collection<Unit> getAttackingUnits();\n \n-  Collection<Unit> getAttackingWaitingToDie();\n-\n   Collection<Unit> getDefendingUnits();\n \n+  Collection<Unit> getUnits(EnumSet<Side> sides);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjUxNw==", "bodyText": "Fair enough, something to consider though. Having a method lead with return is  a powerful clue to a reader. Otherwise with an 'if' and 'otherwise' block here, it's arguably cognitively more complex. Specifically until you've scanned the whole method do you realize that all it is is a condition and a return statement based on that (and the simplest form of that is a ternary which leads with the keyword 'return' to help tell a reader that information immediately)", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487342517", "createdAt": "2020-09-12T00:26:30Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mjc2NQ=="}, "originalCommit": {"oid": "d1896f92811cc5341e710c34beef236bfb2d095f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDA5Mg==", "bodyText": "What do you think about something that is more like:\nif(!attackerCanRetreat(side)) {\n   removeUnprotectedUnits(side);\n}\n\n\nHaving control flow at the outer layers is generally a good thing. A series of void method calls is not a great abstraction, it's cognitively equivalent to adding comments and inlining the methods. A reader being able to skip sections of code because they are tracing control flow is on the other hand very valuable beyond demonstrating the flow of control at the outset. That pattern is called \"imperative shell, functional core\".\nI also suggest that as it took quite a bit of 'groking' to determine that this method is largely just a lot of conditionals then we do the remove operation. I think there is also a mixing of layers of abstraction code smell here too, eg:\n- high level boolean check\n- low level boolean check\n- low level boolean check\n- high level fetch of unit collection\n- low level removal of units\n\nWith the above you keep the high level boolean check and the control flow is extracted, and you can also potentially inline getUnprotectedUnits into removeUnprotectedUnits which I think then makes a lot of sense and keeps the abstractions at a consistent level (and there are just as many methods, but each one is more focused in what they do).", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487344092", "createdAt": "2020-09-12T00:36:39Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      return List.of(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    removeUnprotectedUnits(bridge, BattleState.Side.DEFENSE);\n+    removeUnprotectedUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTAxOA==", "bodyText": "At a first glance this is a bit confusing to have a boolean parameter that negates the whole thing. For consideration, boolean parameters automatically violate SRP, the method by definition then does multiple things (so long as the parameter is used).\nPerhaps the underlying code should get the relationship type instead of using the 'isAllied' and 'isAtWar' methods?\nIn that case you could have withRelationship(Player1, Player2, RelationshipType)", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345018", "createdAt": "2020-09-12T00:43:17Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/MockGameData.java", "diffHunk": "@@ -29,6 +33,18 @@ public GameData build() {\n     return gameData;\n   }\n \n+  public MockGameData withAlliedRelationship(\n+      final GamePlayer player1, final GamePlayer player2, final boolean value) {\n+    when(relationshipTracker.isAllied(player1, player2)).thenReturn(value);\n+    return this;\n+  }\n+\n+  public MockGameData withWarRelationship(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ==", "bodyText": "A @DisplayName on this one could be useful IMO to explain why there is no name expected if land. It would be good to see this made clear up front why we expect this situation to be true. I mention that because without context, it's not clear why 'unprotected units' is an invalid step for land, 'land' can have protected or unprotected units, hence there is context here into the production code needed to understand the test, which is a test code maintenance scaling problem.", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345271", "createdAt": "2020-09-12T00:45:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsTest.java", "diffHunk": "@@ -0,0 +1,510 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RemoveUnprotectedUnitsTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock Territory battleSite;\n+\n+  @Nested\n+  class GetNames {\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTQ2MA==", "bodyText": "This makes me wonder if the rule should be named more directly \"RemoveUnprotectedCasualtyRestrictedTransports\", WDYT?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345460", "createdAt": "2020-09-12T00:46:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsTest.java", "diffHunk": "@@ -0,0 +1,510 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RemoveUnprotectedUnitsTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock Territory battleSite;\n+\n+  @Nested\n+  class GetNames {\n+\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ=="}, "originalCommit": {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee228b289af9e72b8c93aa359d68a9102c5477b5", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ee228b289af9e72b8c93aa359d68a9102c5477b5", "committedDate": "2020-09-12T03:36:30Z", "message": "Review fixes: return early methods and vararg arguments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d2aa493d6c815ff75ff610fa300963c9888dff1", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/3d2aa493d6c815ff75ff610fa300963c9888dff1", "committedDate": "2020-09-12T13:31:57Z", "message": "Unify the attackerHasRetreat early return"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjU5MjUy", "url": "https://github.com/triplea-game/triplea/pull/7606#pullrequestreview-487259252", "createdAt": "2020-09-12T22:06:14Z", "commit": {"oid": "3d2aa493d6c815ff75ff610fa300963c9888dff1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQyMjowNjoxNFrOHQ3yfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQyMjowOToxM1rOHQ3zOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ1MzMxMA==", "bodyText": "Personally I would not have preserved this comment, it makes sense with some context but otherwise is actually not that helpful and is arguably more cheeky than informative. It does leave me with more questions than answers.\nIs there any reason otherwise to not combine the two if statements?", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487453310", "createdAt": "2020-09-12T22:06:14Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -51,20 +51,27 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n   }\n \n   public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n-    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n-      checkUndefendedTransports(bridge, side);\n-      checkUnprotectedUnits(bridge, side);\n+    if (!Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      return;\n     }\n+    // if we are the attacker, we can retreat instead of dying", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d2aa493d6c815ff75ff610fa300963c9888dff1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ1MzQ5OQ==", "bodyText": "Having the early return in this method is much better \ud83d\udc4d\nEarly return is a pattern I like, I do prefer:\nvoid method()  {\n  if(something) {\n     return;\n  }\n}\n\nOver:\nvoid method() {\n  if(!something) {\n    // do stuff\n\n  }\n  return;\n\n}\n\n\nBut, if a method is going to be a no-op, I generally prefer for it just not to be invoked. It's always a bit frustrating to read through code to realize that method calls are no-ops. Methods generally are called so that something can happen. For example, if a method no-ops because of null input, presumably the caller called it for something to happen, did the caller realize that they even provided a null input? IN such a case, I see something like:\nvoid method(Sringg arg) {\n  if(arg == null) {\n     return; // << this is a silent failure, a BUG. Did the caller know they provided a null arg and were just doing a no-op?\n  }\n}", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487453499", "createdAt": "2020-09-12T22:09:13Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -51,20 +51,27 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n   }\n \n   public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n-    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n-      checkUndefendedTransports(bridge, side);\n-      checkUnprotectedUnits(bridge, side);\n+    if (!Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      return;\n     }\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    checkUndefendedTransports(bridge, side);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d2aa493d6c815ff75ff610fa300963c9888dff1"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4003, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}