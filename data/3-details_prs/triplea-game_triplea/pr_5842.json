{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxODU2MTU4", "number": 5842, "title": "AI add buying zero move units", "bodyText": "Address forum requests: https://forums.triplea-game.org/topic/1707/simple-trigger-help/20\nAdd AI support to purchase 0 move and/or construction units which are generally used as static defenses. These are fairly important in some maps.\nTesting\n[x] Manual testing done\n\nRan several all AI games on NWO, NML, and revised to ensure there are no issues and the AI appropriately considers buying bunkers in NWO and trenches in NML.", "createdAt": "2020-01-12T18:12:52Z", "url": "https://github.com/triplea-game/triplea/pull/5842", "merged": true, "mergeCommit": {"oid": "7d3b57fd7f4ea977f45e235433b661fdc8896760"}, "closed": true, "closedAt": "2020-01-20T03:46:32Z", "author": {"login": "ron-murhammer"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb5rxmBAH2gAyMzYxODU2MTU4OjI0MzNlZTg2Y2E2N2E1ODM0NGRhNmJkMGJlMmIyYzE0NTQyZWJlNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8CR8uAFqTM0NTA0NjQzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/2433ee86ca67a58344da6bd0be2b2c14542ebe65", "committedDate": "2020-01-12T18:08:42Z", "message": "AI add buying zero move units"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTkwNDY5", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-341590469", "createdAt": "2020-01-12T18:14:44Z", "commit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxODoxNDo0NFrOFcqgcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxODoxNDo0NVrOFcqgdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Mw==", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600883", "createdAt": "2020-01-12T18:14:44Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4NA==", "bodyText": "Method hasReachedConstructionLimits has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600884", "createdAt": "2020-01-12T18:14:44Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4NQ==", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has a Cognitive Complexity of 11 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600885", "createdAt": "2020-01-12T18:14:44Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Ng==", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 26 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600886", "createdAt": "2020-01-12T18:14:44Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Nw==", "bodyText": "Method hasReachedConstructionLimits has 41 lines of code (exceeds 25 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600887", "createdAt": "2020-01-12T18:14:45Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8343b083834308779677ad0322e3c4f187cc1b7", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/a8343b083834308779677ad0322e3c4f187cc1b7", "committedDate": "2020-01-12T18:22:46Z", "message": "Remove commented code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5935be0b01663b9f6fc7bd6bb0f7607ecc9997f8", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/5935be0b01663b9f6fc7bd6bb0f7607ecc9997f8", "committedDate": "2020-01-12T18:25:30Z", "message": "Refactor method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e02c00e6d23d47fb280169299ea7012ff2c1e429", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e02c00e6d23d47fb280169299ea7012ff2c1e429", "committedDate": "2020-01-13T06:27:50Z", "message": "Improve suicide unit check and have fast AI consider 0 strength"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "committedDate": "2020-01-15T23:07:12Z", "message": "Refactor construction validation methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTgzMzky", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-343583392", "createdAt": "2020-01-15T23:08:58Z", "commit": {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzowODo1OFrOFeJYkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzowODo1OFrOFeJYmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM0NQ==", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155345", "createdAt": "2020-01-15T23:08:58Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM1MA==", "bodyText": "Method findNumberOfConstructionTypeToPlace has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155350", "createdAt": "2020-01-15T23:08:58Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          findMaxConstructionTypeAllowed(purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM1Mg==", "bodyText": "Method findMaxConstructionTypeAllowed has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155352", "createdAt": "2020-01-15T23:08:58Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          findMaxConstructionTypeAllowed(purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(\n+      final ProPurchaseOption purchaseOption,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    int numConstructionTypeToPlace =\n+        CollectionUtils.countMatches(\n+            unitsToPlace, Matches.unitIsOfType(purchaseOption.getUnitType()));\n+    for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+      for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+        if (placeTerritory.getTerritory().equals(territory)) {\n+          numConstructionTypeToPlace +=\n+              CollectionUtils.countMatches(\n+                  placeTerritory.getPlaceUnits(),\n+                  Matches.unitIsOfType(purchaseOption.getUnitType()));\n         }\n-        final int allowedBuild = maxBuilt - currentlyBuilt;\n-        if (allowedBuild - purchaseOption.getQuantity() < 0) {\n-          it.remove();\n+      }\n+    }\n+    return numConstructionTypeToPlace;\n+  }\n+\n+  private static int findMaxConstructionTypeAllowed(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4"}, "originalPosition": 181}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "committedDate": "2020-01-15T23:31:55Z", "message": "Separate utils class into 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTkyMzMz", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-343592333", "createdAt": "2020-01-15T23:33:29Z", "commit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzozMzoyOVrOFeJ0Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzozMzozMVrOFeJ0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMA==", "bodyText": "Method removeInvalidPurchaseOptions has 7 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162430", "createdAt": "2020-01-15T23:33:29Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMQ==", "bodyText": "Method removeInvalidPurchaseOptions has 9 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162431", "createdAt": "2020-01-15T23:33:29Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMw==", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162433", "createdAt": "2020-01-15T23:33:29Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzNQ==", "bodyText": "Method canUnitsBePlaced has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162435", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzNw==", "bodyText": "Method canUnitsBePlaced has 6 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162437", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzOQ==", "bodyText": "Method findPurchaseOptionsForTerritory has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162439", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0MQ==", "bodyText": "Method findPurchaseOptionsForTerritory has 6 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162441", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0Mg==", "bodyText": "Method canTerritoryUsePurchaseOption has 6 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162442", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0NA==", "bodyText": "Method hasReachedConstructionLimits has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162444", "createdAt": "2020-01-15T23:33:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0NQ==", "bodyText": "File ProPurchaseValidationUtils.java has 251 lines of code (exceeds 250 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162445", "createdAt": "2020-01-15T23:33:31Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0OA==", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has a Cognitive Complexity of 11 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162448", "createdAt": "2020-01-15T23:33:31Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1MQ==", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162451", "createdAt": "2020-01-15T23:33:31Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1Mw==", "bodyText": "Method findNumberOfConstructionTypeToPlace has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162453", "createdAt": "2020-01-15T23:33:31Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          ProPurchaseValidationUtils.findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          ProPurchaseValidationUtils.findMaxConstructionTypeAllowed(\n+              purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1NA==", "bodyText": "Method findMaxConstructionTypeAllowed has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162454", "createdAt": "2020-01-15T23:33:31Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          ProPurchaseValidationUtils.findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          ProPurchaseValidationUtils.findMaxConstructionTypeAllowed(\n+              purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(\n+      final ProPurchaseOption purchaseOption,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    int numConstructionTypeToPlace =\n+        CollectionUtils.countMatches(\n+            unitsToPlace, Matches.unitIsOfType(purchaseOption.getUnitType()));\n+    for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+      for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+        if (placeTerritory.getTerritory().equals(territory)) {\n+          numConstructionTypeToPlace +=\n+              CollectionUtils.countMatches(\n+                  placeTerritory.getPlaceUnits(),\n+                  Matches.unitIsOfType(purchaseOption.getUnitType()));\n+        }\n+      }\n+    }\n+    return numConstructionTypeToPlace;\n+  }\n+\n+  private static int findMaxConstructionTypeAllowed(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/85c00551f738f3040b8cb02d704670f6f53e7d27", "committedDate": "2020-01-15T23:34:14Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTY3NzEx", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-344967711", "createdAt": "2020-01-18T23:37:46Z", "commit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMzozNzo0NlrOFfMfMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMzo0NjoyNlrOFfMgTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDc3MQ==", "bodyText": "Is this comment now misplaced? It's hard to see how it relates to the next couple lines, seems like it relates to lines below it.\nThe comment block also seems to be blocking off a logical step, would be a good candidate for an extract method refactor.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254771", "createdAt": "2020-01-18T23:37:46Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProPurchaseAi.java", "diffHunk": "@@ -2551,6 +2571,10 @@ private void addUnitsToPlaceTerritory(\n                 isBid)) {\n \n           // Place max number of units", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDgwOQ==", "bodyText": "Why are constructions being removed from unitsToPlace and added to ppt.\nSecond, would ppt provide better encapsulation if it provided a method to add constructions rather than exposing a mutable datastructure?\nEG:\n ppt.getPlaceUnits().addAll(constructions);\n\nto:\n ppt.addConstructions(constructions); // this method could assert that all units match 'unitIsconstruction'", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254809", "createdAt": "2020-01-18T23:38:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProPurchaseAi.java", "diffHunk": "@@ -2551,6 +2571,10 @@ private void addUnitsToPlaceTerritory(\n                 isBid)) {\n \n           // Place max number of units\n+          final List<Unit> constructions =\n+              CollectionUtils.getMatches(unitsToPlace, Matches.unitIsConstruction());\n+          unitsToPlace.removeAll(constructions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwMA==", "bodyText": "These 4 data members seem very related. Have you considered creating a type around it?", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254900", "createdAt": "2020-01-18T23:41:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseOption.java", "diffHunk": "@@ -71,6 +72,10 @@\n     final Resource pus = data.getResourceList().getResource(Constants.PUS);\n     cost = productionRule.getCosts().getInt(pus);\n     costs = productionRule.getCosts();\n+    isConstruction = unitAttachment.getIsConstruction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwNA==", "bodyText": "What's the rationale for 0.1?", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254904", "createdAt": "2020-01-18T23:41:17Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseOption.java", "diffHunk": "@@ -252,6 +257,9 @@ public double getAmphibEfficiency(\n   }\n \n   private double calculateLandDistanceFactor(final int enemyDistance) {\n+    if (movement <= 0) {\n+      return 0.1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTAwMQ==", "bodyText": "It's a bit difficult to follow this line. An intermediate variable maybe would help, or adding a Matches for 'notConstruction' to avoid the negate. Have you considered unit testing this method to help document and verify it?", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368255001", "createdAt": "2020-01-18T23:44:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseTerritory.java", "diffHunk": "@@ -64,7 +65,8 @@ public ProPurchaseTerritory(\n   public int getRemainingUnitProduction() {\n     int remainingUnitProduction = unitProduction;\n     for (final ProPlaceTerritory ppt : canPlaceTerritories) {\n-      remainingUnitProduction -= ppt.getPlaceUnits().size();\n+      remainingUnitProduction -=\n+          CollectionUtils.countMatches(ppt.getPlaceUnits(), Matches.unitIsConstruction().negate());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTA1Mg==", "bodyText": "Is this comment here because it has to be? I wonder as ValidationUtils seems to be more specific than the comment implies. Second, have you considered using @UtilityClass to avoid the private constructor?", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368255052", "createdAt": "2020-01-18T23:46:26Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f9eb955db7a1408e41159d845ac1378087ae938", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/7f9eb955db7a1408e41159d845ac1378087ae938", "committedDate": "2020-01-19T06:56:28Z", "message": "Various minor refactoring improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTgxMDk1", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-344981095", "createdAt": "2020-01-19T06:58:03Z", "commit": {"oid": "7f9eb955db7a1408e41159d845ac1378087ae938"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNjo1ODowM1rOFfNdHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQwNjo1ODowM1rOFfNdHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDYyMA==", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270620", "createdAt": "2020-01-19T06:58:03Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f9eb955db7a1408e41159d845ac1378087ae938"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTgzOTQy", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-344983942", "createdAt": "2020-01-19T08:01:21Z", "commit": {"oid": "7f9eb955db7a1408e41159d845ac1378087ae938"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c", "committedDate": "2020-01-19T16:37:39Z", "message": "Add comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDEyOTIy", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-345012922", "createdAt": "2020-01-19T16:39:21Z", "commit": {"oid": "c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQxNjozOToyMVrOFfPp1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQxNjozOToyMVrOFfPp1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwNjY0Nw==", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368306647", "createdAt": "2020-01-19T16:39:21Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98031c78fbafe47a991d401ca0b933dce513d444", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/98031c78fbafe47a991d401ca0b933dce513d444", "committedDate": "2020-01-20T01:28:01Z", "message": "Add new constant"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDQ2NDM4", "url": "https://github.com/triplea-game/triplea/pull/5842#pullrequestreview-345046438", "createdAt": "2020-01-20T01:29:48Z", "commit": {"oid": "98031c78fbafe47a991d401ca0b933dce513d444"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwMToyOTo0OFrOFfR1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwMToyOTo0OFrOFfR1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM0MjM1Ng==", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368342356", "createdAt": "2020-01-20T01:29:48Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98031c78fbafe47a991d401ca0b933dce513d444"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3752, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}