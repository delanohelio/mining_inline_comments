{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MjcxMzg0", "number": 8289, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTowODozNlrOE-VLLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo1Nzo0NVrOE-bnSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzk0MDk0OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTowODozNlrOH7eaxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToxNjowNFrOH7ec9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjQwNQ==", "bodyText": "Please rename Matches.alwaysBi(). I had a lot of trouble reading that at first, it was not clear what it meant (even the type being passed was not clear, so it looked like 'Bi' was an abbreviation for something').\nThe implementation for an always true bi-predicate is kinda trivial, I'm not sure we really need a matches for it and can just inline it. I don't think we should be encouraging usages of tautology functions by having it be in Matches. A tautology funtion makes methods look a lot more complex then they actually are.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532126405", "createdAt": "2020-11-29T01:08:36Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -104,6 +104,11 @@ public Territory getTerritory(final String s) {\n     return neighbors;\n   }\n \n+  public Set<Territory> getNeighbors(\n+      final Territory territory, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, cond, Matches.alwaysBi());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20850d8f76e16a5d384ecbca5a030e3e7cc14e0c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjYyNg==", "bodyText": "@DanVanAtta, do you also want to get rid of Matches.always().  I thought that it would be better to have something similar for a bi-predicate.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532126626", "createdAt": "2020-11-29T01:11:13Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -104,6 +104,11 @@ public Territory getTerritory(final String s) {\n     return neighbors;\n   }\n \n+  public Set<Territory> getNeighbors(\n+      final Territory territory, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, cond, Matches.alwaysBi());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjQwNQ=="}, "originalCommit": {"oid": "20850d8f76e16a5d384ecbca5a030e3e7cc14e0c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjk2NA==", "bodyText": "Thanks for asking - Matches.always() might not be best to inline just yet. Eventually perhaps. Hiding the always true predicate in the implementation class I think is the thing to do. If we can, also hide additional predicates in that class so the callers are just invoking a function and not passing in a predicate. The predicate object is a bit too low level. Consider for example using a method that iterates over territories and requires a predicate, you really have to look at the implementation details to understand what the predicate is going to do exactly. Then if we change that implementation all of the expectations of the callers are broken. I think it's an example of relatively tight coupling and lack of information hiding.\nTL;DR - simple inlining of Matches.always() could do more harm than good if it is used pervasively. Instead we should seek to first hide as much of the predicate logic in the implementation code to the point where the predicate is an implementation detail, at that time inlining it is likely appropriate.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532126964", "createdAt": "2020-11-29T01:16:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -104,6 +104,11 @@ public Territory getTerritory(final String s) {\n     return neighbors;\n   }\n \n+  public Set<Territory> getNeighbors(\n+      final Territory territory, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, cond, Matches.alwaysBi());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjQwNQ=="}, "originalCommit": {"oid": "20850d8f76e16a5d384ecbca5a030e3e7cc14e0c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzk0MzkxOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/move/validation/MoveValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToxMjozNlrOH7ecDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToyNzo1MVrOH7egzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjczMg==", "bodyText": "Just noticed, when is the units value null? Generally an empty collection is preferred rather than a null.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532126732", "createdAt": "2020-11-29T01:12:36Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/move/validation/MoveValidator.java", "diffHunk": "@@ -278,13 +279,13 @@ private MoveValidationResult validateCanal(\n    * @param units (Can be null. If null we will assume all units would be stopped by the canal.)\n    */\n   public String validateCanal(\n-      final Route route, final Collection<Unit> units, final GamePlayer player) {\n+      final Route route, @Nullable final Collection<Unit> units, final GamePlayer player) {\n     return validateCanal(route, units, new HashMap<>(), player);\n   }\n \n   String validateCanal(\n       final Route route,\n-      final Collection<Unit> units,\n+      @Nullable final Collection<Unit> units,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjkxNw==", "bodyText": "I don't know.  But one of the callers to this method has it flagged as @Nullable so I flagged this one as well since the caller can pass a null value.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532126917", "createdAt": "2020-11-29T01:15:16Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/move/validation/MoveValidator.java", "diffHunk": "@@ -278,13 +279,13 @@ private MoveValidationResult validateCanal(\n    * @param units (Can be null. If null we will assume all units would be stopped by the canal.)\n    */\n   public String validateCanal(\n-      final Route route, final Collection<Unit> units, final GamePlayer player) {\n+      final Route route, @Nullable final Collection<Unit> units, final GamePlayer player) {\n     return validateCanal(route, units, new HashMap<>(), player);\n   }\n \n   String validateCanal(\n       final Route route,\n-      final Collection<Unit> units,\n+      @Nullable final Collection<Unit> units,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjczMg=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzk1MQ==", "bodyText": "Fair enough, it is better safe than sorry.  \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532127951", "createdAt": "2020-11-29T01:27:51Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/move/validation/MoveValidator.java", "diffHunk": "@@ -278,13 +279,13 @@ private MoveValidationResult validateCanal(\n    * @param units (Can be null. If null we will assume all units would be stopped by the canal.)\n    */\n   public String validateCanal(\n-      final Route route, final Collection<Unit> units, final GamePlayer player) {\n+      final Route route, @Nullable final Collection<Unit> units, final GamePlayer player) {\n     return validateCanal(route, units, new HashMap<>(), player);\n   }\n \n   String validateCanal(\n       final Route route,\n-      final Collection<Unit> units,\n+      @Nullable final Collection<Unit> units,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjczMg=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODk3ODA4OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTozODozNVrOH7mUKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo0MDoyOVrOH7mVKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NTc4Ng==", "bodyText": "Nit - This parameter is now the 'territoryCondition', correct? Would you have any objection to rename it?\nNow that there are two parameters, making the names distinct is more significant as one wonders how the 'cond' and 'routeCond' are different. Secondly, 'cond' was not the best name to begin with as it was cryptic and did not describe what the condition represented or was used for.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532255786", "createdAt": "2020-11-29T19:38:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -103,15 +104,24 @@ public Territory getTerritory(final String s) {\n     return neighbors;\n   }\n \n+  public Set<Territory> getNeighbors(\n+      final Territory territory, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, cond, (it, it2) -> true);\n+  }\n+\n   /**\n    * Returns all adjacent neighbors of the starting territory that match the condition. Does NOT\n    * include the original/starting territory in the returned Set.\n    */\n-  public Set<Territory> getNeighbors(final Territory territory, final Predicate<Territory> cond) {\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      @Nullable final Predicate<Territory> cond,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NjA0Mg==", "bodyText": "It looks like this method is only called internally to GameMap now as well, if I have that right - we can reduce the visibility to private. Would you mind doing so?", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532256042", "createdAt": "2020-11-29T19:40:29Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -103,15 +104,24 @@ public Territory getTerritory(final String s) {\n     return neighbors;\n   }\n \n+  public Set<Territory> getNeighbors(\n+      final Territory territory, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, cond, (it, it2) -> true);\n+  }\n+\n   /**\n    * Returns all adjacent neighbors of the starting territory that match the condition. Does NOT\n    * include the original/starting territory in the returned Set.\n    */\n-  public Set<Territory> getNeighbors(final Territory territory, final Predicate<Territory> cond) {\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      @Nullable final Predicate<Territory> cond,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NTc4Ng=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODk4MjUwOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo0Mjo0MFrOH7mWIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo0Mjo0MFrOH7mWIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NjI5MQ==", "bodyText": "This javadoc perhaps could be better. What kind of check are we doing? What is the signifcance of the check?\nSuggestion: reword to something like:  \"distance All returned territories will be within the max distance from the starting territory. 0 represents the starting territory and no adjacencies, 1 is all immediately adjacent territories.\"", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532256291", "createdAt": "2020-11-29T19:42:40Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODk4NTU3OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo0NjoxOFrOH7mXkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo0NjoxOFrOH7mXkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NjY1OQ==", "bodyText": "Side-note, the getNeighbors code is largely only used by AI. It's something for us to consider as every logical graph operation involving the map does not scale if it's all found within GameMap. My thoughts are a Territory object having a collection of neighbors would help avoid the need to get all data from GameMap, and then also the AI code could have the path finding algorithms localized in the AI packages.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532256659", "createdAt": "2020-11-29T19:46:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODk5MzkxOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo1NToyMlrOH7mbkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNjoxNzo1MFrOH8ZoOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA==", "bodyText": "Thank you for the previous cleanups, it's now clear that either cond is used with an always true bi-predicate (route condition), or if the bi-predicate is used then it is always with these two conditions:\n                ProMatches.territoryCanPotentiallyMoveLandUnits(player, data.getProperties()),\n                ProMatches.noCanalsBetweenTerritories(player, data));\n\nI think there are some issues here:\n\nDRY violation, the idea of how to calculate land-passable territories without canal is derived in two different places (happily the matching logic is in one spot, but still it's indirect to go from a matcher to a method call to actually getting the neighbors).\nMakes for a difficult API to use. I don't think it's very fluent to look up a matcher and seems confusing to keep straight the difference between a route and territory condition. We also have a number of overloads which makes a person wonder how they should get neighbors if that is what they are trying to do.\n\nWhat do you think we created an API that could hide the two predicates from callers?\nThe signature would be something like:\nSet<Territory> getLandTraversableNeighbors(\n      final Territory territory,\n      final int distance);\n\nThen in the javadoc we could define what is meant by land-traversable. Or we could call the method getNonCanalLandTraversableNeighbors if we feel the canal aspect is distinct enough to need to be in the method name.\nI would agree that having ProMatches in GameMap is bad, though I think we are already there indirectly by having entire methods (like this and similar) be in GameMap only to support AI. As noted earlier, the entire method likely ought to be picked up and moved to AI specific code.\nOtherwise, WDYT?\nSuch a move should hopefully make the method overloads easier to use, reduce the API surface, reduce the number of parameters (which makes it more testable!), and just easier to understand how to use these methods.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532257680", "createdAt": "2020-11-29T19:55:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMyNzY2Ng==", "bodyText": "The idea sounds good but I'd rather not do it as part of this PR.  I think these types of changes need to be done after looking into all of the usages of getNeighbor.  I also think the canals check that I added probably needs to be used in more places than just these few places that I found.  It might turn out that it needs to be in all places that call getNeighbor with a territoryCondition.  But I'm not positive about it because of the size and scope of the AI code and my limited knowledge of its inner workings.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532327666", "createdAt": "2020-11-30T03:20:31Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0MDU5OQ==", "bodyText": "I don't understand something. The checks  you added, the bi-predict, you have injected them from what is clearly AI code. What I'm suggesting to do is instead change the method the AI code calls and have the bi-predicates live in GameMap. That should not change the surface area of what you have updated and if there are other places that need to invoke the same logic it would also in turn invoke the new method on GameMap and would not duplicate the same Bi-predicates.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532340599", "createdAt": "2020-11-30T04:22:02Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk4Nzg5Nw==", "bodyText": "I think it is premature to start trying to define the API in a different manner than how it is right now.  Yes, the existing API isn't that great but adding additional API points that are completely different will just make it even more confusing.  The API currently accepts conditions on the territories so adding a new parameter that is also a condition check isn't much different.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532987897", "createdAt": "2020-12-01T00:14:45Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2MjE3Nw==", "bodyText": "I think we can do better than adding a parameter to an existing API. I disagree it is premature at all. We are setting a pattern. If another developer were to look at what is done here, \"I need more functionality in this method - okay, add a parameter that only one part of the code uses and the rest will just pass a no-op value.\" Rinse-wash-repeat, and then eventually the concern of having too many params arise and the response is \"the code was already like that, fixing all usages is out of scope, it is consistent to just add another parameter.\" Hence, I would say it's premature to add a parameter that make the method prematurely generic.\nI don't see what it is a big change to encapsulate the match condition with the getNeighbor method. As-is, I think we violate DRY (which is about expressing an idea in one place, less about removing all duplicate patterns). Currently the neighbor logic is spread between match conditions only used for getNeighbor, the caller that invokes the method with the right parameter bindings, and then the logic in GameMap. Which is where the pattern is not a good one to follow, what if someone were to use this new public method API and pass in another match condition? It'd be an even worse situation, rather than the pattern to encapsulate the getNeighbor logic to one place.\nThough again, I think we can do better than having a 4 param method and just add another method. We are debating so far between adding a 4 arg public method vs a 2 arg public method. The latter is readily tested, the former would likely involve heavy mocking and likely would not test very much. The heuristic of \"can this be reasonably tested\" I think fails when we consider almost any 4 arg method, this is an example I believe.\nFor more consideration, a predicate can be expressed as a bi-predicate, so we could keep the predicate logic all in the caller and add just one new API. EG:\npublic void predicateMethod(Predicate<Territory> territoryPredicate) {\n   biPredicateMethod((start, end) -> territoryPredicate.apply(end));\n}\n\npublic void biPredicateMethod(BiPredicate<Territory, Territory> routePredicate) {\n   ///   \n}", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533062177", "createdAt": "2020-12-01T04:15:48Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2MzEyOA==", "bodyText": "I'll close this then since it doesn't appear to be the correct fix for the issue.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533063128", "createdAt": "2020-12-01T04:19:42Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3NzczMw==", "bodyText": "If you want to work on it, go ahead.  I'm not going to do much else with it.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533077733", "createdAt": "2020-12-01T05:14:13Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3ODY4Mg==", "bodyText": "Given the testing statement there is a fix here and that is very valuable.\n\"Correct\" design is in the eye of the beholder and depends on future events that nobody can know, we can only implement the best design that we see for current and expected future circumstances given a favorable ROI.\nAre you going to pursue this fix any further @trevan ?", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533078682", "createdAt": "2020-12-01T05:17:38Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3OTM1Mg==", "bodyText": "@DanVanAtta , at this point, I'm not going to pursue any more here.  I'd love to get a more in-depth understanding of the AI code but the battle code is plenty big at this point in time.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533079352", "createdAt": "2020-12-01T05:20:11Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4MTQyNQ==", "bodyText": "@trevan , just saw your last comment. That answers my question.\nIt appears you have lost patience for this update & process. I'm disappointed we have reached that point.\nLet's be direct when we can to avoid any misconception. It's okay to say \"no, those design changes are difficult and involved. I'm not sure the updates suggested can cleanly land, feel free to take a stab by adding a commit to this branch.\"\nAlready at a cursory glance, we are dealing with a mess:", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533081425", "createdAt": "2020-12-01T05:27:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5NjUwNg==", "bodyText": "The AI code is an interesting beast!  I think that code belongs in a sub-project, and then ideally we could push a ton of supporting logic into that sub-project as well. I think that would clean up the core game-engine (game-core) considerably.\nFor example, WeakAI would be removed but it is injected as a dummy player into the battle logic. Keep an eye out for that, if you can sever the WeakAI from the OOL & battle logic & battle calculator, then we could drop that AI completely.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r533096506", "createdAt": "2020-12-01T06:17:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -127,19 +137,41 @@ public Territory getTerritory(final String s) {\n   /**\n    * Returns all neighbors within a certain distance of the starting territory that match the\n    * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n    */\n   public Set<Territory> getNeighbors(\n-      final Territory territory, final int distance, final Predicate<Territory> cond) {\n+      final Territory territory, final int distance, @Nullable final Predicate<Territory> cond) {\n+    return getNeighbors(territory, distance, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns all neighbors within a certain distance of the starting territory that match the\n+   * condition. Does NOT include the original/starting territory in the returned Set.\n+   *\n+   * @param territory starting territory\n+   * @param distance distance to check\n+   * @param cond the neighbor territory must match this condition\n+   * @param routeCond the route between the starting territory and the neighbor territory must match\n+   *     this condition\n+   */\n+  public Set<Territory> getNeighbors(\n+      final Territory territory,\n+      final int distance,\n+      @Nullable final Predicate<Territory> cond,\n+      final BiPredicate<Territory, Territory> routeCond) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1NzY4MA=="}, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODk5NTk1OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo1Nzo0NVrOH7mcmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxOTo1Nzo0NVrOH7mcmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI1Nzk0NA==", "bodyText": "Similar comment to this method, it's either invoked with a no-op arg or the arg is always:\n                  ProMatches.territoryCanPotentiallyMoveLandUnits(player, data.getProperties()),\n                  ProMatches.noCanalsBetweenTerritories(player, data));\n\nThat hints that we could use another method rather than it need to be parameterized as part of the public API.", "url": "https://github.com/triplea-game/triplea/pull/8289#discussion_r532257944", "createdAt": "2020-11-29T19:57:45Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameMap.java", "diffHunk": "@@ -317,10 +355,27 @@ public int getDistance(final Territory t1, final Territory t2) {\n    * @param cond condition that covered territories of the route must match\n    */\n   public int getDistance(final Territory t1, final Territory t2, final Predicate<Territory> cond) {\n+    return getDistance(t1, t2, cond, (it, it2) -> true);\n+  }\n+\n+  /**\n+   * Returns the distance between two territories where the covered territories of the route satisfy\n+   * the condition or -1 if they are not connected.\n+   *\n+   * @param t1 start territory of the route\n+   * @param t2 end territory of the route\n+   * @param cond condition that covered territories of the route must match\n+   * @param routeCond condition that routes between neighboring territories must match\n+   */\n+  public int getDistance(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7befed3ddb61344407847c2f66caa58af2a9ce35"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2605, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}