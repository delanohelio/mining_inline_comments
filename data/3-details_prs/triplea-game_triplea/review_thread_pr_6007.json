{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MTEyNDc1", "number": 6007, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowODoxMVrODljA0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDoxNDoxOVrODlz2mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjk3NTU1OnYy", "diffSide": "RIGHT", "path": "java-extras/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowODoxMVrOFygQWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjoyNjowM1rOFyuTgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMTU5NA==", "bodyText": "We usually use the single string notation where the different parts are separated with a colon + we have all the version numbers in the main build.gradle file", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388501594", "createdAt": "2020-03-05T19:08:11Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/build.gradle", "diffHunk": "@@ -1,5 +1,8 @@\n description = 'TripleA library for low-level helper APIs, ie: syntactic sugar'\n \n dependencies {\n+    // https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine\n+    compile group: 'com.github.ben-manes.caffeine', name: 'caffeine', version: '2.8.1'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczMTc3OA==", "bodyText": "I realized late last night while going to bed that I forgot to update this (should have done a better self-review of this PR as well). I was waiting for this comment \ud83d\ude01\nUpdated:  5435f8a", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388731778", "createdAt": "2020-03-06T06:26:03Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/build.gradle", "diffHunk": "@@ -1,5 +1,8 @@\n description = 'TripleA library for low-level helper APIs, ie: syntactic sugar'\n \n dependencies {\n+    // https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine\n+    compile group: 'com.github.ben-manes.caffeine', name: 'caffeine', version: '2.8.1'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMTU5NA=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjk5NDYzOnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxMzowN1rOFygbyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjozMTo0MVrOFyuYiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg==", "bodyText": "What about using BiConsumer instead?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388504522", "createdAt": "2020-03-05T19:13:07Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMTk5NA==", "bodyText": "Just had a look at the caffeine documentation because I thought the explicit casting was weird.\nYou can avoid (I'm 99% sure) the unchecked warning by using\n.<IdT, ValueT>removalListener((key, value, cause) -> {});\nInstead", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388511994", "createdAt": "2020-03-05T19:25:44Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNzY3Mg==", "bodyText": "You could declare the types on the lambda parameters instead,\n.removalListener((IdT key, ValueT value, RemovalCause cause) -> {});", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388527672", "createdAt": "2020-03-05T19:54:22Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczMzA2NQ==", "bodyText": "Good suggestions, thank you - both work. I was struggling to find the right variant. Slightly leaning towards types on the lambda parameters, updated: 1de5679", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388733065", "createdAt": "2020-03-06T06:31:41Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzAwMTM0OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxNTowOVrOFyggLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOToyMjoxMlrOFzEdbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw==", "bodyText": "Maybe I'm missing something, but why is removalListener called explicitly here?\nShouldn't invalidate trigger the listener by itself already?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388505647", "createdAt": "2020-03-05T19:15:09Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyODI5Mw==", "bodyText": "yes. Even if not, you can use asMap().remove(id) to remove the entry and obtain the old value atomically.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388528293", "createdAt": "2020-03-05T19:55:35Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODAxOQ==", "bodyText": "For better or worse, the explicit removal is to avoid any timing issues or non-determinism in test. If we do not have the explicit remove, then this test:\nhttps://github.com/triplea-game/triplea/pull/6007/files#diff-9e70eb2aee6299a62f6edd3626506959R148, updated to be repeated 1000 times will consistently have some failures, eg:\n    @RepeatedTest(1000)\n    void removalListenerIsInvokedWhenItemsAreInvalidated() {\n      realCache.put(\"id10\", 0);\n      realCache.invalidate(\"id10\");\n\n      verify(cacheRemovalListener, atLeastOnce()).accept(new CacheEntry<>(\"id10\", 0));\n    }\n\nWrapping an external API behind an interface can often be good to insulate our code from 3rd party, as a general practice, in large part it is done here with implementation so we can have a \"native\" API and reliable calls to 'removal listener'. That was what kinda kicked this whole thing off, the naive addition of removal listener to the guava cache simply did not work..\nGrant it, with a reliable scheduler, which I think we have, we should get reliable calls to removal listener. With that being said, having no delay for removed item notification and perfectly deterministic testing is IMO worth the cost of potentially having multiple calls to a removal listener.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738019", "createdAt": "2020-03-06T06:51:33Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODEyMg==", "bodyText": "@ben-manes good suggestion, I did not realize 'asMap' would modify the underlying cache. Updated: fa933b3", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738122", "createdAt": "2020-03-06T06:52:01Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMjMzNA==", "bodyText": "@DanVanAtta If it's only the tests, then we could make the test wait until ForkJoinPool.commonPool() processed all events (I had a look at the source code), or alternatively just pass a custom executor for the test cases which simply runs the specified Runnable", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388922334", "createdAt": "2020-03-06T14:10:06Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NDc2Ng==", "bodyText": "Reasonable suggestions, though I think sticking with the explicit notification is okay:\n\nin our context we handle duplicate calls already (at least we should be!). Having a contract that allows for duplicate callbacks seems okay in general as well (and if not then there is room for other implementations to change that).\nthe test is already a bit slow at 700ms. Doing a join could mean we wait for the scheduled cleanup job which could add a second\na join in the test would turn the test from mostly if not entirely a black box test into a white box test. Tests that do not rely on internal implementations tend to be easier to understand and maintain\n\nA custom executor would also fall under the category of test scaffolding, it's better minimized. At the end of the day we also get benefit from an immediate callback, which does make the UI seem more responsive as games are removed nearly immediately and not after a small delay.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389094766", "createdAt": "2020-03-06T19:22:12Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA1NDc0OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyOToyMlrOFyhBCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjo0MTowMlrOFyuhKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw==", "bodyText": "what's the reason this task has a random id attached to it?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388514057", "createdAt": "2020-03-05T19:29:22Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMDU3Mw==", "bodyText": "You can use Caffeine.scheduler to do this for you, too! If you are on JDK9+ then it can leverage the JVM-wide thread (internal to CompletableFuture), or else you can either supply a ScheduledExecutorService or your own implementation.\nCaffeine.newBuilder()\n    .expireAfterWrite(duration, timeUnit)\n    .scheduler(Scheduler.systemScheduler())\n...", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388530573", "createdAt": "2020-03-05T19:59:44Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczNTI3NA==", "bodyText": "@RoiEXLab the random id was so that in case we had multiple caches, the cleanup threads would be given different names. Admittedly, probably over-engineering on my part.\n@ben-manes, thank you for the suggestion, works like a charm \ud83d\udc4d\nI particularly like how we no longer have to clean up the timer thread that was scheduled here, it simplifies a good bit. Updated in: 5eeb317", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388735274", "createdAt": "2020-03-06T06:41:02Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE2MjAwOnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMTowM1rOFyiEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowMzo0NFrOFyu4bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ==", "bodyText": "Atomically,\nreturn Optional.ofNullable(cache.asMap().replace(id, newValue));", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388531241", "createdAt": "2020-03-05T20:01:03Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.triplea.java.cache;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import lombok.Value;\n+\n+public interface TtlCache<IdT, ValueT> {\n+\n+  /**\n+   * Extends the 'life' of a given entry and prevents cache expiration for another TTL. Returns true\n+   * if an element existed and was refreshed, returns false if no such element existed.\n+   */\n+  boolean refresh(IdT id);\n+\n+  /** Retrieves a value from the cache, if any. */\n+  Optional<ValueT> get(IdT id);\n+\n+  /** Places a new item in the cache, overwriting any values with the existing ID. */\n+  void put(IdT id, ValueT value);\n+\n+  /** Explicitly removes an item from cache, returns any such value that was removed. */\n+  Optional<ValueT> invalidate(IdT id);\n+\n+  /**\n+   * Places a new item in the cache if one existed with the same ID and replaces the existing value.\n+   * The replaced item is returned, otherwise returns an empty.\n+   */\n+  default Optional<ValueT> replace(IdT id, ValueT newValue) {\n+    final Optional<ValueT> value = get(id);\n+    if (value.isPresent()) {\n+      put(id, newValue);\n+    }\n+    return value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTIyOQ==", "bodyText": "Seems simpler, atomic is better - thank you for the suggestion! Updated: 08d724e", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388741229", "createdAt": "2020-03-06T07:03:44Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.triplea.java.cache;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import lombok.Value;\n+\n+public interface TtlCache<IdT, ValueT> {\n+\n+  /**\n+   * Extends the 'life' of a given entry and prevents cache expiration for another TTL. Returns true\n+   * if an element existed and was refreshed, returns false if no such element existed.\n+   */\n+  boolean refresh(IdT id);\n+\n+  /** Retrieves a value from the cache, if any. */\n+  Optional<ValueT> get(IdT id);\n+\n+  /** Places a new item in the cache, overwriting any values with the existing ID. */\n+  void put(IdT id, ValueT value);\n+\n+  /** Explicitly removes an item from cache, returns any such value that was removed. */\n+  Optional<ValueT> invalidate(IdT id);\n+\n+  /**\n+   * Places a new item in the cache if one existed with the same ID and replaces the existing value.\n+   * The replaced item is returned, otherwise returns an empty.\n+   */\n+  default Optional<ValueT> replace(IdT id, ValueT newValue) {\n+    final Optional<ValueT> value = get(id);\n+    if (value.isPresent()) {\n+      put(id, newValue);\n+    }\n+    return value;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODUzODA4OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjo1NzoyOVrOFyuyDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTozNzoxOFrOFzE4-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ==", "bodyText": "@RoiEXLab FWIW, this is one place where guava kinda seemed to fall short, eg (below is demonstrate the explicit cast):\n  public Map<IdT, ValueT> asMap() {\n    Map<IdT, ValueT> map = (ConcurrentMap<IdT, ValueT>) CacheBuilder.newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388739599", "createdAt": "2020-03-06T06:57:29Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMzE0Nw==", "bodyText": "I think the way it's supposed to be done is by doing something like:\nMap<IdT, ValueT> map = CacheBuilder.<IdT, ValueT>newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();\ninstead, but ok", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388923147", "createdAt": "2020-03-06T14:11:31Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NjQxMQ==", "bodyText": "Even that variant does not work, you get a type cast exception where ConcurrentMap<Object,Object> is not compatible. \ud83d\ude01", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389096411", "createdAt": "2020-03-06T19:25:36Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMTgxOQ==", "bodyText": "Yes, the builder inference in both APIs is meant for the cache type. You have two options,\nMap<IdT, ValueT> map = CacheBuilder.newBuilder().<IdT, ValueT>build().asMap();\n\nCache<IdT, ValueT> cache = CacheBuilder.newBuilder().build();\nMap<IdT, ValueT> map = cache.asMap();", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389101819", "createdAt": "2020-03-06T19:37:18Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTczNDY0OnYy", "diffSide": "RIGHT", "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDoxNDoxOVrOFy6FCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjozMToyN1rOFzJZjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ==", "bodyText": "Thinking about my suggestion that passes a custom executor for the tests: This particular tests would gain some extra safety, because in case the removalListener is executed asynchronously, the tests might check too early missing this critical error.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388924681", "createdAt": "2020-03-06T14:14:19Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODA4Mw==", "bodyText": "Agree the test could miss the timing. In practice this won't be a problem, there is a trade-off here between a slow test and more thorough test. Adding a second long delay would be the thing to do, and/or making the cache scheduler really aggressive.\nI double checked with a timeout and many repeated tests, as expected the test stays solid which is the most important thing. At this point I'm happy leaving the test to be more behavior documentation/spec than full-proof.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389098083", "createdAt": "2020-03-06T19:29:17Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMzUyNg==", "bodyText": "Another approach than specifying a direct executor is to use a testing library like Awaitility.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389103526", "createdAt": "2020-03-06T19:39:23Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NTY5NA==", "bodyText": "Really what we are testing is the if condition here: https://github.com/triplea-game/triplea/pull/6007/files#diff-bd3a571488048aa02a100236fc5d8a77R33\n            .removalListener(\n                (IdT key, ValueT value, RemovalCause cause) -> {\n                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n                    removalListener.accept(key, value);\n                  }\n\nMockito 'verify' has a timeout function, so it would be straightforward to add the delay. The issue is that we are testing the absence of a call, so we'd always hit the timeout making this a very slow test.\nIMO the best way to test probably would be to inject the filter logic, test the filter, and then trust that the library code does call the filter on remove listener.\nI'm leaning towards keeping this test as is:\n\ninjecting modules is at danger of over-engineering\nthe ROI of a slow but more thorough test is not favorable. We're already close to testing pure library code", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389175694", "createdAt": "2020-03-06T22:31:27Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2507, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}