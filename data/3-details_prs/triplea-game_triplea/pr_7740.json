{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxNTA4Nzc1", "number": 7740, "title": "Replace amphibiousLandAttackers list with checks for wasAmphibious", "bodyText": "As far as I can tell, the amphibiousLandAttackers should function almost identically to the wasAmphibious property.  It looks like wasAmphibious is only added when a unit is unloaded from a sea based transport.  I tested with land, sea, and air based transports in Iron War to check.\nIn the battle calculator, it would just set all of the attackers as amphibiousLandAttackers, so I replicated that behavior by setting wasAmphibious to all of the units.  It appears to work correctly.\nThere might be some small difference in behavior but I can't find one yet.  If there is a way to move a land unit from a sea territory without using a sea transport, then that would could cause a difference.\nTesting\n\nTested with land, sea, and air transports to make sure wasAmphibious is set only during sea transports.\nTested that the amphibious checkbox in the battle calculator updates wasAmphibious correctly.\nRan an amphibious battle and ensured that things were calculated correctly during the battle.\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note", "createdAt": "2020-09-23T04:30:43Z", "url": "https://github.com/triplea-game/triplea/pull/7740", "merged": true, "mergeCommit": {"oid": "f67428744342185fbf09a729009c81b8023a2110"}, "closed": true, "closedAt": "2020-09-25T03:00:14Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLilnwAH2gAyNDkxNTA4Nzc1OjY5MjlmODc2YmU5MDEzNzhlYWMzN2Y0NDk5NGEwYzZlMTNiMDMxYmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMMzpcAFqTQ5NjA3ODk1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/6929f876be901378eac37f44994a0c6e13b031bf", "committedDate": "2020-09-23T01:48:16Z", "message": "Replace amphibiousLandAttackers list with checks for wasAmphibious"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0MDU1NjE1", "url": "https://github.com/triplea-game/triplea/pull/7740#pullrequestreview-494055615", "createdAt": "2020-09-23T04:31:34Z", "commit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDozMTozNFrOHWV-hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDozMTozNFrOHWV-hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDc5MA==", "bodyText": "I have this code duplicated several times.  If you have any suggestions on how to shrink it, I'd love to know.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493190790", "createdAt": "2020-09-23T04:31:34Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculator.java", "diffHunk": "@@ -103,11 +103,25 @@ public AggregateResults calculate(\n         final MustFightBattle battle =\n             new MustFightBattle(location2, attacker2, gameData, battleTracker);\n         battle.setHeadless(true);\n+        if (amphibious) {\n+          attackingUnits.forEach(\n+              unit -> {\n+                unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0MDk1Njgx", "url": "https://github.com/triplea-game/triplea/pull/7740#pullrequestreview-494095681", "createdAt": "2020-09-23T04:58:03Z", "commit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDo1ODowM1rOHWWYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNTowNToyNVrOHWWgMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzQzNA==", "bodyText": "Are game clients getting all of the battle parameters from their local state? Is it this method that feeds the parameters to the remote clients?\nLooking at this param list, it looks like this is what is used for calculating supports. The supports are used when calculating order of loss.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493197434", "createdAt": "2020-09-23T04:58:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/display/IDisplay.java", "diffHunk": "@@ -54,6 +55,8 @@ void reportMessageToPlayers(\n    * @param attacker - PlayerId of attacker\n    * @param defender - PlayerId of defender\n    */\n+  @RemoveOnNextMajorRelease(\n+      \"Remove isAmphibious, amphibiousLandAttackers, dependentUnits, and battleTitle\")\n   @RemoteActionCode(12)\n   void showBattle(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng==", "bodyText": "Have you tested if marines are being given an amphib assault bonus on standard land battles? I'd double check that looking at this update. Have you run across where 'getWasAmphibious' is set to true (could you point me there)?", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493198666", "createdAt": "2020-09-23T05:02:41Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/DiceRoll.java", "diffHunk": "@@ -803,7 +797,7 @@ public static DiceRoll rollNDice(\n                 UnitSupportAttachment::getStrength);\n       } else {\n         strength = ua.getAttack(unit.getOwner());\n-        if (ua.getIsMarine() != 0 && isAmphibiousBattle && amphibiousLandAttackers.contains(unit)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTAxMA==", "bodyText": "This is a suspect I believe for save game compatibility issues. Have you double checked that this field is not serialized?", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199010", "createdAt": "2020-09-23T05:04:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AbstractBattle.java", "diffHunk": "@@ -57,7 +57,6 @@\n \n   List<Unit> attackingUnits = new ArrayList<>();\n   List<Unit> defendingUnits = new ArrayList<>();\n-  List<Unit> amphibiousLandAttackers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTE1Nw==", "bodyText": "Does the list need to be modifiable? If not, List.of() is the conventional preference for empty lists.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199157", "createdAt": "2020-09-23T05:04:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -705,7 +705,6 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n                       defendingUnits,\n                       attackingUnits,\n                       false,\n-                      new ArrayList<>(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTQxMA==", "bodyText": "WDYT of using an enum here to represent the different battle states? It would be purely for a more descriptive API", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199410", "createdAt": "2020-09-23T05:05:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -145,14 +145,13 @@ public void setUnits(\n       final Collection<Unit> defending,\n       final Collection<Unit> attacking,\n       final Collection<Unit> bombarding,\n-      final Collection<Unit> amphibious,\n+      final boolean amphibious,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6929f876be901378eac37f44994a0c6e13b031bf"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38356cc9eb6ca1f079605742365bafb51fa569ea", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/38356cc9eb6ca1f079605742365bafb51fa569ea", "committedDate": "2020-09-23T14:27:21Z", "message": "Re-add class fields that might affect serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/a694383eb8354a4f03a96fb11f016bed20ac02ac", "committedDate": "2020-09-23T23:15:12Z", "message": "Deprecate most usage of amphibious member of AbstractBattle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTE2NTE5", "url": "https://github.com/triplea-game/triplea/pull/7740#pullrequestreview-495116519", "createdAt": "2020-09-23T23:23:57Z", "commit": {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMzoyMzo1N1rOHXEX1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMzoyODoyNlrOHXEdXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MDkzNA==", "bodyText": "I can't figure out why these sorts (sortPreBattle and sortAmphib) happen here.  I tested battles with them removed and things seemed to work the same.  I think that these methods probably existed before the more complex casualty sorter was built and no one got around to removing them.  I worried about removing them as part of this PR but I think they can be removed.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493950934", "createdAt": "2020-09-23T23:23:57Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -718,17 +709,13 @@ public void fight(final IDelegateBridge bridge) {\n         dependentUnits,\n         attacker,\n         defender,\n-        isAmphibious(),\n+        false,\n         getBattleType(),\n-        amphibiousLandAttackers);\n+        List.of());\n     display.listBattleSteps(battleId, stepStrings);\n     if (!headless) {\n       // take the casualties with least movement first\n-      if (isAmphibious()) {\n-        CasualtySortingUtil.sortAmphib(attackingUnits, amphibiousLandAttackers);\n-      } else {\n-        CasualtySortingUtil.sortPreBattle(attackingUnits);\n-      }\n+      CasualtySortingUtil.sortPreBattle(attackingUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MTg4MQ==", "bodyText": "I first looked at not checking for amphibious here and instead doing the getWasAmphibious check inside of the sorter.  But the sorter only looks at one unit of each type so if a battle had an amphibious marine and a non-amphibious marine, the results could be different depending on which unit was seen first.\nI think the sorter needs to be looked at because, right now, if you have a partial amphibious attack (some marines are amphibious and others aren't), it sorts them as if all of the marines are amphibious.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493951881", "createdAt": "2020-09-23T23:26:51Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtySelector.java", "diffHunk": "@@ -308,11 +298,9 @@ private static void killAmphibiousFirst(final List<Unit> killed, final Collectio\n                 .combatModifiers(\n                     CombatModifiers.builder()\n                         .territoryEffects(territoryEffects)\n-                        .amphibious(amphibious)\n+                        .amphibious(targetsToPickFrom.stream().anyMatch(Unit::getWasAmphibious))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MjM0OQ==", "bodyText": "Before I changed this class, I wrote some unit tests to make sure I understood the logic.  And I got unexpected results.  So, I \"fixed\" the class to match the tests.  Take a look at the tests to see if maybe I have an incorrect assumption on how this is supposed to sort units.\nAlso, as I mentioned earlier, I'm not sure this sort code is even needed.", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493952349", "createdAt": "2020-09-23T23:28:26Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtil.java", "diffHunk": "@@ -10,46 +10,24 @@\n \n @UtilityClass\n public class CasualtySortingUtil {\n-  /**\n-   * In an amphibious assault, sort on who is unloading from transports first as this will allow the\n-   * marines with higher scores to get killed last.\n-   */\n-  public static void sortAmphib(final List<Unit> units, final List<Unit> amphibiousLandAttackers) {\n-    final Comparator<Unit> decreasingMovement =\n-        UnitComparator.getLowestToHighestMovementComparator();\n+  /** In an amphibious assault, sort marines with higher scores last */\n+  public static void sortPreBattle(final List<Unit> units) {\n     units.sort(\n         Comparator.comparing(Unit::getType, Comparator.comparing(UnitType::getName))\n-            .thenComparing(\n-                (u1, u2) -> {\n-                  final UnitAttachment ua = UnitAttachment.get(u1.getType());\n-                  final UnitAttachment ua2 = UnitAttachment.get(u2.getType());\n-                  if (ua.getIsMarine() != 0 && ua2.getIsMarine() != 0) {\n-                    return compareAccordingToAmphibious(u1, u2, amphibiousLandAttackers);\n-                  }\n-                  return 0;\n-                })\n-            .thenComparing(decreasingMovement));\n+            .thenComparing(compareMarines())\n+            .thenComparing(UnitComparator.getLowestToHighestMovementComparator()));\n   }\n \n-  private static int compareAccordingToAmphibious(\n-      final Unit u1, final Unit u2, final List<Unit> amphibiousLandAttackers) {\n-    if (amphibiousLandAttackers.contains(u1) && !amphibiousLandAttackers.contains(u2)) {\n-      return -1;\n-    } else if (amphibiousLandAttackers.contains(u2) && !amphibiousLandAttackers.contains(u1)) {\n-      return 1;\n-    }\n-    final int m1 = UnitAttachment.get(u1.getType()).getIsMarine();\n-    final int m2 = UnitAttachment.get(u2.getType()).getIsMarine();\n-    return m2 - m1;\n-  }\n+  public static Comparator<Unit> compareMarines() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "committedDate": "2020-09-24T01:33:32Z", "message": "Supress unused warnings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MDc4OTUx", "url": "https://github.com/triplea-game/triplea/pull/7740#pullrequestreview-496078951", "createdAt": "2020-09-25T02:58:17Z", "commit": {"oid": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMjo1ODoxOFrOHXzRiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMjo1OTozMFrOHXzSsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTM3MQ==", "bodyText": "nit, have you considered using the collection matcher? IE: IsCollectionContaining", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494719371", "createdAt": "2020-09-25T02:58:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtilTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class CasualtySortingUtilTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GamePlayer player;\n+\n+  @Test\n+  void sortByUnitTypeName() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"B\");\n+    final Unit unitB = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final Unit unitA = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitB, unitA);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitA, unitB)));\n+  }\n+\n+  @Test\n+  void sortByMovement() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    when(unitAttachment1.getMovement(player)).thenReturn(2);\n+    final Unit unitWith2Movement = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Movement = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Movement, unitWith1Movement);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWith1Movement, unitWith2Movement)));\n+  }\n+\n+  @Test\n+  void sortByMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    lenient().when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Marine, unitWith1Marine, unitWithNoMarine);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWithNoMarine, unitWith1Marine, unitWith2Marine)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTY2NA==", "bodyText": "nit, a message on the assertion is desirably for most assertions to explain why we expect an exact condition to be true. Spelling out why we expect a test to be correct is important for maintenance", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494719664", "createdAt": "2020-09-25T02:59:30Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtilTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class CasualtySortingUtilTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GamePlayer player;\n+\n+  @Test\n+  void sortByUnitTypeName() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"B\");\n+    final Unit unitB = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final Unit unitA = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitB, unitA);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitA, unitB)));\n+  }\n+\n+  @Test\n+  void sortByMovement() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    when(unitAttachment1.getMovement(player)).thenReturn(2);\n+    final Unit unitWith2Movement = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Movement = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Movement, unitWith1Movement);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWith1Movement, unitWith2Movement)));\n+  }\n+\n+  @Test\n+  void sortByMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    lenient().when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Marine, unitWith1Marine, unitWithNoMarine);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWithNoMarine, unitWith1Marine, unitWith2Marine)));\n+  }\n+\n+  @Test\n+  void sortByMarineWithNonAmphibiousMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType4 = mock(UnitType.class);\n+    when(unitType4.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment4 = mock(UnitAttachment.class);\n+    // add a little more movement than unitWithNoMarine so it sorts stably.\n+    lenient().when(unitAttachment4.getMovement(player)).thenReturn(2);\n+    lenient().when(unitAttachment4.getIsMarine()).thenReturn(1);\n+    lenient().when(unitType4.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment4);\n+    final Unit unitWith3MarineButNotAmphibious = spy(new Unit(unitType4, player, gameData));\n+    when(unitWith3MarineButNotAmphibious.getWasAmphibious()).thenReturn(false);\n+\n+    final List<Unit> units =\n+        Arrays.asList(\n+            unitWith2Marine, unitWith1Marine, unitWithNoMarine, unitWith3MarineButNotAmphibious);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3942, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}