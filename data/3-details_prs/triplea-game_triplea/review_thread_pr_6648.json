{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwNzkyNTU2", "number": 6648, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoxNzo0OVrOEEY9Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyOTozNFrOEEZN2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDM4NjY2OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoxNzo0OVrOGh-2Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoxNzo0OVrOGh-2Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NTg2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n          \n          \n            \n                return builder(DEFAULT_THREAD_SLEEP);", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438285866", "createdAt": "2020-06-10T17:17:49Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDM5NTk1OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyMDoyMlrOGh-8FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoxNjowN1rOGiKZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzM4MQ==", "bodyText": "Interesting kind of builder pattern. I'm not quite sure if I like it more that the \"typical\" approach, but there are some solid pros to compensate for the cons here", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438287381", "createdAt": "2020-06-10T17:20:22Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;\n+\n+    public Retryable build() {\n+      return new Retryable(threadSleeper, maxAttempts, fixedBackOff, taskRunner);\n+    }\n+\n+    public boolean buildAndExecute() {\n+      return build().execute();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NTAxMg==", "bodyText": "Funny enough, this is the 'classic' builder pattern. As you perhaps can see:\n\nit is type-safe\ncompile time checked (if we add new fields, then you get compiler errors wherever it is missing).\n\nThe lack of compile-time checking is a major criticism of Lombok @Builder.", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438475012", "createdAt": "2020-06-11T00:16:07Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;\n+\n+    public Retryable build() {\n+      return new Retryable(threadSleeper, maxAttempts, fixedBackOff, taskRunner);\n+    }\n+\n+    public boolean buildAndExecute() {\n+      return build().execute();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzM4MQ=="}, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDQxMzYxOnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyNToyN1rOGh_Hsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyMTo1NlrOGiKfCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MDM1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i = 0; i < maxAttempts; i++) {\n          \n          \n            \n                  final Boolean result = taskRunner.get();\n          \n          \n            \n                  if (result != null && result) {\n          \n          \n            \n                    return true;\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  final boolean wasLastAttempt = i + 1 == maxAttempts;\n          \n          \n            \n                  // only sleep if there are more attempts left\n          \n          \n            \n                  if (!wasLastAttempt) {\n          \n          \n            \n                    threadSleeper.accept(fixedBackOff);\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                return false;\n          \n          \n            \n                for (int i = 1; i < maxAttempts; i++) {\n          \n          \n            \n                  if (taskRunner.get()) {\n          \n          \n            \n                    return true;\n          \n          \n            \n                  }\n          \n          \n            \n                  threadSleeper.accept(fixedBackOff);\n          \n          \n            \n                }\n          \n          \n            \n                return taskRunner.get();\n          \n      \n    \n    \n  \n\nIs nicer IMO", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438290354", "createdAt": "2020-06-10T17:25:27Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;\n+\n+    public Retryable build() {\n+      return new Retryable(threadSleeper, maxAttempts, fixedBackOff, taskRunner);\n+    }\n+\n+    public boolean buildAndExecute() {\n+      return build().execute();\n+    }\n+  }\n+\n+  /**\n+   * Executes the retryable task with retries. The result of the task is retried until either:\n+   *\n+   * <ul>\n+   *   <li>The task throws an uncaught exception\n+   *   <li>The task returns false and is max executions reaches max attempts\n+   *   <li>The task returns true\n+   * </ul>\n+   *\n+   * After any failures (the task returns false), the retry mechanism will sleep for the back-off\n+   * period and try again.\n+   */\n+  public boolean execute() {\n+    for (int i = 0; i < maxAttempts; i++) {\n+      final Boolean result = taskRunner.get();\n+      if (result != null && result) {\n+        return true;\n+      }\n+\n+      final boolean wasLastAttempt = i + 1 == maxAttempts;\n+      // only sleep if there are more attempts left\n+      if (!wasLastAttempt) {\n+        threadSleeper.accept(fixedBackOff);\n+      }\n+    }\n+    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjU1NA==", "bodyText": "Slightly more clever but shorter. I think the complexity is about equal, which has me lean to the shorter version you have suggested @RoiEXLab ; thanks \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438476554", "createdAt": "2020-06-11T00:21:56Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;\n+\n+    public Retryable build() {\n+      return new Retryable(threadSleeper, maxAttempts, fixedBackOff, taskRunner);\n+    }\n+\n+    public boolean buildAndExecute() {\n+      return build().execute();\n+    }\n+  }\n+\n+  /**\n+   * Executes the retryable task with retries. The result of the task is retried until either:\n+   *\n+   * <ul>\n+   *   <li>The task throws an uncaught exception\n+   *   <li>The task returns false and is max executions reaches max attempts\n+   *   <li>The task returns true\n+   * </ul>\n+   *\n+   * After any failures (the task returns false), the retry mechanism will sleep for the back-off\n+   * period and try again.\n+   */\n+  public boolean execute() {\n+    for (int i = 0; i < maxAttempts; i++) {\n+      final Boolean result = taskRunner.get();\n+      if (result != null && result) {\n+        return true;\n+      }\n+\n+      final boolean wasLastAttempt = i + 1 == maxAttempts;\n+      // only sleep if there are more attempts left\n+      if (!wasLastAttempt) {\n+        threadSleeper.accept(fixedBackOff);\n+      }\n+    }\n+    return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MDM1NA=="}, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDQxNTY2OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyNTo1OVrOGh_I-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyMDoxN1rOGiKdOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MDY4MQ==", "bodyText": "I think https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/BooleanSupplier.html might be a better choice here because it avoids the null Problem", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438290681", "createdAt": "2020-06-10T17:25:59Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjA4OQ==", "bodyText": "I was pretty sure there was a more direct function for supplier boolean and I had some trouble finding it. Thank you for pointing me to it \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438476089", "createdAt": "2020-06-11T00:20:17Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {\n+      Preconditions.checkArgument(duration.toMillis() > 0, \"Minimum backoff is 1ms\");\n+      return new TaskBuilder(threadSleeper, maxAttempts, duration);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class TaskBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration backOff;\n+\n+    public RetryableBuilder withTask(final Supplier<Boolean> taskRunner) {\n+      Preconditions.checkNotNull(taskRunner);\n+      return new RetryableBuilder(threadSleeper, maxAttempts, backOff, taskRunner);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class RetryableBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+    private final Duration fixedBackOff;\n+    private final Supplier<Boolean> taskRunner;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MDY4MQ=="}, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDQxOTA4OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyNjo1OFrOGh_LQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyMjo1MFrOGiKgAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTI2NQ==", "bodyText": "Bonus Points for using java.time instead of raw numbers \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438291265", "createdAt": "2020-06-10T17:26:58Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjgwMw==", "bodyText": "Hehe, raw numbers for inter-system boundaries (IE: JSON - prefer to emit JSON with primitive values rather than nested JSON objects). Since we are within a system boudary, using strongest type possible is good (ie: avoid strings and numbers and use value objects instead, generally use strong typing)", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438476803", "createdAt": "2020-06-11T00:22:50Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");\n+      return new BackOffBuilder(threadSleeper, maxAttempts);\n+    }\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class BackOffBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+    private final int maxAttempts;\n+\n+    public TaskBuilder withFixedBackOff(final Duration duration) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTI2NQ=="}, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDQyOTA2OnYy", "diffSide": "RIGHT", "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyOTozNFrOGh_Rqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyNTowM1rOGiKiDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjkwNg==", "bodyText": "0 attempts is clearly a stupid value.\nI see your point, but technically speaking there would be nothing standing against allowing 1.\nWhile not relevant for our case it could make a difference if we ever want to make it some sort of setting to configure.", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438292906", "createdAt": "2020-06-10T17:29:34Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzMyNg==", "bodyText": "Good point that perhaps a setting would want to turn off retries, but IMO YAGNI on this one.\nMy biggest concern is that 'max attempts' and 'max retries' were ever to be confused. A setting of '1' could seem like \"oh yeah, one retry\".", "url": "https://github.com/triplea-game/triplea/pull/6648#discussion_r438477326", "createdAt": "2020-06-11T00:25:03Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/Retryable.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.triplea.java;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * Module to execute a task with retries. Provides a builder interface to specify number of max\n+ * attempts (max number of times the task will be executed) and backoff.\n+ */\n+@AllArgsConstructor(access = AccessLevel.PRIVATE)\n+public class Retryable {\n+  private static final Consumer<Duration> DEFAULT_THREAD_SLEEP =\n+      duration -> Interruptibles.sleep(duration.toMillis());\n+\n+  private final Consumer<Duration> threadSleeper;\n+  private final int maxAttempts;\n+  private final Duration fixedBackOff;\n+  private final Supplier<Boolean> taskRunner;\n+\n+  public static MaxAttemptsBuilder builder() {\n+    return new MaxAttemptsBuilder(DEFAULT_THREAD_SLEEP);\n+  }\n+\n+  @VisibleForTesting\n+  static MaxAttemptsBuilder builder(final Consumer<Duration> threadSleeper) {\n+    return new MaxAttemptsBuilder(threadSleeper);\n+  }\n+\n+  @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+  public static class MaxAttemptsBuilder {\n+    private final Consumer<Duration> threadSleeper;\n+\n+    public BackOffBuilder withMaxAttempts(final int maxAttempts) {\n+      Preconditions.checkArgument(\n+          maxAttempts > 1,\n+          \"Max attempt count must be greater than 1, if max attempt is 1, \"\n+              + \"just invoke your task directly without the retry mechanism\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjkwNg=="}, "originalCommit": {"oid": "d94adafa2253f1f8e879765d12c92b31f432516b"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2135, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}