{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMDA5MjM0", "number": 7723, "title": "Refactor the BattleState/BattleActions retreat api", "bodyText": "This removes the submergeUnits and queryRetreat methods from the BattleActions and moves all of the retreat/submerge code in MustFightBattle to the individual steps or helper utility classes.\nAlso, part of this involved changing the attackerWins, defenderWins, and nobodyWins methods to always call endBattle and to have just one endBattle(WhoWon) exposed in BattleActions.  I plan to rework the endBattle method as well so that it is split better between BattleState and BattleActions (it is currently on BattleState but assumes that it has access to BattleState instead of being explicit).\nThere should only be one functional change: defending subs can now submerge if SUBMARINES_DEFENDING_MAY_SUBMERGE_OR_RETREAT is true and they have no other retreat territories.  Previously, defending subs would be able to submerge only if there was at least one other retreat territory.\nTesting\n\nI've tested the following retreat scenarios:\n\nDefensive subs that can't retreat\nDefensive subs that can submerge\nDefensive subs that can submerge and retreat to other territories\nOffensive subs submerging by themselves\nOffensive subs submerging before other units retreat\nOffensive subs retreating with other units\nPartial Amphibious assault with non-amphibious land units and air units\nPartial Amphibious assault with air units\nNaval battles that have dependent amphibious assault battles\nNaval battles that have allied air units as cargo\nNaval battles that have allied air units participating\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note\n\nFIX|Defending subs can now submerge if \"Submarines Defending May Submerge Or Retreat\" is true even if there are no other retreat territories.", "createdAt": "2020-09-21T03:05:31Z", "url": "https://github.com/triplea-game/triplea/pull/7723", "merged": true, "mergeCommit": {"oid": "9bd893cecaddb3768770eb24d717b63491a59ff5"}, "closed": true, "closedAt": "2020-09-26T02:15:25Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdK6Dt_AH2gAyNDkwMDA5MjM0OjBlNjc2YjY4ZDI0MWRjMmI3ZDQ4N2E4YzI1OWU5ZTA3MDM3NTI0MGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMgDjPAH2gAyNDkwMDA5MjM0OjUwNmIyMTQ4ZGUzOTM0MmQ3ZjE1OTkwNzYyNzc4MDZjNTZjMmJiZTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e676b68d241dc2b7d487a8c259e9e070375240e", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/0e676b68d241dc2b7d487a8c259e9e070375240e", "committedDate": "2020-09-21T02:35:02Z", "message": "Refactor the BattleState/BattleActions retreat api\n\nMove the logic out of MustFightBattle into the individual BattleSteps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7365c6812c31cd44fddb39958e3317e49803e39", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d7365c6812c31cd44fddb39958e3317e49803e39", "committedDate": "2020-09-21T03:33:16Z", "message": "Fix codacy and codeclimate issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8240dcd31b9a0090b2b9f0757624869481a1000", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/e8240dcd31b9a0090b2b9f0757624869481a1000", "committedDate": "2020-09-21T03:40:25Z", "message": "Fix a typo in calling a method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28708f3dfb473fc74a1ecbb48e9926cadac2815f", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/28708f3dfb473fc74a1ecbb48e9926cadac2815f", "committedDate": "2020-09-21T03:50:06Z", "message": "More codeclimate fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fa44b291b15ce3b8306f093124d72f871ce3431", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/0fa44b291b15ce3b8306f093124d72f871ce3431", "committedDate": "2020-09-21T04:58:54Z", "message": "Use a parameter object for EvaderRetreat.retreatUnits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1ca4534970e8e549765138240e62a0de455d4c6", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b1ca4534970e8e549765138240e62a0de455d4c6", "committedDate": "2020-09-21T15:12:49Z", "message": "Split up OffensiveGeneralRetreater into Retreater classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4544484b4a324be09c6b9524b3ed99a3bfffcee2", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/4544484b4a324be09c6b9524b3ed99a3bfffcee2", "committedDate": "2020-09-21T17:07:48Z", "message": "Reduce complexity of OffensiveGeneralRetreat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7a3cfcba81f0d2836e0747b3c9656996eed4a99d", "committedDate": "2020-09-21T17:52:55Z", "message": "Remove unused parameter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMTI3NDI4", "url": "https://github.com/triplea-game/triplea/pull/7723#pullrequestreview-493127428", "createdAt": "2020-09-22T04:58:37Z", "commit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDo1ODozOFrOHVqP3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDo1ODozOFrOHVqP3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDMzNQ==", "bodyText": "I've thought about having the retreaters have a getChanges() method that returns a list of change objects.  These change objects would encapsulate the retreatSameTerritoryUnits, retreatOtherTerritoryUnits, and extraRetreatChange logic.  But I didn't think the existing Change objects fit this.  The HistoryNode objects are kind of a good fit since these \"changes\" already create history nodes but HistoryNode doesn't seem to have actions to perform.\nThe api of this \"change\" object would be something like:\ninterface BattleChange {\n  void writeHistoryNode();\n  Change perform();\n}\n\nAnd perform would build the actual Change objects as well as modify the BattleState (if needed).", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r492474335", "createdAt": "2020-09-22T04:58:38Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,97 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    if (!battleState.isHeadless()) {\n+      SoundUtils.playRetreatType(\n+          battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n+    }\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTc0OTEw", "url": "https://github.com/triplea-game/triplea/pull/7723#pullrequestreview-493974910", "createdAt": "2020-09-23T01:50:59Z", "commit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1MTowMFrOHWS0jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowNjozMlrOHWTbeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzOTA4NA==", "bodyText": "Any thoughts to use a proper getter here? Particularly a lombok getter?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493139084", "createdAt": "2020-09-23T01:51:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -14,12 +14,22 @@\n public interface BattleState {\n \n   enum Side {\n-    OFFENSE,\n-    DEFENSE;\n+    OFFENSE(IBattle.WhoWon.ATTACKER),\n+    DEFENSE(IBattle.WhoWon.DEFENDER);\n+\n+    private final IBattle.WhoWon whoWon;\n+\n+    Side(final IBattle.WhoWon whoWon) {\n+      this.whoWon = whoWon;\n+    }\n \n     public Side getOpposite() {\n       return this == OFFENSE ? DEFENSE : OFFENSE;\n     }\n+\n+    public IBattle.WhoWon won() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzOTg0NQ==", "bodyText": "Side-comment,  BattleState and BattleActions are growing quite a bit, seemingly a bit coupled.  Do you share my concern @trevan  these  classes could morph back into MustFightBattle, or is this maybe just a necessary refactoring step to get to a simpler place?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493139845", "createdAt": "2020-09-23T01:52:13Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -72,4 +86,8 @@ public boolean isFirstRound() {\n   Collection<Territory> getAttackerRetreatTerritories();\n \n   Collection<Unit> getDependentUnits(Collection<Unit> units);\n+\n+  Collection<Unit> getTransportDependents(Collection<Unit> units);\n+\n+  Collection<IBattle> getDependentBattles();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ==", "bodyText": "I wonder about the nullable return here and error handling. In what cases could we get an incorrect territory back? Perhaps if someone is running a hacked game client? Would a null return value lead to a possible infinite loop and/or an incorrect game state? I'd like to understand this one a bit better, I do wonder if an outright exception would be best to just halt the game. Otherewise, perhaps this logic should redo the 'retreatQuery' and if we can't get an answer back at all, maybe the return value should be able to flag an error.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493141975", "createdAt": "2020-09-23T01:55:21Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw==", "bodyText": "Side-note, the \"CheckGeneral\" I think should have another look. I'd suspect this class would do just as well being called \"CheckBattleEndOld.java\" as it would be \"CheckGeneralBattleEndOld\". I'm also confused by the \"EndOld\" suffix as well.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493144193", "createdAt": "2020-09-23T01:58:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTQ5MQ==", "bodyText": "Why are all of the parameters being aliased (IE: re-assigned) to new variables up front here? The alternative would be to just use the parameter values inline.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493145491", "createdAt": "2020-09-23T02:00:47Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NjQ2NQ==", "bodyText": "nit, mixture of abstractions code smell here. The other methods are high level, then this bit of functionality is very low level. Recommend to extract to a method so we can keep a consistent level of abstraction, eG: \"updateHistoryWithUnitsMoved(..)\"", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493146465", "createdAt": "2020-09-23T02:02:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NzQwOQ==", "bodyText": "A method for a single line method call seems a overkill. Is the 'isHeadless' check truly needed? Even if it is, what do you think about inlining this?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493147409", "createdAt": "2020-09-23T02:03:51Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();\n+      change.add(ChangeFactory.moveUnits(battleState.getBattleSite(), retreatTo, units));\n+      bridge.addChange(change);\n+      battleState.retreatUnits(side, units);\n+\n+      addHistoryRetreat(bridge, units, \" retreated to \" + retreatTo.getName());\n+      notifyRetreat(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(\n+          bridge, retreatingPlayer, step, \" retreats\", \" retreats subs to \" + retreatTo.getName());\n+    }\n+  }\n+\n+  private static void playSound(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0OTA0OQ==", "bodyText": "I think this method is here to avoid doing this same string concatenation in two places. IMO the indirection with overloaded method args is more harmful than duplicating two lines of code. WDYT of inlining this broadcast method @trevan ?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493149049", "createdAt": "2020-09-23T02:06:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();\n+      change.add(ChangeFactory.moveUnits(battleState.getBattleSite(), retreatTo, units));\n+      bridge.addChange(change);\n+      battleState.retreatUnits(side, units);\n+\n+      addHistoryRetreat(bridge, units, \" retreated to \" + retreatTo.getName());\n+      notifyRetreat(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(\n+          bridge, retreatingPlayer, step, \" retreats\", \" retreats subs to \" + retreatTo.getName());\n+    }\n+  }\n+\n+  private static void playSound(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Unit> units) {\n+    if (battleState.isHeadless()) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(retreatingPlayer, units, MustFightBattle.RetreatType.SUBS, bridge);\n+  }\n+\n+  public static void submergeEvaders(\n+      final BattleState battleState,\n+      final BattleActions battleActions,\n+      final Collection<Unit> submerging,\n+      final BattleState.Side side,\n+      final IDelegateBridge bridge) {\n+    final CompositeChange change = new CompositeChange();\n+    for (final Unit u : submerging) {\n+      change.add(ChangeFactory.unitPropertyChange(u, true, Unit.SUBMERGED));\n+    }\n+    bridge.addChange(change);\n+    battleState.retreatUnits(side, submerging);\n+\n+    addHistoryRetreat(bridge, submerging, \" submerged\");\n+    notifyRetreat(battleState, battleActions, submerging, side, bridge);\n+  }\n+\n+  private static void addHistoryRetreat(\n+      final IDelegateBridge bridge, final Collection<Unit> units, final String suffix) {\n+    final String transcriptText = MyFormatter.unitsToText(units) + suffix;\n+    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(units));\n+  }\n+\n+  private static void notifyRetreat(\n+      final BattleState battleState,\n+      final BattleActions battleActions,\n+      final Collection<Unit> retreating,\n+      final BattleState.Side side,\n+      final IDelegateBridge bridge) {\n+    if (battleState.getUnits(side).isEmpty()) {\n+      battleActions.endBattle(side.getOpposite().won(), bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreating);\n+    }\n+  }\n+\n+  private static void broadcastRetreat(\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final String step,\n+      final String messageShortSuffix) {\n+    broadcastRetreat(bridge, retreatingPlayer, step, messageShortSuffix, messageShortSuffix);\n+  }\n+\n+  private static void broadcastRetreat(\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final String step,\n+      final String messageShortSuffix,\n+      final String messageLongSuffix) {\n+    final String messageShort = retreatingPlayer.getName() + messageShortSuffix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/25150f84d1bb65f9efbe783a4164d65fcb054d1d", "committedDate": "2020-09-23T13:22:36Z", "message": "Review feedback\n\nInline usage of parameters\nRemove isHeadless check around sound since sound is already headless\nUse @Getter for Side.whoWon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTUxNzA3", "url": "https://github.com/triplea-game/triplea/pull/7723#pullrequestreview-495151707", "createdAt": "2020-09-24T00:58:41Z", "commit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDo1ODo0MVrOHXGHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxODo0NFrOHXGa7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTU0OA==", "bodyText": "What is meant by an 'evader'? Suggestion: A class javadoc perhaps could be used to clarify that.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493979548", "createdAt": "2020-09-24T00:58:41Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDAwMg==", "bodyText": "nit, are the parameter values mutable? Can these be marked as final? It's perhaps also worthwhile to mark the non-null ones as @Nonnull so that they are checked when the builder is constructed. A downside of lombok builder is that it's not compile time safe, required args can be omitted, so generally it's important to at least get runtime validation with the @Nonnull annotation.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493980002", "createdAt": "2020-09-24T01:00:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  public static class Parameters {\n+    BattleState battleState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTcyNg==", "bodyText": "IMO the control flow would be better at the caller level. This method is a no-op otherwise an is just a void call from the caller. It provides some abstraction but a maintainer needs to jump around in the code to see that this is a potential no-op and when it would be a no-op. It also looks like the null check is dead-code.\nI suspect some details are a bit hidden that probably could be exposed to the caller that would make the code easier to follow. For example, instead of this:\n  @Override\n  public Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(\n      final Collection<Unit> retreatUnits) {\n    return Map.of(RetreatLocation.SAME_TERRITORY, retreatUnits);\n  }\n\nPerhaps the API should be:\nCollection<Unit> splitRetreatUnits(\n     RetreatLocation,\n      final Collection<Unit> retreatUnits)\n\nIn this way it'd be more obvious that if we are calling a non-nullable method, then we'd always have a key value for 'retreatingUnits' and one would then be very comfortable removing the null check.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493981726", "createdAt": "2020-09-24T01:07:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw==", "bodyText": "ditto on burying control flow in private methods, this should probably be pushed up a layer so it's obvious to a caller that this is a no-op method in certain conditions. Arguably it's a bug whenever a no-op method is invoked (Did the caller know they would get a no-op, if so, why would they call a no-op method? If the caller did not know, is the caller in an unknown state and computing garbage data?)", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982487", "createdAt": "2020-09-24T01:10:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjY2Ng==", "bodyText": "nit, good place for a ternary here. Any thoughts or objections to that?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982666", "createdAt": "2020-09-24T01:11:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -59,13 +66,36 @@ public Order getOrder() {\n   public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n     if (battleState.isOver()\n         || isDestroyerPresent()\n-        || !isEvaderPresent()\n-        || !isRetreatPossible()\n+        || isEvaderNotPresent()\n+        || isRetreatNotPossible()\n         || isAutoWinScenario()) {\n       return;\n     }\n-    battleActions.queryRetreat(\n-        false, RetreatType.SUBS, bridge, battleState.getAttackerRetreatTerritories());\n+\n+    final Collection<Unit> unitsToRetreat =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(BattleState.Side.OFFENSE), Matches.unitCanEvade());\n+    if (unitsToRetreat.isEmpty()) {\n+      return;\n+    }\n+\n+    final Collection<Territory> retreatTerritories;\n+    if (Properties.getSubmersibleSubs(battleState.getGameData())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjgyOQ==", "bodyText": "With a ternary done, one could even consider inlining and you'd remove the intermediate variable as well.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982829", "createdAt": "2020-09-24T01:12:05Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -59,13 +66,36 @@ public Order getOrder() {\n   public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n     if (battleState.isOver()\n         || isDestroyerPresent()\n-        || !isEvaderPresent()\n-        || !isRetreatPossible()\n+        || isEvaderNotPresent()\n+        || isRetreatNotPossible()\n         || isAutoWinScenario()) {\n       return;\n     }\n-    battleActions.queryRetreat(\n-        false, RetreatType.SUBS, bridge, battleState.getAttackerRetreatTerritories());\n+\n+    final Collection<Unit> unitsToRetreat =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(BattleState.Side.OFFENSE), Matches.unitCanEvade());\n+    if (unitsToRetreat.isEmpty()) {\n+      return;\n+    }\n+\n+    final Collection<Territory> retreatTerritories;\n+    if (Properties.getSubmersibleSubs(battleState.getGameData())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjY2Ng=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzA5Mw==", "bodyText": "I think a javadoc would do well here to explain what this abstraction is representing exactly. WDYT?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983093", "createdAt": "2020-09-24T01:13:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ==", "bodyText": "This seems to be a UI concern, I'm not sure if it belongs in this API as then any implementation is forced to mix UI and logic. Perhaps the caller could do a lookup of query text based on the retreat type?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983655", "createdAt": "2020-09-24T01:15:21Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4Mzk1NA==", "bodyText": "Ditto on UI concerns present in the API. Perhaps the caller can take care of this based on the retreat type.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983954", "createdAt": "2020-09-24T01:16:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();\n+\n+  MustFightBattle.RetreatType getRetreatType();\n+\n+  Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(Collection<Unit> retreatUnits);\n+\n+  Change extraRetreatChange(Territory retreatTo, Collection<Unit> retreatUnits);\n+\n+  String getShortBroadcastSuffix();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NDQ5Mg==", "bodyText": "I wonder if we are mixing responsibilities with this \"extraRetreatChange\" API. The retreat code probably should not know much about creating a change object.\nSuggestion: have the caller check the battle type, if amphib then the change is 'empty' or do not even add it to the change stack, otherwise inline the implementation code into the caller.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493984492", "createdAt": "2020-09-24T01:18:44Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();\n+\n+  MustFightBattle.RetreatType getRetreatType();\n+\n+  Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(Collection<Unit> retreatUnits);\n+\n+  Change extraRetreatChange(Territory retreatTo, Collection<Unit> retreatUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b12c373cd211a76d3e44e70d0ad4580f8dca2586", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b12c373cd211a76d3e44e70d0ad4580f8dca2586", "committedDate": "2020-09-24T02:03:53Z", "message": "Review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e0b45e735ea4f71a0e412a6d28eee4a09fcd6f1", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/5e0b45e735ea4f71a0e412a6d28eee4a09fcd6f1", "committedDate": "2020-09-24T03:29:18Z", "message": "Rework how Retreater instances interact with the delegate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c52e9791222aed27ef14f031a366bc41ca219d50", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c52e9791222aed27ef14f031a366bc41ca219d50", "committedDate": "2020-09-24T03:38:36Z", "message": "if -> ternary and inline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1db0ac8ec17dbefaffdd1b698ca238f2a2869cfc", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/1db0ac8ec17dbefaffdd1b698ca238f2a2869cfc", "committedDate": "2020-09-24T05:11:56Z", "message": "Only retreat owned planes to same territory for partial amphib"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77de7d10c4e362724b83b6d2069332ec5ce0332c", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/77de7d10c4e362724b83b6d2069332ec5ce0332c", "committedDate": "2020-09-24T05:21:02Z", "message": "Split up retreatUnits in EvaderRetreat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d84e09c0821b9c62bbbf7d49a9b0aa4c985080", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b4d84e09c0821b9c62bbbf7d49a9b0aa4c985080", "committedDate": "2020-09-24T14:10:13Z", "message": "Move ui text out of Retreater and into switch statements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTE0MzMx", "url": "https://github.com/triplea-game/triplea/pull/7723#pullrequestreview-496914331", "createdAt": "2020-09-25T23:41:35Z", "commit": {"oid": "b4d84e09c0821b9c62bbbf7d49a9b0aa4c985080"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "590898d5c1830c876f42ec0f123a4d511975697b", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/590898d5c1830c876f42ec0f123a4d511975697b", "committedDate": "2020-09-26T01:08:25Z", "message": "Merge remote-tracking branch 'upstream/master' into retreat-refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "506b2148de39342d7f1599076277806c56c2bbe0", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/506b2148de39342d7f1599076277806c56c2bbe0", "committedDate": "2020-09-26T01:25:10Z", "message": "Fix merge issue"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3937, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}