{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMjE3MzA2", "number": 7878, "title": "Add mark casualties battle step", "bodyText": "This is a part of #7823.\nDuring the firing part of the battle, there are three steps that are performed (you can see the originals in Fire and FireAa). This is the step that marks the casualties (after the user has selected them which is another step).\nTesting\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note", "createdAt": "2020-10-11T22:34:18Z", "url": "https://github.com/triplea-game/triplea/pull/7878", "merged": true, "mergeCommit": {"oid": "b804d3709224ae642c7e420d7d16cd85b372d225"}, "closed": true, "closedAt": "2020-10-14T04:10:12Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRnLZxAH2gAyNTAxMjE3MzA2OmYyYTEwMWU4NGE5ZjA3ZjgyNmI5ZjA3M2E3YzM3NzMxYmFlNDQwZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSUKO4gH2gAyNTAxMjE3MzA2OjA0MDQwOGZkMDNjMTBjODA2MDg0YTc1MTdiNWJjZTdjOTMwZjI5MTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2a101e84a9f07f826b9f073a7c37731bae440df", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/f2a101e84a9f07f826b9f073a7c37731bae440df", "committedDate": "2020-10-11T22:32:42Z", "message": "Add mark casualties battle step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2d7fa471e4de88490eef88ec92068db08f53a90", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c2d7fa471e4de88490eef88ec92068db08f53a90", "committedDate": "2020-10-11T22:36:57Z", "message": "Add select casualties battle step"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI4ODU3", "url": "https://github.com/triplea-game/triplea/pull/7878#pullrequestreview-506228857", "createdAt": "2020-10-11T23:33:16Z", "commit": {"oid": "f2a101e84a9f07f826b9f073a7c37731bae440df"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMzozMzoxNlrOHfriuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMzozNDo1NFrOHfrjdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTMwNw==", "bodyText": "side-note, this dependency on WeakAi is something we really would like to get rid of:\n\nallows for all of weak ai to be deleted\nkinda poor design, the core game engine should not depend on AI code", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r502981307", "createdAt": "2020-10-11T23:33:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleActions.java", "diffHunk": "@@ -59,4 +64,12 @@ Territory querySubmergeTerritory(\n       GamePlayer retreatingPlayer,\n       Collection<Territory> availableTerritories,\n       String text);\n+\n+  default Player getRemotePlayer(final GamePlayer player, final IDelegateBridge bridge) {\n+    // if its the null player, return a do nothing proxy\n+    if (player.isNull()) {\n+      return new WeakAi(player.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a101e84a9f07f826b9f073a7c37731bae440df"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTQ5NQ==", "bodyText": "nit, I'm not sure the annotation comment string here makes a lot of sense. Would we be just as well off if it were removed? Otherwise, can it be made more direct, is it indicating that we have to do something else beyond upgrading to a non-compatible release to remove this method?", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r502981495", "createdAt": "2020-10-11T23:34:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -107,4 +109,8 @@ public boolean isFirstRound() {\n   Collection<Unit> getTransportDependents(Collection<Unit> units);\n \n   Collection<IBattle> getDependentBattles();\n+\n+  @RemoveOnNextMajorRelease(\"Only used to handle step string changes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2a101e84a9f07f826b9f073a7c37731bae440df"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee6d2adad5c4b7cd3e12708c79f790bf05f37f53", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ee6d2adad5c4b7cd3e12708c79f790bf05f37f53", "committedDate": "2020-10-12T03:55:42Z", "message": "Remove unneeded annotation string for removal"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2Mjc3NTcy", "url": "https://github.com/triplea-game/triplea/pull/7878#pullrequestreview-506277572", "createdAt": "2020-10-12T03:56:53Z", "commit": {"oid": "ee6d2adad5c4b7cd3e12708c79f790bf05f37f53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMzo1Njo1M1rOHfuR9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMzo1Njo1M1rOHfuR9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNjE2Nw==", "bodyText": "This is where the isSuicideOnHit check is being used.  You had wondered about that in the FiringGroup PR.", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503026167", "createdAt": "2020-10-12T03:56:53Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/MarkCasualties.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_FIRST_STRIKE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_NAVAL_BOMBARDMENT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.RequiredArgsConstructor;\n+import org.triplea.java.ChangeOnNextMajorRelease;\n+import org.triplea.java.Interruptibles;\n+import org.triplea.java.RemoveOnNextMajorRelease;\n+\n+/** Step where the casualties are moved from ALIVE to CASUALTY */\n+@RequiredArgsConstructor\n+public class MarkCasualties implements BattleStep {\n+\n+  private static final long serialVersionUID = -3823676731273987167L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  /** The side of the firing player */\n+  private final BattleState.Side side;\n+\n+  private final FiringGroup firingGroup;\n+\n+  private final FireRoundState fireRoundState;\n+\n+  @ChangeOnNextMajorRelease(\n+      \"returnFire is ALL for everything except NavalBombardment and old saves.\"\n+          + \"Rework so that returnFire isn't needed at all.\")\n+  private final MustFightBattle.ReturnFire returnFire;\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of(getName());\n+  }\n+\n+  private String getName() {\n+    return battleState.getPlayer(side.getOpposite()).getName()\n+        + REMOVE_PREFIX\n+        // displaying UNITS makes the text feel redundant so hide it if that is the group name\n+        + (firingGroup.getDisplayName().equals(UNITS)\n+            ? CASUALTIES_WITHOUT_SPACE_SUFFIX\n+            : firingGroup.getDisplayName() + CASUALTIES_SUFFIX);\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_FIRE_ROUND_CASUALTIES;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (!battleState.getStatus().isHeadless()) {\n+      notifyCasualties(bridge);\n+    }\n+\n+    battleActions.removeCasualties(\n+        fireRoundState.getCasualties().getKilled(),\n+        returnFire,\n+        side.getOpposite() == DEFENSE,\n+        bridge);\n+\n+    if (firingGroup.isSuicideOnHit()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee6d2adad5c4b7cd3e12708c79f790bf05f37f53"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82e6d747d4bdce82ff706f10d8b04a1b9ae8098b", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/82e6d747d4bdce82ff706f10d8b04a1b9ae8098b", "committedDate": "2020-10-12T03:58:17Z", "message": "Add missing enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17528ed2156eeb47c5df554d16b29afcb01c029a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/17528ed2156eeb47c5df554d16b29afcb01c029a", "committedDate": "2020-10-12T04:10:29Z", "message": "Add missing imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b5bc547c1161f29bcd4d61ac6bbacb1a927e3e0", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/5b5bc547c1161f29bcd4d61ac6bbacb1a927e3e0", "committedDate": "2020-10-12T23:19:57Z", "message": "Rename SelectNormalCasualties to SelectMainBattleCasualties"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTkwMzE3", "url": "https://github.com/triplea-game/triplea/pull/7878#pullrequestreview-506990317", "createdAt": "2020-10-13T00:14:01Z", "commit": {"oid": "5b5bc547c1161f29bcd4d61ac6bbacb1a927e3e0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/e923c460db988293f1c1085fd066566b0cf8600d", "committedDate": "2020-10-13T01:37:10Z", "message": "Add tests for SelectMainBattleCasualties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53eea6b5c2068e05bcad69fc850c038faf1b9351", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/53eea6b5c2068e05bcad69fc850c038faf1b9351", "committedDate": "2020-10-13T01:39:33Z", "message": "Merge remote-tracking branch 'upstream/master' into mark-casualties-step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "827e6a23dc355aace3e8c0e7b628016cae949ac4", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/827e6a23dc355aace3e8c0e7b628016cae949ac4", "committedDate": "2020-10-13T01:39:48Z", "message": "Run spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDI0NTA5", "url": "https://github.com/triplea-game/triplea/pull/7878#pullrequestreview-507024509", "createdAt": "2020-10-13T02:20:00Z", "commit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMjoyMDowMFrOHgTEow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMjoyMzo0MlrOHgTH_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyODk2Mw==", "bodyText": "nit, test method feels to be missing the implication of what happens when edit mode. A @DisplayName perhaps should become routine for any test method over 5 lines and particularly if there is more than one assert (think of it as a way to replace a javadoc on each test method, and each one should have a summary either in a direct title or display name to describe what we are testing).", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503628963", "createdAt": "2020-10-13T02:20:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTEzNg==", "bodyText": "nit, the comment on the assertion is essentially what the string arg for assertions is for : )\nEG:\n  assertThat(\"edit mode sets auto calcuated to true\" , details.getAutoCalculated(), is(true));", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629136", "createdAt": "2020-10-13T02:20:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTU2OQ==", "bodyText": "side-note, it does look like we are doing a pretty heavy lift in this test by verifying further implementation calls. If we can have the code under test instead return a result object, then have the caller invoke the select function, it would be more testable, functional, and likely easier to understand when reading the prod code (fewer side effects)", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629569", "createdAt": "2020-10-13T02:22:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTY4OA==", "bodyText": "It looks like there are more hit points here than hits, is the name of the test correct? \"moreHitsThanHitPoints\"", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629688", "createdAt": "2020-10-13T02:23:08Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));\n+    }\n+\n+    @Test\n+    void moreHitsThanHitPoints() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTgyMw==", "bodyText": "Any thoughts to create a constructor that removes the no-op arguments? EG:\nnew FiringGroup(targetUnits);", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629823", "createdAt": "2020-10-13T02:23:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));\n+    }\n+\n+    @Test\n+    void moreHitsThanHitPoints() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+            when(unit.getHits()).thenReturn(1);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e923c460db988293f1c1085fd066566b0cf8600d"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ff5befd1bdaa567bdee1ba2d41ba39b9217a007", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7ff5befd1bdaa567bdee1ba2d41ba39b9217a007", "committedDate": "2020-10-13T03:26:23Z", "message": "Add test descriptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b3b44c9bd37e0aaf8c60e427f9f6f3165f7fb4", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d5b3b44c9bd37e0aaf8c60e427f9f6f3165f7fb4", "committedDate": "2020-10-13T03:37:04Z", "message": "Add 'Remaining' to the test name to indicate that it is hit points remaining"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "518aa5848759b45dea8357adfc0c217ee730f9a6", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/518aa5848759b45dea8357adfc0c217ee730f9a6", "committedDate": "2020-10-13T15:29:53Z", "message": "Make FiringGroup's constructor private"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3OTI1ODk5", "url": "https://github.com/triplea-game/triplea/pull/7878#pullrequestreview-507925899", "createdAt": "2020-10-14T01:01:14Z", "commit": {"oid": "518aa5848759b45dea8357adfc0c217ee730f9a6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "040408fd03c10c806084a7517b5bce7c930f2919", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/040408fd03c10c806084a7517b5bce7c930f2919", "committedDate": "2020-10-14T02:57:09Z", "message": "Fix checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3880, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}