{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMDA5MjM0", "number": 7723, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDo1ODozN1rOEl7Dgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxODo0M1rOEm1rKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjAwMzIzOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDo1ODozOFrOHVqP3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDo1ODozOFrOHVqP3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDMzNQ==", "bodyText": "I've thought about having the retreaters have a getChanges() method that returns a list of change objects.  These change objects would encapsulate the retreatSameTerritoryUnits, retreatOtherTerritoryUnits, and extraRetreatChange logic.  But I didn't think the existing Change objects fit this.  The HistoryNode objects are kind of a good fit since these \"changes\" already create history nodes but HistoryNode doesn't seem to have actions to perform.\nThe api of this \"change\" object would be something like:\ninterface BattleChange {\n  void writeHistoryNode();\n  Change perform();\n}\n\nAnd perform would build the actual Change objects as well as modify the BattleState (if needed).", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r492474335", "createdAt": "2020-09-22T04:58:38Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,97 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    if (!battleState.isHeadless()) {\n+      SoundUtils.playRetreatType(\n+          battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n+    }\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjI5MDgxOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1MTowMFrOHWS0jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1MTowMFrOHWS0jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzOTA4NA==", "bodyText": "Any thoughts to use a proper getter here? Particularly a lombok getter?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493139084", "createdAt": "2020-09-23T01:51:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -14,12 +14,22 @@\n public interface BattleState {\n \n   enum Side {\n-    OFFENSE,\n-    DEFENSE;\n+    OFFENSE(IBattle.WhoWon.ATTACKER),\n+    DEFENSE(IBattle.WhoWon.DEFENDER);\n+\n+    private final IBattle.WhoWon whoWon;\n+\n+    Side(final IBattle.WhoWon whoWon) {\n+      this.whoWon = whoWon;\n+    }\n \n     public Side getOpposite() {\n       return this == OFFENSE ? DEFENSE : OFFENSE;\n     }\n+\n+    public IBattle.WhoWon won() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjI5NTg1OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1MjoxM1rOHWS3hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDozNTozM1rOHWWCMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzOTg0NQ==", "bodyText": "Side-comment,  BattleState and BattleActions are growing quite a bit, seemingly a bit coupled.  Do you share my concern @trevan  these  classes could morph back into MustFightBattle, or is this maybe just a necessary refactoring step to get to a simpler place?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493139845", "createdAt": "2020-09-23T01:52:13Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -72,4 +86,8 @@ public boolean isFirstRound() {\n   Collection<Territory> getAttackerRetreatTerritories();\n \n   Collection<Unit> getDependentUnits(Collection<Unit> units);\n+\n+  Collection<Unit> getTransportDependents(Collection<Unit> units);\n+\n+  Collection<IBattle> getDependentBattles();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTczMQ==", "bodyText": "I'm not yet sure where BattleActions is headed.  I first thought I'd use it to contain all of the delegate logic but now that I've actually refactored a method that uses the delegate, I'm finding it not as useful.  BattleState might morph with IBattle or AbstractBattle once I start working on other battle classes.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493191731", "createdAt": "2020-09-23T04:35:33Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -72,4 +86,8 @@ public boolean isFirstRound() {\n   Collection<Territory> getAttackerRetreatTerritories();\n \n   Collection<Unit> getDependentUnits(Collection<Unit> units);\n+\n+  Collection<Unit> getTransportDependents(Collection<Unit> units);\n+\n+  Collection<IBattle> getDependentBattles();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEzOTg0NQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjMwOTYyOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1NToyMVrOHWS_1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMToxNjowMVrOHXBRzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ==", "bodyText": "I wonder about the nullable return here and error handling. In what cases could we get an incorrect territory back? Perhaps if someone is running a hacked game client? Would a null return value lead to a possible infinite loop and/or an incorrect game state? I'd like to understand this one a bit better, I do wonder if an outright exception would be best to just halt the game. Otherewise, perhaps this logic should redo the 'retreatQuery' and if we can't get an answer back at all, maybe the return value should be able to flag an error.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493141975", "createdAt": "2020-09-23T01:55:21Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MzIwMQ==", "bodyText": "This error handling was added back in 2005.  So it has been around for a while.  It has been a severe log since 2018.  I haven't seen the error show up in github so it is possible it never happens.\nReturning null will just have the retreat not happen.  The game will continue as if the user never had a retreat option.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493193201", "createdAt": "2020-09-23T04:41:30Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NzkyOQ==", "bodyText": "I wonder a bit if it is simply just dead code. Given the seeming remote call, one could picture a badly behaving client that would trigger this.\nIt is a shame that the diff marks don't show more clearly what is moved vs new.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493757929", "createdAt": "2020-09-23T17:15:27Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NjE2OA==", "bodyText": "It might be.  Looking at the original commit (94dcbc4), the message mentions that the messaging framework is still buggy.\nAlso, there was a situation in the original code where the selected territory wasn't part of the possible territories.  This happened when a submerge was offered.  But that code was changed sometime ago so that the possible territories included the submerge territory.\nDo you want me to change it to an exception or just drop the code?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493886168", "createdAt": "2020-09-23T20:48:59Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMDIzOA==", "bodyText": "Probably let's follow up with this, but soon as we have spent time on it and it's better to resolve it sooner than later.\nIMO if we are pretty confident it is dead code, then drop it. If we think it's only possible if there is a buggy game client (like the server is okay, but the other person is running some sort of hacked up code), then perhaps the current handling is actually more or less okay.. It's hard to really know what to do with this one.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493900238", "createdAt": "2020-09-23T21:16:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -315,6 +319,57 @@ public BattleRound getBattleRoundState() {\n     return BattleRound.of(round, maxRounds);\n   }\n \n+  @Override\n+  public @Nullable Territory queryRetreatTerritory(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Territory> availableTerritories,\n+      final String text) {\n+    return retreatQuery(\n+        battleState, getRemote(retreatingPlayer, bridge), availableTerritories, false, text);\n+  }\n+\n+  private @Nullable Territory retreatQuery(\n+      final BattleState battleState,\n+      final Player remotePlayer,\n+      final Collection<Territory> availableTerritories,\n+      final boolean submerge,\n+      final String text) {\n+    final Territory retreatTo =\n+        remotePlayer.retreatQuery(\n+            battleState.getBattleId(),\n+            submerge,\n+            battleState.getBattleSite(),\n+            availableTerritories,\n+            text);\n+    if (retreatTo != null && !availableTerritories.contains(retreatTo)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTk3NQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjMyNDc0OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMTo1ODo1NFrOHWTIgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMToyODowMFrOHXBnBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw==", "bodyText": "Side-note, the \"CheckGeneral\" I think should have another look. I'd suspect this class would do just as well being called \"CheckBattleEndOld.java\" as it would be \"CheckGeneralBattleEndOld\". I'm also confused by the \"EndOld\" suffix as well.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493144193", "createdAt": "2020-09-23T01:58:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MzQyMQ==", "bodyText": "The Old was to differentiate it from the non Old class.  Unfortunately, since they are part of the save game, we can't change their names :(", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493193421", "createdAt": "2020-09-23T04:42:17Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NjIyMg==", "bodyText": "This code is new since the last release (right?) -  sparingly, you can break prerelease save games. The latest release is where we need to absolutely need to guarantee compatibility unless we agree to do a major version release.  It's somewhat assumed that those that stumble upon a prerelease know what they are doing and compatibility is not 100% guaranteed.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493196222", "createdAt": "2020-09-23T04:53:26Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NzA4OQ==", "bodyText": "Yes, the CheckGeneralBattleEnd* classes were added in 2.3.21665 which I believe is a prerelease.  Also, I think I'm mistaken on the Old class.  It shouldn't be included in any save.  The CheckGeneralBattleEnd class, though, will be.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493887089", "createdAt": "2020-09-23T20:50:40Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMDQ5Ng==", "bodyText": "Any objects then to removing the 'General' word from the class names?\nIMO this is just as descriptive of a name CheckBattleEnd as is: CheckGeneralBattleEnd", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493900496", "createdAt": "2020-09-23T21:16:40Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMTQ5NQ==", "bodyText": "General stands for the \"general phase\" (that's what the rule books generally call it).  I would expect to add a CheckFirstStrikeBattleEnd and a CheckAaBattleEnd at some point.  So I'd like to keep General around.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493901495", "createdAt": "2020-09-23T21:18:57Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTY3MA==", "bodyText": "In this context, the word General IMHO simply does not add anything.\nSeeing these two would be fine by me:\n\nCheckFirstStrikeBattleEnd\nCheckBattleEnd\n\nI'll agree to disagree with you here. When you've lost context on this code and come back to it in a few weeks or months, perhaps in the back of your mind, check if you still have the same opinion and if the word 'general' adds more information or is actually more noise.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493905670", "createdAt": "2020-09-23T21:28:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEndOld.java", "diffHunk": "@@ -4,6 +4,7 @@\n import games.strategy.triplea.delegate.ExecutionStack;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDE5Mw=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjMzMzM3OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowMDo0N1rOHWTNkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDo1NTo0OFrOHWWWSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTQ5MQ==", "bodyText": "Why are all of the parameters being aliased (IE: re-assigned) to new variables up front here? The alternative would be to just use the parameter values inline.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493145491", "createdAt": "2020-09-23T02:00:47Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MzY5MQ==", "bodyText": "I initially didn't have the parameters object but codeclimate complained about too many parameters.  So I switched to the object but didn't want to add parameters. in front of all of the places.  Just laziness.  If you want parameters. inlined, I'll do it.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493193691", "createdAt": "2020-09-23T04:43:28Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTQ5MQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5Njg3NQ==", "bodyText": "In the places where it makes sense, perhaps most of them, please do.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493196875", "createdAt": "2020-09-23T04:55:48Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTQ5MQ=="}, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjM0MDAyOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowMjoxNlrOHWTRYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowMjoxNlrOHWTRYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NjQ2NQ==", "bodyText": "nit, mixture of abstractions code smell here. The other methods are high level, then this bit of functionality is very low level. Recommend to extract to a method so we can keep a consistent level of abstraction, eG: \"updateHistoryWithUnitsMoved(..)\"", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493146465", "createdAt": "2020-09-23T02:02:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjM0NjYxOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowMzo1MVrOHWTVEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowMzo1MVrOHWTVEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NzQwOQ==", "bodyText": "A method for a single line method call seems a overkill. Is the 'isHeadless' check truly needed? Even if it is, what do you think about inlining this?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493147409", "createdAt": "2020-09-23T02:03:51Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();\n+      change.add(ChangeFactory.moveUnits(battleState.getBattleSite(), retreatTo, units));\n+      bridge.addChange(change);\n+      battleState.retreatUnits(side, units);\n+\n+      addHistoryRetreat(bridge, units, \" retreated to \" + retreatTo.getName());\n+      notifyRetreat(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(\n+          bridge, retreatingPlayer, step, \" retreats\", \" retreats subs to \" + retreatTo.getName());\n+    }\n+  }\n+\n+  private static void playSound(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjM1Nzk3OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowNjozMlrOHWTbeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjowNjozMlrOHWTbeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0OTA0OQ==", "bodyText": "I think this method is here to avoid doing this same string concatenation in two places. IMO the indirection with overloaded method args is more harmful than duplicating two lines of code. WDYT of inlining this broadcast method @trevan ?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493149049", "createdAt": "2020-09-23T02:06:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  static class Parameters {\n+    BattleState battleState;\n+    BattleActions battleActions;\n+    BattleState.Side side;\n+    IDelegateBridge bridge;\n+    Collection<Territory> possibleRetreatSites;\n+    Collection<Unit> units;\n+    String step;\n+  }\n+\n+  public static void retreatUnits(final Parameters parameters) {\n+    final BattleState battleState = parameters.battleState;\n+    final BattleActions battleActions = parameters.battleActions;\n+    final BattleState.Side side = parameters.side;\n+    final IDelegateBridge bridge = parameters.bridge;\n+    final Collection<Territory> possibleRetreatSites = parameters.possibleRetreatSites;\n+    final Collection<Unit> units = parameters.units;\n+    final String step = parameters.step;\n+    final GamePlayer retreatingPlayer =\n+        side == BattleState.Side.DEFENSE ? battleState.getDefender() : battleState.getAttacker();\n+    final String text = retreatingPlayer.getName() + \" retreat subs?\";\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), step);\n+    final boolean isAttemptingSubmerge =\n+        possibleRetreatSites.size() == 1\n+            && possibleRetreatSites.contains(battleState.getBattleSite());\n+    final Territory retreatTo =\n+        isAttemptingSubmerge\n+            ? battleActions.querySubmergeTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text)\n+            : battleActions.queryRetreatTerritory(\n+                battleState, bridge, retreatingPlayer, possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    playSound(battleState, bridge, retreatingPlayer, units);\n+    if (battleState.getBattleSite().equals(retreatTo)) {\n+      submergeEvaders(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(bridge, retreatingPlayer, step, \" submerges subs\");\n+    } else {\n+\n+      final CompositeChange change = new CompositeChange();\n+      change.add(ChangeFactory.moveUnits(battleState.getBattleSite(), retreatTo, units));\n+      bridge.addChange(change);\n+      battleState.retreatUnits(side, units);\n+\n+      addHistoryRetreat(bridge, units, \" retreated to \" + retreatTo.getName());\n+      notifyRetreat(battleState, battleActions, units, side, bridge);\n+      broadcastRetreat(\n+          bridge, retreatingPlayer, step, \" retreats\", \" retreats subs to \" + retreatTo.getName());\n+    }\n+  }\n+\n+  private static void playSound(\n+      final BattleState battleState,\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final Collection<Unit> units) {\n+    if (battleState.isHeadless()) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(retreatingPlayer, units, MustFightBattle.RetreatType.SUBS, bridge);\n+  }\n+\n+  public static void submergeEvaders(\n+      final BattleState battleState,\n+      final BattleActions battleActions,\n+      final Collection<Unit> submerging,\n+      final BattleState.Side side,\n+      final IDelegateBridge bridge) {\n+    final CompositeChange change = new CompositeChange();\n+    for (final Unit u : submerging) {\n+      change.add(ChangeFactory.unitPropertyChange(u, true, Unit.SUBMERGED));\n+    }\n+    bridge.addChange(change);\n+    battleState.retreatUnits(side, submerging);\n+\n+    addHistoryRetreat(bridge, submerging, \" submerged\");\n+    notifyRetreat(battleState, battleActions, submerging, side, bridge);\n+  }\n+\n+  private static void addHistoryRetreat(\n+      final IDelegateBridge bridge, final Collection<Unit> units, final String suffix) {\n+    final String transcriptText = MyFormatter.unitsToText(units) + suffix;\n+    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(units));\n+  }\n+\n+  private static void notifyRetreat(\n+      final BattleState battleState,\n+      final BattleActions battleActions,\n+      final Collection<Unit> retreating,\n+      final BattleState.Side side,\n+      final IDelegateBridge bridge) {\n+    if (battleState.getUnits(side).isEmpty()) {\n+      battleActions.endBattle(side.getOpposite().won(), bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreating);\n+    }\n+  }\n+\n+  private static void broadcastRetreat(\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final String step,\n+      final String messageShortSuffix) {\n+    broadcastRetreat(bridge, retreatingPlayer, step, messageShortSuffix, messageShortSuffix);\n+  }\n+\n+  private static void broadcastRetreat(\n+      final IDelegateBridge bridge,\n+      final GamePlayer retreatingPlayer,\n+      final String step,\n+      final String messageShortSuffix,\n+      final String messageLongSuffix) {\n+    final String messageShort = retreatingPlayer.getName() + messageShortSuffix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a3cfcba81f0d2836e0747b3c9656996eed4a99d"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU3NDEzOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDo1ODo0MVrOHXGHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTozNTozNFrOHXGsfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTU0OA==", "bodyText": "What is meant by an 'evader'? Suggestion: A class javadoc perhaps could be used to clarify that.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493979548", "createdAt": "2020-09-24T00:58:41Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4ODk5MA==", "bodyText": "canEvade units.  But I'll add a javadoc.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493988990", "createdAt": "2020-09-24T01:35:34Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTU0OA=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU3NzIyOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowMDoxOFrOHXGJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowMDoxOFrOHXGJYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDAwMg==", "bodyText": "nit, are the parameter values mutable? Can these be marked as final? It's perhaps also worthwhile to mark the non-null ones as @Nonnull so that they are checked when the builder is constructed. A downside of lombok builder is that it's not compile time safe, required args can be omitted, so generally it's important to at least get runtime validation with the @Nonnull annotation.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493980002", "createdAt": "2020-09-24T01:00:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/EvaderRetreat.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import lombok.Builder;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.sound.SoundUtils;\n+\n+@UtilityClass\n+public class EvaderRetreat {\n+\n+  @Builder(toBuilder = true)\n+  public static class Parameters {\n+    BattleState battleState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU4ODk4OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowNzozM1rOHXGQHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTowNzozM1rOHXGQHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTcyNg==", "bodyText": "IMO the control flow would be better at the caller level. This method is a no-op otherwise an is just a void call from the caller. It provides some abstraction but a maintainer needs to jump around in the code to see that this is a potential no-op and when it would be a no-op. It also looks like the null check is dead-code.\nI suspect some details are a bit hidden that probably could be exposed to the caller that would make the code easier to follow. For example, instead of this:\n  @Override\n  public Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(\n      final Collection<Unit> retreatUnits) {\n    return Map.of(RetreatLocation.SAME_TERRITORY, retreatUnits);\n  }\n\nPerhaps the API should be:\nCollection<Unit> splitRetreatUnits(\n     RetreatLocation,\n      final Collection<Unit> retreatUnits)\n\nIn this way it'd be more obvious that if we are calling a non-nullable method, then we'd always have a key value for 'retreatingUnits' and one would then be very comfortable removing the null check.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493981726", "createdAt": "2020-09-24T01:07:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU5NDE4OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxMDo0M1rOHXGTFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMzo0MDowNVrOHXIi0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw==", "bodyText": "ditto on burying control flow in private methods, this should probably be pushed up a layer so it's obvious to a caller that this is a no-op method in certain conditions. Arguably it's a bug whenever a no-op method is invoked (Did the caller know they would get a no-op, if so, why would they call a no-op method? If the caller did not know, is the caller in an unknown state and computing garbage data?)", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982487", "createdAt": "2020-09-24T01:10:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5MTk2MQ==", "bodyText": "Codeclimate complained about too much complexity in the retreat method so I created these helper methods to move the if statements away.\nI, personally, don't see a problem with calling a no-op method when using abstractions.  In this case, the Retreater classes may or may not have these types of retreating instances.  The caller doesn't need to care.  It just needs to ask the Retreater for the data (which might be empty or null) and the helper method does the checks.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493991961", "createdAt": "2020-09-24T01:47:53Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NzgwNQ==", "bodyText": "In this case it hurts a bit as you lose context of why retreating units can be null (it can't). It makes it seem like this is called from multiple places. One needs to be careful about void method calls. They are generally poor abstractions.\nFor example, what if someone moves where this invoked or adds something in between where the method is called and where these variables are set.\nAnother scenario, what if you need an 'else' statement, in this case the abstraction breaks down completely since you are doing two different things. I think it is analgous to this:\n   doPrinting(Connection c);\n}\n\nvoid doPrinting(Connection c) {\n     if(c.connected) {\n          sendToFax();\n     }\n}\n\nvs:\n\nif(c.connected()) {\n  sendToFax();\n}\n\nAnd with an if/else branch:\n   doPrinting(Connection c);\n}\n\nprivate void doPrinting(Connection c) {\n     if(c.connected) {\n          sendToFax();\n     } else {\n          sendToCopier();\n    }\n}\n\nIn the above, you can see it is just as well to have the if/else statement at the higher level. I think it also comes back to trying to favor having control flow in one place, at a high level, then keep the private methods that are invoked to be functional.\nLast comment, when a no-op method, or a method is carved off with control-flow, it often means the abstraction is cut at a slightly awkward level. The method is not quite control flow, not quite functional. Either the method should do more control flow and invoke other methods, or it should be just the body of the if statement. So  I believe from that it is a code smell.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493997805", "createdAt": "2020-09-24T02:10:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5ODQ5OQ==", "bodyText": "I do think this is more cohesive and actually simpler since you (AFAIK) you don't have to worry about the empty change:\n    final var retreatingUnits = retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY);\n    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n      change.add(retreatOtherTerritoryUnits(bridge, retreatTo, retreatingUnits));\n    }\n\n    bridge.addChange(change);\n\n    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n    } else {\n      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n    }", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493998499", "createdAt": "2020-09-24T02:13:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5ODg3Nw==", "bodyText": "Even more, the if condition of the private method is duplicated, so the control flow is actually kind loopy to understand. We can simplify by combining, eg:\n    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n        retreater.splitRetreatUnits(retreatUnits);\n    final var retreatingUnits = retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY);\n    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n      retreatSameTerritoryUnits(\n          bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n      change.add(retreatOtherTerritoryUnits(bridge, retreatTo, retreatingUnits));\n    }\n\n    bridge.addChange(change);\n\n    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n    } else {\n      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n    }", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493998877", "createdAt": "2020-09-24T02:15:17Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwMTM4OQ==", "bodyText": "To fix the complexity of this method, I would do the above, but also make the 'retreat' method actually do a retreat. It violates the \"yoda\" principle: \"Do or do not, there is no try\".\nSpecifically here:\n    if (retreatTo == null) {\n      return;\n    }\n\nIn this case we have a 'retreat' method that is only conditionally doing a retreat.  If the method says 'retreat', I would expect it to do an unconditional retreat.\nIn this case I would do similar and push the control flow up a level so that this method has a SRP to it and does \"retreat\". In that case it then becomes the retreat sequence and no longer some of the logic if a retreat should be initiated and the actual sequence.\nEG:\n    if (retreater != null) {\n      final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n      final Collection<Territory> possibleRetreatSites =\n          retreater.getPossibleRetreatSites(retreatUnits);\n      final String text = retreater.getQueryText();\n      bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n      final Territory retreatTo =\n          battleActions.queryRetreatTerritory(\n              battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n      if (retreatTo != null) {\n        retreat(bridge, retreater, retreatTo);\n      }\n    }\n\nThis makes the 'retreatUnits' method more worthwhile, more control flow is pushed up. Now if you get to 'retreat', you actually know that is executed and is not yet more control flow and potentially a no-op.\nIt makes the retreat method much more cohesive too IMHO:\n  private void retreat(final IDelegateBridge bridge, final Retreater retreater, final Territory retreatTo) {\n    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n\n    SoundUtils.playRetreatType(\n        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n\n    final CompositeChange change = new CompositeChange();\n   :\n   :\n\nI would probably go on to rewrite the retreat method as follows:\n  private void retreat(final IDelegateBridge bridge, final Retreater retreater, final Territory retreatTo) {\n    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n\n    SoundUtils.playRetreatType(\n        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n\n    bridge.addChange(computeRetreatChange(...));\n    \n    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n    } else {\n      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n    }\n\n    bridge\n        .getDisplayChannelBroadcaster()\n        .notifyRetreat(\n            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n            getName(),\n            battleState.getAttacker());\n  }\n\nI think I woudl stop there for rewriting that method since you really need to then pivot functionality out of the bridge and I think it hits diminishing returns..\nIDK if this was overly pedantic for you, hopefully helpful maybe for some ideas, WDYT @trevan ?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494001389", "createdAt": "2020-09-24T02:25:31Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxOTI4MQ==", "bodyText": "I've reworked it.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494019281", "createdAt": "2020-09-24T03:40:05Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -61,71 +97,95 @@ public void retreatUnits(final IDelegateBridge bridge) {\n     if (battleState.isOver()) {\n       return;\n     }\n-    final RetreatData retreatData;\n \n-    if (battleState.isAmphibious()) {\n-      retreatData = getAmphibiousRetreatData();\n-      if (retreatData == null) {\n-        return;\n-      }\n+    Retreater retreater = null;\n \n+    if (battleState.isAmphibious()) {\n+      retreater = getAmphibiousRetreater();\n     } else if (canAttackerRetreat()) {\n-      retreatData =\n-          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n-    } else {\n-      return;\n+      retreater = new RetreaterGeneral(battleState);\n     }\n \n-    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+    if (retreater != null) {\n+      retreat(bridge, retreater);\n+    }\n   }\n \n-  private @Nullable RetreatData getAmphibiousRetreatData() {\n+  private Retreater getAmphibiousRetreater() {\n     if (canAttackerRetreatPartialAmphib()) {\n-      return RetreatData.of(\n-          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n-\n+      return new RetreaterPartialAmphibious(battleState);\n     } else if (canAttackerRetreatAmphibPlanes()) {\n-      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n-\n-    } else {\n-      return null;\n+      return new RetreaterAirAmphibious(battleState);\n     }\n+    return null;\n   }\n \n-  @Value(staticConstructor = \"of\")\n-  private static class RetreatData {\n-    RetreatType retreatType;\n-    Collection<Territory> retreatSites;\n-  }\n+  private void retreat(final IDelegateBridge bridge, final Retreater retreater) {\n+    final Collection<Unit> retreatUnits = retreater.getRetreatUnits();\n+    final Collection<Territory> possibleRetreatSites =\n+        retreater.getPossibleRetreatSites(retreatUnits);\n+    final String text = retreater.getQueryText();\n+\n+    bridge.getDisplayChannelBroadcaster().gotoBattleStep(battleState.getBattleId(), getName());\n+    final Territory retreatTo =\n+        battleActions.queryRetreatTerritory(\n+            battleState, bridge, battleState.getAttacker(), possibleRetreatSites, text);\n+    if (retreatTo == null) {\n+      return;\n+    }\n+    SoundUtils.playRetreatType(\n+        battleState.getAttacker(), retreatUnits, retreater.getRetreatType(), bridge);\n \n-  private boolean canAttackerRetreat() {\n-    return RetreatChecks.canAttackerRetreat(\n-        battleState.getUnits(BattleState.Side.DEFENSE),\n-        battleState.getGameData(),\n-        battleState::getAttackerRetreatTerritories,\n-        battleState.isAmphibious());\n-  }\n+    final CompositeChange change = new CompositeChange();\n \n-  private boolean canAttackerRetreatSeaPlanes() {\n-    return battleState.getBattleSite().isWater()\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+    change.add(retreater.extraRetreatChange(retreatTo, retreatUnits));\n+\n+    final Map<Retreater.RetreatLocation, Collection<Unit>> retreatingUnitMap =\n+        retreater.splitRetreatUnits(retreatUnits);\n+\n+    retreatSameTerritoryUnits(\n+        bridge, retreatingUnitMap.get(Retreater.RetreatLocation.SAME_TERRITORY));\n+    change.add(\n+        retreatOtherTerritoryUnits(\n+            bridge, retreatTo, retreatingUnitMap.get(Retreater.RetreatLocation.OTHER_TERRITORY)));\n+\n+    bridge.addChange(change);\n+\n+    if (battleState.getUnits(BattleState.Side.OFFENSE).isEmpty()) {\n+      battleActions.endBattle(IBattle.WhoWon.DEFENDER, bridge);\n+    } else {\n+      bridge.getDisplayChannelBroadcaster().notifyRetreat(battleState.getBattleId(), retreatUnits);\n+    }\n+\n+    bridge\n+        .getDisplayChannelBroadcaster()\n+        .notifyRetreat(\n+            battleState.getAttacker().getName() + retreater.getShortBroadcastSuffix(),\n+            battleState.getAttacker().getName() + retreater.getLongBroadcastSuffix(retreatTo),\n+            getName(),\n+            battleState.getAttacker());\n   }\n \n-  private boolean canAttackerRetreatPartialAmphib() {\n-    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      return false;\n+  private void retreatSameTerritoryUnits(\n+      final IDelegateBridge bridge, final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {\n+      battleState.retreatUnits(BattleState.Side.OFFENSE, retreatingUnits);\n+      final String transcriptText = MyFormatter.unitsToText(retreatingUnits) + \" retreated\";\n+      bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(retreatingUnits));\n     }\n-    // Only include land units when checking for allow amphibious retreat\n-    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n-        .filter(Matches.unitIsLand())\n-        .anyMatch(Predicate.not(Unit::getWasAmphibious));\n   }\n \n-  private boolean canAttackerRetreatAmphibPlanes() {\n-    final GameData gameData = battleState.getGameData();\n-    return (Properties.getWW2V2(gameData)\n-            || Properties.getAttackerRetreatPlanes(gameData)\n-            || Properties.getPartialAmphibiousRetreat(gameData))\n-        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  private Change retreatOtherTerritoryUnits(\n+      final IDelegateBridge bridge,\n+      final Territory retreatTo,\n+      final Collection<Unit> retreatingUnits) {\n+    if (retreatingUnits != null && !retreatingUnits.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjQ4Nw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU5NTM2OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxMToyOFrOHXGTyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxMjowNVrOHXGUbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjY2Ng==", "bodyText": "nit, good place for a ternary here. Any thoughts or objections to that?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982666", "createdAt": "2020-09-24T01:11:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -59,13 +66,36 @@ public Order getOrder() {\n   public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n     if (battleState.isOver()\n         || isDestroyerPresent()\n-        || !isEvaderPresent()\n-        || !isRetreatPossible()\n+        || isEvaderNotPresent()\n+        || isRetreatNotPossible()\n         || isAutoWinScenario()) {\n       return;\n     }\n-    battleActions.queryRetreat(\n-        false, RetreatType.SUBS, bridge, battleState.getAttackerRetreatTerritories());\n+\n+    final Collection<Unit> unitsToRetreat =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(BattleState.Side.OFFENSE), Matches.unitCanEvade());\n+    if (unitsToRetreat.isEmpty()) {\n+      return;\n+    }\n+\n+    final Collection<Territory> retreatTerritories;\n+    if (Properties.getSubmersibleSubs(battleState.getGameData())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjgyOQ==", "bodyText": "With a ternary done, one could even consider inlining and you'd remove the intermediate variable as well.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493982829", "createdAt": "2020-09-24T01:12:05Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -59,13 +66,36 @@ public Order getOrder() {\n   public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n     if (battleState.isOver()\n         || isDestroyerPresent()\n-        || !isEvaderPresent()\n-        || !isRetreatPossible()\n+        || isEvaderNotPresent()\n+        || isRetreatNotPossible()\n         || isAutoWinScenario()) {\n       return;\n     }\n-    battleActions.queryRetreat(\n-        false, RetreatType.SUBS, bridge, battleState.getAttackerRetreatTerritories());\n+\n+    final Collection<Unit> unitsToRetreat =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(BattleState.Side.OFFENSE), Matches.unitCanEvade());\n+    if (unitsToRetreat.isEmpty()) {\n+      return;\n+    }\n+\n+    final Collection<Territory> retreatTerritories;\n+    if (Properties.getSubmersibleSubs(battleState.getGameData())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MjY2Ng=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTU5ODExOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxMzoyMlrOHXGVdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNTo0OTowN1rOHXKnjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzA5Mw==", "bodyText": "I think a javadoc would do well here to explain what this abstraction is representing exactly. WDYT?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983093", "createdAt": "2020-09-24T01:13:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NDY0Mw==", "bodyText": "I mentioned when I first created this PR about turning these into \"change objects\".  I don't think it fits with any of the existing \"change\" interfaces (Change, HistoryNode are what I've found) because it either can't invert (such as Change) or it isn't just a history text (such as HistoryNode).  Maybe at some point, we might want to allow it to invert so being an instance of Change would be best.  WDYT?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493994643", "createdAt": "2020-09-24T01:58:31Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzA5Mw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MzI2Mw==", "bodyText": "If invert becomes a big problem, then we can probably compensate that by replaying the n-1 events. I think eventually we'll have a base-state that will be fixed that would allow us to do that. Overall I think the history probably should not be displaying every single change and changes would probably become more granular.\nI think there is some groundwork that needs to be done before we can get there, so I wouldn't force objects to be 'change' objects just yet unless it really fits.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494053263", "createdAt": "2020-09-24T05:49:07Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzA5Mw=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTYwMTc3OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxNToyMVrOHXGXpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMDozMzoxMlrOHXxCTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ==", "bodyText": "This seems to be a UI concern, I'm not sure if it belongs in this API as then any implementation is forced to mix UI and logic. Perhaps the caller could do a lookup of query text based on the retreat type?", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983655", "createdAt": "2020-09-24T01:15:21Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5MzM0NQ==", "bodyText": "These methods are a \"lookup of query text based on the retreat type\".  That's what this API is for: handling a specific retreat type with its related change objects and UI text.  Something has to keep the two together.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493993345", "createdAt": "2020-09-24T01:53:28Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NTE2NQ==", "bodyText": "The UI text element seems to make this interface very implementation specific and even coupled to the UI. If the query text is a function of the retreat type, and that is only used in one place, IMO it's a stronger interface if it's made more focused and loses the UI concern. The methods in this interface are generally all related to model, hence it's a bit out of place for the UI parts.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494055165", "createdAt": "2020-09-24T05:55:15Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MjkzOA==", "bodyText": "I'd prefer having the logic around the different types of retreats together but I've gone ahead and removed the text strings methods.  The caller now has switch statements to figure out which text to use.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494352938", "createdAt": "2020-09-24T14:12:09Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MjcwMg==", "bodyText": "I'm getting into over-engineering territory, IMO that implies just having multiple interfaces.\nRetreater & RetreaterUiLabels\nImplementations can then implement both interfaces, the interfaces themselves would be cohesive/whole, and you can pass around the right interface type depending on your need, if you need the UI portion or if you need the business logic portion. I recognize that we probably have the two concerns mixed in well enough though that we'd either see one interface inherit from the other or both interface types being passed around, both of which would be somewhat ugly.\nI appreciate you making that update though, thank you.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r494682702", "createdAt": "2020-09-25T00:33:12Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MzY1NQ=="}, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTYwMzc2OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxNjozM1rOHXGY0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxNjozM1rOHXGY0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4Mzk1NA==", "bodyText": "Ditto on UI concerns present in the API. Perhaps the caller can take care of this based on the retreat type.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493983954", "createdAt": "2020-09-24T01:16:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();\n+\n+  MustFightBattle.RetreatType getRetreatType();\n+\n+  Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(Collection<Unit> retreatUnits);\n+\n+  Change extraRetreatChange(Territory retreatTo, Collection<Unit> retreatUnits);\n+\n+  String getShortBroadcastSuffix();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTYwNzQ2OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxODo0NFrOHXGa7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMToxODo0NFrOHXGa7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4NDQ5Mg==", "bodyText": "I wonder if we are mixing responsibilities with this \"extraRetreatChange\" API. The retreat code probably should not know much about creating a change object.\nSuggestion: have the caller check the battle type, if amphib then the change is 'empty' or do not even add it to the change stack, otherwise inline the implementation code into the caller.", "url": "https://github.com/triplea-game/triplea/pull/7723#discussion_r493984492", "createdAt": "2020-09-24T01:18:44Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/Retreater.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+interface Retreater {\n+\n+  enum RetreatLocation {\n+    SAME_TERRITORY,\n+    OTHER_TERRITORY;\n+  }\n+\n+  Collection<Unit> getRetreatUnits();\n+\n+  Collection<Territory> getPossibleRetreatSites(Collection<Unit> retreatUnits);\n+\n+  String getQueryText();\n+\n+  MustFightBattle.RetreatType getRetreatType();\n+\n+  Map<RetreatLocation, Collection<Unit>> splitRetreatUnits(Collection<Unit> retreatUnits);\n+\n+  Change extraRetreatChange(Territory retreatTo, Collection<Unit> retreatUnits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25150f84d1bb65f9efbe783a4164d65fcb054d1d"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2848, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}