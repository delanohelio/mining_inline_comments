{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDI4NTE4", "number": 6046, "title": "Simplify Locking Mechanisms", "bodyText": "Follow-up to #5561\nMost of the changes are straightforward, but there are some changes with potential changes in behaviour.\nI'd highly recommend looking at this PR commit-by-commit.\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[x] Problem fix:  #5561\n[] Other:   \nTesting\n\nI verified I could start a normal game with fast AI, and didn't get any exceptions", "createdAt": "2020-03-13T22:17:57Z", "url": "https://github.com/triplea-game/triplea/pull/6046", "merged": true, "mergeCommit": {"oid": "8247e7968e34b99edfeea073a965b16b1293fa40"}, "closed": true, "closedAt": "2020-03-15T23:45:42Z", "author": {"login": "RoiEXLab"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNXNH_gH2gAyMzg4MDI4NTE4OjI0OTkyYTY0NzgyOWZjNmRmMDk2MjhmYzk2YTlkYTlhNDhjMTlkMDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNt6Q-AH2gAyMzg4MDI4NTE4OmY4ZTkyNTFiYzY1MmEzMDBhMTcwM2UzZTM5YzdhMDJjYzk4MmUxMGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "24992a647829fc6df09628fc96a9da9a48c19d07", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/24992a647829fc6df09628fc96a9da9a48c19d07", "committedDate": "2020-03-13T21:29:15Z", "message": "Use synchronized keyword over custom logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba091e96ed2c7fd9a3efd2006b80255fa91663aa", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/ba091e96ed2c7fd9a3efd2006b80255fa91663aa", "committedDate": "2020-03-13T21:49:41Z", "message": "Use mutex for Tile class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6a32905bb1ba7681bdf1d0bf69c105f07d3721e", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/a6a32905bb1ba7681bdf1d0bf69c105f07d3721e", "committedDate": "2020-03-13T21:58:02Z", "message": "Avoid using LockUtil"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ea20345128059c2e14ceb39b6a72a131e0deae7", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/0ea20345128059c2e14ceb39b6a72a131e0deae7", "committedDate": "2020-03-13T21:58:19Z", "message": "Remove now unused LockUtil class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4692b1dda01ed2d190008fb83c681ba3dd583e3b", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/4692b1dda01ed2d190008fb83c681ba3dd583e3b", "committedDate": "2020-03-13T22:04:36Z", "message": "Remove ReadWriteLock missing check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "committedDate": "2020-03-13T22:17:02Z", "message": "Fix NPE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjQ5NjM0", "url": "https://github.com/triplea-game/triplea/pull/6046#pullrequestreview-374649634", "createdAt": "2020-03-13T22:21:31Z", "commit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyMTozMVrOF2VAKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyMTozMVrOF2VAKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTUzMQ==", "bodyText": "Serialization is stupid -_-\nWe can't use the final keyword anymore, but I think this is better than performing a null-check that's impossible to fail if it wasn't for (de)serialization", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392511531", "createdAt": "2020-03-13T22:21:31Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameData.java", "diffHunk": "@@ -97,8 +95,10 @@\n   private transient GameDataEventListeners gameDataEventListeners = new GameDataEventListeners();\n \n   private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    // The process of deserializing makes use of this lock,\n+    // we'll get an NPE if we don't set this field here already.\n+    readWriteLock = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjUwNTQ4", "url": "https://github.com/triplea-game/triplea/pull/6046#pullrequestreview-374650548", "createdAt": "2020-03-13T22:24:22Z", "commit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyNDoyM1rOF2VDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyNDoyM1rOF2VDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjMxMw==", "bodyText": "Here and in Line 634 I wasn't sure if this was the best move to expose the mutex like this.\nIt should be pretty safe to do that, it only ensures that the image isn't changed somehow while we perform drawing operations", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392512313", "createdAt": "2020-03-13T22:24:23Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/triplea/ui/panels/map/MapPanel.java", "diffHunk": "@@ -813,8 +810,7 @@ private void drawTiles(\n       final List<Tile> undrawn) {\n     g.translate(-bounds.getX(), -bounds.getY());\n     for (final Tile tile : tileManager.getTiles(bounds)) {\n-      tile.acquireLock();\n-      try {\n+      synchronized (tile.getMutex()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NzAzMzIy", "url": "https://github.com/triplea-game/triplea/pull/6046#pullrequestreview-374703322", "createdAt": "2020-03-14T06:52:35Z", "commit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNjo1MjozNVrOF2YJeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNjo1ODo0NVrOF2YKuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzA2Ng==", "bodyText": "Do you understand why we need locks at all when rendering Tiles?\nThe thing I don't understand why there is just not a data copy done and that is rendered. I don't think locking actually really helps.\nThe scenarios I see:\nCase A)\n-> Tile grabs game lock\n-> Game update blocks waiting for lock\n-> Tile finishes rendering release lock\n-> Game  update happens. The tile rendering is now wrong and out of date\n-> (hopefully) Game update triggers a new rendering\n-> tile grabs an uncontested lock and does its rendering job.\nIf the tile blocks on a game update, then the tile is going to get correct data and just render once, but if the tile is locking first then it seems like the output will become wrong unless a new rendering occurs. I think a lot of TripleA locking is incorrect in this way, locks are grabbed to prevent contention during rendering, but we wind up with a stale result rendered and it's wrong anyways in the end, which means that just simply grabbing locks is not enough to get correctness. I think there are two problems: 1) concurrent changes and idempotent results, but also 2) result freshness and not rendering stale (and incorrect) data.\nTL:DR, I've long wondered why Tile doesn't just create an immutable copy and render that, it would be just as correct as if it had grabbed a lock.", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563066", "createdAt": "2020-03-14T06:52:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -15,9 +15,6 @@\n import java.util.List;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEyMA==", "bodyText": "This comment assumes it is known what is meant by a 'double buffer'. With humbleness, I'm not sure I know what it means! Perhaps this comment should be more direct about stating what we are solving/avoiding.", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563120", "createdAt": "2020-03-14T06:53:49Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEzNw==", "bodyText": "Minor: Did you consider using lombok for the getter?", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563137", "createdAt": "2020-03-14T06:54:11Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n+   * (the swing components support it internally, but we don't draw in batch) we expose this\n+   * internal mutex to prevent tiles being drawn mid-refresh.\n+   */\n+  public Object getMutex() {\n+    return mutex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzIzMg==", "bodyText": "Before we had a very fancy 'read/writer' lock where readers did not block each other. This mutex on the other hand is just a re-entrant lock but would block other readers? AFAIK this lock is grabbed many times in fast succession (kinda scary from many perspective, but it is how it works), can you speculate if there would be a performance impact and/or have you checked it?", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563232", "createdAt": "2020-03-14T06:55:55Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n+   * (the swing components support it internally, but we don't draw in batch) we expose this\n+   * internal mutex to prevent tiles being drawn mid-refresh.\n+   */\n+  public Object getMutex() {\n+    return mutex;\n   }\n \n   /** Returns the image representing this tile, re-rendering it first if the tile is dirty. */\n   public Image getImage(final GameData data, final MapData mapData) {\n     if (isDirty) {\n-      acquireLock();\n-      try {\n+      synchronized (mutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ==", "bodyText": "What a surprise to see this class deleted \ud83e\udd42 \ud83d\udcaf \ud83c\udf86  \ud83c\udf7e  \ud83c\udf89\nIs this class deleted because anywhere we used the lock util is not replaced with just standard java synchronization?", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563385", "createdAt": "2020-03-14T06:58:45Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/org/triplea/thread/LockUtil.java", "diffHunk": "@@ -1,154 +0,0 @@\n-package org.triplea.thread;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NzI1OTM0", "url": "https://github.com/triplea-game/triplea/pull/6046#pullrequestreview-374725934", "createdAt": "2020-03-14T13:03:07Z", "commit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQxMzowMzowN1rOF2Zmtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQxMzowNjo0MlrOF2ZnlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NjkzNQ==", "bodyText": "My experience with this class was that it was some sort of primitive deadlock detector for cases where multiple locks were acquired on different, but concurrent, code paths.  That is, it was an attempt to enforce consistent lock ordering by preventing constructs like the following:\nThread A                   Thread B\n--------                   --------\nsynchronized(lock1) {      synchronized(lock2) {\n  . . .                      . . .\n  synchronized(lock2) {      synchronized(lock1) {\n    . . .                      . . .\n  }                          }\n}                          }\n\nWhere the lock acquisitions may happen in totally different methods, and thus not be obvious to a developer that they are introducing an inconsistent lock ordering.\nI don't know if there are still such cases where the same set of locks are acquired on concurrent code paths.  If so, that would be the only reason I could see keeping this class around.", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392586935", "createdAt": "2020-03-14T13:03:07Z", "author": {"login": "ssoloff"}, "path": "game-core/src/main/java/org/triplea/thread/LockUtil.java", "diffHunk": "@@ -1,154 +0,0 @@\n-package org.triplea.thread;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import java.lang.ref.WeakReference;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.WeakHashMap;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.locks.Lock;\n-import lombok.extern.java.Log;\n-\n-/**\n- * Utility class for ensuring that locks are acquired in a consistent order.\n- *\n- * <p>Simply use this class and call acquireLock(aLock) releaseLock(aLock) instead of lock.lock(),\n- * lock.release(). If locks are acquired in an inconsistent order, an error message will be printed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NzE1Ng==", "bodyText": "Since you are always setting this field in readObject(), can it be marked transient?", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392587156", "createdAt": "2020-03-14T13:06:42Z", "author": {"login": "ssoloff"}, "path": "game-core/src/main/java/games/strategy/engine/data/GameData.java", "diffHunk": "@@ -59,8 +58,7 @@\n  */\n public class GameData implements Serializable {\n   private static final long serialVersionUID = -2612710634080125728L;\n-  private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n-  private transient LockUtil lockUtil = LockUtil.INSTANCE;\n+  private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8e9251bc652a300a1703e3e39c7a02cc982e10f", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/f8e9251bc652a300a1703e3e39c7a02cc982e10f", "committedDate": "2020-03-14T23:56:28Z", "message": "Use transient keyword"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3734, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}