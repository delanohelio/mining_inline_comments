{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1OTE0NjAw", "number": 7072, "title": "Clean up messy AI unit sorting code.", "bodyText": "Clean up messy AI unit sorting code.\nThis PR refactors the code to simplify the logic and remove duplication related to AI unit comparison.\nNo logic changes.\nNote: The code in question was one of the largest duplicated code blocks found by code climate.\n\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[X] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix\n[] Other:   \nTesting\nSanity check w/ all AI game.", "createdAt": "2020-07-08T03:45:31Z", "url": "https://github.com/triplea-game/triplea/pull/7072", "merged": true, "mergeCommit": {"oid": "a55664fedacb97d59344a54d887a5af3987d70aa"}, "closed": true, "closedAt": "2020-07-10T13:23:59Z", "author": {"login": "asvitkine"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyyFctAH2gAyNDQ1OTE0NjAwOmIyZGM1ZDc1MmQyNTdkNmRjOGM0MGMwMzVjN2MxOWI1NGI5YWFhYTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczjfOOAFqTQ0NjM5MjA1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "author": {"user": {"login": "asvitkine", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "committedDate": "2020-07-08T03:43:30Z", "message": "Clean up messy AI unit sorting code.\n\nThis PR refactors the code to simplify the logic and remove\nduplication related to AI unit comparison.\n\nNo logic changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Mzk4NDE4", "url": "https://github.com/triplea-game/triplea/pull/7072#pullrequestreview-444398418", "createdAt": "2020-07-08T04:07:23Z", "commit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDowNzoyNFrOGuXX7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDowNzoyNFrOGuXX7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDYzNg==", "bodyText": "This line is failing the custom code-convention check:\nAvoid using size() to check for empty or not empty\n\nEx: size() == 0 -> isEmpty(), size() > 0 -> !isEmpty()\n\n./game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java:127:          if (territories1.size() == 0) {\n\n[FIX]", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451270636", "createdAt": "2020-07-08T04:07:24Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0Mzk5MTE5", "url": "https://github.com/triplea-game/triplea/pull/7072#pullrequestreview-444399119", "createdAt": "2020-07-08T04:09:56Z", "commit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDowOTo1NlrOGuXaEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDoxMjoyMFrOGuXcdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTE4NQ==", "bodyText": "Any thoughts if filterNonWinningTerritories is a better name for this method?", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451271185", "createdAt": "2020-07-08T04:09:56Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.size() == 0) {\n             return 0;\n           }\n \n+          final Unit unit1 = o1.getKey();\n+          final Unit unit2 = o2.getKey();\n+\n           // Sort by attack efficiency\n-          int minPower1 = Integer.MAX_VALUE;\n-          for (final Territory t : o1.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o1.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower1) {\n-                minPower1 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua1 = UnitAttachment.get(o1.getKey().getType());\n-          if (ua1.getIsAir()) {\n-            minPower1 *= 10;\n-          }\n           final double attackEfficiency1 =\n-              (double) minPower1 / proData.getUnitValue(o1.getKey().getType());\n-          int minPower2 = Integer.MAX_VALUE;\n-          for (final Territory t : o2.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o2.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower2) {\n-                minPower2 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua2 = UnitAttachment.get(o2.getKey().getType());\n-          if (ua2.getIsAir()) {\n-            minPower2 *= 10;\n-          }\n+              calculateAttackEfficiency(proData, player, attackMap, territories1, unit1);\n           final double attackEfficiency2 =\n-              (double) minPower2 / proData.getUnitValue(o2.getKey().getType());\n+              calculateAttackEfficiency(proData, player, attackMap, territories2, unit2);\n           if (attackEfficiency1 != attackEfficiency2) {\n             return (attackEfficiency1 < attackEfficiency2) ? 1 : -1;\n           }\n \n-          // Check if unit types are equal and is air then sort by average distance\n-          if (o1.getKey().getType().equals(o2.getKey().getType())) {\n-            final boolean isAirUnit = UnitAttachment.get(o1.getKey().getType()).getIsAir();\n-            if (isAirUnit) {\n-              int distance1 = 0;\n-              for (final Territory t : o1.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance1 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o1.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              int distance2 = 0;\n-              for (final Territory t : o2.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance2 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o2.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              if (distance1 != distance2) {\n-                return distance1 - distance2;\n-              }\n+          final UnitType unitType1 = unit1.getType();\n+          final UnitType unitType2 = unit2.getType();\n+\n+          // If unit types are equal and are air, then sort by average distance.\n+          if (unitType1.equals(unitType2) && UnitAttachment.get(unitType1).getIsAir()) {\n+            final Predicate<Territory> predicate =\n+                ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true);\n+            final Territory territory1 = unitTerritoryMap.get(unit1);\n+            final Territory territory2 = unitTerritoryMap.get(unit2);\n+            int distance1 = 0;\n+            for (final Territory t : territories1) {\n+              distance1 += data.getMap().getDistanceIgnoreEndForCondition(territory1, t, predicate);\n+            }\n+            int distance2 = 0;\n+            for (final Territory t : territories2) {\n+              distance2 += data.getMap().getDistanceIgnoreEndForCondition(territory2, t, predicate);\n+            }\n+            if (distance1 != distance2) {\n+              return distance1 - distance2;\n             }\n           }\n-          return o1.getKey().getType().getName().compareTo(o2.getKey().getType().getName());\n+\n+          return unitType1.getName().compareTo(unitType2.getName());\n         });\n     final Map<Unit, Set<Territory>> sortedUnitAttackOptions = new LinkedHashMap<>();\n     for (final Map.Entry<Unit, Set<Territory>> entry : list) {\n       sortedUnitAttackOptions.put(entry.getKey(), entry.getValue());\n     }\n     return sortedUnitAttackOptions;\n   }\n+\n+  private static Collection<Territory> filterOutWinningTerritories(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw==", "bodyText": "Wow, this is quite the method \ud83d\udc4d\nLooks to be a very good use of priority queue, I like particularly how the data structure can just \"take care of itself\" and does the right thing.", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451271797", "createdAt": "2020-07-08T04:12:20Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/collections/CollectionUtils.java", "diffHunk": "@@ -113,4 +115,15 @@\n     return Iterables.elementsEqual(c1, c2)\n         || (c1.size() == c2.size() && c2.containsAll(c1) && c1.containsAll(c2));\n   }\n+\n+  /**\n+   * Creates a sorted, mutable collection containing the specified elements that will maintain its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTkyMTIx", "url": "https://github.com/triplea-game/triplea/pull/7072#pullrequestreview-444592121", "createdAt": "2020-07-08T09:56:37Z", "commit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTo1NjozOFrOGugzXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTo1OTo0NVrOGug6TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNTExOQ==", "bodyText": "I want to point out that calling a PriorityQueue \"sorted\" is misleading.\nWhen using it like this:\nfinal var queue = new PriorityQueue<>(elements.size(), comparator);\nsortedCollection.addAll(elements);\nwhile (!sortedCollection.isEmpty()) {\n  final var element = sortedCollection.remove();\n// Elements are returned in correct order\n}\nit works as expected, but the JavaDocs explicitly state that:\n\nThe Iterator provided in method iterator() and the Spliterator provided in method spliterator() are not guaranteed to traverse the elements of the priority queue in any particular order.\n\nWith that being said, a TreeSet might be the better data structure here, but only if the keys are unique so far (it doesn't permit multiple elements that the comparator considers \"equal\", even if equals returns false)", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451425119", "createdAt": "2020-07-08T09:56:38Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/collections/CollectionUtils.java", "diffHunk": "@@ -113,4 +115,15 @@\n     return Iterables.elementsEqual(c1, c2)\n         || (c1.size() == c2.size() && c2.containsAll(c1) && c1.containsAll(c2));\n   }\n+\n+  /**\n+   * Creates a sorted, mutable collection containing the specified elements that will maintain its", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw=="}, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNjg5Mw==", "bodyText": "Haven't checked if this works nicely in every case, but have you considered using the Comparator builder methods like\nComparator#comparing?\nWe have several examples in the code where Comparator#thenComparing is used to chain several conditions together.\nDepending on the complexity it will either make the code half the size because you only have to provide the key function once instead of twice, or make it close to unreadable because the pattern doesn't match the needs", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451426893", "createdAt": "2020-07-08T09:59:45Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -65,39 +71,23 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee0709e66596719901a96f49b7bee92df45929b5", "author": {"user": {"login": "asvitkine", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ee0709e66596719901a96f49b7bee92df45929b5", "committedDate": "2020-07-09T01:05:15Z", "message": "Address feedback:\n  -> isEmpty()\n  -> Use TreeMultiset\n  -> Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8195b272afc414bc6ad9a3c708d907580863c0e3", "author": {"user": {"login": "asvitkine", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/8195b272afc414bc6ad9a3c708d907580863c0e3", "committedDate": "2020-07-09T01:23:20Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2e955d34f0293600edc9c8219e9fc92f554e41d", "author": {"user": {"login": "asvitkine", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c2e955d34f0293600edc9c8219e9fc92f554e41d", "committedDate": "2020-07-10T02:08:59Z", "message": "Rename function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzkwNjQ1", "url": "https://github.com/triplea-game/triplea/pull/7072#pullrequestreview-446390645", "createdAt": "2020-07-10T13:15:00Z", "commit": {"oid": "c2e955d34f0293600edc9c8219e9fc92f554e41d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzoxNTowMFrOGv233Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzoxNjowNVrOGv26OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzNTI5Mw==", "bodyText": "Unrelated to this PR, just a general thought.\nI think writing this weird loop differently would make it more readable:\nfinal int powerWithout = DiceRoll.getTotalPower(\n              DiceRoll.getUnitPowerAndRollsForNormalBattles(\n                  sortedUnits,\n                  defendingUnits,\n                   sortedUnits,\n                   false,\n                   data,\n                   t,\n                   effects,\n                   false,\n                   null),\n                 data);\nsortedUnits.add(unit);\nfinal int powerWith = DiceRoll.getTotalPower(\n              DiceRoll.getUnitPowerAndRollsForNormalBattles(\n                  sortedUnits,\n                  defendingUnits,\n                   sortedUnits,\n                   false,\n                   data,\n                   t,\n                   effects,\n                   false,\n                   null),\n                 data);\n\nminPower = Math.min(powerWith - powerWithout, minPower);", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452835293", "createdAt": "2020-07-10T13:15:00Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              removeWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              removeWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.isEmpty()) {\n             return 0;\n           }\n \n+          final Unit unit1 = o1.getKey();\n+          final Unit unit2 = o2.getKey();\n+\n           // Sort by attack efficiency\n-          int minPower1 = Integer.MAX_VALUE;\n-          for (final Territory t : o1.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o1.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower1) {\n-                minPower1 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua1 = UnitAttachment.get(o1.getKey().getType());\n-          if (ua1.getIsAir()) {\n-            minPower1 *= 10;\n-          }\n           final double attackEfficiency1 =\n-              (double) minPower1 / proData.getUnitValue(o1.getKey().getType());\n-          int minPower2 = Integer.MAX_VALUE;\n-          for (final Territory t : o2.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o2.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower2) {\n-                minPower2 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua2 = UnitAttachment.get(o2.getKey().getType());\n-          if (ua2.getIsAir()) {\n-            minPower2 *= 10;\n-          }\n+              calculateAttackEfficiency(proData, player, attackMap, territories1, unit1);\n           final double attackEfficiency2 =\n-              (double) minPower2 / proData.getUnitValue(o2.getKey().getType());\n+              calculateAttackEfficiency(proData, player, attackMap, territories2, unit2);\n           if (attackEfficiency1 != attackEfficiency2) {\n             return (attackEfficiency1 < attackEfficiency2) ? 1 : -1;\n           }\n \n-          // Check if unit types are equal and is air then sort by average distance\n-          if (o1.getKey().getType().equals(o2.getKey().getType())) {\n-            final boolean isAirUnit = UnitAttachment.get(o1.getKey().getType()).getIsAir();\n-            if (isAirUnit) {\n-              int distance1 = 0;\n-              for (final Territory t : o1.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance1 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o1.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              int distance2 = 0;\n-              for (final Territory t : o2.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance2 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o2.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              if (distance1 != distance2) {\n-                return distance1 - distance2;\n-              }\n+          final UnitType unitType1 = unit1.getType();\n+          final UnitType unitType2 = unit2.getType();\n+\n+          // If unit types are equal and are air, then sort by average distance.\n+          if (unitType1.equals(unitType2) && UnitAttachment.get(unitType1).getIsAir()) {\n+            final Predicate<Territory> predicate =\n+                ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true);\n+            final Territory territory1 = unitTerritoryMap.get(unit1);\n+            final Territory territory2 = unitTerritoryMap.get(unit2);\n+            int distance1 = 0;\n+            for (final Territory t : territories1) {\n+              distance1 += data.getMap().getDistanceIgnoreEndForCondition(territory1, t, predicate);\n+            }\n+            int distance2 = 0;\n+            for (final Territory t : territories2) {\n+              distance2 += data.getMap().getDistanceIgnoreEndForCondition(territory2, t, predicate);\n+            }\n+            if (distance1 != distance2) {\n+              return distance1 - distance2;\n             }\n           }\n-          return o1.getKey().getType().getName().compareTo(o2.getKey().getType().getName());\n+\n+          return unitType1.getName().compareTo(unitType2.getName());\n         });\n     final Map<Unit, Set<Territory>> sortedUnitAttackOptions = new LinkedHashMap<>();\n     for (final Map.Entry<Unit, Set<Territory>> entry : list) {\n       sortedUnitAttackOptions.put(entry.getKey(), entry.getValue());\n     }\n     return sortedUnitAttackOptions;\n   }\n+\n+  private static Collection<Territory> removeWinningTerritories(\n+      final Collection<Territory> territories,\n+      final GamePlayer player,\n+      final Map<Territory, ProTerritory> attackMap,\n+      final ProOddsCalculator calc) {\n+    return territories.stream()\n+        .filter(\n+            t -> {\n+              final ProTerritory patd = attackMap.get(t);\n+              if (patd.getBattleResult() == null) {\n+                patd.estimateBattleResult(calc, player);\n+              }\n+              return !patd.isCurrentlyWins();\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private static double calculateAttackEfficiency(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final Map<Territory, ProTerritory> attackMap,\n+      final Collection<Territory> territories,\n+      final Unit unit) {\n+    final GameData data = proData.getData();\n+\n+    int minPower = Integer.MAX_VALUE;\n+    for (final Territory t : territories) {\n+      final Collection<TerritoryEffect> effects = TerritoryEffectHelper.getEffects(t);\n+      final UnitBattleComparator comparator =\n+          new UnitBattleComparator(false, proData.getUnitValueMap(), effects, data);\n+\n+      final List<Unit> defendingUnits =\n+          t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n+      final Collection<Unit> sortedUnits =\n+          CollectionUtils.createSortedCollection(attackMap.get(t).getUnits(), comparator);\n+      // Compare the difference in total power when including the unit or not.\n+      int powerDifference = 0;\n+      for (final boolean includeUnit : new boolean[] {false, true}) {\n+        if (includeUnit) {\n+          sortedUnits.add(unit);\n+        }\n+        powerDifference +=\n+            (includeUnit ? 1 : -1)\n+                * DiceRoll.getTotalPower(\n+                    DiceRoll.getUnitPowerAndRollsForNormalBattles(\n+                        sortedUnits,\n+                        defendingUnits,\n+                        sortedUnits,\n+                        false,\n+                        data,\n+                        t,\n+                        effects,\n+                        false,\n+                        null),\n+                    data);\n+      }\n+      if (powerDifference < minPower) {\n+        minPower = powerDifference;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2e955d34f0293600edc9c8219e9fc92f554e41d"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzNTg5Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452835896", "createdAt": "2020-07-10T13:16:05Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -65,39 +71,23 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNjg5Mw=="}, "originalCommit": {"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzkyMDU1", "url": "https://github.com/triplea-game/triplea/pull/7072#pullrequestreview-446392055", "createdAt": "2020-07-10T13:17:00Z", "commit": {"oid": "c2e955d34f0293600edc9c8219e9fc92f554e41d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3199, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}