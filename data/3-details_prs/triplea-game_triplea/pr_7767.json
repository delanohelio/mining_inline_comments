{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNDc1ODYw", "number": 7767, "title": "Fix: Casualty OOL handles amphibious and non-amphibious units in same battle", "bodyText": "The casualty OOL now checks the wasAmphibious instead of just assuming that all units are amphibious if the battle is amphibious.\nTesting\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note\n\nFIX|Non-amphibious units are sorted lower than similar amphibious units in AI casualty selection.", "createdAt": "2020-09-26T03:03:24Z", "url": "https://github.com/triplea-game/triplea/pull/7767", "merged": true, "mergeCommit": {"oid": "b1c747b20d8a9d93644eca100bf9c3c7f3630061"}, "closed": true, "closedAt": "2020-09-26T18:07:00Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMhYuaAH2gAyNDkzNDc1ODYwOjBlODk2NGMxMjJmNTRmOTczNGZmNjc2YjM2MDhkYmYyNjZkZjM5ODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMuXy4gFqTQ5NzAyMTQ3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/0e8964c122f54f9734ff676b3608dbf266df3980", "committedDate": "2020-09-26T02:58:12Z", "message": "Fix: Casualty OOL handles amphibious and non-amphibious units in same battle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTM0Nzc3", "url": "https://github.com/triplea-game/triplea/pull/7767#pullrequestreview-496934777", "createdAt": "2020-09-26T03:05:28Z", "commit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMzowNToyOFrOHYdAXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMzowNzoxMVrOHYdDEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzEwMQ==", "bodyText": "I don't know why the armor is the last unit.  This test has the same units as the improvedArtillery test except that one of the marines isn't amphibious.  I expected the tank to be below the amphibious marine like in the improvedArtillery but for some reason it is above.  I'm not entirely sure if this is correct behavior or some bug.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495403101", "createdAt": "2020-09-26T03:05:28Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLossesTestOnBigWorldV3.java", "diffHunk": "@@ -165,4 +161,115 @@ void infantryAndArtillery() {\n     assertThat(\n         \"Artillery has the better total power\", result.get(1).getType(), is(testData.artillery));\n   }\n+\n+  @Test\n+  void nonAmphibiousMarineWithAmphibiousAssault() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result, hasSize(4));\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(result.get(1), is(attackingUnits.get(1)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+    assertThat(result.get(3), is(attackingUnits.get(0)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzc5Mw==", "bodyText": "I'd really like to test that the cache was used and that the rest of the code was skipped, but it is all static based so I can't spy on method calls to see what is called or not.  I manually stepped through the code for this test to verify that the cache was being used.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495403793", "createdAt": "2020-09-26T03:07:11Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLossesTestOnBigWorldV3.java", "diffHunk": "@@ -165,4 +161,115 @@ void infantryAndArtillery() {\n     assertThat(\n         \"Artillery has the better total power\", result.get(1).getType(), is(testData.artillery));\n   }\n+\n+  @Test\n+  void nonAmphibiousMarineWithAmphibiousAssault() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result, hasSize(4));\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(result.get(1), is(attackingUnits.get(1)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+    assertThat(result.get(3), is(attackingUnits.get(0)));\n+  }\n+\n+  @Test\n+  void amphibiousAndNonAmphibiousCaching() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+\n+    final List<Unit> result2 =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits.subList(0, 3))\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result2, hasSize(3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTM2ODE3", "url": "https://github.com/triplea-game/triplea/pull/7767#pullrequestreview-496936817", "createdAt": "2020-09-26T03:42:20Z", "commit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMzo0MjoyMFrOHYdaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMzo1NDowNFrOHYdd6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTc3MQ==", "bodyText": "1st Casualty\nThe first casualty is clear to remove the non-amphib.\n2nd Casualty\nThis leaves the follow powers (where the +1 is support bonus):\ntank      3\nmarine    3 +1\nartillery 2\n\nf the artillery is taken, leaves total of 6\ntank 3\nmarine 3\n\nif the marine is taken, leaves total of 5\ntank 3\nartillery 2\n\nif the tank is taken, leaves total of 6\nmarine 3+1\nartillery 2\n\nRemoving the marine is a bad choice. This leaves a choice between artillery and tank with the same remaining power. Tank is more expensive and has better defensive power, so the choice is to remove artillery.\n3rd Casualty\nWe are left with this choice:\ntank 3\nmarine 3\n\nTank is more expensive and has better defensive value, so marine is the choice\n4th casualty\nTrivial case as we are left with only the tank.\nFinal ordering\nmarine, artillery, marine, tank", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495409771", "createdAt": "2020-09-26T03:42:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLossesTestOnBigWorldV3.java", "diffHunk": "@@ -165,4 +161,115 @@ void infantryAndArtillery() {\n     assertThat(\n         \"Artillery has the better total power\", result.get(1).getType(), is(testData.artillery));\n   }\n+\n+  @Test\n+  void nonAmphibiousMarineWithAmphibiousAssault() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result, hasSize(4));\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(result.get(1), is(attackingUnits.get(1)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+    assertThat(result.get(3), is(attackingUnits.get(0)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzEwMQ=="}, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDEyMA==", "bodyText": "IMO that is good enough. Though I think the cache is actually only used once. All of this code is called to determine where units are to be placed on the combat board, and then later we go through this path with cache when computing supports.\nI took a deep look at calculating supports some time ago but the performance was not super easy to match. If you're ever interested I could go over you where I left and what I think is a simple algorithm for this.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495410120", "createdAt": "2020-09-26T03:46:23Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLossesTestOnBigWorldV3.java", "diffHunk": "@@ -165,4 +161,115 @@ void infantryAndArtillery() {\n     assertThat(\n         \"Artillery has the better total power\", result.get(1).getType(), is(testData.artillery));\n   }\n+\n+  @Test\n+  void nonAmphibiousMarineWithAmphibiousAssault() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result, hasSize(4));\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(result.get(1), is(attackingUnits.get(1)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+    assertThat(result.get(3), is(attackingUnits.get(0)));\n+  }\n+\n+  @Test\n+  void amphibiousAndNonAmphibiousCaching() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(\n+        unit -> {\n+          unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)\n+              .ifPresent(\n+                  property -> {\n+                    try {\n+                      property.setValue(true);\n+                    } catch (final MutableProperty.InvalidValueException e) {\n+                      // should not happen\n+                    }\n+                  });\n+        });\n+\n+    final List<Unit> attackingUnits = new ArrayList<>(amphibUnits);\n+    attackingUnits.addAll(testData.marine(1));\n+\n+    final List<Unit> result =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits)\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(\n+        \"Non amphibious marine only has attack of 2 since it doesn't get marine bonus\",\n+        result.get(0),\n+        is(attackingUnits.get(3)));\n+    assertThat(\"Amphibious marine has attack of 3\", result.get(2), is(attackingUnits.get(2)));\n+\n+    final List<Unit> result2 =\n+        CasualtyOrderOfLosses.sortUnitsForCasualtiesWithSupport(\n+            CasualtyOrderOfLosses.Parameters.builder()\n+                .targetsToPickFrom(attackingUnits.subList(0, 3))\n+                .combatModifiers(\n+                    CombatModifiers.builder().defending(false).territoryEffects(List.of()).build())\n+                .player(testData.british)\n+                .enemyUnits(List.of())\n+                .battlesite(testData.france)\n+                .costs(testData.costMap)\n+                .data(testData.gameData)\n+                .build());\n+\n+    assertThat(result2, hasSize(3));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzc5Mw=="}, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDIwMQ==", "bodyText": "Would it be just as well to do set the property for just the marine rather than all units? That would remove the forEach loop", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495410201", "createdAt": "2020-09-26T03:47:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLossesTestOnBigWorldV3.java", "diffHunk": "@@ -165,4 +161,115 @@ void infantryAndArtillery() {\n     assertThat(\n         \"Artillery has the better total power\", result.get(1).getType(), is(testData.artillery));\n   }\n+\n+  @Test\n+  void nonAmphibiousMarineWithAmphibiousAssault() {\n+    testData.addTech(new ImprovedArtillerySupportAdvance(testData.gameData));\n+\n+    final List<Unit> amphibUnits = new ArrayList<>();\n+    amphibUnits.addAll(testData.tank(1));\n+    amphibUnits.addAll(testData.artillery(1));\n+    amphibUnits.addAll(testData.marine(1));\n+\n+    amphibUnits.forEach(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDI5Mw==", "bodyText": "Complete side note, I think we got an error report stating that this comparator is invalid. The error message was \"contract violated\". If the following are units, { u1, u2, u3}, and if {u1 < u2}, and {u2 < u3}, then the following should be true {u1 < u3}. Apparently it was not and we got an exception for that.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495410293", "createdAt": "2020-09-26T03:49:07Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/UnitBattleComparator.java", "diffHunk": "@@ -48,7 +47,7 @@ public UnitBattleComparator(\n       final Collection<TerritoryEffect> territoryEffects,\n       final GameData data,\n       final boolean bonus) {\n-    this(defending, costs, territoryEffects, data, bonus, false, false);\n+    this(defending, costs, territoryEffects, data, bonus, false);\n   }\n \n   public UnitBattleComparator(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDYzNg==", "bodyText": "I do suspect the cache will be incorrect here. If we fight a battle with non-amphib units, then later those units are amphib, the cache will have a value when we would have preferred to have had a cache miss.\nThere were already some problems here, and this code is certainly not fully correct, very complicated, and performance optimized (a really bad combination).\nAny thoughts @trevan ? I suspect that this is a consideration we are building in that just breaks this cache. We would not want a new cache value for every permutation of possibly amphib unit, that really blows it up in size.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495410636", "createdAt": "2020-09-26T03:53:26Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLosses.java", "diffHunk": "@@ -239,29 +237,34 @@ void clearOolCache() {\n     }\n     sortedWellEnoughUnitsList.addAll(sortedUnitsList);\n     // Cache result and all subsets of the result\n-    final List<UnitType> unitTypes = new ArrayList<>();\n+    final List<AmphibType> unitTypes = new ArrayList<>();\n     for (final Unit u : sortedWellEnoughUnitsList) {\n-      unitTypes.add(u.getType());\n+      unitTypes.add(AmphibType.of(u.getType(), u.getWasAmphibious()));\n     }\n-    for (final Iterator<UnitType> it = unitTypes.iterator(); it.hasNext(); ) {\n+    for (final Iterator<AmphibType> it = unitTypes.iterator(); it.hasNext(); ) {\n       oolCache.put(key, new ArrayList<>(unitTypes));\n-      final UnitType unitTypeToRemove = it.next();\n+      final AmphibType unitTypeToRemove = it.next();\n       targetTypes.remove(unitTypeToRemove);\n       key = computeOolCacheKey(parameters, targetTypes);\n       it.remove();\n     }\n     return sortedWellEnoughUnitsList;\n   }\n \n-  static String computeOolCacheKey(final Parameters parameters, final List<UnitType> targetTypes) {\n+  @Value(staticConstructor = \"of\")\n+  static class AmphibType {\n+    UnitType type;\n+    boolean isAmphibious;\n+  }\n+\n+  static String computeOolCacheKey(\n+      final Parameters parameters, final List<AmphibType> targetTypes) {\n     return parameters.player.getName()\n         + \"|\"\n         + parameters.battlesite.getName()\n         + \"|\"\n         + parameters.combatModifiers.isDefending()\n         + \"|\"\n-        + parameters.combatModifiers.isAmphibious()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDY2Ng==", "bodyText": "It's possibly an option to just allow the cache to be incorrect for amphib units.. though not ideal.", "url": "https://github.com/triplea-game/triplea/pull/7767#discussion_r495410666", "createdAt": "2020-09-26T03:54:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtyOrderOfLosses.java", "diffHunk": "@@ -239,29 +237,34 @@ void clearOolCache() {\n     }\n     sortedWellEnoughUnitsList.addAll(sortedUnitsList);\n     // Cache result and all subsets of the result\n-    final List<UnitType> unitTypes = new ArrayList<>();\n+    final List<AmphibType> unitTypes = new ArrayList<>();\n     for (final Unit u : sortedWellEnoughUnitsList) {\n-      unitTypes.add(u.getType());\n+      unitTypes.add(AmphibType.of(u.getType(), u.getWasAmphibious()));\n     }\n-    for (final Iterator<UnitType> it = unitTypes.iterator(); it.hasNext(); ) {\n+    for (final Iterator<AmphibType> it = unitTypes.iterator(); it.hasNext(); ) {\n       oolCache.put(key, new ArrayList<>(unitTypes));\n-      final UnitType unitTypeToRemove = it.next();\n+      final AmphibType unitTypeToRemove = it.next();\n       targetTypes.remove(unitTypeToRemove);\n       key = computeOolCacheKey(parameters, targetTypes);\n       it.remove();\n     }\n     return sortedWellEnoughUnitsList;\n   }\n \n-  static String computeOolCacheKey(final Parameters parameters, final List<UnitType> targetTypes) {\n+  @Value(staticConstructor = \"of\")\n+  static class AmphibType {\n+    UnitType type;\n+    boolean isAmphibious;\n+  }\n+\n+  static String computeOolCacheKey(\n+      final Parameters parameters, final List<AmphibType> targetTypes) {\n     return parameters.player.getName()\n         + \"|\"\n         + parameters.battlesite.getName()\n         + \"|\"\n         + parameters.combatModifiers.isDefending()\n         + \"|\"\n-        + parameters.combatModifiers.isAmphibious()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDYzNg=="}, "originalCommit": {"oid": "0e8964c122f54f9734ff676b3608dbf266df3980"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67ee40c0c5cc75e057273987637529dd5873d6df", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/67ee40c0c5cc75e057273987637529dd5873d6df", "committedDate": "2020-09-26T05:34:35Z", "message": "Only add amphibious to the cache key if the unit is a marine"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MDIxNDc5", "url": "https://github.com/triplea-game/triplea/pull/7767#pullrequestreview-497021479", "createdAt": "2020-09-26T18:05:57Z", "commit": {"oid": "67ee40c0c5cc75e057273987637529dd5873d6df"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3952, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}