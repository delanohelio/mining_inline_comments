{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MTk0ODUx", "number": 6138, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxMDoyNFrODu6wDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxNDoxM1rODu6xPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTIzNjYwOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxMDoyNFrOGBDZPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxMDoyNFrOGBDZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1NzM3NA==", "bodyText": "nit, I'd assign this to Collection. I've found that in cases where we pass Set to places that want a List parameter but could be a collection, we incur a collection copy unnecessarily.\nEG:\nfoo(List.of(set));\nvoid foo(List thisDoesNotHaveToBeList);\n\nvs:\n\nfoo(setPassedAsCollection)\nvoid foo(Collection anyCollectionWillDo);", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403757374", "createdAt": "2020-04-05T21:10:24Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -24,10 +26,9 @@\n   // the next number we can run\n   private long currentRunnableNumber = 0;\n   private final Object numberMutex = new Object();\n-  private final Object implementorsMutex = new Object();\n   private final String name;\n   private final Class<?> remoteClass;\n-  private final List<Object> implementors = new ArrayList<>();\n+  private final Set<Object> implementors = new CopyOnWriteArraySet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTIzNzczOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxMjowNFrOGBDZzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMzo1ODo0M1rOGBEjNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1NzUxOQ==", "bodyText": "Side-comment (as this is existing behavior):\nI've questioned a bit why the original code throws on this case.\nPerhaps because we're trying to detect a bug where we did not remove an implementor and we got the name wrong?\nIf that is the motivation, then adding a remove listener is probably a better way to go, or having a 'removeAll' hook maybe.", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403757519", "createdAt": "2020-04-05T21:12:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -91,19 +91,16 @@ public int getLocalImplementorCount() {\n    * @return we have no more implementors.\n    */\n   boolean removeImplementor(final Object implementor) {\n-    synchronized (implementorsMutex) {\n-      if (!implementors.remove(implementor)) {\n-        throw new IllegalStateException(\n-            \"Not removed, impl:\" + implementor + \" have \" + implementors);\n-      }\n-      return implementors.isEmpty();\n+    if (!implementors.remove(implementor)) {\n+      throw new IllegalStateException(\"Not removed, impl:\" + implementor + \" have \" + implementors);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NjMxMQ==", "bodyText": "removeAll maybe, but I don't think all use cases always remove everything.\nNo idea why the exception is there either.", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403776311", "createdAt": "2020-04-05T23:58:43Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -91,19 +91,16 @@ public int getLocalImplementorCount() {\n    * @return we have no more implementors.\n    */\n   boolean removeImplementor(final Object implementor) {\n-    synchronized (implementorsMutex) {\n-      if (!implementors.remove(implementor)) {\n-        throw new IllegalStateException(\n-            \"Not removed, impl:\" + implementor + \" have \" + implementors);\n-      }\n-      return implementors.isEmpty();\n+    if (!implementors.remove(implementor)) {\n+      throw new IllegalStateException(\"Not removed, impl:\" + implementor + \" have \" + implementors);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1NzUxOQ=="}, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTIzOTY3OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMToxNDoxM1rOGBDasw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwMTowNjozNFrOGBFGgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1Nzc0Nw==", "bodyText": "Important, is there any chance we will invoke this method while implementors are being removed? If so we could hit a concurrent modification exception. Have you considered creating an implementor collection copy? Since we are copying references of a couple dozen objects, it should be a negligibly cheap operation.", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403757747", "createdAt": "2020-04-05T21:14:13Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -119,16 +116,9 @@ boolean removeImplementor(final Object implementor) {\n \n   private List<RemoteMethodCallResults> invokeMultiple(\n       final RemoteMethodCall call, final INode messageOriginator) {\n-    // copy the implementors\n-    final List<Object> implementorsCopy;\n-    synchronized (implementorsMutex) {\n-      implementorsCopy = new ArrayList<>(implementors);\n-    }\n-    final List<RemoteMethodCallResults> results = new ArrayList<>(implementorsCopy.size());\n-    for (final Object implementor : implementorsCopy) {\n-      results.add(invokeSingle(call, implementor, messageOriginator));\n-    }\n-    return results;\n+    return implementors.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NjYzNQ==", "bodyText": "Unlikely we'll invoke both at the same time, but implementors is a thread safe implementation, which effectively creates a defensive copy whenever something is written to it so no worries there.", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403776635", "createdAt": "2020-04-06T00:01:19Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -119,16 +116,9 @@ boolean removeImplementor(final Object implementor) {\n \n   private List<RemoteMethodCallResults> invokeMultiple(\n       final RemoteMethodCall call, final INode messageOriginator) {\n-    // copy the implementors\n-    final List<Object> implementorsCopy;\n-    synchronized (implementorsMutex) {\n-      implementorsCopy = new ArrayList<>(implementors);\n-    }\n-    final List<RemoteMethodCallResults> results = new ArrayList<>(implementorsCopy.size());\n-    for (final Object implementor : implementorsCopy) {\n-      results.add(invokeSingle(call, implementor, messageOriginator));\n-    }\n-    return results;\n+    return implementors.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1Nzc0Nw=="}, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NTM0NA==", "bodyText": "Cool, thanks \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/6138#discussion_r403785344", "createdAt": "2020-04-06T01:06:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/message/unifiedmessenger/EndPoint.java", "diffHunk": "@@ -119,16 +116,9 @@ boolean removeImplementor(final Object implementor) {\n \n   private List<RemoteMethodCallResults> invokeMultiple(\n       final RemoteMethodCall call, final INode messageOriginator) {\n-    // copy the implementors\n-    final List<Object> implementorsCopy;\n-    synchronized (implementorsMutex) {\n-      implementorsCopy = new ArrayList<>(implementors);\n-    }\n-    final List<RemoteMethodCallResults> results = new ArrayList<>(implementorsCopy.size());\n-    for (final Object implementor : implementorsCopy) {\n-      results.add(invokeSingle(call, implementor, messageOriginator));\n-    }\n-    return results;\n+    return implementors.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1Nzc0Nw=="}, "originalCommit": {"oid": "6316656bd81a7c6aa71e544ae6229d0086339d3a"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2409, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}