{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MTEyNDc1", "number": 6007, "title": "Expire games", "bodyText": "Overview\nNoticed that the mechanism to remove closed games no longer works ever since we went to websocket for game listing. This update fixes that a bit by adding a game listing removal listener that will notify clients if a game times out and does not issue a keep alive.\nStill to do in future updates will be to send explicit game listing notices from game hosts that are shutting down back to the lobby.\nCommits\ncommit 25f3750\nNotify game client when lobby listings are expired from cache.\n\nGames are expired from cache if they are not renewed via keep-alive.\nCurrently nothing notifies clients when such a game is removed and\nthe client will think the game is still available. We previously\nwould have polled for all available games and the client would\ndetermine when games have been removed. Then after switching to\nwebsockets and an expiring cache, there was nothing done to replace\nthis notification mechanism.\n\nGetting a listener to be notified on cache expiry is a bit tricky and\nrequires a cleanup job to be run. To extract these details, we\ncreate a 'Cache' interface and consolidate CacheUtils to this interface.\nThen we create an implementation that will invoke a removed item listener.\nThis is done by creating a scheduled thread that periodically calls\n'cleanup' on the cache.\n\ncommit 1d2c34c\nAdd a number of contract tests for cache\n\ncommit c62312b\nRename \"stopTimer\" method to \"close\"\n\ncommit 1777ff9\nRemove mock cache from test\n\n \nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[] Code Cleanup or refactor\n[] Configuration Change\n[x] Problem fix:  \n[] Other:   \nTesting\n\n[x] Manual testing done", "createdAt": "2020-03-05T07:32:29Z", "url": "https://github.com/triplea-game/triplea/pull/6007", "merged": true, "mergeCommit": {"oid": "44bf62e86b083cb1bb5cd52bcf0a92c7dbdb507a"}, "closed": true, "closedAt": "2020-03-06T22:56:48Z", "author": {"login": "DanVanAtta"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKmhVwAH2gAyMzg0MTEyNDc1OjI1ZjM3NTAyNDVjYWMzMjg0MWRhYmRhNThlMTY0NmU2NzE5NWJmOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcLH6jAAH2gAyMzg0MTEyNDc1OjdkNGI5OGM5NmMxOTI1YTRhODAzZDEyMWRkY2FlODljNTI5MTEyY2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "25f3750245cac32841dabda58e1646e67195bf97", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/25f3750245cac32841dabda58e1646e67195bf97", "committedDate": "2020-03-05T07:38:08Z", "message": "Notify game client when lobby listings are expired from cache.\n\nGames are expired from cache if they are not renewed via keep-alive.\nCurrently nothing notifies clients when such a game is removed and\nthe client will think the game is still available. We previously\nwould have polled for all available games and the client would\ndetermine when games have been removed. Then after switching to\nwebsockets and an expiring cache, there was nothing done to replace\nthis notification mechanism.\n\nGetting a listener to be notified on cache expiry is a bit tricky and\nrequires a cleanup job to be run. To extract these details, we\ncreate a 'Cache' interface and consolidate CacheUtils to this interface.\nThen we create an implementation that will invoke a removed item listener.\nThis is done by creating a scheduled thread that periodically calls\n'cleanup' on the cache."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d2c34c25db927ec4a5ed45165a4cc33f3418923", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/1d2c34c25db927ec4a5ed45165a4cc33f3418923", "committedDate": "2020-03-05T07:38:08Z", "message": "Add a number of contract tests for cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c62312b1c8dfaa9524dedbd49bfffd5a0991aeb6", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/c62312b1c8dfaa9524dedbd49bfffd5a0991aeb6", "committedDate": "2020-03-05T07:38:08Z", "message": "Rename \"stopTimer\" method to \"close\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1777ff9ebf5a697b3475b9877c5684d7ce712569", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/1777ff9ebf5a697b3475b9877c5684d7ce712569", "committedDate": "2020-03-05T07:38:08Z", "message": "Remove mock cache from test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/738891c5a0e78879dfea1dd192a97f9f6c26510c", "committedDate": "2020-03-05T07:38:08Z", "message": "Notify removal listener explicitly on 'invalidate' calls\n\nThis makes tests more deterministic and avoids delays for the callback\nwhen waiting for 'cleanup'"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a04aec86b9311be0acea7e4d5141903dc2e871d9", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/a04aec86b9311be0acea7e4d5141903dc2e871d9", "committedDate": "2020-03-05T06:40:35Z", "message": "Shutdown lobby watcher on server game cancel"}, "afterCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/738891c5a0e78879dfea1dd192a97f9f6c26510c", "committedDate": "2020-03-05T07:38:08Z", "message": "Notify removal listener explicitly on 'invalidate' calls\n\nThis makes tests more deterministic and avoids delays for the callback\nwhen waiting for 'cleanup'"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODM3MzA5", "url": "https://github.com/triplea-game/triplea/pull/6007#pullrequestreview-369837309", "createdAt": "2020-03-05T19:08:11Z", "commit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTowODoxMVrOFygQWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyOToyMlrOFyhBCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMTU5NA==", "bodyText": "We usually use the single string notation where the different parts are separated with a colon + we have all the version numbers in the main build.gradle file", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388501594", "createdAt": "2020-03-05T19:08:11Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/build.gradle", "diffHunk": "@@ -1,5 +1,8 @@\n description = 'TripleA library for low-level helper APIs, ie: syntactic sugar'\n \n dependencies {\n+    // https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine\n+    compile group: 'com.github.ben-manes.caffeine', name: 'caffeine', version: '2.8.1'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg==", "bodyText": "What about using BiConsumer instead?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388504522", "createdAt": "2020-03-05T19:13:07Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw==", "bodyText": "Maybe I'm missing something, but why is removalListener called explicitly here?\nShouldn't invalidate trigger the listener by itself already?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388505647", "createdAt": "2020-03-05T19:15:09Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMTk5NA==", "bodyText": "Just had a look at the caffeine documentation because I thought the explicit casting was weird.\nYou can avoid (I'm 99% sure) the unchecked warning by using\n.<IdT, ValueT>removalListener((key, value, cause) -> {});\nInstead", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388511994", "createdAt": "2020-03-05T19:25:44Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw==", "bodyText": "what's the reason this task has a random id attached to it?", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388514057", "createdAt": "2020-03-05T19:29:22Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODczMjY5", "url": "https://github.com/triplea-game/triplea/pull/6007#pullrequestreview-369873269", "createdAt": "2020-03-05T20:01:03Z", "commit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMTowM1rOFyiEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMTowM1rOFyiEKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ==", "bodyText": "Atomically,\nreturn Optional.ofNullable(cache.asMap().replace(id, newValue));", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388531241", "createdAt": "2020-03-05T20:01:03Z", "author": {"login": "ben-manes"}, "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.triplea.java.cache;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import lombok.Value;\n+\n+public interface TtlCache<IdT, ValueT> {\n+\n+  /**\n+   * Extends the 'life' of a given entry and prevents cache expiration for another TTL. Returns true\n+   * if an element existed and was refreshed, returns false if no such element existed.\n+   */\n+  boolean refresh(IdT id);\n+\n+  /** Retrieves a value from the cache, if any. */\n+  Optional<ValueT> get(IdT id);\n+\n+  /** Places a new item in the cache, overwriting any values with the existing ID. */\n+  void put(IdT id, ValueT value);\n+\n+  /** Explicitly removes an item from cache, returns any such value that was removed. */\n+  Optional<ValueT> invalidate(IdT id);\n+\n+  /**\n+   * Places a new item in the cache if one existed with the same ID and replaces the existing value.\n+   * The replaced item is returned, otherwise returns an empty.\n+   */\n+  default Optional<ValueT> replace(IdT id, ValueT newValue) {\n+    final Optional<ValueT> value = get(id);\n+    if (value.isPresent()) {\n+      put(id, newValue);\n+    }\n+    return value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/f79804af90eaa1af9128d1daaff4072cb344b827", "committedDate": "2020-03-06T05:34:08Z", "message": "Test fix, game removed listener can be called multiple times."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5435f8a184db3486a1cfd6ea83b1ab7672483c90", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/5435f8a184db3486a1cfd6ea83b1ab7672483c90", "committedDate": "2020-03-06T06:25:53Z", "message": "Update dependency syntax and put version number in main build.gradle and reference through a variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1de5679fe9319f32fccce74aa4d81193c7207cd2", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/1de5679fe9319f32fccce74aa4d81193c7207cd2", "committedDate": "2020-03-06T06:29:51Z", "message": "Remove explicit casting by adding types to lambda parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eeb317b5d4c0300e7fc009009d94b7a98fe5f25", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/5eeb317b5d4c0300e7fc009009d94b7a98fe5f25", "committedDate": "2020-03-06T06:37:29Z", "message": "Use built-in Caffeine cache scheduler for maintenance operation scheduling\n\nMaintenance operations, the things that trigger removals and removal listeners\nto be notified are not reliably run all the time. The scheduler fixes this\nso that maintenance happens more frequently and we get a dependendable call\nto removal listeners."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa933b3ed5d6363701c39b6248d4acaa7468870d", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/fa933b3ed5d6363701c39b6248d4acaa7468870d", "committedDate": "2020-03-06T06:49:38Z", "message": "Update invalidate to have atomic removal and get of teh value being removed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08d724ea050e005ad56165aa99105ba719d956f5", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/08d724ea050e005ad56165aa99105ba719d956f5", "committedDate": "2020-03-06T07:03:22Z", "message": "Simplify replace and make replace atomic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTA0NzM4", "url": "https://github.com/triplea-game/triplea/pull/6007#pullrequestreview-370104738", "createdAt": "2020-03-06T06:26:02Z", "commit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjoyNjowM1rOFyuTgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowMzo0NFrOFyu4bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczMTc3OA==", "bodyText": "I realized late last night while going to bed that I forgot to update this (should have done a better self-review of this PR as well). I was waiting for this comment \ud83d\ude01\nUpdated:  5435f8a", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388731778", "createdAt": "2020-03-06T06:26:03Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/build.gradle", "diffHunk": "@@ -1,5 +1,8 @@\n description = 'TripleA library for low-level helper APIs, ie: syntactic sugar'\n \n dependencies {\n+    // https://mvnrepository.com/artifact/com.github.ben-manes.caffeine/caffeine\n+    compile group: 'com.github.ben-manes.caffeine', name: 'caffeine', version: '2.8.1'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwMTU5NA=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczMzA2NQ==", "bodyText": "Good suggestions, thank you - both work. I was struggling to find the right variant. Slightly leaning towards types on the lambda parameters, updated: 1de5679", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388733065", "createdAt": "2020-03-06T06:31:41Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczNTI3NA==", "bodyText": "@RoiEXLab the random id was so that in case we had multiple caches, the cleanup threads would be given different names. Admittedly, probably over-engineering on my part.\n@ben-manes, thank you for the suggestion, works like a charm \ud83d\udc4d\nI particularly like how we no longer have to clean up the timer thread that was scheduled here, it simplifies a good bit. Updated in: 5eeb317", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388735274", "createdAt": "2020-03-06T06:41:02Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODAxOQ==", "bodyText": "For better or worse, the explicit removal is to avoid any timing issues or non-determinism in test. If we do not have the explicit remove, then this test:\nhttps://github.com/triplea-game/triplea/pull/6007/files#diff-9e70eb2aee6299a62f6edd3626506959R148, updated to be repeated 1000 times will consistently have some failures, eg:\n    @RepeatedTest(1000)\n    void removalListenerIsInvokedWhenItemsAreInvalidated() {\n      realCache.put(\"id10\", 0);\n      realCache.invalidate(\"id10\");\n\n      verify(cacheRemovalListener, atLeastOnce()).accept(new CacheEntry<>(\"id10\", 0));\n    }\n\nWrapping an external API behind an interface can often be good to insulate our code from 3rd party, as a general practice, in large part it is done here with implementation so we can have a \"native\" API and reliable calls to 'removal listener'. That was what kinda kicked this whole thing off, the naive addition of removal listener to the guava cache simply did not work..\nGrant it, with a reliable scheduler, which I think we have, we should get reliable calls to removal listener. With that being said, having no delay for removed item notification and perfectly deterministic testing is IMO worth the cost of potentially having multiple calls to a removal listener.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738019", "createdAt": "2020-03-06T06:51:33Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODEyMg==", "bodyText": "@ben-manes good suggestion, I did not realize 'asMap' would modify the underlying cache. Updated: fa933b3", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738122", "createdAt": "2020-03-06T06:52:01Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ==", "bodyText": "@RoiEXLab FWIW, this is one place where guava kinda seemed to fall short, eg (below is demonstrate the explicit cast):\n  public Map<IdT, ValueT> asMap() {\n    Map<IdT, ValueT> map = (ConcurrentMap<IdT, ValueT>) CacheBuilder.newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388739599", "createdAt": "2020-03-06T06:57:29Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTIyOQ==", "bodyText": "Seems simpler, atomic is better - thank you for the suggestion! Updated: 08d724e", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388741229", "createdAt": "2020-03-06T07:03:44Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.triplea.java.cache;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import lombok.Value;\n+\n+public interface TtlCache<IdT, ValueT> {\n+\n+  /**\n+   * Extends the 'life' of a given entry and prevents cache expiration for another TTL. Returns true\n+   * if an element existed and was refreshed, returns false if no such element existed.\n+   */\n+  boolean refresh(IdT id);\n+\n+  /** Retrieves a value from the cache, if any. */\n+  Optional<ValueT> get(IdT id);\n+\n+  /** Places a new item in the cache, overwriting any values with the existing ID. */\n+  void put(IdT id, ValueT value);\n+\n+  /** Explicitly removes an item from cache, returns any such value that was removed. */\n+  Optional<ValueT> invalidate(IdT id);\n+\n+  /**\n+   * Places a new item in the cache if one existed with the same ID and replaces the existing value.\n+   * The replaced item is returned, otherwise returns an empty.\n+   */\n+  default Optional<ValueT> replace(IdT id, ValueT newValue) {\n+    final Optional<ValueT> value = get(id);\n+    if (value.isPresent()) {\n+      put(id, newValue);\n+    }\n+    return value;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzQ3MTUy", "url": "https://github.com/triplea-game/triplea/pull/6007#pullrequestreview-370347152", "createdAt": "2020-03-06T14:10:06Z", "commit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDoxMDowNlrOFy573g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDoxNDoxOVrOFy6FCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMjMzNA==", "bodyText": "@DanVanAtta If it's only the tests, then we could make the test wait until ForkJoinPool.commonPool() processed all events (I had a look at the source code), or alternatively just pass a custom executor for the test cases which simply runs the specified Runnable", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388922334", "createdAt": "2020-03-06T14:10:06Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMzE0Nw==", "bodyText": "I think the way it's supposed to be done is by doing something like:\nMap<IdT, ValueT> map = CacheBuilder.<IdT, ValueT>newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();\ninstead, but ok", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388923147", "createdAt": "2020-03-06T14:11:31Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ==", "bodyText": "Thinking about my suggestion that passes a custom executor for the tests: This particular tests would gain some extra safety, because in case the removalListener is executed asynchronously, the tests might check too early missing this critical error.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388924681", "createdAt": "2020-03-06T14:14:19Z", "author": {"login": "RoiEXLab"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdc8b2402708f7683a058b4ab11fe44289535e10", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/fdc8b2402708f7683a058b4ab11fe44289535e10", "committedDate": "2020-03-06T19:32:39Z", "message": "Use a bi-consumer for removal listener instead of consumer<entry>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/de60ba28b330df6290f88db7101ba28ee229abfd", "committedDate": "2020-03-06T07:06:56Z", "message": "Auto-Formatting"}, "afterCommit": {"oid": "fdc8b2402708f7683a058b4ab11fe44289535e10", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/fdc8b2402708f7683a058b4ab11fe44289535e10", "committedDate": "2020-03-06T19:32:39Z", "message": "Use a bi-consumer for removal listener instead of consumer<entry>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTY3ODE5", "url": "https://github.com/triplea-game/triplea/pull/6007#pullrequestreview-370567819", "createdAt": "2020-03-06T19:22:12Z", "commit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOToyMjoxMlrOFzEdbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOToyOToxN1rOFzEqYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NDc2Ng==", "bodyText": "Reasonable suggestions, though I think sticking with the explicit notification is okay:\n\nin our context we handle duplicate calls already (at least we should be!). Having a contract that allows for duplicate callbacks seems okay in general as well (and if not then there is room for other implementations to change that).\nthe test is already a bit slow at 700ms. Doing a join could mean we wait for the scheduled cleanup job which could add a second\na join in the test would turn the test from mostly if not entirely a black box test into a white box test. Tests that do not rely on internal implementations tend to be easier to understand and maintain\n\nA custom executor would also fall under the category of test scaffolding, it's better minimized. At the end of the day we also get benefit from an immediate callback, which does make the UI seem more responsive as games are removed nearly immediately and not after a small delay.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389094766", "createdAt": "2020-03-06T19:22:12Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, "originalCommit": {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NjQxMQ==", "bodyText": "Even that variant does not work, you get a type cast exception where ConcurrentMap<Object,Object> is not compatible. \ud83d\ude01", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389096411", "createdAt": "2020-03-06T19:25:36Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, "originalCommit": {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODA4Mw==", "bodyText": "Agree the test could miss the timing. In practice this won't be a problem, there is a trade-off here between a slow test and more thorough test. Adding a second long delay would be the thing to do, and/or making the cache scheduler really aggressive.\nI double checked with a timeout and many repeated tests, as expected the test stays solid which is the most important thing. At this point I'm happy leaving the test to be more behavior documentation/spec than full-proof.", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389098083", "createdAt": "2020-03-06T19:29:17Z", "author": {"login": "DanVanAtta"}, "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, "originalCommit": {"oid": "de60ba28b330df6290f88db7101ba28ee229abfd"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c96a3d18d5070f17902589f233a294f28c10bd0", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/0c96a3d18d5070f17902589f233a294f28c10bd0", "committedDate": "2020-03-06T20:06:29Z", "message": "Update test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff49e3184b6c846deced52ceedf666402edab561", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ff49e3184b6c846deced52ceedf666402edab561", "committedDate": "2020-03-06T20:08:47Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c1255de0c9f6ce7d3ff32795c7a9762accadc2", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/d3c1255de0c9f6ce7d3ff32795c7a9762accadc2", "committedDate": "2020-03-06T20:20:28Z", "message": "Update tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa4457b30a058a330731714ee870b8b23ef65332", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/fa4457b30a058a330731714ee870b8b23ef65332", "committedDate": "2020-03-06T20:45:57Z", "message": "Exclude conflicting caffeine dependency brought in by errorprone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4b98c96c1925a4a803d121ddcae89c529112ca", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/7d4b98c96c1925a4a803d121ddcae89c529112ca", "committedDate": "2020-03-06T22:32:32Z", "message": "Instead of excluding errorpone caffeine dep, define it explicitly to pick up the right version"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3718, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}