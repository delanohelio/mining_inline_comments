{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MzM5MDEz", "number": 6575, "title": "Simplify: Combine if statements", "bodyText": "Resolves various Codacy violations\nPlease double check for any 'or' conditions in particular and that if blocks are combined correctly\nPR is broken up into multiple to avoid review overload\nPlease review without whitespace changes, only changes to if statement blocks\n\nhttps://github.com/triplea-game/triplea/pull/6575/files?w=1", "createdAt": "2020-06-02T04:14:28Z", "url": "https://github.com/triplea-game/triplea/pull/6575", "merged": true, "mergeCommit": {"oid": "1f8aa5a628d9dcff6aa642d042be8237b38cd3f7"}, "closed": true, "closedAt": "2020-06-03T16:08:54Z", "author": {"login": "DanVanAtta"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnM6vagH2gAyNDI2MzM5MDEzOjYwZTJlZWViYWIzY2FlMWY5M2NjZDVmMzNlNmRkZmY3YWNlOTdhZmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnrxOmgFqTQyMzcxMzE0MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "committedDate": "2020-06-02T04:12:09Z", "message": "Simplify: Combine if statements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzMwNTUx", "url": "https://github.com/triplea-game/triplea/pull/6575#pullrequestreview-422330551", "createdAt": "2020-06-02T04:16:36Z", "commit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNDoxNjozNlrOGdhfhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNDoxNjozNlrOGdhfiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYyOQ==", "bodyText": "Avoid deeply nested control flow statements.", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610629", "createdAt": "2020-06-02T04:16:36Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleDelegate.java", "diffHunk": "@@ -1298,43 +1295,39 @@ private void doKamikazeSuicideAttacks() {\n         if (t.getUnits().stream().noneMatch(Matches.unitIsOwnedBy(player))) {\n           continue;\n         }\n-        if (onlyWhereThereAreBattlesOrAmphibious) {\n-          // if no battle or amphibious from here, ignore it\n-          if (!pendingBattles.contains(t)) {\n-            if (!Matches.territoryIsWater().test(t)) {\n-              continue;\n-            }\n-            boolean amphib = false;\n-            final Collection<Territory> landNeighbors =\n-                data.getMap().getNeighbors(t, Matches.territoryIsLand());\n-            for (final Territory neighbor : landNeighbors) {\n-              final IBattle battle =\n-                  battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n-              if (battle == null) {\n-                final Map<Territory, Collection<Unit>> whereFrom =\n-                    battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n-                if (whereFrom != null && whereFrom.containsKey(t)) {\n-                  amphib = true;\n-                  break;\n-                }\n-                continue;\n-              }\n-              if (battle.isAmphibious()\n-                  && ((battle instanceof MustFightBattle\n-                          && ((MustFightBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t))\n-                      || (battle instanceof NonFightingBattle\n-                          && ((NonFightingBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t)))) {\n+        // if no battle or amphibious from here, ignore it\n+        if (onlyWhereThereAreBattlesOrAmphibious && !pendingBattles.contains(t)) {\n+          if (!Matches.territoryIsWater().test(t)) {\n+            continue;\n+          }\n+          boolean amphib = false;\n+          final Collection<Territory> landNeighbors =\n+              data.getMap().getNeighbors(t, Matches.territoryIsLand());\n+          for (final Territory neighbor : landNeighbors) {\n+            final IBattle battle =\n+                battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n+            if (battle == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYzMA==", "bodyText": "Avoid deeply nested control flow statements.", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610630", "createdAt": "2020-06-02T04:16:36Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleDelegate.java", "diffHunk": "@@ -1298,43 +1295,39 @@ private void doKamikazeSuicideAttacks() {\n         if (t.getUnits().stream().noneMatch(Matches.unitIsOwnedBy(player))) {\n           continue;\n         }\n-        if (onlyWhereThereAreBattlesOrAmphibious) {\n-          // if no battle or amphibious from here, ignore it\n-          if (!pendingBattles.contains(t)) {\n-            if (!Matches.territoryIsWater().test(t)) {\n-              continue;\n-            }\n-            boolean amphib = false;\n-            final Collection<Territory> landNeighbors =\n-                data.getMap().getNeighbors(t, Matches.territoryIsLand());\n-            for (final Territory neighbor : landNeighbors) {\n-              final IBattle battle =\n-                  battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n-              if (battle == null) {\n-                final Map<Territory, Collection<Unit>> whereFrom =\n-                    battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n-                if (whereFrom != null && whereFrom.containsKey(t)) {\n-                  amphib = true;\n-                  break;\n-                }\n-                continue;\n-              }\n-              if (battle.isAmphibious()\n-                  && ((battle instanceof MustFightBattle\n-                          && ((MustFightBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t))\n-                      || (battle instanceof NonFightingBattle\n-                          && ((NonFightingBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t)))) {\n+        // if no battle or amphibious from here, ignore it\n+        if (onlyWhereThereAreBattlesOrAmphibious && !pendingBattles.contains(t)) {\n+          if (!Matches.territoryIsWater().test(t)) {\n+            continue;\n+          }\n+          boolean amphib = false;\n+          final Collection<Territory> landNeighbors =\n+              data.getMap().getNeighbors(t, Matches.territoryIsLand());\n+          for (final Territory neighbor : landNeighbors) {\n+            final IBattle battle =\n+                battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n+            if (battle == null) {\n+              final Map<Territory, Collection<Unit>> whereFrom =\n+                  battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n+              if (whereFrom != null && whereFrom.containsKey(t)) {\n                 amphib = true;\n                 break;\n               }\n-            }\n-            if (!amphib) {\n               continue;\n             }\n+            if (battle.isAmphibious()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYzMw==", "bodyText": "Avoid deeply nested control flow statements.", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610633", "createdAt": "2020-06-02T04:16:36Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProCombatMoveAi.java", "diffHunk": "@@ -370,20 +370,18 @@ private void determineTerritoriesToAttack(final List<ProTerritory> prioritizedTe\n         }\n \n         // If already used all transports then remove any remaining amphib territories\n-        if (!haveRemovedAllAmphibTerritories) {\n-          if (territoryManager.haveUsedAllAttackTransports()) {\n-            final List<ProTerritory> amphibTerritoriesToRemove = new ArrayList<>();\n-            for (int i = numToAttack; i < prioritizedTerritories.size(); i++) {\n-              if (prioritizedTerritories.get(i).isNeedAmphibUnits()) {\n-                amphibTerritoriesToRemove.add(prioritizedTerritories.get(i));\n-                ProLogger.debug(\n-                    \"Removing amphib territory since already used all transports: \"\n-                        + prioritizedTerritories.get(i).getTerritory().getName());\n-              }\n+        if (!haveRemovedAllAmphibTerritories && territoryManager.haveUsedAllAttackTransports()) {\n+          final List<ProTerritory> amphibTerritoriesToRemove = new ArrayList<>();\n+          for (int i = numToAttack; i < prioritizedTerritories.size(); i++) {\n+            if (prioritizedTerritories.get(i).isNeedAmphibUnits()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzEzMTQw", "url": "https://github.com/triplea-game/triplea/pull/6575#pullrequestreview-423713140", "createdAt": "2020-06-03T16:08:49Z", "commit": {"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3342, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}