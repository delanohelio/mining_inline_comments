{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMTE4MjE2", "number": 7901, "title": "Add builder for the fire round steps", "bodyText": "This is part of #7823\nThis basically replaces Fire and FireAa.  The four fire steps (AA, FirstStrike, General, and Bombard) will use this builder to build the three fire round steps.\nThe next PR after this will be the final integration.  I don't think I can split it up any more.  All of these classes will finally be plumbed through the system.  There will be a lot of test changes to deal with the string changes.\nTesting\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note", "createdAt": "2020-10-14T05:32:55Z", "url": "https://github.com/triplea-game/triplea/pull/7901", "merged": true, "mergeCommit": {"oid": "b0caa251eaac6b2ff4921dbd52a88f1d69ac4b5d"}, "closed": true, "closedAt": "2020-10-31T02:07:10Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSWVtpAH2gAyNTAzMTE4MjE2OjA4ZDA3ZTY0ZmY1ZWI2YmJhZDkwMjljNmYwYjJmODJjNzQ3ZmExMDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXYUW1gH2gAyNTAzMTE4MjE2OmQxOThmODU2YzI4OWQyMzg3NzE2YjJmZWQyNzBkNTgzMjQ5MDIyNzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "committedDate": "2020-10-14T05:29:30Z", "message": "Add builder for the fire round steps"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMDE5OTgz", "url": "https://github.com/triplea-game/triplea/pull/7901#pullrequestreview-511019983", "createdAt": "2020-10-17T22:47:22Z", "commit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QyMjo0NzoyMlrOHjgVfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QyMjo1NDoyOFrOHjgXgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MTk5OA==", "bodyText": "I think you could fit the builder pattern more exactly by removing the parameter object, adding @Builder to FireRoundStepsBuilder, and then convert this 'buildSteps' method to be a no-arg.\nEven doing that, I think this class would still be more of a factory. The following flow is a bit odd:\n*Builder.builder()\n     .\n     .\n     .build()\n     .buildSteps(...)\n\nIf we call this a factory though, I think it works out better and is arguably a better fit to the pattern (a builder tends to return the thing that is prefixed on the builder, EG: a stringBuilder returns a string, a \"gameBuilder' returns a 'game')\nCalling this a factory, we get something like:\nFireRoundStepsFactory.builder()\n             .\n             .\n             .build()\n             .createSteps();", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506991998", "createdAt": "2020-10-17T22:47:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;\n+  }\n+\n+  public static List<BattleStep> buildSteps(final Parameters parameters) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjEwNQ==", "bodyText": "nit, as a function name, what do you think of chaning 'selectCasualties' to 'casualtySelector'. As a verb I think it fits a bit better, eg:\nCasualtyDetails casualtyDetails = selectCasualties.apply(...)\n// vs\nasualtyDetails casualtyDetails =  casualtySelector.apply( ...)", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992105", "createdAt": "2020-10-17T22:48:56Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjE1Mw==", "bodyText": "Ditto for 'roll', perhaps better as 'diceRoller'?\nfiringGroupSplitter already has a verb kind of name, updating these last two bi-functions I think would make that naming more consistent in this class overall.", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992153", "createdAt": "2020-10-17T22:49:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjEwNQ=="}, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjM0NA==", "bodyText": "Maybe worth considering using the streaming API here? Seeing an array list copy raises flags for me, but that could just be me.\nAs a stream, we'd have soemthing like:\n final List<FiringGroup> firingGroups =\n   parameters.firingGroupSplitter.apply(parameters.battleState).stream().sorted(...).collect(Collectors.toList());", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992344", "createdAt": "2020-10-17T22:52:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;\n+  }\n+\n+  public static List<BattleStep> buildSteps(final Parameters parameters) {\n+    final List<BattleStep> steps = new ArrayList<>();\n+\n+    final List<FiringGroup> firingGroups =\n+        new ArrayList<>(parameters.firingGroupSplitter.apply(parameters.battleState));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjQ4MQ==", "bodyText": "Thoughts to use the iterable matcher here? You could avoid created the intermediate list and hopefully the failure message would be more user-friendly and tell you exactly how the lists mismatched, EG:\nassertThat(names, IsIterableContainingInOrder.contains(\n    \"attacker\" + FIRE_SUFFIX,\n            \"defender\" + SELECT_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX,\n            \"defender\" + REMOVE_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX));", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992481", "createdAt": "2020-10-17T22:54:08Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilderTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsBuilderTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            List.of(\n+                                FiringGroup.groupBySuicideOnHit(\n+                                        \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                    .get(0),\n+                                FiringGroup.groupBySuicideOnHit(\n+                                        \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                    .get(0)))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"attacker spies\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"spies\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"spies\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                UNITS, List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX);\n+    assertThat(names, is(expected));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjUxMw==", "bodyText": "Good use of @DisplayName  \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992513", "createdAt": "2020-10-17T22:54:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilderTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsBuilderTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97c0de4f8be4506f30d317e5b711b7462e3f81f", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d97c0de4f8be4506f30d317e5b711b7462e3f81f", "committedDate": "2020-10-20T21:54:33Z", "message": "Rename FireRoundStepsBuilder -> FireRoundStepsFactory and make it a builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0b114402433ce516454bb40c7d1e50dcc7f61b5", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c0b114402433ce516454bb40c7d1e50dcc7f61b5", "committedDate": "2020-10-20T22:01:53Z", "message": "Merge remote-tracking branch 'upstream/master' into fire-steps-builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/ce8ca5dc387a04f9d9e938c383a8917da32837a8", "committedDate": "2020-10-20T22:10:28Z", "message": "Use helper test methods in BattleStepsTest for step string matching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDYzOTAx", "url": "https://github.com/triplea-game/triplea/pull/7901#pullrequestreview-518063901", "createdAt": "2020-10-27T19:25:20Z", "commit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToyNToyMFrOHpNC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTozMjowM1rOHpNUhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NzQwNQ==", "bodyText": "What is the implied ordering of the output list from firingGroupSplitter? What contract would instances of this local variable need to satisfy to be consistent with the expected usages within this class?", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512967405", "createdAt": "2020-10-27T19:25:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2ODQzMA==", "bodyText": "Side note, we may want to rename 'RollDice'. 'RollDice' and 'diceRoll' being inverses of each other is somewhat confusing, the distinction seems to be very weak, another maintainer might see no real difference between the two terms.", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512968430", "createdAt": "2020-10-27T19:26:27Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+  @NonNull final BattleState.Side side;\n+  @NonNull final MustFightBattle.ReturnFire returnFire;\n+  @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> diceRoller;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDEwMA==", "bodyText": "nit, this seemingly could be simpler as a map + flatmap operation.\nEG:\nreturn   firingGroupSplitter.apply(battleState).stream()\n            .sorted(\n                Comparator.comparing(FiringGroup::getDisplayName)\n                    .thenComparing(FiringGroup::isSuicideOnHit))\n             .map(firingGroup -> List.of(new RollDice(battleState, side, firingGroup, fireRoundState, diceRoller),\n                           new SelectCasualties(battleState, side, firingGroup, fireRoundState, casualtySelector),\n                           new MarkCasualties(\n              battleState, battleActions, side, firingGroup, fireRoundState, returnFire))\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512970100", "createdAt": "2020-10-27T19:29:05Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+  @NonNull final BattleState.Side side;\n+  @NonNull final MustFightBattle.ReturnFire returnFire;\n+  @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> diceRoller;\n+  @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> casualtySelector;\n+\n+  public List<BattleStep> createSteps() {\n+    final List<BattleStep> steps = new ArrayList<>();\n+\n+    final List<FiringGroup> firingGroups =\n+        firingGroupSplitter.apply(battleState).stream()\n+            .sorted(\n+                Comparator.comparing(FiringGroup::getDisplayName)\n+                    .thenComparing(FiringGroup::isSuicideOnHit))\n+            .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDg5Mw==", "bodyText": "What is meant by 'readable'?", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512970893", "createdAt": "2020-10-27T19:30:26Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MTkxMA==", "bodyText": "nit, I notice there is no new line between the test setup and the invocation of the unit under test. Having the setup, invocation of the test unit, and the assertions be separated by a new line helps delimit them and helps the reader easily see what is being tested vs the setup. (Arrange, Act, Assert (AAA) testing pattern). Any objection to inserting such new lines?\nFor example,\ntestMethod() {\n    setupVar = setup...\n    player = ... setup\n    otherState = ... setup\n\n    resultValue = methodUnderTest.invoke(player, otherState ...)\n\n    assertions(....) \n}\n\nSide note on AAA\nI've even some styles where developers use boiler plate templates with comment blocks to delimit these sections, eg:\ntestMethod() {\n   // arrange\n\n   // act\n\n   // assert\n}\n\nI\"ve also seen those comments be called \"given, when, then\". IMO the comment blocks add clutter and the test method should be simple enough that simple new lines are delimiter enough to mark the different parts of a test. The latter should be possible almost all of the time, particularly if any complicated arrangements are extracted to helper methods that give a high level overview of what we are setting up with parameters for the key values that would control the result value of the unit under test.", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512971910", "createdAt": "2020-10-27T19:32:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b74ad007a4e6e18c604a25ae03d2583af0ec89b8", "committedDate": "2020-10-27T22:00:50Z", "message": "Review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjM2NTI5", "url": "https://github.com/triplea-game/triplea/pull/7901#pullrequestreview-518236529", "createdAt": "2020-10-28T00:04:34Z", "commit": {"oid": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDowNDozNFrOHpVTQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDowNDozNFrOHpVTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMjY1Nw==", "bodyText": "Why should units not be in the name?\nI think this would be a stronger statement if it were something like:\n\"A battle with offense and all suicide units should be labelled as 'XYZ'\"\nWith the above, I wonder why are we not checking for an exact name?\nI suspect that would be more obvious if the checked values were not behind a method. I also notice there is logic for a magic value of emptry string in generalFightStepStrings. I think it might make for stronger tests to inline the function everywhere in tests to make the assertions explicit and clear.", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513102657", "createdAt": "2020-10-28T00:04:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should not include UNITS\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            UNITS, List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        \"units should not be in the name\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjM3MTA3", "url": "https://github.com/triplea-game/triplea/pull/7901#pullrequestreview-518237107", "createdAt": "2020-10-28T00:06:16Z", "commit": {"oid": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDowNjoxNlrOHpVVbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDowNjoxNlrOHpVVbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMzIxNA==", "bodyText": "Maybe call it  RollDiceStep? or  RollDiceBattleStep\n\n\"Since in LL, dice isn't guaranteed to be rolled.\"\n\nI suppose it's a pedantic argument whether rolling 0 dice is rolling dice. If you took that view, then having a LL roll dice step would still make sense.", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513103214", "createdAt": "2020-10-28T00:06:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+  @NonNull final BattleState.Side side;\n+  @NonNull final MustFightBattle.ReturnFire returnFire;\n+  @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> diceRoller;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2ODQzMA=="}, "originalCommit": {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d198f856c289d2387716b2fed270d58324902279", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d198f856c289d2387716b2fed270d58324902279", "committedDate": "2020-10-29T20:37:27Z", "message": "Rename RollDice as RollDiceStep and rename the Rollers"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3894, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}