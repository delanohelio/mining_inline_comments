{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzNDA2MzI0", "number": 7596, "title": "Update: convert game parser to use xml-reader and map-data (StAX based parser)", "bodyText": "Changes GameParser over to use xml-reader & map-data\nThis conversion allows for more flexibility when parsing as we can more\neasily get the same different from different locations.\n\n\nGame parsing no longer requires or uses a DTD\nThis gives us flexibility going forward if change tags, an old or new map\nthat does not conform to such a standard would not get a DTD failure\nand we can help migrate the compatibility in code. DTD is still\nuseful for validation and we should see about building a map validation\ntool that would use it.\n\n\nGameParsing becomes simpler, it now assembles a GameData instead of\nparsing XML. The details of XML parsing are removed and things like\nchecking for child nodes is removed and we get native java types\nthat are already converted to for example integers or booleans.\n\n\n\nTesting\nDid some smoke testing to verify various games would launch. It looks like there was incidentally pretty good test coverage as we tend to parse full maps to do other testing (so there is quite a lot of map parsing in tests in addition to the 'validation' kicking off after parsing and the compatibility check parsing over a hundred more XMLs).\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nPerformance change was not measured to be significant. Sometimes faster, sometimes slower, looks like performance is more dependent perhaps on disk caching.\n\nRelease Note\nUPDATE|Map XML parser re-written to allow for more flexible XML structure. The XML DTD is no longer checked or used.", "createdAt": "2020-09-10T05:36:14Z", "url": "https://github.com/triplea-game/triplea/pull/7596", "merged": true, "mergeCommit": {"oid": "d3bcb8241b48c323ca7e1de15302fe5b28aedb5d"}, "closed": true, "closedAt": "2020-09-12T01:50:24Z", "author": {"login": "DanVanAtta"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHaJB7AH2gAyNDgzNDA2MzI0OjYyYmNkZGQyNWU2MzRlN2M3MzVjNDg1MjFkYjYwNTAxNmU0ZmM3ZTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdIo72KAFqTQ4NzM2NDY1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "committedDate": "2020-09-10T05:42:06Z", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5903c2acd06180691cb01a59ba546b0192555d2f", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/5903c2acd06180691cb01a59ba546b0192555d2f", "committedDate": "2020-09-10T05:23:44Z", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans."}, "afterCommit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "committedDate": "2020-09-10T05:42:06Z", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NjA1NzM1", "url": "https://github.com/triplea-game/triplea/pull/7596#pullrequestreview-485605735", "createdAt": "2020-09-10T06:04:13Z", "commit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjowNDoxM1rOHPkTNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjowNDoxM1rOHPkTNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NTQyOA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r486085428", "createdAt": "2020-09-10T06:04:13Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -618,216 +554,204 @@ private void parseDelegates(final List<Element> delegateList) throws GameParseEx\n     }\n   }\n \n-  private void parseSequence(final Node sequence) throws GameParseException {\n-    parseSteps(getChildren(\"step\", sequence));\n-  }\n-\n-  private void parseSteps(final List<Element> stepList) throws GameParseException {\n-    for (final Element current : stepList) {\n-      final IDelegate delegate = getDelegate(current.getAttribute(\"delegate\"));\n-      final GamePlayer player = getPlayerIdOptional(current.getAttribute(\"player\")).orElse(null);\n-      final String name = current.getAttribute(\"name\");\n+  private void parseSteps(final List<GamePlay.Sequence.Step> stepList) throws GameParseException {\n+    for (final GamePlay.Sequence.Step current : stepList) {\n+      final IDelegate delegate = getDelegate(current.getDelegate());\n+      final GamePlayer player = getPlayerIdOptional(current.getPlayer()).orElse(null);\n+      final String name = current.getName();\n       String displayName = null;\n-      final List<Element> propertyElements = getChildren(\"stepProperty\", current);\n-      final Properties stepProperties = parseStepProperties(propertyElements);\n-      if (current.hasAttribute(\"display\")) {\n-        displayName = current.getAttribute(\"display\");\n+      final Properties stepProperties = parseStepProperties(current.getStepProperties());\n+      if (!current.getDisplay().isBlank()) {\n+        displayName = current.getDisplay();\n       }\n       final GameStep step = new GameStep(name, displayName, player, delegate, data, stepProperties);\n-      if (current.hasAttribute(\"maxRunCount\")) {\n-        final int runCount = Integer.parseInt(current.getAttribute(\"maxRunCount\"));\n-        if (runCount <= 0) {\n-          throw new GameParseException(\"maxRunCount must be positive\");\n-        }\n-        step.setMaxRunCount(runCount);\n+      if (current.getMaxRunCount() > 0) {\n+        step.setMaxRunCount(current.getMaxRunCount());\n       }\n       data.getSequence().addStep(step);\n     }\n   }\n \n-  private static Properties parseStepProperties(final List<Element> properties) {\n+  private static Properties parseStepProperties(\n+      final List<GamePlay.Sequence.Step.StepProperty> properties) {\n     final Properties stepProperties = new Properties();\n-    for (final Element stepProperty : properties) {\n-      final String name = stepProperty.getAttribute(\"name\");\n-      final String value = stepProperty.getAttribute(\"value\");\n-      stepProperties.setProperty(name, value);\n-    }\n+    properties.forEach(\n+        stepProperty ->\n+            stepProperties.setProperty(stepProperty.getName(), stepProperty.getValue()));\n     return stepProperties;\n   }\n \n-  private void parseProduction(final Node root) throws GameParseException {\n-    parseProductionRules(getChildren(\"productionRule\", root));\n-    parseProductionFrontiers(getChildren(\"productionFrontier\", root));\n-    parsePlayerProduction(getChildren(\"playerProduction\", root));\n-    parseRepairRules(getChildren(\"repairRule\", root));\n-    parseRepairFrontiers(getChildren(\"repairFrontier\", root));\n-    parsePlayerRepair(getChildren(\"playerRepair\", root));\n-  }\n-\n-  private void parseTechnology(final Node root) throws GameParseException {\n-    parseTechnologies(getSingleChildOptional(\"technologies\", root).orElse(null));\n-    parsePlayerTech(getChildren(\"playerTech\", root));\n-  }\n-\n-  private void parseProductionRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n+  private void parseProductionRules(final List<Production.ProductionRule> elements)\n+      throws GameParseException {\n+    for (final Production.ProductionRule current : elements) {\n+      final String name = current.getName();\n       final ProductionRule rule = new ProductionRule(name, data);\n-      parseCosts(rule, getChildren(\"cost\", current));\n-      parseResults(rule, getChildren(\"result\", current));\n+      parseCosts(rule, current.getCosts());\n+      parseResults(rule, current.getResults());\n       data.getProductionRuleList().addProductionRule(rule);\n     }\n   }\n \n-  private void parseRepairRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n-      final RepairRule rule = new RepairRule(name, data);\n-      parseRepairCosts(rule, getChildren(\"cost\", current));\n-      parseRepairResults(rule, getChildren(\"result\", current));\n+  private void parseRepairRules(final List<Production.RepairRule> elements)\n+      throws GameParseException {\n+    for (final Production.RepairRule current : elements) {\n+      final RepairRule rule = new RepairRule(current.getName(), data);\n+      parseRepairCosts(rule, current.getCosts());\n+      parseRepairResults(rule, current.getResults());\n       data.getRepairRules().addRepairRule(rule);\n     }\n   }\n \n-  private void parseCosts(final ProductionRule rule, final List<Element> elements)\n+  private void parseCosts(\n+      final ProductionRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseRepairCosts(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairCosts(\n+      final RepairRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseResults(final ProductionRule rule, final List<Element> elements)\n+  private void parseResults(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2"}, "originalPosition": 794}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NTQzMA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r486085430", "createdAt": "2020-09-10T06:04:13Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -618,216 +554,204 @@ private void parseDelegates(final List<Element> delegateList) throws GameParseEx\n     }\n   }\n \n-  private void parseSequence(final Node sequence) throws GameParseException {\n-    parseSteps(getChildren(\"step\", sequence));\n-  }\n-\n-  private void parseSteps(final List<Element> stepList) throws GameParseException {\n-    for (final Element current : stepList) {\n-      final IDelegate delegate = getDelegate(current.getAttribute(\"delegate\"));\n-      final GamePlayer player = getPlayerIdOptional(current.getAttribute(\"player\")).orElse(null);\n-      final String name = current.getAttribute(\"name\");\n+  private void parseSteps(final List<GamePlay.Sequence.Step> stepList) throws GameParseException {\n+    for (final GamePlay.Sequence.Step current : stepList) {\n+      final IDelegate delegate = getDelegate(current.getDelegate());\n+      final GamePlayer player = getPlayerIdOptional(current.getPlayer()).orElse(null);\n+      final String name = current.getName();\n       String displayName = null;\n-      final List<Element> propertyElements = getChildren(\"stepProperty\", current);\n-      final Properties stepProperties = parseStepProperties(propertyElements);\n-      if (current.hasAttribute(\"display\")) {\n-        displayName = current.getAttribute(\"display\");\n+      final Properties stepProperties = parseStepProperties(current.getStepProperties());\n+      if (!current.getDisplay().isBlank()) {\n+        displayName = current.getDisplay();\n       }\n       final GameStep step = new GameStep(name, displayName, player, delegate, data, stepProperties);\n-      if (current.hasAttribute(\"maxRunCount\")) {\n-        final int runCount = Integer.parseInt(current.getAttribute(\"maxRunCount\"));\n-        if (runCount <= 0) {\n-          throw new GameParseException(\"maxRunCount must be positive\");\n-        }\n-        step.setMaxRunCount(runCount);\n+      if (current.getMaxRunCount() > 0) {\n+        step.setMaxRunCount(current.getMaxRunCount());\n       }\n       data.getSequence().addStep(step);\n     }\n   }\n \n-  private static Properties parseStepProperties(final List<Element> properties) {\n+  private static Properties parseStepProperties(\n+      final List<GamePlay.Sequence.Step.StepProperty> properties) {\n     final Properties stepProperties = new Properties();\n-    for (final Element stepProperty : properties) {\n-      final String name = stepProperty.getAttribute(\"name\");\n-      final String value = stepProperty.getAttribute(\"value\");\n-      stepProperties.setProperty(name, value);\n-    }\n+    properties.forEach(\n+        stepProperty ->\n+            stepProperties.setProperty(stepProperty.getName(), stepProperty.getValue()));\n     return stepProperties;\n   }\n \n-  private void parseProduction(final Node root) throws GameParseException {\n-    parseProductionRules(getChildren(\"productionRule\", root));\n-    parseProductionFrontiers(getChildren(\"productionFrontier\", root));\n-    parsePlayerProduction(getChildren(\"playerProduction\", root));\n-    parseRepairRules(getChildren(\"repairRule\", root));\n-    parseRepairFrontiers(getChildren(\"repairFrontier\", root));\n-    parsePlayerRepair(getChildren(\"playerRepair\", root));\n-  }\n-\n-  private void parseTechnology(final Node root) throws GameParseException {\n-    parseTechnologies(getSingleChildOptional(\"technologies\", root).orElse(null));\n-    parsePlayerTech(getChildren(\"playerTech\", root));\n-  }\n-\n-  private void parseProductionRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n+  private void parseProductionRules(final List<Production.ProductionRule> elements)\n+      throws GameParseException {\n+    for (final Production.ProductionRule current : elements) {\n+      final String name = current.getName();\n       final ProductionRule rule = new ProductionRule(name, data);\n-      parseCosts(rule, getChildren(\"cost\", current));\n-      parseResults(rule, getChildren(\"result\", current));\n+      parseCosts(rule, current.getCosts());\n+      parseResults(rule, current.getResults());\n       data.getProductionRuleList().addProductionRule(rule);\n     }\n   }\n \n-  private void parseRepairRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n-      final RepairRule rule = new RepairRule(name, data);\n-      parseRepairCosts(rule, getChildren(\"cost\", current));\n-      parseRepairResults(rule, getChildren(\"result\", current));\n+  private void parseRepairRules(final List<Production.RepairRule> elements)\n+      throws GameParseException {\n+    for (final Production.RepairRule current : elements) {\n+      final RepairRule rule = new RepairRule(current.getName(), data);\n+      parseRepairCosts(rule, current.getCosts());\n+      parseRepairResults(rule, current.getResults());\n       data.getRepairRules().addRepairRule(rule);\n     }\n   }\n \n-  private void parseCosts(final ProductionRule rule, final List<Element> elements)\n+  private void parseCosts(\n+      final ProductionRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseRepairCosts(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairCosts(\n+      final RepairRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseResults(final ProductionRule rule, final List<Element> elements)\n+  private void parseResults(\n+      final ProductionRule rule, final List<Production.ProductionRule.Result> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no results  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n+    for (final Production.ProductionRule.Result current : elements) {\n       // must find either a resource or a unit with the given name\n-      NamedAttachable result =\n-          getResourceOptional(current.getAttribute(\"resourceOrUnit\")).orElse(null);\n+      NamedAttachable result = getResourceOptional(current.getResourceOrUnit()).orElse(null);\n       if (result == null) {\n-        result = getUnitTypeOptional(current.getAttribute(\"resourceOrUnit\")).orElse(null);\n+        result = getUnitTypeOptional(current.getResourceOrUnit()).orElse(null);\n       }\n       if (result == null) {\n         throw new GameParseException(\n-            \"Could not find resource or unit\" + current.getAttribute(\"resourceOrUnit\"));\n+            \"Could not find resource or unit\" + current.getResourceOrUnit());\n       }\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+      final int quantity = current.getQuantity();\n       rule.addResult(result, quantity);\n     }\n   }\n \n-  private void parseRepairResults(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairResults(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2"}, "originalPosition": 822}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "919423169de88bf2a2f61ebe61265164aaa009c8", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/919423169de88bf2a2f61ebe61265164aaa009c8", "committedDate": "2020-09-10T07:24:35Z", "message": "Install a newer version of Java in Travis\n\nGetting an odd parse error within CDATA of an XML.\nThe java version on travis is a bit dated, trying\na newer JDK to resolve."}, "afterCommit": {"oid": "7becf1eec61d342f6fc3717dd604b8677c67b017", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/7becf1eec61d342f6fc3717dd604b8677c67b017", "committedDate": "2020-09-10T07:33:20Z", "message": "Install a newer version of Java in Travis\n\nGetting an odd parse error within CDATA of an XML.\nThe java version on travis is a bit dated, trying\na newer JDK to resolve."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3175394e349290af280e485ad9caad2dd7c73150", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/3175394e349290af280e485ad9caad2dd7c73150", "committedDate": "2020-09-10T08:19:39Z", "message": "Fix, install latest JDK for compatibility check rather than the smoke test."}, "afterCommit": {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "committedDate": "2020-09-10T05:42:06Z", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb", "committedDate": "2020-09-11T03:23:11Z", "message": "Keep parse exceptions at severe level.\n\nWhile this could create noise with error reports, knowing the frequency\nand why players hit parse exceptions can be useful. For example\notherwise we would have not known about the continued prevelance\nof 'attatchment' parse errors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzY0NjUw", "url": "https://github.com/triplea-game/triplea/pull/7596#pullrequestreview-487364650", "createdAt": "2020-09-14T01:23:03Z", "commit": {"oid": "4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToyMzowNFrOHRBKdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwMToyMzowNFrOHRBKdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjkwMw==", "bodyText": "I wonder where this check comes from. If the list is empty the for loop shouldn't iterate a single time and getRelationShipTracker doesn't look like it would throw an exception", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r487606903", "createdAt": "2020-09-14T01:23:04Z", "author": {"login": "RoiEXLab"}, "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -395,149 +371,118 @@ private void parseResources(final Element root) throws GameParseException {\n     return players;\n   }\n \n-  private void parseRelationshipTypes(final Element root) {\n-    getChildren(\"relationshipType\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseRelationshipTypes(final RelationshipTypes relationshipTypes) {\n+    relationshipTypes.getRelationshipTypes().stream()\n+        .map(RelationshipTypes.RelationshipType::getName)\n         .map(name -> new RelationshipType(name, data))\n         .forEach(data.getRelationshipTypeList()::addRelationshipType);\n   }\n \n-  private void parseTerritoryEffects(final Element root) {\n-    getChildren(\"territoryEffect\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseTerritoryEffects(final TerritoryEffectList territoryEffectList) {\n+    territoryEffectList.getTerritoryEffects().stream()\n+        .map(TerritoryEffectList.TerritoryEffect::getName)\n         .forEach(name -> data.getTerritoryEffectList().put(name, new TerritoryEffect(name, data)));\n   }\n \n-  private void parseUnits(final Element root) {\n-    getChildren(\"unit\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseUnits(final UnitList unitList) {\n+    unitList.getUnits().stream()\n+        .map(UnitList.Unit::getName)\n         .map(name -> new UnitType(name, data))\n         .forEach(data.getUnitTypeList()::addUnitType);\n   }\n \n-  private void parsePlayerList(final Element root) {\n-    final PlayerList playerList = data.getPlayerList();\n-    for (final Element current : getChildren(\"player\", root)) {\n-      final String name = current.getAttribute(\"name\");\n-      final boolean isOptional = current.getAttribute(\"optional\").equals(\"true\");\n-      final boolean canBeDisabled = current.getAttribute(\"canBeDisabled\").equals(\"true\");\n-      final String defaultType = current.getAttribute(\"defaultType\");\n-      final boolean isHidden = current.getAttribute(\"isHidden\").equals(\"true\");\n-      final GamePlayer newPlayer =\n-          new GamePlayer(name, isOptional, canBeDisabled, defaultType, isHidden, data);\n-      playerList.addPlayerId(newPlayer);\n-    }\n-  }\n-\n-  private void parseAlliances(final Element root) throws GameParseException {\n+  private void parsePlayerList(final PlayerList playerListData) {\n+    playerListData\n+        .getPlayers()\n+        .forEach(\n+            current ->\n+                data.getPlayerList()\n+                    .addPlayerId(\n+                        new GamePlayer(\n+                            current.getName(),\n+                            current.isOptional(),\n+                            current.isCanBeDisabled(),\n+                            current.getDefaultType(),\n+                            current.isHidden(),\n+                            data)));\n+  }\n+\n+  private void parseAlliances(final Game game) throws GameParseException {\n     final AllianceTracker allianceTracker = data.getAllianceTracker();\n     final Collection<GamePlayer> players = data.getPlayerList().getPlayers();\n-    for (final Element current : getChildren(\"alliance\", root)) {\n-      final GamePlayer p1 = getPlayerId(current.getAttribute(\"player\"));\n-      final String alliance = current.getAttribute(\"alliance\");\n+\n+    for (final PlayerList.Alliance current : game.getPlayerList().getAlliances()) {\n+      final GamePlayer p1 = getPlayerId(current.getPlayer());\n+      final String alliance = current.getAlliance();\n       allianceTracker.addToAlliance(p1, alliance);\n     }\n-    // if relationships aren't initialized based on relationshipInitialize we use the alliances to\n-    // set the relationships\n-    if (getSingleChildOptional(\"relationshipInitialize\", root).orElse(null) == null) {\n-      final RelationshipTracker relationshipTracker = data.getRelationshipTracker();\n-      final RelationshipTypeList relationshipTypeList = data.getRelationshipTypeList();\n-      // iterate through all players to get known allies and enemies\n-      for (final GamePlayer currentPlayer : players) {\n-        // start with all players as enemies\n-        // start with no players as allies\n-        final Set<GamePlayer> allies = allianceTracker.getAllies(currentPlayer);\n-        final Set<GamePlayer> enemies = new HashSet<>(players);\n-        enemies.removeAll(allies);\n-\n-        // remove self from enemies list (in case of free-for-all)\n-        enemies.remove(currentPlayer);\n-        // remove self from allies list (in case you are a member of an alliance)\n-        allies.remove(currentPlayer);\n-        // At this point enemies and allies should be set for this player.\n-        for (final GamePlayer alliedPLayer : allies) {\n-          relationshipTracker.setRelationship(\n-              currentPlayer, alliedPLayer, relationshipTypeList.getDefaultAlliedRelationship());\n-        }\n-        for (final GamePlayer enemyPlayer : enemies) {\n-          relationshipTracker.setRelationship(\n-              currentPlayer, enemyPlayer, relationshipTypeList.getDefaultWarRelationship());\n-        }\n+    final RelationshipTracker relationshipTracker = data.getRelationshipTracker();\n+    final RelationshipTypeList relationshipTypeList = data.getRelationshipTypeList();\n+    // iterate through all players to get known allies and enemies\n+    for (final GamePlayer currentPlayer : players) {\n+      // start with all players as enemies\n+      // start with no players as allies\n+      final Set<GamePlayer> allies = allianceTracker.getAllies(currentPlayer);\n+      final Set<GamePlayer> enemies = new HashSet<>(players);\n+      enemies.removeAll(allies);\n+\n+      // remove self from enemies list (in case of free-for-all)\n+      enemies.remove(currentPlayer);\n+      // remove self from allies list (in case you are a member of an alliance)\n+      allies.remove(currentPlayer);\n+      // At this point enemies and allies should be set for this player.\n+      for (final GamePlayer alliedPLayer : allies) {\n+        relationshipTracker.setRelationship(\n+            currentPlayer, alliedPLayer, relationshipTypeList.getDefaultAlliedRelationship());\n+      }\n+      for (final GamePlayer enemyPlayer : enemies) {\n+        relationshipTracker.setRelationship(\n+            currentPlayer, enemyPlayer, relationshipTypeList.getDefaultWarRelationship());\n       }\n     }\n   }\n \n-  private void parseRelationInitialize(final List<Element> relations) throws GameParseException {\n-    if (!relations.isEmpty()) {\n+  private void parseRelationInitialize(final Initialize.RelationshipInitialize relations)\n+      throws GameParseException {\n+    if (!relations.getRelationships().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb"}, "originalPosition": 472}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4000, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}