{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNDA1MTcx", "number": 8338, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjozOTozOVrOFBFq2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxNzo0M1rOFBZIQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg1Nzg1OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjozOTozOVrOH_rGug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjozOTozOVrOH_rGug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyODU3MA==", "bodyText": "It is interesting that an empty condition means that the operation to create guaranteed hit groups is not possible and implies that it's all just one large group from which we choose targets. The guaranteedHitGroups variable is possibly then doing double duty, non-empty means a succesful operation where we have results, and empty means that a result could not be computed because the split was not possible.\nAs-is, there seems to be an implicit inference based on implementation for when we have guaranteedHitGroups to be empty and what that implies. To fix this potential SRP code-smell we can make the object targetGroups be more expressive and have a method that returns the condition directly.\nEG, as a suggestion:\n\nif(targetGroups.hasGuaranteedHitGroups())\nif(targetGroups.canBeSplitIntoGuaranteedHitGroups())", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536528570", "createdAt": "2020-12-05T06:39:39Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg2NjY0OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo0Njo1N1rOH_rKZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo0Njo1N1rOH_rKZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyOTUwOA==", "bodyText": "It appears we are computed hitTargetIndices all with data from targetGroups. This is a possible 'feature envy' code smell. Have you considered pushing the computation of hitTargetIndices into the object targetGroups?\nEG:\nList<Unit> hitGroupTargets = targetGroups.computeHitGroupTargets(dice);\nreturn buildCasualtyDetails(availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n\nIn the above the majority of the branching logic becomes an implementation detail (the naming could certainly be better). In the end the net result is the control flow could become more clear perhaps, ie:\n- try to split into guaranteed targets\n   - if cannot, do random hits amongst available targets\n   - else do random hits amongst computed targets from target groups", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536529508", "createdAt": "2020-12-05T06:46:57Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg2ODU1OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo0ODoyMlrOH_rLMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo0ODoyMlrOH_rLMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyOTcxMg==", "bodyText": "Any thoughts to make this a constructor for LowLuckTargetGroups? There is enough in the target groups functionality that it can, IMHO, be a 1st class object. The API on it becomes relatively clear I think as well and would be suitable for isolated testing even.", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536529712", "createdAt": "2020-12-05T06:48:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg3MDgyOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo1MDoxOFrOH_rMOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo1NTowMVrOH_rPCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyOTk3OA==", "bodyText": "An explanatory variable or two could make this boolean condition easier to digest. WDYT of the following suggestion:\nboolean hasRemainder = lastGroup != null && lastGroup.size() != guaranteedHitGroupSize();\nif(hasRemainder) {\n\n }", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536529978", "createdAt": "2020-12-05T06:50:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUzMDY5Ng==", "bodyText": "Following up on this comment, there is quite a lot to chew on in this method.\nI wonder if we can avoid the check for 'lastGroup != null' with an early termination condition. The last group being null would seem to imply that something is empty. It's not quite clear to me what that thing would be, like, how would we get a null value here? I'm ultimately wondering if we can update the code in a way to moot this question and basically early terminate if we are going to have a null last group.\nPerhaps something like this:\n      if (!guaranteedGroups.isEmpty()) {\n        final List<Unit> lastGroup = guaranteedGroups.peekLast();\n        // if the last group isn't the right size, put those units in the remainder list\n        if (lastGroup.size() != guaranteeHitGroupSize) {\n          guaranteedGroups.removeLast();\n          remainderUnits.addAll(lastGroup);\n        }\n        guaranteedHitGroups.addAll(guaranteedGroups);\n      }", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536530696", "createdAt": "2020-12-05T06:55:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyOTk3OA=="}, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg4MjMwOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo1OTowMFrOH_rRLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNjo1OTowMFrOH_rRLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUzMTI0Nw==", "bodyText": "The body of the if statement takes a bit more effort to understand IMHO then is strictly necessary largely because we are re-using a variable from the peek last that we already used to determine if there is a remainder.\nFrom this:\n        guaranteedGroups.removeLast();\n        remainderUnits.addAll(lastGroup);\n\nI think it would be a bit easier to make this transfer explicit and eliminate the need for the reader to remember what the lastGroup variable is (particularly after it has been used for a different purpose). Suggestion:\nvar groupWithRemainderUnits = guaranteedGroups.removeLast();\nremainderUnits.addAll(groupWithRemainderUnits);", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536531247", "createdAt": "2020-12-05T06:59:00Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {\n+        guaranteedGroups.removeLast();\n+        remainderUnits.addAll(lastGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Njg4Nzc5OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNzowMzowOFrOH_rTfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNzowMzowOFrOH_rTfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUzMTgzOQ==", "bodyText": "Is this a place where we could early terminate and avoid processing on empty lists?\nEG:\n    final int guaranteeHitGroupSize =\n        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n   if(guaranteedHitGroupSize == 0) {\n           return LowLuckTargetGroups.NO_GUARANTEED_HITS;\n    }\n\nNote, this comment was made out of order for other comments below, this could moot some of those suggestions.", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536531839", "createdAt": "2020-12-05T07:03:08Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDAzMjgyOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzowODoxMFrOIAGU0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzowODoxMFrOIAGU0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk3NDU0Ng==", "bodyText": "It's not immediately clear what an overstack hit is. Maybe a quick comment explaining the term, or a different variable name would make this clear? I struggled here a bit and then reading a bit more later about the overstack AA hits it made more sense (but I'm still not sure I understand the concept TBH).", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536974546", "createdAt": "2020-12-06T07:08:10Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {\n+        guaranteedGroups.removeLast();\n+        remainderUnits.addAll(lastGroup);\n       }\n-    } else if (hits < availableTargets.size()) {\n-      // there isn't a roll for every target so need to randomly pick the target for each hit\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              availableTargets.size(),\n-              hits,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // turn the random numbers into a unique set of targets\n-      hitTargets = new HashSet<>();\n-      int index = 0;\n-      for (final int randomIndex : hitRandom) {\n-        index = (index + randomIndex) % availableTargets.size();\n-        while (hitTargets.contains(index)) {\n-          index = (index + 1) % availableTargets.size();\n-        }\n-        hitTargets.add(index);\n+      guaranteedHitGroups.addAll(guaranteedGroups);\n+    }\n+    return LowLuckTargetGroups.of(guaranteedHitGroups, remainderUnits);\n+  }\n+\n+  @Value(staticConstructor = \"of\")\n+  private static class LowLuckTargetGroups {\n+    List<List<Unit>> guaranteedHitGroups;\n+    List<Unit> remainderUnits;\n+  }\n+\n+  /**\n+   * Calculate the number of targets that guarantee a hit in a low luck dice roll\n+   *\n+   * <p>In low luck, the number of hits = (power / dice sides). If the strength for all of the aa\n+   * units is the same, then the number of hits = (strength * targetCount / diceSides). To find out\n+   * how big a group is needed to get a guaranteed hit, re-order the equation to be (targetCount /\n+   * hits) = (diceSides / strength). So, for every (diceSides / strength) targets, there is one\n+   * guaranteed hit.\n+   *\n+   * @return 0 if not possible to split up the targets into guaranteed hit groups or > 0 for the\n+   *     size that guarantees a hit\n+   */\n+  private static int calculateGuaranteeLowLuckHitGroupSize(\n+      final Collection<Unit> availableTargets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n+    final int bestStrength = unitPowerAndRollsMap.getBestStrength();\n+    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n+\n+    final boolean hasOverstackHits =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDAzOTU5OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxMzoxNVrOIAGXtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxMzoxNVrOIAGXtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk3NTI4Nw==", "bodyText": "Perhaps a style preference on my part, to another extent I see we are doing the 'single-return' point design as well. I think some this method block would be relatively clear returning when we can. For example, the last 'else' statement would avoid some extra thought to realize that `availableTargets' is equal to 'hitTargets'.\nPersonally I've come to find the single-return point design is only really good for longer methods, ones that are complicated and return for different reasons at different places. For short methods, something like the below is just fine IMO:\nif\n   return\nelse if\n   return\nelse\n   return\n\nThe above example I'd say is more clear than the single return variable, ie:\nvar returnVal;\nif\n   returnVal = a\nelse if\n   returnVal =b\nelse\n   returnVal =c\n\nreturn returnVal", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536975287", "createdAt": "2020-12-06T07:13:15Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {\n+        guaranteedGroups.removeLast();\n+        remainderUnits.addAll(lastGroup);\n       }\n-    } else if (hits < availableTargets.size()) {\n-      // there isn't a roll for every target so need to randomly pick the target for each hit\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              availableTargets.size(),\n-              hits,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // turn the random numbers into a unique set of targets\n-      hitTargets = new HashSet<>();\n-      int index = 0;\n-      for (final int randomIndex : hitRandom) {\n-        index = (index + randomIndex) % availableTargets.size();\n-        while (hitTargets.contains(index)) {\n-          index = (index + 1) % availableTargets.size();\n-        }\n-        hitTargets.add(index);\n+      guaranteedHitGroups.addAll(guaranteedGroups);\n+    }\n+    return LowLuckTargetGroups.of(guaranteedHitGroups, remainderUnits);\n+  }\n+\n+  @Value(staticConstructor = \"of\")\n+  private static class LowLuckTargetGroups {\n+    List<List<Unit>> guaranteedHitGroups;\n+    List<Unit> remainderUnits;\n+  }\n+\n+  /**\n+   * Calculate the number of targets that guarantee a hit in a low luck dice roll\n+   *\n+   * <p>In low luck, the number of hits = (power / dice sides). If the strength for all of the aa\n+   * units is the same, then the number of hits = (strength * targetCount / diceSides). To find out\n+   * how big a group is needed to get a guaranteed hit, re-order the equation to be (targetCount /\n+   * hits) = (diceSides / strength). So, for every (diceSides / strength) targets, there is one\n+   * guaranteed hit.\n+   *\n+   * @return 0 if not possible to split up the targets into guaranteed hit groups or > 0 for the\n+   *     size that guarantees a hit\n+   */\n+  private static int calculateGuaranteeLowLuckHitGroupSize(\n+      final Collection<Unit> availableTargets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n+    final int bestStrength = unitPowerAndRollsMap.getBestStrength();\n+    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n+\n+    final boolean hasOverstackHits =\n+        diceRoll.getHits()\n+            > Math.ceil(\n+                (double) (bestStrength * availableTargets.size()) / (double) chosenDiceSize);\n+\n+    // if the aa units aren't the same strength, then it isn't possible to calculate the target\n+    // count for a guaranteed hit because different strengths have different target counts.\n+    if (!unitPowerAndRollsMap.isSameStrength()\n+        // if there are more hits than (strength * targetCount / diceSides), then there must have\n+        // been overstack AA and that messes up the target count.\n+        || hasOverstackHits\n+        // if the best strength isn't a factor of chosenDiceSize, then the target count will be\n+        // fractional which doesn't work\n+        || chosenDiceSize % bestStrength != 0) {\n+      return 0;\n+    }\n+\n+    return chosenDiceSize / bestStrength;\n+  }\n+\n+  /** Select a random set of targets out of availableTargets */\n+  private static Collection<Unit> findRandomTargets(\n+      final List<Unit> availableTargets, final IDelegateBridge bridge, final int hits) {\n+    final int[] hitRandom =\n+        bridge.getRandom(\n+            availableTargets.size(),\n+            hits,\n+            null,\n+            DiceType.ENGINE,\n+            \"Deciding which planes should die due to AA fire\");\n+    // turn the random numbers into a unique set of targets\n+    final Set<Integer> hitTargets = new HashSet<>();\n+    int index = 0;\n+    for (final int randomIndex : hitRandom) {\n+      index = (index + randomIndex) % availableTargets.size();\n+      while (hitTargets.contains(index)) {\n+        index = (index + 1) % availableTargets.size();\n       }\n-    } else {\n-      // all targets were hit so add them all\n-      hitTargets = IntStream.range(0, availableTargets.size()).boxed().collect(Collectors.toSet());\n+      hitTargets.add(index);\n     }\n+    return hitTargets.stream().map(availableTargets::get).collect(Collectors.toList());\n+  }\n \n+  private static CasualtyDetails buildCasualtyDetails(\n+      final List<Unit> availableTargets, final Collection<Unit> hitTargets) {\n     final Map<Unit, Long> unitHp =\n         availableTargets.stream()\n             .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n \n-    for (final Integer hitTarget : hitTargets) {\n-      final Unit unit = availableTargets.get(hitTarget);\n+    final CasualtyDetails casualtyDetails = new CasualtyDetails();\n+    for (final Unit hitTarget : hitTargets) {\n+      final Unit unit = availableTargets.get(availableTargets.indexOf(hitTarget));\n       unitHp.computeIfPresent(\n           unit,\n           (unitKey, hp) -> {\n             if (hp > 1) {\n-              finalCasualtyDetails.addToDamaged(unit);\n+              casualtyDetails.addToDamaged(unit);\n             } else {\n-              finalCasualtyDetails.addToKilled(unit);\n+              casualtyDetails.addToKilled(unit);\n             }\n             return hp - 1;\n           });\n     }\n-    return finalCasualtyDetails;\n+    return casualtyDetails;\n   }\n \n-  /**\n-   * http://triplea.sourceforge.net/mywiki/Forum#nabble-td4658925%7Ca4658925 returns two lists, the\n-   * first list is the air units that can be evenly divided into groups of 3 or 6 (depending on\n-   * radar) the second list is all the air units that do not fit in the first list\n-   */\n-  private static Tuple<List<List<Unit>>, List<Unit>> categorizeLowLuckAirUnits(\n-      final Collection<Unit> units, final int groupSize) {\n-    final Collection<UnitCategory> categorizedAir =\n-        UnitSeparator.categorize(units, null, false, true);\n-    final List<List<Unit>> groupsOfSize = new ArrayList<>();\n-    final List<Unit> toRoll = new ArrayList<>();\n-    for (final UnitCategory uc : categorizedAir) {\n-      final int remainder = uc.getUnits().size() % groupSize;\n-      final int splitPosition = uc.getUnits().size() - remainder;\n-      final List<Unit> group = new ArrayList<>(uc.getUnits().subList(0, splitPosition));\n-      if (!group.isEmpty()) {\n-        for (int i = 0; i < splitPosition; i += groupSize) {\n-          final List<Unit> miniGroup = new ArrayList<>(uc.getUnits().subList(i, i + groupSize));\n-          if (!miniGroup.isEmpty()) {\n-            groupsOfSize.add(miniGroup);\n-          }\n-        }\n-      }\n-      toRoll.addAll(uc.getUnits().subList(splitPosition, uc.getUnits().size()));\n+  private static CasualtyDetails calculateRolledAaCasualties(\n+      final List<Unit> availableTargets,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n+      final DiceRoll dice,\n+      final IDelegateBridge bridge) {\n+\n+    final int hits = dice.getHits();\n+    final Collection<Unit> hitTargets;\n+    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n+        && hits < availableTargets.size()) {\n+      // there is a roll for every target but not enough hits to kill all of the targets\n+      // so no need to get a random set of units since all units will either have a hit\n+      // or miss roll\n+      hitTargets = findRolledTargets(availableTargets, dice);\n+    } else if (hits < availableTargets.size()) {\n+      // there isn't a roll for every target so need to randomly pick the target for each hit\n+      hitTargets = findRandomTargets(availableTargets, bridge, hits);\n+    } else {\n+      // all targets were hit so add them all\n+      hitTargets = availableTargets;\n     }\n-    return Tuple.of(groupsOfSize, toRoll);\n+\n+    return buildCasualtyDetails(availableTargets, hitTargets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 459}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDA0MjM4OnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxNToxMlrOIAGY6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxNToxMlrOIAGY6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk3NTU5Mg==", "bodyText": "Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536975592", "createdAt": "2020-12-06T07:15:12Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {\n+        guaranteedGroups.removeLast();\n+        remainderUnits.addAll(lastGroup);\n       }\n-    } else if (hits < availableTargets.size()) {\n-      // there isn't a roll for every target so need to randomly pick the target for each hit\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              availableTargets.size(),\n-              hits,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // turn the random numbers into a unique set of targets\n-      hitTargets = new HashSet<>();\n-      int index = 0;\n-      for (final int randomIndex : hitRandom) {\n-        index = (index + randomIndex) % availableTargets.size();\n-        while (hitTargets.contains(index)) {\n-          index = (index + 1) % availableTargets.size();\n-        }\n-        hitTargets.add(index);\n+      guaranteedHitGroups.addAll(guaranteedGroups);\n+    }\n+    return LowLuckTargetGroups.of(guaranteedHitGroups, remainderUnits);\n+  }\n+\n+  @Value(staticConstructor = \"of\")\n+  private static class LowLuckTargetGroups {\n+    List<List<Unit>> guaranteedHitGroups;\n+    List<Unit> remainderUnits;\n+  }\n+\n+  /**\n+   * Calculate the number of targets that guarantee a hit in a low luck dice roll\n+   *\n+   * <p>In low luck, the number of hits = (power / dice sides). If the strength for all of the aa\n+   * units is the same, then the number of hits = (strength * targetCount / diceSides). To find out\n+   * how big a group is needed to get a guaranteed hit, re-order the equation to be (targetCount /\n+   * hits) = (diceSides / strength). So, for every (diceSides / strength) targets, there is one\n+   * guaranteed hit.\n+   *\n+   * @return 0 if not possible to split up the targets into guaranteed hit groups or > 0 for the\n+   *     size that guarantees a hit\n+   */\n+  private static int calculateGuaranteeLowLuckHitGroupSize(\n+      final Collection<Unit> availableTargets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n+    final int bestStrength = unitPowerAndRollsMap.getBestStrength();\n+    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n+\n+    final boolean hasOverstackHits =\n+        diceRoll.getHits()\n+            > Math.ceil(\n+                (double) (bestStrength * availableTargets.size()) / (double) chosenDiceSize);\n+\n+    // if the aa units aren't the same strength, then it isn't possible to calculate the target\n+    // count for a guaranteed hit because different strengths have different target counts.\n+    if (!unitPowerAndRollsMap.isSameStrength()\n+        // if there are more hits than (strength * targetCount / diceSides), then there must have\n+        // been overstack AA and that messes up the target count.\n+        || hasOverstackHits\n+        // if the best strength isn't a factor of chosenDiceSize, then the target count will be\n+        // fractional which doesn't work\n+        || chosenDiceSize % bestStrength != 0) {\n+      return 0;\n+    }\n+\n+    return chosenDiceSize / bestStrength;\n+  }\n+\n+  /** Select a random set of targets out of availableTargets */\n+  private static Collection<Unit> findRandomTargets(\n+      final List<Unit> availableTargets, final IDelegateBridge bridge, final int hits) {\n+    final int[] hitRandom =\n+        bridge.getRandom(\n+            availableTargets.size(),\n+            hits,\n+            null,\n+            DiceType.ENGINE,\n+            \"Deciding which planes should die due to AA fire\");\n+    // turn the random numbers into a unique set of targets\n+    final Set<Integer> hitTargets = new HashSet<>();\n+    int index = 0;\n+    for (final int randomIndex : hitRandom) {\n+      index = (index + randomIndex) % availableTargets.size();\n+      while (hitTargets.contains(index)) {\n+        index = (index + 1) % availableTargets.size();\n       }\n-    } else {\n-      // all targets were hit so add them all\n-      hitTargets = IntStream.range(0, availableTargets.size()).boxed().collect(Collectors.toSet());\n+      hitTargets.add(index);\n     }\n+    return hitTargets.stream().map(availableTargets::get).collect(Collectors.toList());\n+  }\n \n+  private static CasualtyDetails buildCasualtyDetails(\n+      final List<Unit> availableTargets, final Collection<Unit> hitTargets) {\n     final Map<Unit, Long> unitHp =\n         availableTargets.stream()\n             .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n \n-    for (final Integer hitTarget : hitTargets) {\n-      final Unit unit = availableTargets.get(hitTarget);\n+    final CasualtyDetails casualtyDetails = new CasualtyDetails();\n+    for (final Unit hitTarget : hitTargets) {\n+      final Unit unit = availableTargets.get(availableTargets.indexOf(hitTarget));\n       unitHp.computeIfPresent(\n           unit,\n           (unitKey, hp) -> {\n             if (hp > 1) {\n-              finalCasualtyDetails.addToDamaged(unit);\n+              casualtyDetails.addToDamaged(unit);\n             } else {\n-              finalCasualtyDetails.addToKilled(unit);\n+              casualtyDetails.addToKilled(unit);\n             }\n             return hp - 1;\n           });\n     }\n-    return finalCasualtyDetails;\n+    return casualtyDetails;\n   }\n \n-  /**\n-   * http://triplea.sourceforge.net/mywiki/Forum#nabble-td4658925%7Ca4658925 returns two lists, the\n-   * first list is the air units that can be evenly divided into groups of 3 or 6 (depending on\n-   * radar) the second list is all the air units that do not fit in the first list\n-   */\n-  private static Tuple<List<List<Unit>>, List<Unit>> categorizeLowLuckAirUnits(\n-      final Collection<Unit> units, final int groupSize) {\n-    final Collection<UnitCategory> categorizedAir =\n-        UnitSeparator.categorize(units, null, false, true);\n-    final List<List<Unit>> groupsOfSize = new ArrayList<>();\n-    final List<Unit> toRoll = new ArrayList<>();\n-    for (final UnitCategory uc : categorizedAir) {\n-      final int remainder = uc.getUnits().size() % groupSize;\n-      final int splitPosition = uc.getUnits().size() - remainder;\n-      final List<Unit> group = new ArrayList<>(uc.getUnits().subList(0, splitPosition));\n-      if (!group.isEmpty()) {\n-        for (int i = 0; i < splitPosition; i += groupSize) {\n-          final List<Unit> miniGroup = new ArrayList<>(uc.getUnits().subList(i, i + groupSize));\n-          if (!miniGroup.isEmpty()) {\n-            groupsOfSize.add(miniGroup);\n-          }\n-        }\n-      }\n-      toRoll.addAll(uc.getUnits().subList(splitPosition, uc.getUnits().size()));\n+  private static CasualtyDetails calculateRolledAaCasualties(\n+      final List<Unit> availableTargets,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n+      final DiceRoll dice,\n+      final IDelegateBridge bridge) {\n+\n+    final int hits = dice.getHits();\n+    final Collection<Unit> hitTargets;\n+    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n+        && hits < availableTargets.size()) {\n+      // there is a roll for every target but not enough hits to kill all of the targets\n+      // so no need to get a random set of units since all units will either have a hit\n+      // or miss roll\n+      hitTargets = findRolledTargets(availableTargets, dice);\n+    } else if (hits < availableTargets.size()) {\n+      // there isn't a roll for every target so need to randomly pick the target for each hit\n+      hitTargets = findRandomTargets(availableTargets, bridge, hits);\n+    } else {\n+      // all targets were hit so add them all\n+      hitTargets = availableTargets;\n     }\n-    return Tuple.of(groupsOfSize, toRoll);\n+\n+    return buildCasualtyDetails(availableTargets, hitTargets);\n   }\n \n-  private static int getTotalHitpointsLeft(final Unit unit) {\n-    if (unit == null) {\n-      return 0;\n+  /** Find the targets that were hit by a dice roll */\n+  private static Collection<Unit> findRolledTargets(\n+      final List<Unit> availableTargets, final DiceRoll dice) {\n+    final List<Die> rolls = dice.getRolls();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDA0NjEwOnYy", "diffSide": "RIGHT", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxNzo0M1rOIAGafQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwNzoxNzo0M1rOIAGafQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk3NTk5Nw==", "bodyText": "It looks like there is an implicit assumption that avaialbleTargets will have the same size as 'dice.getRolls'. This assumption is not necessarily clear here, a Precondition.checkArgument(availableTarget.size() == dice.getRolls().size()) at the start of the method would help document this. A reader would do a double take here wondering if there could be an indexing problem because i is tracking against rolls, not availableTargets.", "url": "https://github.com/triplea-game/triplea/pull/8338#discussion_r536975997", "createdAt": "2020-12-06T07:17:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelector.java", "diffHunk": "@@ -114,265 +112,209 @@ private static CasualtyDetails getLowLuckAaCasualties(\n       final List<Unit> availableTargets,\n       final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n       final DiceRoll dice,\n-      final IDelegateBridge bridge,\n-      final boolean allowMultipleHitsPerUnit) {\n+      final IDelegateBridge bridge) {\n \n-    int hitsLeft = dice.getHits();\n+    final LowLuckTargetGroups targetGroups =\n+        createGuaranteedLowLuckHitGroups(availableTargets, dice, unitPowerAndRollsMap);\n \n-    // if we can damage units, do it now\n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int highestAttack = unitPowerAndRollsMap.getBestStrength();\n-    if (highestAttack < 1) {\n-      return new CasualtyDetails();\n-    }\n-    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n-    final boolean allSameAttackPower = unitPowerAndRollsMap.isSameStrength();\n-    // multiple HP units need to be counted multiple times:\n-    // killing the air by groups does not work if the the attack power is different for some of the\n-    // rolls\n-    // also, killing by groups does not work if some of the aa guns have 'MayOverStackAA' and we\n-    // have more hits than the\n-    // total number of groups (including the remainder group)\n-    // (when i mean, 'does not work', i mean that it is no longer a mathematically fair way to find\n-    // casualties)\n-    // find group size (if no groups, do dice sides)\n-    final int groupSize;\n-    if (allSameAttackPower) {\n-      groupSize = chosenDiceSize / highestAttack;\n-    } else {\n-      groupSize = chosenDiceSize;\n-    }\n-    final int numberOfGroupsByDiceSides =\n-        (int) Math.ceil((double) availableTargets.size() / (double) groupSize);\n-    final boolean tooManyHitsToDoGroups = hitsLeft > numberOfGroupsByDiceSides;\n-    if (!allSameAttackPower || tooManyHitsToDoGroups || chosenDiceSize % highestAttack != 0) {\n-      // we have too many hits, so just pick randomly\n-      return calculateAaCasualties(availableTargets, unitPowerAndRollsMap, dice, bridge);\n+    if (targetGroups.guaranteedHitGroups.isEmpty()) {\n+      // it is not possible to separate the targets into guaranteed hit groups so randomly choose\n+      // the targets instead\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(availableTargets, bridge, dice.getHits()));\n     }\n \n-    // if we have a group of 6 fighters and 2 bombers, and dicesides is 6, and attack was 1, then we\n-    // would want 1\n-    // fighter to die for sure. this is what group size is for.\n-    // if the attack is greater than 1 though, and all use the same attack power, then the group\n-    // size can be smaller\n-    // (ie: attack is 2, and we have 3 fighters and 2 bombers, we would want 1 fighter to die for\n-    // sure).\n-    // categorize with groupSize\n-    final Tuple<List<List<Unit>>, List<Unit>> airSplit =\n-        categorizeLowLuckAirUnits(availableTargets, groupSize);\n-    // the non rolling air units\n-    // if we are less hits than the number of groups, OR we have equal hits to number of groups but\n-    // we also have a\n-    // remainder that is equal to or greater than group size,\n-    // THEN we need to make sure to pick randomly, and include the remainder group. (reason we do\n-    // not do this with any\n-    // remainder size, is because we might have missed the dice roll to hit the remainder)\n-    if (hitsLeft\n-        < (airSplit.getFirst().size()\n-            + ((int) Math.ceil((double) airSplit.getSecond().size() / (double) groupSize)))) {\n-      // fewer hits than groups\n-      final List<Unit> tempPossibleHitUnits = new ArrayList<>();\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        tempPossibleHitUnits.add(group.get(0));\n-      }\n-      if (!airSplit.getSecond().isEmpty()) {\n-        // if we have a remainder group, we need to add some of them into the mix\n-        // but we have to do so randomly\n-        final List<Unit> remainders = new ArrayList<>(airSplit.getSecond());\n-        if (remainders.size() == 1) {\n-          tempPossibleHitUnits.add(remainders.remove(0));\n-        } else {\n-          final int numberOfRemainderGroups =\n-              (int) Math.ceil((double) remainders.size() / (double) groupSize);\n-          final int[] randomRemainder =\n-              bridge.getRandom(\n-                  remainders.size(),\n-                  numberOfRemainderGroups,\n-                  null,\n-                  DiceType.ENGINE,\n-                  \"Deciding which planes should die due to AA fire\");\n-          int pos2 = 0;\n-          for (final int element : randomRemainder) {\n-            pos2 += element;\n-            tempPossibleHitUnits.add(remainders.remove(pos2 % remainders.size()));\n-          }\n-        }\n+    if (dice.getHits() >= targetGroups.guaranteedHitGroups.size()) {\n+      // there are enough hits to take one unit from each guaranteed hit group\n+      final List<Unit> hitTargetIndices = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        hitTargetIndices.add(group.get(0));\n       }\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              tempPossibleHitUnits.size(),\n-              hitsLeft,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // now we find the\n-      int pos = 0;\n-      for (final int element : hitRandom) {\n-        pos += element;\n-        final Unit unitHit = tempPossibleHitUnits.remove(pos % tempPossibleHitUnits.size());\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n+\n+      // if there are more hits than groups, the extra hits come out of the remainderUnits\n+      final int remainderHits = dice.getHits() - targetGroups.guaranteedHitGroups.size();\n+      if (remainderHits > 0) {\n+        if (remainderHits == targetGroups.remainderUnits.size()) {\n+          hitTargetIndices.addAll(targetGroups.remainderUnits);\n         } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n+          // randomly pull out units from the remainder group\n+          hitTargetIndices.addAll(\n+              findRandomTargets(targetGroups.remainderUnits, bridge, remainderHits));\n         }\n       }\n+      return buildCasualtyDetails(availableTargets, hitTargetIndices);\n     } else {\n-      // kill one in every group\n-      for (final List<Unit> group : airSplit.getFirst()) {\n-        final Unit unitHit = group.get(0);\n-        if (allowMultipleHitsPerUnit\n-            && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                < (getTotalHitpointsLeft(unitHit) - 1))) {\n-          finalCasualtyDetails.addToDamaged(unitHit);\n-        } else {\n-          finalCasualtyDetails.addToKilled(unitHit);\n-        }\n-        hitsLeft--;\n-      }\n-      // for any hits left over...\n-      if (hitsLeft == airSplit.getSecond().size()) {\n-        for (final Unit unitHit : airSplit.getSecond()) {\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n-      } else if (hitsLeft != 0) {\n-        // the remainder\n-        // roll all at once to prevent frequent random calls, important for pbem games\n-        final int[] hitRandom =\n-            bridge.getRandom(\n-                airSplit.getSecond().size(),\n-                hitsLeft,\n-                null,\n-                DiceType.ENGINE,\n-                \"Deciding which planes should die due to AA fire\");\n-        int pos = 0;\n-        for (final int element : hitRandom) {\n-          pos += element;\n-          final Unit unitHit = airSplit.getSecond().remove(pos % airSplit.getSecond().size());\n-          if (allowMultipleHitsPerUnit\n-              && (Collections.frequency(finalCasualtyDetails.getDamaged(), unitHit)\n-                  < (getTotalHitpointsLeft(unitHit) - 1))) {\n-            finalCasualtyDetails.addToDamaged(unitHit);\n-          } else {\n-            finalCasualtyDetails.addToKilled(unitHit);\n-          }\n-        }\n+      // There is somehow more guaranteed hit groups than hits. This currently only happens\n+      // with multi hp targets and damageable AA shots.\n+\n+      // pull out one unit from each guaranteed hit and then randomly pick the hits from those\n+      final List<Unit> guaranteedHitUnits = new ArrayList<>();\n+      for (final List<Unit> group : targetGroups.guaranteedHitGroups) {\n+        guaranteedHitUnits.add(group.get(0));\n       }\n-    }\n \n-    // double check\n-    if (finalCasualtyDetails.size() != dice.getHits()) {\n-      throw new IllegalStateException(\n-          \"wrong number of casualties, expected:\" + dice + \" but got: \" + finalCasualtyDetails);\n+      return buildCasualtyDetails(\n+          availableTargets, findRandomTargets(guaranteedHitUnits, bridge, dice.getHits()));\n     }\n-    return finalCasualtyDetails;\n   }\n \n-  private static CasualtyDetails calculateAaCasualties(\n-      final List<Unit> availableTargets,\n-      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n-      final DiceRoll dice,\n-      final IDelegateBridge bridge) {\n+  /**\n+   * Categorize the units and then split them up into groups of guaranteeHitGroupSize\n+   *\n+   * <p>Any group less than guaranteeHitGroupSize is added to the remainderUnits\n+   */\n+  private static LowLuckTargetGroups createGuaranteedLowLuckHitGroups(\n+      final Collection<Unit> targets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n \n-    final CasualtyDetails finalCasualtyDetails = new CasualtyDetails();\n-    final int hits = dice.getHits();\n-    final Set<Integer> hitTargets;\n-    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n-        && hits < availableTargets.size()) {\n-      // there is a roll for every target but not enough hits to kill all of the targets\n-      // so no need to get a random set of units since all units will either have a hit\n-      // or miss roll\n-      final List<Die> rolls = dice.getRolls();\n-      hitTargets = new HashSet<>();\n-      for (int i = 0; i < rolls.size(); i++) {\n-        if (rolls.get(i).getType() == DieType.HIT) {\n-          hitTargets.add(i);\n-        }\n+    final int guaranteeHitGroupSize =\n+        calculateGuaranteeLowLuckHitGroupSize(targets, diceRoll, unitPowerAndRollsMap);\n+\n+    final Collection<UnitCategory> groupedTargets =\n+        UnitSeparator.categorize(targets, null, false, true);\n+    final List<List<Unit>> guaranteedHitGroups = new ArrayList<>();\n+    final List<Unit> remainderUnits = new ArrayList<>();\n+    for (final UnitCategory uc : groupedTargets) {\n+      final Deque<List<Unit>> guaranteedGroups =\n+          new ArrayDeque<>(Lists.partition(uc.getUnits(), guaranteeHitGroupSize));\n+      final List<Unit> lastGroup = guaranteedGroups.peekLast();\n+      // if the last group isn't the right size, put those units in the remainder list\n+      if (lastGroup != null && lastGroup.size() != guaranteeHitGroupSize) {\n+        guaranteedGroups.removeLast();\n+        remainderUnits.addAll(lastGroup);\n       }\n-    } else if (hits < availableTargets.size()) {\n-      // there isn't a roll for every target so need to randomly pick the target for each hit\n-      final int[] hitRandom =\n-          bridge.getRandom(\n-              availableTargets.size(),\n-              hits,\n-              null,\n-              DiceType.ENGINE,\n-              \"Deciding which planes should die due to AA fire\");\n-      // turn the random numbers into a unique set of targets\n-      hitTargets = new HashSet<>();\n-      int index = 0;\n-      for (final int randomIndex : hitRandom) {\n-        index = (index + randomIndex) % availableTargets.size();\n-        while (hitTargets.contains(index)) {\n-          index = (index + 1) % availableTargets.size();\n-        }\n-        hitTargets.add(index);\n+      guaranteedHitGroups.addAll(guaranteedGroups);\n+    }\n+    return LowLuckTargetGroups.of(guaranteedHitGroups, remainderUnits);\n+  }\n+\n+  @Value(staticConstructor = \"of\")\n+  private static class LowLuckTargetGroups {\n+    List<List<Unit>> guaranteedHitGroups;\n+    List<Unit> remainderUnits;\n+  }\n+\n+  /**\n+   * Calculate the number of targets that guarantee a hit in a low luck dice roll\n+   *\n+   * <p>In low luck, the number of hits = (power / dice sides). If the strength for all of the aa\n+   * units is the same, then the number of hits = (strength * targetCount / diceSides). To find out\n+   * how big a group is needed to get a guaranteed hit, re-order the equation to be (targetCount /\n+   * hits) = (diceSides / strength). So, for every (diceSides / strength) targets, there is one\n+   * guaranteed hit.\n+   *\n+   * @return 0 if not possible to split up the targets into guaranteed hit groups or > 0 for the\n+   *     size that guarantees a hit\n+   */\n+  private static int calculateGuaranteeLowLuckHitGroupSize(\n+      final Collection<Unit> availableTargets,\n+      final DiceRoll diceRoll,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap) {\n+    final int bestStrength = unitPowerAndRollsMap.getBestStrength();\n+    final int chosenDiceSize = unitPowerAndRollsMap.getDiceSides();\n+\n+    final boolean hasOverstackHits =\n+        diceRoll.getHits()\n+            > Math.ceil(\n+                (double) (bestStrength * availableTargets.size()) / (double) chosenDiceSize);\n+\n+    // if the aa units aren't the same strength, then it isn't possible to calculate the target\n+    // count for a guaranteed hit because different strengths have different target counts.\n+    if (!unitPowerAndRollsMap.isSameStrength()\n+        // if there are more hits than (strength * targetCount / diceSides), then there must have\n+        // been overstack AA and that messes up the target count.\n+        || hasOverstackHits\n+        // if the best strength isn't a factor of chosenDiceSize, then the target count will be\n+        // fractional which doesn't work\n+        || chosenDiceSize % bestStrength != 0) {\n+      return 0;\n+    }\n+\n+    return chosenDiceSize / bestStrength;\n+  }\n+\n+  /** Select a random set of targets out of availableTargets */\n+  private static Collection<Unit> findRandomTargets(\n+      final List<Unit> availableTargets, final IDelegateBridge bridge, final int hits) {\n+    final int[] hitRandom =\n+        bridge.getRandom(\n+            availableTargets.size(),\n+            hits,\n+            null,\n+            DiceType.ENGINE,\n+            \"Deciding which planes should die due to AA fire\");\n+    // turn the random numbers into a unique set of targets\n+    final Set<Integer> hitTargets = new HashSet<>();\n+    int index = 0;\n+    for (final int randomIndex : hitRandom) {\n+      index = (index + randomIndex) % availableTargets.size();\n+      while (hitTargets.contains(index)) {\n+        index = (index + 1) % availableTargets.size();\n       }\n-    } else {\n-      // all targets were hit so add them all\n-      hitTargets = IntStream.range(0, availableTargets.size()).boxed().collect(Collectors.toSet());\n+      hitTargets.add(index);\n     }\n+    return hitTargets.stream().map(availableTargets::get).collect(Collectors.toList());\n+  }\n \n+  private static CasualtyDetails buildCasualtyDetails(\n+      final List<Unit> availableTargets, final Collection<Unit> hitTargets) {\n     final Map<Unit, Long> unitHp =\n         availableTargets.stream()\n             .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n \n-    for (final Integer hitTarget : hitTargets) {\n-      final Unit unit = availableTargets.get(hitTarget);\n+    final CasualtyDetails casualtyDetails = new CasualtyDetails();\n+    for (final Unit hitTarget : hitTargets) {\n+      final Unit unit = availableTargets.get(availableTargets.indexOf(hitTarget));\n       unitHp.computeIfPresent(\n           unit,\n           (unitKey, hp) -> {\n             if (hp > 1) {\n-              finalCasualtyDetails.addToDamaged(unit);\n+              casualtyDetails.addToDamaged(unit);\n             } else {\n-              finalCasualtyDetails.addToKilled(unit);\n+              casualtyDetails.addToKilled(unit);\n             }\n             return hp - 1;\n           });\n     }\n-    return finalCasualtyDetails;\n+    return casualtyDetails;\n   }\n \n-  /**\n-   * http://triplea.sourceforge.net/mywiki/Forum#nabble-td4658925%7Ca4658925 returns two lists, the\n-   * first list is the air units that can be evenly divided into groups of 3 or 6 (depending on\n-   * radar) the second list is all the air units that do not fit in the first list\n-   */\n-  private static Tuple<List<List<Unit>>, List<Unit>> categorizeLowLuckAirUnits(\n-      final Collection<Unit> units, final int groupSize) {\n-    final Collection<UnitCategory> categorizedAir =\n-        UnitSeparator.categorize(units, null, false, true);\n-    final List<List<Unit>> groupsOfSize = new ArrayList<>();\n-    final List<Unit> toRoll = new ArrayList<>();\n-    for (final UnitCategory uc : categorizedAir) {\n-      final int remainder = uc.getUnits().size() % groupSize;\n-      final int splitPosition = uc.getUnits().size() - remainder;\n-      final List<Unit> group = new ArrayList<>(uc.getUnits().subList(0, splitPosition));\n-      if (!group.isEmpty()) {\n-        for (int i = 0; i < splitPosition; i += groupSize) {\n-          final List<Unit> miniGroup = new ArrayList<>(uc.getUnits().subList(i, i + groupSize));\n-          if (!miniGroup.isEmpty()) {\n-            groupsOfSize.add(miniGroup);\n-          }\n-        }\n-      }\n-      toRoll.addAll(uc.getUnits().subList(splitPosition, uc.getUnits().size()));\n+  private static CasualtyDetails calculateRolledAaCasualties(\n+      final List<Unit> availableTargets,\n+      final AaPowerStrengthAndRolls unitPowerAndRollsMap,\n+      final DiceRoll dice,\n+      final IDelegateBridge bridge) {\n+\n+    final int hits = dice.getHits();\n+    final Collection<Unit> hitTargets;\n+    if (unitPowerAndRollsMap.calculateTotalRolls() == availableTargets.size()\n+        && hits < availableTargets.size()) {\n+      // there is a roll for every target but not enough hits to kill all of the targets\n+      // so no need to get a random set of units since all units will either have a hit\n+      // or miss roll\n+      hitTargets = findRolledTargets(availableTargets, dice);\n+    } else if (hits < availableTargets.size()) {\n+      // there isn't a roll for every target so need to randomly pick the target for each hit\n+      hitTargets = findRandomTargets(availableTargets, bridge, hits);\n+    } else {\n+      // all targets were hit so add them all\n+      hitTargets = availableTargets;\n     }\n-    return Tuple.of(groupsOfSize, toRoll);\n+\n+    return buildCasualtyDetails(availableTargets, hitTargets);\n   }\n \n-  private static int getTotalHitpointsLeft(final Unit unit) {\n-    if (unit == null) {\n-      return 0;\n+  /** Find the targets that were hit by a dice roll */\n+  private static Collection<Unit> findRolledTargets(\n+      final List<Unit> availableTargets, final DiceRoll dice) {\n+    final List<Die> rolls = dice.getRolls();\n+    final List<Unit> hitTargets = new ArrayList<>();\n+    for (int i = 0; i < rolls.size(); i++) {\n+      if (rolls.get(i).getType() == DieType.HIT) {\n+        hitTargets.add(availableTargets.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "340171766ad5e19b75e45dc01c0101b805e77397"}, "originalPosition": 472}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2635, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}