{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMDk3NDE3", "number": 7899, "title": "Allow AA to target all infrastructure", "bodyText": "Fixes #7833\nThis modifies Matches.unitTypeCanBeInBattle to accept the list of attackers and checks if any of those attackers can hit the unit using targetsAa.  I've also added tests around the infrastructure part of that method.\nThis should allow any infrastructure units that are listed in targetsAa to be part of the battle.  They'll show up in the Battle UI and can be taken as casualties.\nTesting\n\nI used the save #7823 (comment) to verify that the air_transports would be taken as casualties.\nI also ran a hard ai for a few rounds.\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note\n\nCHANGE|Removed from \"infrastructure\" units the ability to be immune to targeted (AA-like) fire and made infrastructures targetable also beyond the first round of combat (in accordance to the fact that TripleA allows infrastructures to remain in combat beyond the first round of it).", "createdAt": "2020-10-14T04:28:08Z", "url": "https://github.com/triplea-game/triplea/pull/7899", "merged": true, "mergeCommit": {"oid": "618fc72cdbb944c15acda8cc35fb16de4eb8f8da"}, "closed": true, "closedAt": "2020-10-19T05:45:56Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSKOx8AH2gAyNTAzMDk3NDE3OjlkMmZmNzJmYjhhNjRkOGNiMTljNTM2NTBjNjFkMTI5NjUwYzJhNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdT9kODAFqTUxMTQyNjA0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d2ff72fb8a64d8cb19c53650c61d129650c2a41", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/9d2ff72fb8a64d8cb19c53650c61d129650c2a41", "committedDate": "2020-10-13T15:23:04Z", "message": "Allow all units in battle that can be hit by AA fire"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5747723e726b1081db12e1e9db84f190f77810f6", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/5747723e726b1081db12e1e9db84f190f77810f6", "committedDate": "2020-10-14T04:18:44Z", "message": "Add unittests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1e928071561ad5b53e39733401deefdf13e63f2", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c1e928071561ad5b53e39733401deefdf13e63f2", "committedDate": "2020-10-14T04:38:13Z", "message": "Remove unnecessary qualified name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/1da61fa850c1819a6db666d7e0a04fa0b6f5f18b", "committedDate": "2020-10-16T17:45:01Z", "message": "Remove test on excluding infrastructure since it isn't excluded anymore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMDA4NjI4", "url": "https://github.com/triplea-game/triplea/pull/7899#pullrequestreview-511008628", "createdAt": "2020-10-17T19:08:58Z", "commit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QxOTowODo1OFrOHjfPsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QxOToyOTozMlrOHjfW1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDEyOA==", "bodyText": "Typo: unitTypeCanByHitByAaFire -> \"BeHitBy..\"", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974128", "createdAt": "2020-10-17T19:08:58Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -652,6 +652,23 @@ private Matches() {}\n     };\n   }\n \n+  /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n+  private static Predicate<UnitType> unitTypeCanByHitByAaFire(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDQ0Ng==", "bodyText": "WDYT to pass the data from GameData to this method rather than passing GameData to it?\nGameData has a problem where it's passed everywhere and used by everything. That makes decoupling quite difficult, for example, testing involving with a game data almost always means doing a full blown integration test and loading an XML (which is extremely limiting as we may want to test perhaps 12 permutations of one element of game data for just one set of tests).\nAnyways, the less dependencies we can have on game data for now-  the better.", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974446", "createdAt": "2020-10-17T19:11:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -652,6 +652,23 @@ private Matches() {}\n     };\n   }\n \n+  /** Checks if the unit type can be hit with AA fire by one of the firingUnits */\n+  private static Predicate<UnitType> unitTypeCanByHitByAaFire(\n+      final Collection<UnitType> firingUnits, final GameData gameData, final int battleRound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ==", "bodyText": "Intermediate variables can perhaps help reduce the commentary. For example:\nvar isAaThatCanFireThisRound = unitType -> unitTypeIsAaForCombatOnly().and(unitTypeIsAaThatCanFireOnRound(battleRound);\n\nWDYT of using that technique to avoid the inline commentary? I think that is only needed for the more complex conditions, the simpler ones, the code might be able to just speak for itself.", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974661", "createdAt": "2020-10-17T19:13:48Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -2313,14 +2342,18 @@ private Matches() {}\n       final GamePlayer player,\n       final int battleRound,\n       final boolean includeAttackersThatCanNotMove,\n-      final boolean doNotIncludeBombardingSeaUnits) {\n+      final boolean doNotIncludeBombardingSeaUnits,\n+      final Collection<UnitType> firingUnits) {\n \n-    // Filter out anything like factories, or units that have no combat ability AND cannot be taken\n-    // casualty\n     final PredicateBuilder<UnitType> canBeInBattleBuilder =\n+        // remove infrastructure units\n         PredicateBuilder.of(unitTypeIsInfrastructure().negate())\n+            // unless it can support or fight\n             .or(unitTypeIsSupporterOrHasCombatAbility(attack, player))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDgxOQ==", "bodyText": "For a long series of statements, having one comment to describe the general outcome and what is generally happening can be a good thing. Make it easier for a reader to know what to expect and makes it easier to see how each statement fits in to the overall outcome. Commenting each line though is more questionable and can speak to inarticulate code (which can be fixed by improving naming, intermediate variables, private helper methods, re-organizing methods).", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506974819", "createdAt": "2020-10-17T19:15:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -2313,14 +2342,18 @@ private Matches() {}\n       final GamePlayer player,\n       final int battleRound,\n       final boolean includeAttackersThatCanNotMove,\n-      final boolean doNotIncludeBombardingSeaUnits) {\n+      final boolean doNotIncludeBombardingSeaUnits,\n+      final Collection<UnitType> firingUnits) {\n \n-    // Filter out anything like factories, or units that have no combat ability AND cannot be taken\n-    // casualty\n     final PredicateBuilder<UnitType> canBeInBattleBuilder =\n+        // remove infrastructure units\n         PredicateBuilder.of(unitTypeIsInfrastructure().negate())\n+            // unless it can support or fight\n             .or(unitTypeIsSupporterOrHasCombatAbility(attack, player))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NDY2MQ=="}, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTA2Mw==", "bodyText": "side-note, not for thsi PR - this API could use work. From the looks of it, most of the parameters are not used. From a caller perspective, it's kind meaningless of an API call, the 'trues', 'falses', redundant call to isLand() are certainly minor problems.\nI comment on this as we should be careful to avoid making such problems worse when we can, but here I think the horse has already left the barn.", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975063", "createdAt": "2020-10-17T19:18:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculatorPanel.java", "diffHunk": "@@ -1336,7 +1336,8 @@ private void setAttackingUnits(final List<Unit> initialUnits) {\n         getAttacker(),\n         CollectionUtils.getMatches(\n             units,\n-            Matches.unitCanBeInBattle(true, isLand(), 1, hasMaxRounds(isLand(), data), false)),\n+            Matches.unitCanBeInBattle(\n+                true, isLand(), 1, hasMaxRounds(isLand(), data), false, List.of())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTMwNg==", "bodyText": "givenGameData() is not as descriptive as one would hope. What is given about this game data? Can we say or require anything to be true about this game data? Though, I suspect the instantiation of any game data is something of a hack for game data being very difficult to mock (God class code-smell, we use it everywhere for everything.\nI'd recommend renaming this method to givenAnyGameData() perhaps to indicate that we require nothing other than an instantiated game data, otherwise any requirements of the data would either be specified as parameters or baked into the game data name. For example, givenGameDataWithUnits(...)", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975306", "createdAt": "2020-10-17T19:21:09Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTUyMg==", "bodyText": "Looking at this further, perhaps calling it givenMockGameData().\nThough, ideally we would not need the object and any data from the game data would individually be passed to this class. In other words, game data is acting as a tuple with other objects. Rather than passing the tuple and grabbing the objects from the tuple, instead we can pass the individual objects from the tuple to where they are needed.", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975522", "createdAt": "2020-10-17T19:24:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTMwNg=="}, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTczNw==", "bodyText": "Does this method need the other mocked elements of gameData, or do we mostly only need for the dice sides?\nI'd recommend to try and fully mock objects within the test method where reasonable, at least within a test so the test is more self contained. For example if another test required slightly different mocking of a game data, we'd suddenly have a conflict between that test and any other that depended on the mock.\nMore fundamentally it probably is better to break up the data needed from game data, use only that data, then you can pass those data objects as test parameters. For example, rather than passing a game data to get dice sides to another method, instead pass the dice sides value directly.", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975737", "createdAt": "2020-10-17T19:26:14Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTg1NA==", "bodyText": "A parameter object I think would help a lot here, this parameter list is not very meaningful:\ntrue, true, 1, false, List.of()\nI wonder a bit as well why the parameter list is not Matches.unitTypeCanBeInBattleForRound( < UnitType > , <battleRound:Int> )", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975854", "createdAt": "2020-10-17T19:27:58Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit normally can not be in battle\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk3NTk1Ng==", "bodyText": "The assert comments are good and pretty reasonable setup  \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/7899#discussion_r506975956", "createdAt": "2020-10-17T19:29:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/MatchesTest.java", "diffHunk": "@@ -254,4 +266,179 @@ void shouldNotMatchWhenSeaTerritoryIsUnownedAndDoesNotHaveTerritoryAttachment()\n       assertThat(newMatch(), notMatches(seaTerritory));\n     }\n   }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  final class UnitCanBeInBattle {\n+\n+    @Mock GamePlayer player;\n+    GameData gameData;\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      gameData = givenGameData().build();\n+    }\n+\n+    @Test\n+    void infrastructureShouldNormallyNotBeInBattle() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit normally can not be in battle\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),\n+          is(false));\n+    }\n+\n+    @Test\n+    void infrastructureWithAttackCanBeInBattleWhenAttacking() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setAttack(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with attack can be in battle when it is attacking\",\n+          Matches.unitCanBeInBattle(true, true, 1, false, List.of()).test(unit),\n+          is(true));\n+    }\n+\n+    @Test\n+    void infrastructureWithAttackCanNotBeInBattleWhenDefending() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setAttack(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with attack can not be in battle when it is attacking\",\n+          Matches.unitCanBeInBattle(false, true, 1, false, List.of()).test(unit),\n+          is(false));\n+    }\n+\n+    @Test\n+    void infrastructureWithDefenseCanBeInBattleWhenDefending() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setDefense(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with defense can be in battle when it is defending\",\n+          Matches.unitCanBeInBattle(false, true, 1, false, List.of()).test(unit),\n+          is(true));\n+    }\n+\n+    @Test\n+    void infrastructureWithDefenseCanNotBeInBattleWhenAttacking() {\n+      when(gameData.getDiceSides()).thenReturn(6);\n+      final UnitType unitType = new UnitType(\"infrastructure\", gameData);\n+      final UnitAttachment unitAttachment =\n+          new UnitAttachment(\"infrastructure\", unitType, gameData);\n+      unitAttachment.setIsInfrastructure(true);\n+      unitAttachment.setDefense(1);\n+      unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+      final Unit unit = unitType.create(1, player, true).get(0);\n+\n+      assertThat(\n+          \"An infrastructure unit with defense can not be in battle when it is attacking\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da61fa850c1819a6db666d7e0a04fa0b6f5f18b"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/38e507bdee66ec5a40e61269bc8b6f905e85f1f4", "committedDate": "2020-10-19T00:24:31Z", "message": "Fix mispelling of unitTypeCanBeHitByAaFire and condense comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNDI2MDQz", "url": "https://github.com/triplea-game/triplea/pull/7899#pullrequestreview-511426043", "createdAt": "2020-10-19T05:45:34Z", "commit": {"oid": "38e507bdee66ec5a40e61269bc8b6f905e85f1f4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3890, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}