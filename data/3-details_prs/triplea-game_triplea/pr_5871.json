{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NDY2OTgy", "number": 5871, "title": "Enhance suicide functionality and deprecate old suicide options", "bodyText": "Addresses feature request: https://forums.triplea-game.org/topic/1579/suicide-munitions-unit-with-support\n\nAdd new isSuicideOnAttack and isSuicideOnDefense properties to deprecate isSuicide and global property \"Defending Suicide and Munition Units Do Not Fire\"\nSuicide units will now fire either during first strike phase (subs) or normal phase rather than a separate hacked phase before first strike\nSuicide units can now receive and give support\nFix bug where first strike units weren't actually receiving support even though the battle window showed it: https://forums.triplea-game.org/topic/1181/total-world-war-december-1941-3-0-0-6/456\nImplement remaining target limiting properties canNotTarget and canNotBeTargetBy: https://forums.triplea-game.org/topic/1603/cannottarget-not-working\nLots of refactoring to allow all of these to be implemented and to better centralize a lot of the functionality\n\nFunctional Changes\n\n[] New map or map update\n[x] New Feature\n[x] Feature update or enhancement\n[] Feature Removal\n[] Code Cleanup or refactor\n[] Configuration Change\n[x] Problem fix:  \n[] Other:   \nTesting\n\n[x] Manual testing done\n\nTested suicide units on NML and Iron War. Tested revised and global to make sure regular battles and subs/destroyers still function properly. Ran a few all AI games.", "createdAt": "2020-01-23T17:00:00Z", "url": "https://github.com/triplea-game/triplea/pull/5871", "merged": true, "mergeCommit": {"oid": "afc2e80164f81f27c234afb8a45aa5011f663418"}, "closed": true, "closedAt": "2020-02-07T04:43:14Z", "author": {"login": "ron-murhammer"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9NSzmgH2gAyMzY2NDY2OTgyOjAzNWEyZTc3ZTE5NzNiMzMyNTNiM2I1YWM5ZTdjNDAwN2RjZTkyNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcB3JK0AFqTM1NDkxODkyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/035a2e77e1973b33253b3b5ac9e7c4007dce9259", "committedDate": "2020-01-23T16:53:37Z", "message": "Add new suicide options and replace the old options"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDYwNjQ3", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-347460647", "createdAt": "2020-01-23T17:01:46Z", "commit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzowMTo0N1rOFhFwrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzowMTo0N1rOFhFwtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMQ==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241711", "createdAt": "2020-01-23T17:01:47Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -198,20 +198,20 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n               defendingWaitingToDie.clear();\n               // kill any suicide attackers (veqryn)\n               final Predicate<Unit> attackerSuicide =\n-                  PredicateBuilder.of(Matches.unitIsSuicide())\n+                  PredicateBuilder.of(Matches.unitIsSuicideOnAttack())\n                       .andIf(isBombingRun, Matches.unitIsNotStrategicBomber())\n                       .build();\n               if (attackingUnits.stream().anyMatch(attackerSuicide)) {\n                 final List<Unit> suicideUnits =\n-                    CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide());\n+                    CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicideOnAttack());\n                 attackingUnits.removeAll(suicideUnits);\n                 remove(suicideUnits, bridge, battleSite);\n                 tuvLostAttacker = TuvUtils.getTuv(suicideUnits, attacker, attackerCosts, gameData);\n                 attackerLostTuv += tuvLostAttacker;\n               }\n-              if (defendingUnits.stream().anyMatch(Matches.unitIsSuicide())) {\n+              if (defendingUnits.stream().anyMatch(Matches.unitIsSuicideOnDefense())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241712", "createdAt": "2020-01-23T17:01:47Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1380,17 +1379,18 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n   }\n \n   private void fireSuicideUnitsAttack() {\n+    // TODO: Remove isSuicideOnAttack check and update to use canNotTarget/canNotBeTargetedBy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxNw==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241717", "createdAt": "2020-01-23T17:01:47Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1419,20 +1419,18 @@ private void fireSuicideUnitsAttack() {\n   }\n \n   private void fireSuicideUnitsDefend() {\n-    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {\n-      return;\n-    }\n+    // TODO: Remove isSuicideOnDefense check and update to use canNotTarget/canNotBeTargetedBy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f96e481ef5c85697685cee00961a918b125aa5a", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/1f96e481ef5c85697685cee00961a918b125aa5a", "committedDate": "2020-01-23T18:44:39Z", "message": "Fix bug where all allied supporting units not being properly considered"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "committedDate": "2020-01-23T18:55:21Z", "message": "Remove unnecessary parameter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NzI0MDcz", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-347724073", "createdAt": "2020-01-24T02:24:25Z", "commit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMjoyNDoyNVrOFhSfGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMjozNToxOVrOFhSmYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDIwMg==", "bodyText": "Why is this the condition for suicide on defense?\n!Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450202", "createdAt": "2020-01-24T02:24:25Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDMzNg==", "bodyText": "Should first strike truly be a side effect of is suicide? Does this limit our options in case we want a unit that is just 'isSuicide'? Say someone has a non-attacking unit, or an attacking unit that is suicide, but not first strike, how could that be handled?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450336", "createdAt": "2020-01-24T02:25:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA==", "bodyText": "Should the 's' convention be carried forward? Would it be more clear if the parameter were simply spelled out?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450480", "createdAt": "2020-01-24T02:26:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+  }\n+\n+  private void setIsSuicideOnAttack(final String s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDgwNg==", "bodyText": "Side-note, do you recall the rationale to not attach this method as a property of Unit? I suspect it would be pretty clearly better encapsulation.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450806", "createdAt": "2020-01-24T02:27:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -493,8 +493,12 @@ private Matches() {}\n             && !unitCanBeCapturedOnEnteringToInThisTerritory(player, terr, data).test(unit);\n   }\n \n-  public static Predicate<Unit> unitIsSuicide() {\n-    return unit -> UnitAttachment.get(unit.getType()).getIsSuicide();\n+  public static Predicate<Unit> unitIsSuicideOnAttack() {\n+    return unit -> UnitAttachment.get(unit.getType()).getIsSuicideOnAttack();\n+  }\n+\n+  public static Predicate<Unit> unitIsSuicideOnDefense() {\n+    return unit -> UnitAttachment.get(unit.getType()).getIsSuicideOnDefense();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTQ0Nw==", "bodyText": "Would it maybe be more clear and direct to have a 'isSucicideOnAttack' property? It seems to get at that property, one has to be pretty clever to set a combination of values.\nI wonder as well if simply adding those two properties would make it easier for this update to be backward compatible. I'm very concerned that the property is not directly from the XML but is instead derived, it seems like it is quite complex compared to other properties that are usually 1:1.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451447", "createdAt": "2020-01-24T02:31:38Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTY3Nw==", "bodyText": "Kinda agree with the TODO climate warning unless we have a reference to who or what owns this task.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451677", "createdAt": "2020-01-24T02:32:51Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1380,17 +1379,18 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n   }\n \n   private void fireSuicideUnitsAttack() {\n+    // TODO: Remove isSuicideOnAttack check and update to use canNotTarget/canNotBeTargetedBy", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg=="}, "originalCommit": {"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw==", "bodyText": "Should canReturnFire be a method of Properties? Would that be more direct and re-usable? Any concern that we might duplicate or confuse this check somewhere else?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451747", "createdAt": "2020-01-24T02:33:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1404,35 +1404,33 @@ private void fireSuicideUnitsAttack() {\n     if (suicideAttackers.isEmpty() || attackedDefenders.isEmpty()) {\n       return;\n     }\n-    final boolean canReturnFire = (!isSuicideAndMunitionCasualtiesRestricted());\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>();\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingUnits);\n+    final boolean canReturnFire = (!Properties.getSuicideAndMunitionCasualtiesRestricted(gameData));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MjA2NA==", "bodyText": "Would a method overload be cleaner to avoid passing null parameter when the last parameter is unused?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370452064", "createdAt": "2020-01-24T02:35:19Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/DiceRollTest.java", "diffHunk": "@@ -63,19 +63,23 @@ void testSimple() {\n         .thenAnswer(withValues(1)); // infantry attack does not hit at 1 (0 based)\n     // infantry defends\n     final DiceRoll roll =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, true, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll.getHits(), is(1));\n     // infantry\n     final DiceRoll roll2 =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, true, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll2.getHits(), is(0));\n     // infantry attacks\n     final DiceRoll roll3 =\n-        DiceRoll.rollDice(infantry, false, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, false, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll3.getHits(), is(1));\n     // infantry attack\n     final DiceRoll roll4 =\n-        DiceRoll.rollDice(infantry, false, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "committedDate": "2020-01-28T19:39:00Z", "message": "Remove old suicide steps and begin refactoring other steps"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NjQ5ODM2", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-349649836", "createdAt": "2020-01-28T19:40:35Z", "commit": {"oid": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0MDozNVrOFiyCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0MDozNVrOFiyCYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTcxMQ==", "bodyText": "Method firstStrikeFire has 7 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372015711", "createdAt": "2020-01-28T19:40:35Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,59 +1912,63 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units defend, \",\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n+        returnFire,\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units attack, \",\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc"}, "originalPosition": 448}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTcxMw==", "bodyText": "Method standardFire has 7 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372015713", "createdAt": "2020-01-28T19:40:35Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -2014,102 +1981,98 @@ private void attackAirOnNonSubs() {\n           CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n       final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n       allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+      final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n+      allFriendlyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n       fire(\n           defender.getName() + SELECT_CASUALTIES,\n           units,\n           enemyUnitsNotSubs,\n           allEnemyUnitsAliveOrWaitingToDie,\n+          allFriendlyUnitsAliveOrWaitingToDie,\n           false,\n           ReturnFire.ALL,\n           \"Attacker's aircraft fire,\");\n     }\n   }\n \n-  /**\n-   * If there are no attacking DDs, but defending SUBs, remove attacking AIR as they've already\n-   * fired, otherwise fire all attackers.\n-   */\n-  private void attackNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike().negate());\n-    units.addAll(\n-        CollectionUtils.getMatches(attackingWaitingToDie, Matches.unitIsFirstStrike().negate()));\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    // if restricted, remove aircraft from attackers\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units.removeAll(CollectionUtils.getMatches(units, Matches.unitIsAir()));\n-    }\n-    if (units.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_CASUALTIES,\n-        units,\n-        defendingUnits,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n-        ReturnFire.ALL,\n-        \"Attackers fire,\");\n-  }\n-\n   private void defendAirOnNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n     Collection<Unit> units = new ArrayList<>(defendingUnits);\n     units.addAll(defendingWaitingToDie);\n     if (!canAirAttackSubs(attackingUnits, units)) {\n       units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n       final Collection<Unit> enemyUnitsNotSubs =\n           CollectionUtils.getMatches(attackingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      if (enemyUnitsNotSubs.isEmpty()) {\n-        return;\n-      }\n       final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n       allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n+      final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n+      allFriendlyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n       fire(\n           attacker.getName() + SELECT_CASUALTIES,\n           units,\n           enemyUnitsNotSubs,\n           allEnemyUnitsAliveOrWaitingToDie,\n+          allFriendlyUnitsAliveOrWaitingToDie,\n           true,\n           ReturnFire.ALL,\n           \"Defender's aircraft fire,\");\n     }\n   }\n \n-  private void defendNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n+  private void standardAttackersFire() {\n+    standardFire(\n+        defender.getName() + SELECT_CASUALTIES,\n+        \"Attackers fire, \",\n+        false,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void standardDefendersFire() {\n+    standardFire(\n+        attacker.getName() + SELECT_CASUALTIES,\n+        \"Defenders fire, \",\n+        true,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n+  }\n+\n+  private void standardFire(\n+      final String stepName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc"}, "originalPosition": 600}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fcdca58493bef0d78eb52570178c9d85eec117b", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/6fcdca58493bef0d78eb52570178c9d85eec117b", "committedDate": "2020-01-28T19:41:10Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97d2e060eb55787acc011ea8323359023b9eb495", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/97d2e060eb55787acc011ea8323359023b9eb495", "committedDate": "2020-01-29T21:35:17Z", "message": "Refactor firing air units on non-subs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDQxNTg2", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-350441586", "createdAt": "2020-01-29T21:37:06Z", "commit": {"oid": "97d2e060eb55787acc011ea8323359023b9eb495"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMTozNzowNlrOFjYXiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMTozNzowNlrOFjYXiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MzcyMQ==", "bodyText": "Method fireAirOnNonSubs has 7 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372643721", "createdAt": "2020-01-29T21:37:06Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,167 +1913,174 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units defend, \",\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n+        returnFire,\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units attack, \",\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,\n+      final String stepName,\n+      final String message,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> firingUnitsWaitingToDie,\n+      final Collection<Unit> enemyUnits,\n+      final Collection<Unit> enemyUnitsWaitingToDie) {\n+\n+    Collection<Unit> firing = new ArrayList<>(firingUnits);\n+    firing.addAll(firingUnitsWaitingToDie);\n+    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n+    final Set<UnitType> canNotTarget =\n+        firing.stream()\n+            .map(unit -> UnitAttachment.get(unit.getType()).getCanNotTarget())\n+            .flatMap(unitTypes -> unitTypes.stream())\n+            .collect(Collectors.toSet());\n+    final Collection<Unit> attackableUnits =\n+        CollectionUtils.getMatches(enemyUnits, Matches.unitIsOfTypes(canNotTarget).negate());\n+    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(enemyUnits);\n+    allEnemyUnitsAliveOrWaitingToDie.addAll(enemyUnitsWaitingToDie);\n+    final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(firingUnits);\n+    allFriendlyUnitsAliveOrWaitingToDie.addAll(firingUnitsWaitingToDie);\n     fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n+        stepName,\n         firing,\n-        attacked,\n+        attackableUnits,\n         allEnemyUnitsAliveOrWaitingToDie,\n+        allFriendlyUnitsAliveOrWaitingToDie,\n         false,\n         returnFire,\n-        \"Subs fire,\");\n+        message);\n   }\n \n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n   private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n+    fireAirOnNonSubs(\n+        defender.getName() + SELECT_CASUALTIES,\n+        \"Attacker's aircraft fire,\",\n+        false,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void defendAirOnNonSubs() {\n+    fireAirOnNonSubs(\n+        attacker.getName() + SELECT_CASUALTIES,\n+        \"Defender's aircraft fire,\",\n+        true,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n+  }\n+\n+  private void fireAirOnNonSubs(\n+      final String stepName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97d2e060eb55787acc011ea8323359023b9eb495"}, "originalPosition": 532}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "committedDate": "2020-01-30T00:09:44Z", "message": "Add target groups to generize limited targets (air vs subs, subs vs air)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTExMjIw", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-350511220", "createdAt": "2020-01-30T00:11:26Z", "commit": {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDoxMToyN1rOFjbzTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDoxMToyN1rOFjbzTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ==", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372699981", "createdAt": "2020-01-30T00:11:27Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4Mw==", "bodyText": "Method findTargets has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372699983", "createdAt": "2020-01-30T00:11:27Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }\n+    return sortFiringGroups(firingGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b79b9a94f95c88b799b75fedb085227983e4e152", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/b79b9a94f95c88b799b75fedb085227983e4e152", "committedDate": "2020-01-30T00:17:30Z", "message": "Update first strike to use target groups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTEzODgx", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-350513881", "createdAt": "2020-01-30T00:19:07Z", "commit": {"oid": "b79b9a94f95c88b799b75fedb085227983e4e152"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDoxOTowOFrOFjb75g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMDoxOTowOFrOFjb75g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjE4Mg==", "bodyText": "Method firstStrikeFire has 8 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372702182", "createdAt": "2020-01-30T00:19:08Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,169 +1893,115 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        true,\n+        defender,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs fire,\");\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        false,\n+        attacker,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n   }\n \n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n-  private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b79b9a94f95c88b799b75fedb085227983e4e152"}, "originalPosition": 518}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "948bbce0dc7233ca147927e39b0072699ba7fac8", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/948bbce0dc7233ca147927e39b0072699ba7fac8", "committedDate": "2020-01-30T02:10:50Z", "message": "Merge first strike and standard fire methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNTQ2MjUx", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-350546251", "createdAt": "2020-01-30T02:12:25Z", "commit": {"oid": "948bbce0dc7233ca147927e39b0072699ba7fac8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMjoxMjoyNVrOFjdlfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwMjoxMjoyNVrOFjdlfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcyOTIxNQ==", "bodyText": "Method findTargetGroupsAndFire has 9 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372729215", "createdAt": "2020-01-30T02:12:25Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,167 +1893,91 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    findTargetGroupsAndFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        true,\n+        defender,\n+        Matches.unitIsFirstStrike(),\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    findTargetGroupsAndFire(\n         returnFire,\n-        \"Subs fire,\");\n-  }\n-\n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n-  private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-      fire(\n-          defender.getName() + SELECT_CASUALTIES,\n-          units,\n-          enemyUnitsNotSubs,\n-          allEnemyUnitsAliveOrWaitingToDie,\n-          false,\n-          ReturnFire.ALL,\n-          \"Attacker's aircraft fire,\");\n-    }\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        false,\n+        attacker,\n+        Matches.unitIsFirstStrike(),\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n   }\n \n-  /**\n-   * If there are no attacking DDs, but defending SUBs, remove attacking AIR as they've already\n-   * fired, otherwise fire all attackers.\n-   */\n-  private void attackNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike().negate());\n-    units.addAll(\n-        CollectionUtils.getMatches(attackingWaitingToDie, Matches.unitIsFirstStrike().negate()));\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    // if restricted, remove aircraft from attackers\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units.removeAll(CollectionUtils.getMatches(units, Matches.unitIsAir()));\n-    }\n-    if (units.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n+  private void standardAttackersFire() {\n+    findTargetGroupsAndFire(\n+        ReturnFire.ALL,\n         defender.getName() + SELECT_CASUALTIES,\n-        units,\n-        defendingUnits,\n-        allEnemyUnitsAliveOrWaitingToDie,\n         false,\n+        attacker,\n+        Matches.unitIsFirstStrike().negate(),\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void standardDefendersFire() {\n+    findTargetGroupsAndFire(\n         ReturnFire.ALL,\n-        \"Attackers fire,\");\n+        attacker.getName() + SELECT_CASUALTIES,\n+        true,\n+        defender,\n+        Matches.unitIsFirstStrike().negate(),\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void defendAirOnNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(defendingUnits);\n-    units.addAll(defendingWaitingToDie);\n-    if (!canAirAttackSubs(attackingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(attackingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      if (enemyUnitsNotSubs.isEmpty()) {\n-        return;\n-      }\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n+  private void findTargetGroupsAndFire(\n+      final ReturnFire returnFire,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "948bbce0dc7233ca147927e39b0072699ba7fac8"}, "originalPosition": 602}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4779445748cf45fc367d1bb62c150aef62aba2b", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/f4779445748cf45fc367d1bb62c150aef62aba2b", "committedDate": "2020-01-30T03:53:05Z", "message": "Remove old suicide methods and reorder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "committedDate": "2020-01-30T05:22:12Z", "message": "Fix bug with filtering out suicide units as targets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acd8a4264a7ab567beb9a0a40f90985a17cdb031", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/acd8a4264a7ab567beb9a0a40f90985a17cdb031", "committedDate": "2020-01-30T06:43:05Z", "message": "Add comment and deprecated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjA1Mzkw", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-350605390", "createdAt": "2020-01-30T06:34:59Z", "commit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNjozNDo1OVrOFjgn_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNjo0MjowN1rOFjgugQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ==", "bodyText": "nit, not sure a casual reader will understand the comment to 'support isSuicide \"shortcut\"', they may wonder how it is a shortcut, and what 'isSuicide' is necessarily even referring to.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372779005", "createdAt": "2020-01-30T06:34:59Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng==", "bodyText": "nit, it's just the matches type that varies depending on the if condition, seems though the if/else could be simplified.\nBeyond the code low-level cleanup, why is the 'isSub' and 'isSuicide' properties opposites of one another? IE: why is if 'isSuicide' is false, then 'isSub' is true?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372779586", "createdAt": "2020-01-30T06:37:27Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut\n+        canNotTarget =\n+            new HashSet<>(\n+                CollectionUtils.getMatches(\n+                    getData().getUnitTypeList().getAllUnitTypes(),\n+                    Matches.unitTypeIsSuicideOnAttack().or(Matches.unitTypeIsSuicideOnDefense())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MDA1OQ==", "bodyText": "\"Easier to just update them all at once.\"\n\nI have trouble agreeing as there are many more instances 'to fix' now. It's not clear they would all get the same fix.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372780059", "createdAt": "2020-01-30T06:39:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+  }\n+\n+  private void setIsSuicideOnAttack(final String s) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MDY3Mw==", "bodyText": "Actually, backing up a bit, the private setter is really odd. Perhaps would it be easier if we just inlined this? Then when invoked via method reference, it would imply that we have more going on then a simple setter. Someone reading the code would be no worse off seeing any of the inconsistent cases, either they'd see the simple setter inline, or they would see a method reference that is either more complex or is a simple setter (which we could later come back to clean up).", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372780673", "createdAt": "2020-01-30T06:42:07Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+  }\n+\n+  private void setIsSuicideOnAttack(final String s) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1229bdbb613fd471e150e8040858bbda8ac91b8", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e1229bdbb613fd471e150e8040858bbda8ac91b8", "committedDate": "2020-01-30T18:49:56Z", "message": "Fix isSuicide target setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e45366947243005208ef3c06e474eb0744ce5847", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e45366947243005208ef3c06e474eb0744ce5847", "committedDate": "2020-01-31T01:16:47Z", "message": "Fix battle window suicide unit casualty display"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87261f56df749663d812b6fe8cd2d1fd388456a3", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/87261f56df749663d812b6fe8cd2d1fd388456a3", "committedDate": "2020-01-31T05:09:12Z", "message": "Improve removing suicide units from battle window earlier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/618906a97c18387623f1050f6c7d7cccaf0409a2", "committedDate": "2020-01-31T06:24:43Z", "message": "Add overload diceRoll method and refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODQ2NjE2", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351846616", "createdAt": "2020-02-01T00:30:47Z", "commit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDozMDo0OFrOFkbSow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMDo1NDozMlrOFkbekg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MDE5NQ==", "bodyText": "I don't think that would qualify as too much inlining, it helps a lot as it makes clear what is different between the two cases. You can assign to an intermediary variable if the inline syntax feels awkward.\n\nThey aren't true opposites...\n\nPoint taken, a casual reader would be very confused why we can assume with one condition being false that we fall into this other (seemingly very unrelated) case.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373740195", "createdAt": "2020-02-01T00:30:48Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut\n+        canNotTarget =\n+            new HashSet<>(\n+                CollectionUtils.getMatches(\n+                    getData().getUnitTypeList().getAllUnitTypes(),\n+                    Matches.unitTypeIsSuicideOnAttack().or(Matches.unitTypeIsSuicideOnDefense())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng=="}, "originalCommit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MDc2Mg==", "bodyText": "Some options:\n\nremove the comment\nexpound on the comment and provide links/references for context\nbake the 'isSuicide' into matches.\nMake 'CanTarget' a property of \"UnitType\", add explanations there\n\nThe last is probably my preferred approach followed by adding a specific matcher. I like the last approach as it has the best encapsulation and is the most easily tested (this section of code would be great to have tests for, it would make review easier and would lend more confidence this is working as intended).\nIs there a legit timeline of when we can retrofit all maps to not have 'isSuicide'? IMHO the bulk map update experiences we have had caused far more pain than they are worth, and we do not even have ownership of all maps, and there was a lot of pain there. Removing map features I don't think is feasible and is part of why I think it's important we add versioning to map syntax/formats. Regardless of your viewpoint there, having a 'Matches.isSuicide' is independent of it is an actual unit property and the matches is, like here, a composite property.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373740762", "createdAt": "2020-02-01T00:35:01Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ=="}, "originalCommit": {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MTMwMg==", "bodyText": "I believe the double setters (1 string, 1 actual type) has to do with the XML parsing for attachments. The attachment classes in general are very rough and primarily there for to hold the values from the map XML parsing.\n\nI believe I understood that; My point is the indirection here does not seem useful, inlining these methods would reduce the indirection.\nRe: variable name, most of the examples have been touched/added here and the new setter methods could have different variable names altogether. I don't really trust that we ever will come back and fix them.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373741302", "createdAt": "2020-02-01T00:39:08Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+  }\n+\n+  private void setIsSuicideOnAttack(final String s) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjAzMA==", "bodyText": "It does not look like this setter is used. Can it be removed? Is this class actually immutable? If not, it looks like it would not take too much to make it so, is that feasible? Is there a reason for mutability?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742030", "createdAt": "2020-02-01T00:44:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA==", "bodyText": "It looks like the getter here is used only internally. Unless I missed a usage, do you have any thoughts on removing the getter or restricting the visibility of the get method?\nLooking at the class, and the class properties, it raises a code smell if we return the internal data, it makes it seem as if the class were incompletely providing operations on the data members. IE: if this class provides operations on two internal sets, then what's the point to return the internal data unless this class is incomplete in doing so.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742538", "createdAt": "2020-02-01T00:48:27Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjY1OA==", "bodyText": "It looks like this is always a singleton set, do I see that correctly? Why store this as a set if it always has size == 1?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742658", "createdAt": "2020-02-01T00:49:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjgwOQ==", "bodyText": "Nit, this method can be marked as static. It also seems to not really belong to this class as well (knowing it's static helps highlight that). Any thoughts to simply inline this to its single usage and avoid the indirection?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742809", "createdAt": "2020-02-01T00:50:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0Mjk0Mw==", "bodyText": "A test of this method would help review and add confidence this is completely working as expected. Such a test would give design feedback as well and potentially help drive further break down in responsibility to make it easier to test and understand.\nFor example, extracting 'findTargets' to its own module would be a first simplification that would help decompose the problem, ie: a targetFinder that is perhaps injected into this class.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742943", "createdAt": "2020-02-01T00:51:46Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ=="}, "originalCommit": {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzEwMg==", "bodyText": "\ud83d\udc4d   Good to see unused/placeholder args falling away.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743102", "createdAt": "2020-02-01T00:53:21Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/DiceRollTest.java", "diffHunk": "@@ -63,19 +63,19 @@ void testSimple() {\n         .thenAnswer(withValues(1)); // infantry attack does not hit at 1 (0 based)\n     // infantry defends\n     final DiceRoll roll =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(infantry, true, russians, bridge, battle, territoryEffects);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzI1MA==", "bodyText": "\ud83d\udc4d   I like quite a bit we are making the ordering more generic and list 'first strike units' rather than assuming any/all first strike units are subs.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743250", "createdAt": "2020-02-01T00:54:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/WW2V3Year41Test.java", "diffHunk": "@@ -1143,12 +1129,12 @@ void testAttackDestroyerAndSubsAgainstSubAndDestroyer() {\n     final List<String> steps = battle.determineStepStrings(true);\n     assertEquals(\n         List.of(\n-                attacker + SUBS_FIRE,\n-                defender + SELECT_SUB_CASUALTIES,\n+                attacker + FIRST_STRIKE_UNITS_FIRE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODUxNDU3", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351851457", "createdAt": "2020-02-01T01:01:02Z", "commit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMTowMTowMlrOFkbh3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMTowMTowMlrOFkbh3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDA5Mw==", "bodyText": "This deadUnit notification only appears in one branch of the unmodified code, for a case of isDefendingSuicideAndMunitionUnitsDoNotFire, why should this be shown now for all cases? Is this a no-op perhaps, is there something subtle that is not obvious?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373744093", "createdAt": "2020-02-01T01:01:02Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1805,25 +1805,16 @@ private void defenderRetreatSubs(final IDelegateBridge bridge) {\n    * Check for suicide units and kill them immediately (they get to shoot back, which is the point).\n    */\n   private void checkSuicideUnits(final IDelegateBridge bridge) {\n-    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {\n-      final List<Unit> deadUnits =\n-          CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide());\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, attacker, deadUnits, dependentUnits);\n-      remove(deadUnits, bridge, battleSite, false);\n-    } else {\n-      final List<Unit> deadUnits = new ArrayList<>();\n-      deadUnits.addAll(CollectionUtils.getMatches(defendingUnits, Matches.unitIsSuicide()));\n-      deadUnits.addAll(CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide()));\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, attacker, deadUnits, dependentUnits);\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, defender, deadUnits, dependentUnits);\n-      remove(deadUnits, bridge, battleSite, null);\n-    }\n+    final List<Unit> deadUnits = new ArrayList<>();\n+    deadUnits.addAll(CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicideOnAttack()));\n+    deadUnits.addAll(CollectionUtils.getMatches(defendingUnits, Matches.unitIsSuicideOnDefense()));\n+    bridge", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODUxOTg3", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351851987", "createdAt": "2020-02-01T01:05:12Z", "commit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMTowNToxMlrOFkbj1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMTowNToxMlrOFkbj1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDU5OQ==", "bodyText": "It's striking we have the same parameter passed in twice to a method. IMHO it is a pretty significant API code smell. Perhaps an extract parameter object refactor would fix that?\nIMO the existing API already has significant technical debt, I don't think that is fair reason to add more potential debt for someone else to attempt to fix. It's also very notable that a number of other parameters are already useless, seems like this API is already stretched.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373744599", "createdAt": "2020-02-01T01:05:12Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/PacificTest.java", "diffHunk": "@@ -108,20 +108,44 @@ void testNonJapanAttack() {\n     // Defending US infantry\n     DiceRoll roll =\n         DiceRoll.rollDice(\n-            infantryUs, true, americans, bridge, mock(IBattle.class), \"\", territoryEffects, null);\n+            infantryUs,\n+            true,\n+            americans,\n+            bridge,\n+            mock(IBattle.class),\n+            \"\",\n+            territoryEffects,\n+            null,\n+            infantryUs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f20102ef3e8ff6c07b4b2fceb8cd48f0ae208019", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/f20102ef3e8ff6c07b4b2fceb8cd48f0ae208019", "committedDate": "2020-02-01T06:00:59Z", "message": "Refactor canNotTarget method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "committedDate": "2020-02-01T06:03:04Z", "message": "Remove unused setters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODcwNjAz", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351870603", "createdAt": "2020-02-01T07:20:07Z", "commit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyMDowN1rOFkcvKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyMDowN1rOFkcvKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzg4MA==", "bodyText": "Could you clarify or define 'restrictive' in this context? It's not clear to me from this context what that would exactly mean.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763880", "createdAt": "2020-02-01T07:20:07Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODcwNjU2", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351870656", "createdAt": "2020-02-01T07:22:16Z", "commit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyMjoxNlrOFkcveA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyMjoxNlrOFkcveA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA==", "bodyText": "Have you considered re-writing this with a stream+map+collect to remove the intermediary variables and the 'added' local tracking variable? Any thoughts to adding an explanatory comment to help indicate what operation we are doing here?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763960", "createdAt": "2020-02-01T07:22:16Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODcwNzIx", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351870721", "createdAt": "2020-02-01T07:24:04Z", "commit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyNDowNFrOFkcvzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwNzoyNDowNFrOFkcvzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NDA0NA==", "bodyText": "nit, noneMatch should be able to replace the !...anyMatch() and help avoid the negation", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373764044", "createdAt": "2020-02-01T07:24:04Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }\n+    return sortFiringGroups(firingGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    if (!unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODc0MDYz", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351874063", "createdAt": "2020-02-01T09:03:17Z", "commit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwOTowMzoxOFrOFkc_Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwOTowMzoxOFrOFkc_Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ==", "bodyText": "The set to null might be potentially dangerous / NPE if setCanNotTarget is invoked after setIsSuicide, noting on line 683:\n  private void setCanNotTarget(final String value) throws GameParseException {\n    final String[] s = splitOnColon(value);\n    for (final String u : s) {\n      final UnitType ut = getData().getUnitTypeList().getUnitType(u);\n      if (ut == null) {\n        throw new GameParseException(\"canNotTarget: no such unit type: \" + u + thisErrorMsg());\n      }\n683:      canNotTarget.add(ut);\n    }\n  }\n\nWould that be a potential problem?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373767959", "createdAt": "2020-02-01T09:03:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1751,20 +1756,54 @@ private void resetCanDieFromReachingMaxDamage() {\n     canDieFromReachingMaxDamage = false;\n   }\n \n+  @Deprecated\n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n+  @Deprecated\n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    // Global property controlled whether isSuicide units would suicide on defense\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+    if (s) {\n+      canNotTarget = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "825fab6207cdb9c40240924cf97a3825c8a09783", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/825fab6207cdb9c40240924cf97a3825c8a09783", "committedDate": "2020-02-01T16:49:30Z", "message": "Use mapper helper method to reduce needed methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef7cb2eebcf41feee7e9d83d61fef4d4f3e35397", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/ef7cb2eebcf41feee7e9d83d61fef4d4f3e35397", "committedDate": "2020-02-01T17:31:06Z", "message": "Reduce getter visibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c10e900d63431f02c394e910d1fb50491e659a2a", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/c10e900d63431f02c394e910d1fb50491e659a2a", "committedDate": "2020-02-01T17:33:46Z", "message": "Move message functionality in line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86fef31414b37cd8ed56d6c575c1908d46e5c817", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/86fef31414b37cd8ed56d6c575c1908d46e5c817", "committedDate": "2020-02-01T17:34:48Z", "message": "Update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e43cc9151b6191d214dbe2dcd95cc8b7bc2f18eb", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e43cc9151b6191d214dbe2dcd95cc8b7bc2f18eb", "committedDate": "2020-02-01T17:38:54Z", "message": "Replace negated anyMatch with noneMatch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b132dee1943b2cee302c1105387cfa8af3cfa6e3", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/b132dee1943b2cee302c1105387cfa8af3cfa6e3", "committedDate": "2020-02-01T18:13:07Z", "message": "Refactor TargetGroup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd88b5adab4bb79e5a59ccf71cbaf336d1bcd2c6", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/cd88b5adab4bb79e5a59ccf71cbaf336d1bcd2c6", "committedDate": "2020-02-01T18:15:41Z", "message": "Rename variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70ce42ef5472fabf34777b054200f721696dc57c", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/70ce42ef5472fabf34777b054200f721696dc57c", "committedDate": "2020-02-01T20:14:46Z", "message": "Add unit tests for TargetGroup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb504fa3c49f996059abcedc47859808a087b2b", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/7bb504fa3c49f996059abcedc47859808a087b2b", "committedDate": "2020-02-02T00:32:16Z", "message": "Refactor to use streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/4720f7a8962bbcc430de07a7e10161e755ed6008", "committedDate": "2020-02-02T00:40:02Z", "message": "Add null check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxOTgyODIx", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-351982821", "createdAt": "2020-02-03T00:53:10Z", "commit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMDo1MzoxMVrOFkkebw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMDo1OTowOVrOFkkgPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDY3MQ==", "bodyText": "nit: https://github.com/triplea-game/triplea/wiki/Java-Test-Code-Conventions#favor-hamcrest-assertthat-for-new-tests--5526\nassertEquals(0, results.size()) -> assertThat(results, is(emptyCollection())", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890671", "createdAt": "2020-02-03T00:53:11Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDg4OQ==", "bodyText": "https://github.com/triplea-game/triplea/wiki/Java-Test-Code-Conventions#favor-adding-displayname-to-each-test-case-5525\nIt's not 100% clear why the result should be empty. A @DisplayName would help this potentially.\nIt looks like the empty result is because the first List.of() parameter is empty. A comment in the assertThat method can also be used to help clarify why we expect the test to be true. (a convention for this is nearly finalized: #5527)\nSide-note, it's a very important aspect of test maintainability that it's obvious why they should pass. The combination of @DisplayName and assertion comments is intended to make it obvious on each test case.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890889", "createdAt": "2020-02-03T00:56:12Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw==", "bodyText": "nit: assertEquals(1, results.size()) -> assertThat(result, hasSize(1))", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890977", "createdAt": "2020-02-03T00:57:17Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), enemyUnits);\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyEnemyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsForOneUnitAndOneEnemyUnit() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final GamePlayer britain = GameDataTestUtil.britain(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.britishInfantry(twwGameData).create(1, britain);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, enemyUnits);\n+    assertEquals(1, result.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MTEzNA==", "bodyText": "As noted once, but ditto and for the rest of the tests, an assertion comment and/or displayname to explicitly state why we expect the various assertion conditions to be true would go a long way to making it trivial to understand these tests - in that case if any should break it would be much easier to fix them and skips the preliminary step of investigating why the test was correct to begin with.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373891134", "createdAt": "2020-02-03T00:59:09Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), enemyUnits);\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyEnemyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsForOneUnitAndOneEnemyUnit() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final GamePlayer britain = GameDataTestUtil.britain(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.britishInfantry(twwGameData).create(1, britain);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, enemyUnits);\n+    assertEquals(1, result.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw=="}, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDEzNDcz", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-352013473", "createdAt": "2020-02-03T04:14:53Z", "commit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDoxNDo1NFrOFkmB5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDoxNDo1NFrOFkmB5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA==", "bodyText": "This looks strange, could you check this @ron-murhammer ? It looks like targetGroups is always empty.  Was the iteration supposed to be on targets?", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373916134", "createdAt": "2020-02-03T04:14:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> targetGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      addToTargetGroups(unitType, targets, targetGroups);\n+    }\n+    return sortTargetGroups(targetGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    return unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())\n+        ? targets\n+        : targets.stream()\n+            .filter(\n+                target -> !UnitAttachment.get(target).getCanNotBeTargetedBy().contains(unitType))\n+            .collect(Collectors.toSet());\n+  }\n+\n+  private static void addToTargetGroups(\n+      final UnitType unitType, final Set<UnitType> targets, final List<TargetGroup> targetGroups) {\n+    if (targets.isEmpty()) {\n+      return;\n+    }\n+    targetGroups.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDEzODUz", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-352013853", "createdAt": "2020-02-03T04:17:18Z", "commit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDoxNzoxOFrOFkmDOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDoxNzoxOFrOFkmDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjQ3NQ==", "bodyText": "nit, addToTargetGroups could be a bit more descriptive. Notably, I'm curious/not sure what exactly we are adding to target groups. I'm not honestly 100% sure how to describe what we're adding to target groups here, sorry to not have good suggestions for you on-hand.\nSecond, bit of a side note, if you're able to see a way, would be nice as well to be able to return a result rather than modifying the input param targetGroups.  In which case up on line 55 we could have something like:\ntargetGroups.addEligibleTargets(unitType, targets);", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373916475", "createdAt": "2020-02-03T04:17:18Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> targetGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      addToTargetGroups(unitType, targets, targetGroups);\n+    }\n+    return sortTargetGroups(targetGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    return unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())\n+        ? targets\n+        : targets.stream()\n+            .filter(\n+                target -> !UnitAttachment.get(target).getCanNotBeTargetedBy().contains(unitType))\n+            .collect(Collectors.toSet());\n+  }\n+\n+  private static void addToTargetGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDE3NTM0", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-352017534", "createdAt": "2020-02-03T04:36:50Z", "commit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDozNjo1MFrOFkmO-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDozNjo1MFrOFkmO-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxOTQ4MQ==", "bodyText": "I see AI is tearing through this method quite frequently while simulating battles. Would it make sense to early return an empty list here if either of the input parameters are empty? I'm wondering if that might help performance a bit, particularly if unit stacks get to be very large, and secondly it might help a code maintainer grok this method to quickly know this method is effectively a no-op if either parameter is empty.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373919481", "createdAt": "2020-02-03T04:36:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0ed40f5e41b0a4cd71bd94f3cf76d5916c2ae7c", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/a0ed40f5e41b0a4cd71bd94f3cf76d5916c2ae7c", "committedDate": "2020-02-04T02:50:02Z", "message": "Refactor unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de213100360178d0859e9aa35f8317ebb81956c9", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/de213100360178d0859e9aa35f8317ebb81956c9", "committedDate": "2020-02-04T03:02:43Z", "message": "Fix formatting issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "506169c46c2520e9892f623cea27d7a9ff1b65d4", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/506169c46c2520e9892f623cea27d7a9ff1b65d4", "committedDate": "2020-02-06T05:21:54Z", "message": "Update unit test to check can not target property is set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bda17c03b303952f37419a1df26de5d4670514a", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/9bda17c03b303952f37419a1df26de5d4670514a", "committedDate": "2020-02-07T03:09:19Z", "message": "Refactor to avoid mutable parameters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTA5Mjcy", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-354909272", "createdAt": "2020-02-07T03:11:17Z", "commit": {"oid": "9bda17c03b303952f37419a1df26de5d4670514a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzoxMToxN1rOFmxJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzoxMToxN1rOFmxJlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE5NTQ3Ng==", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376195476", "createdAt": "2020-02-07T03:11:17Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bda17c03b303952f37419a1df26de5d4670514a"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e34ed1cf5c838b7cf400c587d79a899915d7ada3", "author": {"user": {"login": "ron-murhammer", "name": "Ron"}}, "url": "https://github.com/triplea-game/triplea/commit/e34ed1cf5c838b7cf400c587d79a899915d7ada3", "committedDate": "2020-02-07T03:27:18Z", "message": "Remove unused parameter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTEzNDM5", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-354913439", "createdAt": "2020-02-07T03:29:30Z", "commit": {"oid": "e34ed1cf5c838b7cf400c587d79a899915d7ada3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzoyOTozMFrOFmxYpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzoyOTozMFrOFmxYpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE5OTMzMw==", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376199333", "createdAt": "2020-02-07T03:29:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34ed1cf5c838b7cf400c587d79a899915d7ada3"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d", "author": {"user": {"login": "DanVanAtta", "name": "Dan Van Atta"}}, "url": "https://github.com/triplea-game/triplea/commit/4c38ef18f8e4d4a1f3822bd157e94d88595fb08d", "committedDate": "2020-02-07T03:53:10Z", "message": "Merge remote-tracking branch 'origin' into Enhance_Suicide_Options"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTE4ODY1", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-354918865", "createdAt": "2020-02-07T03:54:32Z", "commit": {"oid": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzo1NDozMlrOFmxrCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMzo1NDozMlrOFmxrCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIwNDA0MQ==", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376204041", "createdAt": "2020-02-07T03:54:32Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTE4OTIw", "url": "https://github.com/triplea-game/triplea/pull/5871#pullrequestreview-354918920", "createdAt": "2020-02-07T03:54:48Z", "commit": {"oid": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3765, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}