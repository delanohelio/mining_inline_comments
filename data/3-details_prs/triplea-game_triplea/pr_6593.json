{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTA0NDI2", "number": 6593, "title": "Move SubmergeVsAir and AirVsNonSubs steps to individual BattleStep classes", "bodyText": "This shows the new BattleStep classes and refactoring three steps.\nEach BattleStep has 0 or more names and 0 or 1 executables.  Of the three steps that have been converted, one has a name and an executable, the other two have no executables.\nEach BattleStep has a valid function that checks if the step is needed according to the battle state.  This is used when determining if the names should be grabbed, if the executable should be added to the stack, or if the executable should be executed.\nI've created two new interfaces: BattleActions and BattleState.  The MustFightBattle implements both of them.  The BattleActions will only encompass methods that interact with the IBridgeDelegate.  BattleState will only encompass methods that interact with internal data structures of MustFightBattle.  These interfaces will grow as more steps are converted.  Once all the steps are converted, it might be good to look into splitting the logic behind these interfaces into separate classes instead of MustFightBattle.  The interfaces will also help in converting the other battle classes.\nI haven't yet built a factory class that generates the steps in the correct order.  I'm not sure how to implement it with only some of the steps converted.  I'll build the factory class once I've converted more steps.\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix:  \n[] Other:   \nTesting\nNo manual testing\nAdditional Review Notes\nI'm also fixing what I think is two bugs.\nIn the original code, the step SUBMERGE_SUBS_VS_AIR_ONLY was shown in the battle UI after the subs fired step.  But the actual step was executed before the subs fired.  So you would have a battle ui that said \"Subs fire\", \"Remove Sub Casualties\", \"Subs Submerge vs Air\".  I think the order is wrong.  Also, the \"subs fire\", \"remove sub casualties\" probably shouldn't show up but that's another step that I'll work on.\nAlso, it only showed the SUBMERGE_SUBS_VS_AIR_ONLY if the attacker was all airplanes and the defender was subs.  But if the attacker was all subs and the defender was all airplanes, you'd still submerge.  You just wouldn't see that in the battle ui.  I changed that as well.", "createdAt": "2020-06-04T21:36:36Z", "url": "https://github.com/triplea-game/triplea/pull/6593", "merged": true, "mergeCommit": {"oid": "cc0bf88357fb16f4b93eb5f5c70d6c3736988b77"}, "closed": true, "closedAt": "2020-06-08T04:48:10Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoFFGegFqTQyNDg1NDAxNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpJBuAAFqTQyNTkxMzAzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU0MDE0", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-424854014", "createdAt": "2020-06-04T21:38:08Z", "commit": {"oid": "f7a20bde28db85f24059b73e6c3a262630d916d6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTozODowOFrOGfY7pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTozODowOVrOGfY7qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUyNg==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567526", "createdAt": "2020-06-04T21:38:08Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package games.strategy.triplea.delegate.battle.steps;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a20bde28db85f24059b73e6c3a262630d916d6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUyOQ==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567529", "createdAt": "2020-06-04T21:38:09Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/AirDefendVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package games.strategy.triplea.delegate.battle.steps;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a20bde28db85f24059b73e6c3a262630d916d6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUzMQ==", "bodyText": "TODO found", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567531", "createdAt": "2020-06-04T21:38:09Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1127,6 +1383,8 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n                 attacker, battleSite, gameData));\n     // bombarding units can't move after bombarding\n     if (!headless) {\n+      // TODO: StepRefactor: Why is a change always added even if there are no units?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a20bde28db85f24059b73e6c3a262630d916d6"}, "originalPosition": 382}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzE2MTM4", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425716138", "createdAt": "2020-06-06T05:39:25Z", "commit": {"oid": "546c4a2f638fddbac3a4335eb1a955bc3c843385"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwNTozOToyNVrOGgCBvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwNTozOToyNVrOGgCBvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDgyOA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436240828", "createdAt": "2020-06-06T05:39:25Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546c4a2f638fddbac3a4335eb1a955bc3c843385"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDgzMA==", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436240830", "createdAt": "2020-06-06T05:39:25Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirDefendVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "546c4a2f638fddbac3a4335eb1a955bc3c843385"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b340780a3bea0fd95d439000b1624762c41089da", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b340780a3bea0fd95d439000b1624762c41089da", "committedDate": "2020-06-06T23:27:18Z", "message": "Move logic for SubmergeSubsVsAir to a BattleStep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72a091ff50b9786dea287a1e8a5751e40ae53fa2", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/72a091ff50b9786dea287a1e8a5751e40ae53fa2", "committedDate": "2020-06-06T23:27:18Z", "message": "Move logic for AirVsNonSubs to a BattleStep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b1231f589c1590eb15fa3799a3a60373f4a5e51", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/0b1231f589c1590eb15fa3799a3a60373f4a5e51", "committedDate": "2020-06-06T23:27:18Z", "message": "A single BattleStep will only have at most one name and one executable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0cde49386954cffe13ec8ffd15415f64db82806", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/e0cde49386954cffe13ec8ffd15415f64db82806", "committedDate": "2020-06-06T23:27:18Z", "message": "Firing steps have two step names: fire and remove casualties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fe48325eee8f44fa0fbd86146f47fc2465e745c", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/2fe48325eee8f44fa0fbd86146f47fc2465e745c", "committedDate": "2020-06-06T23:27:18Z", "message": "Add comments and improve the names of things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "921b008f58c4b8cc063d6f99c388d667f5e1aebc", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/921b008f58c4b8cc063d6f99c388d667f5e1aebc", "committedDate": "2020-06-06T23:27:18Z", "message": "Group classes into packages and simplify some duplicate test code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df501a88d471e12df483e0f7c8a997fba3dcd4bb", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/df501a88d471e12df483e0f7c8a997fba3dcd4bb", "committedDate": "2020-06-06T23:27:18Z", "message": "Run spotlessApply"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "546c4a2f638fddbac3a4335eb1a955bc3c843385", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/546c4a2f638fddbac3a4335eb1a955bc3c843385", "committedDate": "2020-06-06T05:37:02Z", "message": "Run spotlessApply"}, "afterCommit": {"oid": "df501a88d471e12df483e0f7c8a997fba3dcd4bb", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/df501a88d471e12df483e0f7c8a997fba3dcd4bb", "committedDate": "2020-06-06T23:27:18Z", "message": "Run spotlessApply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3d9cdf98b807457f64a004a77536e73a77152f7", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d3d9cdf98b807457f64a004a77536e73a77152f7", "committedDate": "2020-06-07T01:05:17Z", "message": "Remove unused IExecutable named subclass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0e1884f50c127c1dc6403dbdc52074a26e2eab8", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/f0e1884f50c127c1dc6403dbdc52074a26e2eab8", "committedDate": "2020-06-07T03:25:06Z", "message": "Create a 'battle state' contract between the battle steps and MustFightBattle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d1aa9ca7512274acb907d7ffacd1a3045452f641", "committedDate": "2020-06-07T03:35:54Z", "message": "Import the enum directly"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzg0NTY4", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425784568", "createdAt": "2020-06-07T03:41:13Z", "commit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMzo0MToxM1rOGgG8gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMzo0MToxM1rOGgG8gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQxMQ==", "bodyText": "I copied this comment from MustFightBattle#getBattleExecutables but I think the comment might be outdated.  I think it should reference IDelegateBridge instead of IDisplay, IPlayer, or IRandomSource.  The only way I see steps can talk to IDisplay, IPlayer, or IRandomSource is by going through IDelegateBridge.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436321411", "createdAt": "2020-06-07T03:41:13Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Request.EXEC;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  /** Indicates when {@link #valid} is being called */\n+  public enum Request {\n+    // Occurs at the start of the battle round\n+    NAME,\n+    // Occurs right before the step executes\n+    EXEC,\n+  }\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @param request Indicates when valid is being called\n+   * @return true if valid\n+   */\n+  public abstract boolean valid(Request request);\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked\n+   *\n+   * @param stack The current stack of steps\n+   * @param bridge DelegateBridge for interacting with the rest of the program\n+   */\n+  protected abstract void execute(ExecutionStack stack, IDelegateBridge bridge);\n+\n+  /**\n+   * This is used to break up the battle into separate atomic pieces. If there is a network error,\n+   * or some other unfortunate event, then we need to keep track of what pieces we have executed,\n+   * and what is left to do. Each atomic step is in its own BattleAtomic with the definition of\n+   * atomic is that either:\n+   *\n+   * <ol>\n+   *   <li>The code does not call to an IDisplay, IPlayer, or IRandomSource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzg0NjE3", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425784617", "createdAt": "2020-06-07T03:42:45Z", "commit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMzo0Mjo0NVrOGgG8wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMzo0Mjo0NVrOGgG8wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQ3Mw==", "bodyText": "As I mentioned in the first comment, these manual instantiations of the steps will be moved into a step factory that builds the required steps and puts them in the correct order.  But I can't build that factory until I have a few more steps converted.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436321473", "createdAt": "2020-06-07T03:42:45Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -44,9 +55,14 @@\n   final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n   final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n       getEmptyOrFriendlySeaNeighbors;\n+  final @NonNull BattleActions battleActions;\n \n   public List<String> get() {\n \n+    final BattleStep submergeSubsVsOnlyAir = new SubmergeSubsVsOnlyAirStep(this, battleActions);\n+    final BattleStep airAttackVsNonSubs = new AirAttackVsNonSubsStep(this, battleActions);\n+    final BattleStep airDefendVsNonSubs = new AirDefendVsNonSubsStep(this, battleActions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd427a17f914835aa07396e84af56a3721954ad5", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/fd427a17f914835aa07396e84af56a3721954ad5", "committedDate": "2020-06-07T03:49:11Z", "message": "Remove the Request enum since it doesn't appear to be needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e1c1f0d7f16573ae0821d5e4f17cf79275a86cb", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/5e1c1f0d7f16573ae0821d5e4f17cf79275a86cb", "committedDate": "2020-06-07T05:39:39Z", "message": "Parameterize SubmergeSubsVsOnlyAirStepTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "548e792477ecfc003d17abf0b40705bd952e83e7", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/548e792477ecfc003d17abf0b40705bd952e83e7", "committedDate": "2020-06-07T05:40:08Z", "message": "Add Builder to the MockBattleState inner class to indicate that it is for building"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ca3523bd43a48fb8c3f241f2b602b5f1be0b32a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/2ca3523bd43a48fb8c3f241f2b602b5f1be0b32a", "committedDate": "2020-06-07T05:52:44Z", "message": "Merge remote-tracking branch 'upstream/master' into submerge-vs-air-moved-to-step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "904502d32148455eeae9ca127969582ef2ebbe4e", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/904502d32148455eeae9ca127969582ef2ebbe4e", "committedDate": "2020-06-07T05:58:24Z", "message": "Remove duplicate tests now that the step is in its own class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89563828abc9b93bac68138091b487168b727412", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/89563828abc9b93bac68138091b487168b727412", "committedDate": "2020-06-07T06:00:01Z", "message": "Run spotlessJavaApply"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzg5NzYw", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425789760", "createdAt": "2020-06-07T06:02:05Z", "commit": {"oid": "89563828abc9b93bac68138091b487168b727412"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNjowMjowNlrOGgHYOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNjowMjowNlrOGgHYOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyODUwNQ==", "bodyText": "These two tests (attackingCanNotBeTargetedByAllCanSubmergeWithAllAir and defendingCanNotBeTargetedByAllCanSubmergeWithAllAir) are now being tested in SubmergeSubsVsOnlyAirStepTest#testSubmerging.  I considered leaving these tests in till after this is merged just to show that the logic is still correct.  Should I put them back in or is it ok to delete them now?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436328505", "createdAt": "2020-06-07T06:02:06Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -1603,68 +1602,4 @@ void firstStrikeDefenderReturnFireAttNoDestroyerDefNoDestroyerWW2v2FalseSneakAtt\n         MustFightBattle.ReturnFire.ALL,\n         false);\n   }\n-\n-  @Test\n-  @DisplayName(\"Verify attacking canNotBeTargetedByAll can submerge if all is air\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89563828abc9b93bac68138091b487168b727412"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d785386323545db6c2a105cfe572e452922640b5", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d785386323545db6c2a105cfe572e452922640b5", "committedDate": "2020-06-07T14:17:25Z", "message": "Make the MockBattleState a builder instead of having it wrap a builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a09b2e3cad7e262e5c3ce04e19f1f6dd86511119", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/a09b2e3cad7e262e5c3ce04e19f1f6dd86511119", "committedDate": "2020-06-07T14:19:38Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54b79f7066cbb6b1e1df822e65956eecc49c9889", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/54b79f7066cbb6b1e1df822e65956eecc49c9889", "committedDate": "2020-06-07T15:05:01Z", "message": "Fix ordering of variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/fe64e1ca01ceb7122f91f632e1cf88acdc148108", "committedDate": "2020-06-07T17:19:00Z", "message": "Handle save game compatibility"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODUyNTA4", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425852508", "createdAt": "2020-06-07T20:54:48Z", "commit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMDo1NDo0OVrOGgLzDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMTozNTozMlrOGgL_XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDkxMA==", "bodyText": "My presumption is that changes to the battle state are implementation dependent, IE: we assume that the underlying collection is returned and any modifications to it will modify the underlying collection.\nWhat are your thoughts to provide mutator methods?\nIE:\nvoid removeAttackerUnits(Unit... units);\nvoid removeDefendingUnits(Unit... units);", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436400910", "createdAt": "2020-06-07T20:54:49Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+\n+/** Exposes the battle state and allows updates to it */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTI0NA==", "bodyText": "Nit, I don't think we typically document when something is mutable or immutable. There are annotations to do that. Presume for example that BattleState were used in 10 places, that's 10 places to have the mutable comment. If we were then to make BattleState immutable, it is either a lot of commentary that is out of date, or best case a lot of comments to update. Either way we add maintenance work. I think it's just easier then to omit mutable/immutable documentation (and if immutable, then perhaps that is okay to document via @Immutable as we probably should not make making an immutable object mutable)", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401244", "createdAt": "2020-06-07T20:59:06Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTYxOQ==", "bodyText": "Inheritance is a very strong form of coupling, using protected variables is also potentially very painful as well when considering inheritance hierarchies. In some cases as well some implementations may not need all of the protected variables.\nWhat are your thoughts to convert this class to an interface? In such a case, it seems like we only need to move these two variables to the child classes. The level of code duplication is pretty negligable since they already have the all arg constructors and in turn each of the child classes would be much more strongly encapsulated. WDYT, any concerns with that suggestion?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401619", "createdAt": "2020-06-07T21:03:15Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTY1MQ==", "bodyText": "A javadoc on this method could be of some use. It's a bit odd to think that a step would have multiple names. It'd be nice to know what it means to have multiple names for a step and secondarily if this is for display purposes only.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401651", "createdAt": "2020-06-07T21:03:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjgwNA==", "bodyText": "Typically methods should not be aware of who is calling them. It's also a design smell when we require one method to have been called before another (and furthermore when that method is determining state that dictates whether you can and should call another method).\nThat could potentially be fixed by returning an object to then be executed. EG:\nprotected Optional<BiConsumer<ExecutionStack, IDelegateBridge>> getBattleStepExecutable();\n\nThen usage below of:\n public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n      final BattleStep executingStep = BattleStep.this;\n      if (executingStep.valid()) {\n        executingStep.execute(stack, bridge);\n      }\n\nwould be transformed into:\n public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       getBattleStepExecutable().ifPresent(stepExecutable -> stepExecutable.accept(stack, bridge));\n  }\n\nIt also appears that getName() has a dependency on isValid() as well. In those cases if isValid() is false then presumably getNames() could return an empty collection.\nWDYT?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402804", "createdAt": "2020-06-07T21:18:28Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @return true if valid\n+   */\n+  public abstract boolean valid();\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjkwNQ==", "bodyText": "Is this an inner class only because of IExecutable?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402905", "createdAt": "2020-06-07T21:19:57Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @return true if valid\n+   */\n+  public abstract boolean valid();\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked\n+   *\n+   * @param stack The current stack of steps\n+   * @param bridge DelegateBridge for interacting with the rest of the program\n+   */\n+  protected abstract void execute(ExecutionStack stack, IDelegateBridge bridge);\n+\n+  /**\n+   * This is used to break up the battle into separate atomic pieces. If there is a network error,\n+   * or some other unfortunate event, then we need to keep track of what pieces we have executed,\n+   * and what is left to do. Each atomic step is in its own BattleAtomic with the definition of\n+   * atomic is that either:\n+   *\n+   * <ol>\n+   *   <li>The code does not call to an IDisplay, IPlayer, or IRandomSource\n+   *   <li>If the code calls to an IDisplay, IPlayer, IRandomSource, and an exception is called from\n+   *       one of those methods, the exception will be propagated out of execute() and the execute\n+   *       method can be called again.\n+   * </ol>\n+   */\n+  public abstract class BattleAtomic implements IExecutable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjk5MA==", "bodyText": "Probably might as well update it so it makes sense. Won't make any more sense to anyone else at this point, and you've about as much context into this as anyone would have after the work you've done here. So if it does not make sense to you now, it probably won't make sense to anyone else (in which case the documentation is not very useful).", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402990", "createdAt": "2020-06-07T21:20:58Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Request.EXEC;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  /** Indicates when {@link #valid} is being called */\n+  public enum Request {\n+    // Occurs at the start of the battle round\n+    NAME,\n+    // Occurs right before the step executes\n+    EXEC,\n+  }\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @param request Indicates when valid is being called\n+   * @return true if valid\n+   */\n+  public abstract boolean valid(Request request);\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked\n+   *\n+   * @param stack The current stack of steps\n+   * @param bridge DelegateBridge for interacting with the rest of the program\n+   */\n+  protected abstract void execute(ExecutionStack stack, IDelegateBridge bridge);\n+\n+  /**\n+   * This is used to break up the battle into separate atomic pieces. If there is a network error,\n+   * or some other unfortunate event, then we need to keep track of what pieces we have executed,\n+   * and what is left to do. Each atomic step is in its own BattleAtomic with the definition of\n+   * atomic is that either:\n+   *\n+   * <ol>\n+   *   <li>The code does not call to an IDisplay, IPlayer, or IRandomSource", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQxMQ=="}, "originalCommit": {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzE5OA==", "bodyText": "nit, if the return value is nullable, at the very least the method should be marked as @Nullable. Perhaps better though if this returns Optional<BattleAtomic> so that any caller won't mistakenly think the return value is non-nullable and run into a NPE.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403198", "createdAt": "2020-06-07T21:23:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+\n+/** Air can not attack subs unless a destroyer is present */\n+public abstract class AirVsNonSubsStep extends BattleStep {\n+\n+  public AirVsNonSubsStep(final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public BattleAtomic getExecutable() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzIzNA==", "bodyText": "If we always return 0 or 1 element, would Optional<String> be a better return API? In that case there would not be any confusion that we can have more than one element and it'd be clear we'd have either zero or one.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403234", "createdAt": "2020-06-07T21:24:20Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/sub/SubmergeSubsVsOnlyAirStep.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat.sub;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBMERGE_SUBS_VS_AIR_ONLY;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Units that canNotBeTargetedByAll can submerge if there are only Air units in the battle */\n+public class SubmergeSubsVsOnlyAirStep extends BattleStep {\n+\n+  private static final Predicate<Unit> canNotBeTargetedByAllMatch =\n+      Matches.unitCanEvade().and(Matches.unitCanNotBeTargetedByAll());\n+\n+  public SubmergeSubsVsOnlyAirStep(\n+      final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public BattleAtomic getExecutable() {\n+    return new BattleAtomic() {\n+      private static final long serialVersionUID = 99990L;\n+    };\n+  }\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of(SUBMERGE_SUBS_VS_AIR_ONLY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzI3Nw==", "bodyText": "Minor: I noticed you used lombok getters on another class, why not here too?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403277", "createdAt": "2020-06-07T21:24:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {\n+\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+\n+  public static MockBattleState.MockBattleStateBuilder givenBattleState() {\n+    return MockBattleState.builder().attackingUnits(List.of()).defendingUnits(List.of());\n+  }\n+\n+  @Override\n+  public Collection<Unit> getAttackingUnits() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzU5Ng==", "bodyText": "It looks like all usages of this method always define attacking unit and defending units, why not just use the builder directly?\nIE: instead of: MockBattleState.givenBattleState(), use instead: MockBattleState.builder()", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403596", "createdAt": "2020-06-07T21:28:53Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {\n+\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+\n+  public static MockBattleState.MockBattleStateBuilder givenBattleState() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNDA2MA==", "bodyText": "Attacking and defending units being together pretty much always looks like the data clump code smell. It appears that BattleState could instead become a first class object and be a relatively simple value object.\nIt might make sense to rename BattleState to UnitsInBattle or BattleUnits, or BattleParticipants as we are not capturing the full battle state but just the units in battle.\nIf serialization were not a concern, then we could replace both attacking and defending units with a BattleState. To fix the data clump code smell we could:\n\nadd a transient BattleState object. Whenever we assign a battle state object then we write the corresponding values to attacking and defending units. This way we would get serialization and any usages of the data would be through battle state. It might be possible as well to override the serialization write-object method and to serialize attacking units and defending units through a battle state. Serialization proxy might be a way to do that, though the proxy itself could break compatibility alone.\n\nFundamentally BattleState is not really an interface, it's more data that can be present in an object and I suspect it makes sense to simply have a reference to it.\nWDYT?", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436404060", "createdAt": "2020-06-07T21:35:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -31,8 +37,13 @@\n   final @NonNull GamePlayer defender;\n   final @NonNull Collection<Unit> offensiveAa;\n   final @NonNull Collection<Unit> defendingAa;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull Collection<Unit> attackingUnits;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f0ea3c8ebe9665c4638c19a6cc14229418ce125", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7f0ea3c8ebe9665c4638c19a6cc14229418ce125", "committedDate": "2020-06-07T23:34:37Z", "message": "Fix documentation and use of lombok"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af45f1509a1d27a22d2348ec0150023af2500d1", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7af45f1509a1d27a22d2348ec0150023af2500d1", "committedDate": "2020-06-08T00:02:30Z", "message": "Refactor BattleStep to be an interface and remove BattleAtomic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44e85a335799ac4a61dfbcd1dd640bbc69e895a0", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/44e85a335799ac4a61dfbcd1dd640bbc69e895a0", "committedDate": "2020-06-08T00:33:40Z", "message": "Fix code style issues and clean up comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/5b9d5dc50a130745ca9a064a75686efafb903de9", "committedDate": "2020-06-08T00:50:31Z", "message": "Assume getNames will do isValid inside of it and so always call it"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODcwNTQw", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425870540", "createdAt": "2020-06-08T01:03:11Z", "commit": {"oid": "7af45f1509a1d27a22d2348ec0150023af2500d1"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMTowMzoxMVrOGgM9Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyNDowOVrOGgNGwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxOTg4Mw==", "bodyText": "nit, can use a ternary here to be a bit more concise. It's generally a bit easier (lower cognitive load) for if statements to lead with the 'true' value.\nIE:\nreturn valid()\n   ? List.of(AIR_ATTACK_NON_SUBS)\n   : List.of();", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436419883", "createdAt": "2020-06-08T01:03:11Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -2,18 +2,20 @@\n \n import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_ATTACK_NON_SUBS;\n \n-import games.strategy.triplea.delegate.battle.BattleActions;\n import games.strategy.triplea.delegate.battle.BattleState;\n import java.util.List;\n \n /** Air can not attack subs unless a destroyer is present */\n public class AirAttackVsNonSubsStep extends AirVsNonSubsStep {\n-  public AirAttackVsNonSubsStep(final BattleState battleState, final BattleActions battleActions) {\n-    super(battleState, battleActions);\n+  public AirAttackVsNonSubsStep(final BattleState battleState) {\n+    super(battleState);\n   }\n \n   @Override\n   public List<String> getNames() {\n+    if (!valid()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af45f1509a1d27a22d2348ec0150023af2500d1"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDk4MQ==", "bodyText": "The givenBattleState is still odd, it probably should at least return a builder().\nYou can make list values non-file and use @Builder.Default to initialize them to empty lists.\nAlso consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:\nMockBattleState.builder()\n   .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class)))\n   .defendingUnit(givenUnit())\n   .defendingUnit(givenUnitIsAir())\n   .build();", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436420981", "createdAt": "2020-06-08T01:12:42Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirDefendVsNonSubsStepTest.java", "diffHunk": "@@ -6,67 +6,59 @@\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.mockito.Mockito.mock;\n \n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n import games.strategy.triplea.delegate.battle.BattleState;\n import java.util.List;\n-import org.junit.jupiter.api.DisplayName;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.junit.jupiter.MockitoExtension;\n \n @ExtendWith(MockitoExtension.class)\n class AirDefendVsNonSubsStepTest {\n \n-  @Test\n-  @DisplayName(\"valid() is true if defender has air and no destroyer and attacker has sub\")\n-  void airVsSub() {\n-    final Unit defender1 = givenUnit();\n-    final Unit defender2 = givenUnitIsAir();\n-    final Unit attacker = givenUnitCanNotBeTargetedBy(mock(UnitType.class));\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(true));\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirDefendVsNonSubsStep underTest = new AirDefendVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n   }\n \n-  @Test\n-  @DisplayName(\"valid() is false if defender has air and destroyer\")\n-  void airDestroyerVsAnything() {\n-    final Unit defender1 = givenUnitDestroyer();\n-    final Unit defender2 = givenUnitIsAir();\n-    // once a destroyer is around, it doesn't care about the attacker units\n-    final Unit attacker = mock(Unit.class);\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(false));\n-  }\n-\n-  @Test\n-  @DisplayName(\"valid() is false if defender has air and no destroyer and attacker has no sub\")\n-  void airVsOther() {\n-    final Unit defender1 = givenUnit();\n-    final Unit defender2 = givenUnitIsAir();\n-    final Unit attacker = givenUnit();\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(false));\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Defender has air units and no destroyers vs Attacker subs\",\n+            givenBattleState()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTQ0MQ==", "bodyText": "My point is that you don't need to use a builder to init the values to empty lists and then return that builder to overwrite the values. You can use builder directly I would think. Look into using @Singular on those: https://projectlombok.org/features/Builder#singular", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436421441", "createdAt": "2020-06-08T01:16:54Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {\n+\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+\n+  public static MockBattleState.MockBattleStateBuilder givenBattleState() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzU5Ng=="}, "originalCommit": {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ==", "bodyText": "Nit, this is not really a Mock. A stub is something that returns the same value (the stub controls the return value), a mock is something that returns the value you tell it to (test controls the return value), and a 'fake' is a simplified implementation (aka, a test double).\nIn this case it looks like we basically have a real implementation. It's tempting to call this a test-fake, but given the API is so simple it looks to be full-blown.\nThis makes me wonder if we should have a DefaultBattleState on the BattleState interface itself.  Essentially in BattleState declaring a public static class DefaultBattleState that would be this class. You've mentioned though you expect this class to grow and perhaps then we'll want to use a true-mock.\nIn the meantime the naming is a bit misleading and I think would be useful to fix. Perhaps we could call this a DefaultBattleState, or a SimpleBattleState.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436421845", "createdAt": "2020-06-08T01:20:10Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjA5MA==", "bodyText": "Nit, most given methods should take a parameter. Something like:\ngivenUnitWithAttackPower(2)\n\nIf there is no parameter, and the return value is very generic, then something like the following would be typical (note the 'any' word):\ngivenAnyUnit()\n\nOtherwise the given should probably spell out what is special about the thing that is being returned, you've done that in the example of: givenUnitIsAir()", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422090", "createdAt": "2020-06-08T01:21:53Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStepTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import static games.strategy.triplea.delegate.battle.MockBattleState.givenBattleState;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanNotBeTargetedBy;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AirAttackVsNonSubsStepTest {\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Attacker has air units and no destroyers vs Defender subs\",\n+            givenBattleState()\n+                .attackingUnits(List.of(givenUnit(), givenUnitIsAir()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjI4OQ==", "bodyText": "Side note, if you could follow-up and remove the Tuple return value from newUnitAndAttachment, it would be appreciated. We really do want to delete that class outright in favor of value objects.", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422289", "createdAt": "2020-06-08T01:23:43Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/BattleStepsTest.java", "diffHunk": "@@ -139,6 +145,19 @@ public static Unit givenUnitAttackerFirstStrikeCanNotBeTargetedBy(final UnitType\n     return unitAndAttachment.getFirst();\n   }\n \n+  public static Unit givenUnitCanEvadeAndCanNotBeTargetedBy(final UnitType otherType) {\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    when(unitAndAttachment.getSecond().getCanEvade()).thenReturn(true);\n+    when(unitAndAttachment.getSecond().getCanNotBeTargetedBy()).thenReturn(Set.of(otherType));\n+    return unitAndAttachment.getFirst();\n+  }\n+\n+  public static Unit givenUnitCanNotBeTargetedBy(final UnitType otherType) {\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    when(unitAndAttachment.getSecond().getCanNotBeTargetedBy()).thenReturn(Set.of(otherType));\n+    return unitAndAttachment.getFirst();\n+  }\n+\n   public static Unit givenUnitDefenderFirstStrike() {\n     final UnitType canNotTargetType = mock(UnitType.class);\n     final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjMzNg==", "bodyText": "Any thoughts to simplify this helper method from:\ngivenUnitCanNotBeTargetedBy(mock(UnitType.class))\n\nTo:\ngivenUnitCanNotBeTargetedByAnyUnit();\n\nOr am I misunder", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422336", "createdAt": "2020-06-08T01:24:09Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStepTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import static games.strategy.triplea.delegate.battle.MockBattleState.givenBattleState;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanNotBeTargetedBy;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AirAttackVsNonSubsStepTest {\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Attacker has air units and no destroyers vs Defender subs\",\n+            givenBattleState()\n+                .attackingUnits(List.of(givenUnit(), givenUnitIsAir()))\n+                .defendingUnits(List.of(givenUnitCanNotBeTargetedBy(mock(UnitType.class))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1486ccbc8b5e6ef19853e0a71bc18b9bd640e029", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/1486ccbc8b5e6ef19853e0a71bc18b9bd640e029", "committedDate": "2020-06-08T03:10:37Z", "message": "Rename and minor tweaks per review requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a100ea14808b490a68cc38bca12fe74dc8f5ee2e", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/a100ea14808b490a68cc38bca12fe74dc8f5ee2e", "committedDate": "2020-06-08T03:20:45Z", "message": "Move the comment of the empty method into the method to calm Codacy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTEzMDM0", "url": "https://github.com/triplea-game/triplea/pull/6593#pullrequestreview-425913034", "createdAt": "2020-06-08T04:48:00Z", "commit": {"oid": "a100ea14808b490a68cc38bca12fe74dc8f5ee2e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3349, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}