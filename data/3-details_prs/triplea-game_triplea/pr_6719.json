{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2ODQ2MjUx", "number": 6719, "title": "Create OffensiveSubsRetreat step", "bodyText": "This converts the offensive subs retreat step into a BattleStep.\nThis step can happen before or after a battle, depending on the setting \"Sub Retreat Before Battle\".\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix:  \n[] Other:   \nTesting\nSaved a game with subs and loaded it.\n\n\nAdditional Review Notes\nThis unifies the logic for offensive subs withdrawal/submerge.  But because of the unification, some changes are going to occur.  I have limited the changes to how the UI displays the step string.\n\nIf Sub Retreat Before Battle was true or ifSub Retreat Before Battle was false and Submersible Subs was false, then it would show the step string even if there was no territories to retreat to.  It now checks it always.\nIt Sub Retreat Before Battle was false and Submersible Subs was false, then it would not show the step string if there was a destroyer there.  But if the destroyer died before the step actually happened, then it would trigger an error.  It now only checks for a destroyer if Sub Retreat Before Battle is true.", "createdAt": "2020-06-19T02:02:33Z", "url": "https://github.com/triplea-game/triplea/pull/6719", "merged": true, "mergeCommit": {"oid": "d92e750aa19af413001583bb7e4e944596448abe"}, "closed": true, "closedAt": "2020-06-22T17:46:43Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsor4cgH2gAyNDM2ODQ2MjUxOjdlZTZiY2UwZTA4MTE5NmY2ZDkxZGFiODJiMGY1MmRjZGUwOTg5MGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABctxy1kgH2gAyNDM2ODQ2MjUxOjI4YTc0NDAzYTFiZjNjZTJlNTY3MGVkMmMzYThmNzg3MjdlMWJjMTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/7ee6bce0e081196f6d91dab82b0f52dcde09890a", "committedDate": "2020-06-19T01:22:53Z", "message": "Create OffensiveSubsRetreat step"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzU3MDI3", "url": "https://github.com/triplea-game/triplea/pull/6719#pullrequestreview-433757027", "createdAt": "2020-06-19T02:05:04Z", "commit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjowNTowNVrOGmFtcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjowNTowNVrOGmFtcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5MjYyNg==", "bodyText": "I couldn't use @Getter because isOver is a Boolean and not a boolean.  @Getter will create a is function only for boolean.  I could change isOver to be a boolean and then I can't have the @NonNull.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442592626", "createdAt": "2020-06-19T02:05:05Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -51,24 +55,49 @@\n   final @NonNull Collection<Unit> defendingUnits;\n \n   final @NonNull Collection<Unit> attackingWaitingToDie;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull Collection<Unit> defendingWaitingToDie;\n+\n   final @NonNull Territory battleSite;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull GameData gameData;\n+\n   final @NonNull Collection<Unit> bombardingUnits;\n   final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n   final @NonNull Boolean isBattleSiteWater;\n+\n   final @NonNull Boolean isAmphibious;\n   final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n   final @NonNull Function<Collection<Unit>, Collection<Territory>> getEmptyOrFriendlySeaNeighbors;\n   final @NonNull BattleActions battleActions;\n \n+  final @NonNull Boolean isOver;\n+\n+  @Override\n+  public Collection<Territory> getAttackerRetreatTerritories() {\n+    return getAttackerRetreatTerritories.get();\n+  }\n+\n+  @Override\n+  public boolean isOver() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzU4MTM1", "url": "https://github.com/triplea-game/triplea/pull/6719#pullrequestreview-433758135", "createdAt": "2020-06-19T02:09:21Z", "commit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjowOToyMlrOGmFxQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjowOToyMlrOGmFxQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5MzYwMA==", "bodyText": "I figured out why destroyers weren't being checked and it was correct.  The else after this (where it calls canAttackerRetreatSubs) shouldn't have been checking for destroyers either.  I was able to trigger an error in the UI in that else case.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442593600", "createdAt": "2020-06-19T02:09:22Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -185,22 +214,8 @@\n     // remove casualties\n     steps.add(REMOVE_CASUALTIES);\n     // retreat attacking subs\n-    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n-      if (Properties.getSubmersibleSubs(gameData)) {\n-        // TODO: BUG? Should the presence of destroyers be checked?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzU5MDAx", "url": "https://github.com/triplea-game/triplea/pull/6719#pullrequestreview-433759001", "createdAt": "2020-06-19T02:12:25Z", "commit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoxMjoyNVrOGmF0GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoxNjoxOVrOGmF3aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMyOA==", "bodyText": "I'm not sure about keeping this logic.  It only works as long as nothing can kill the destroyer before the sub has a chance to retreat.  Since the sub can retreat at the beginning of the battle, the only thing that fires before its retreat is AA guns.  And if a map has an AA gun that can target destroyers, then an error could occur.\nWould you expect AA guns that can target destroyers?  I could either remove this logic or change it to go through all of the units, figure out if there are any AA guns and determine if they can target all of the destroyers in the defenders side.  I lean towards removing the logic.  It'll mean that the withdraw/submerge step will show up more often in the UI then it did previously.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442594328", "createdAt": "2020-06-19T02:12:25Z", "author": {"login": "trevan"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_SUBMERGE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Order.SUB_OFFENSIVE_RETREAT_AFTER_BATTLE;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Order.SUB_OFFENSIVE_RETREAT_BEFORE_BATTLE;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class OffensiveSubsRetreat implements BattleStep {\n+\n+  private static final long serialVersionUID = -244024585102561887L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (!isEvaderPresent() || !isRetreatPossible()) {\n+      return List.of();\n+    }\n+\n+    if (getOrder() == SUB_OFFENSIVE_RETREAT_BEFORE_BATTLE && isDestroyerPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDY1NQ==", "bodyText": "All of these tests have been moved to the OffensiveSubsRetreat tests.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442594655", "createdAt": "2020-06-19T02:13:52Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -448,240 +444,6 @@ void offensiveAndDefensiveAaFire() {\n         is(2));\n   }\n \n-  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTE3Ng==", "bodyText": "What do you think of this class?  I was wanting a fluent way to generate a mock GameData.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442595176", "createdAt": "2020-06-19T02:16:19Z", "author": {"login": "trevan"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a56a4eb695009814f21fcd42d532d884444c6028", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/a56a4eb695009814f21fcd42d532d884444c6028", "committedDate": "2020-06-19T02:19:20Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b427ccf74fd2d539b4ed13a2af93f270bc8caee7", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/b427ccf74fd2d539b4ed13a2af93f270bc8caee7", "committedDate": "2020-06-19T02:45:16Z", "message": "Correct the location of the test file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "committedDate": "2020-06-19T02:47:32Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NTUyMTgx", "url": "https://github.com/triplea-game/triplea/pull/6719#pullrequestreview-434552181", "createdAt": "2020-06-22T01:01:21Z", "commit": {"oid": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMTowMToyMlrOGmvbbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwMTowOToyNlrOGmvfkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjE0Mg==", "bodyText": "nit, if you have to parameterize the display name, I think we might be parameterizing 'wrong'\nThe display name should likely be a constant for any test, the only thing that is changing are just values under test.\nFor example, if you are testing a 'sine' function, the input and expected outputs are parameterized, but in all cases we are testing a sine function. In part as well, JUnit will automatically print out the test parameters as part of the display.\nTo resolve, a comment on the test data could be sufficient. You could also consider passing in as parameters the components for a Battlestate and then constructing the battle state in the test.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276142", "createdAt": "2020-06-22T01:01:22Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjMxMQ==", "bodyText": "I think I might be missing something. A defending destroyer prevents submerge, why does it prevent retreat?", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276311", "createdAt": "2020-06-22T01:02:50Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3Njk0OA==", "bodyText": "Can this mock instantiation be inlined and a constructor avoided?\nI think our general convention is to favor inlining declarations and only declare what you must in a constructor.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276948", "createdAt": "2020-06-22T01:07:34Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzA3Mg==", "bodyText": "Is this if check here to avoid strict mocking checks?\nIt might be a case where we can use lenient. IMO using lenient is going to be better than having lazy instantiation of a mock expectation.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277072", "createdAt": "2020-06-22T01:08:32Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);\n+      gameProperties = mock(GameProperties.class);\n+    }\n+\n+    static MockGameData givenGameData() {\n+      return new MockGameData();\n+    }\n+\n+    GameData build() {\n+      return gameData;\n+    }\n+\n+    MockGameData withTransportCasualtiesRestricted(final boolean value) {\n+      setupProperties();\n+      when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(value);\n+      return this;\n+    }\n+\n+    private void setupProperties() {\n+      if (!propertiesSetup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzEzOQ==", "bodyText": "I like this method \ud83d\udc4d\nI tend to think this indicates we should aggregate more of this kind of logic in GameData itself so you could have method on game data to turn this property on.", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277139", "createdAt": "2020-06-22T01:09:03Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);\n+      gameProperties = mock(GameProperties.class);\n+    }\n+\n+    static MockGameData givenGameData() {\n+      return new MockGameData();\n+    }\n+\n+    GameData build() {\n+      return gameData;\n+    }\n+\n+    MockGameData withTransportCasualtiesRestricted(final boolean value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzIwMA==", "bodyText": "Not too shabby \ud83d\udc4d", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277200", "createdAt": "2020-06-22T01:09:26Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTE3Ng=="}, "originalCommit": {"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a2b1fabf1948612ab43fd4bd4f2f2105fb4f944", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/2a2b1fabf1948612ab43fd4bd4f2f2105fb4f944", "committedDate": "2020-06-22T02:38:03Z", "message": "Rework tests to not be parameterized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "650dad477cbb0a02e8de72b83814a3daed3e7e2d", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/650dad477cbb0a02e8de72b83814a3daed3e7e2d", "committedDate": "2020-06-22T02:45:28Z", "message": "Merge remote-tracking branch 'upstream/master' into offensive-subs-retreat-step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28a74403a1bf3ce2e5670ed2c3a8f78727e1bc12", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/28a74403a1bf3ce2e5670ed2c3a8f78727e1bc12", "committedDate": "2020-06-22T14:33:33Z", "message": "Inline then test helper"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3266, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}