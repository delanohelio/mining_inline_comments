{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4OTA1MjI2", "number": 6328, "title": "Simplify ConcurrentBattleCalculator code", "bodyText": "This PR tries to simplify the code within ConcurrentBattleCalculator by removing some heuristics and using more \"standard\" approaches in general.\nI ran some benchmarks and the time seems to be about equal (which is to be expected because the approach didn't really change)\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix:  \n[] Other:   \nTesting\n\nI verified BattleCalc works as usual and let the Hard AI play a game of classic WW2, which worked without any problems.", "createdAt": "2020-04-25T13:04:17Z", "url": "https://github.com/triplea-game/triplea/pull/6328", "merged": true, "mergeCommit": {"oid": "ff2411554ea02c0815480e6903c3f820388079bf"}, "closed": true, "closedAt": "2020-04-25T21:13:44Z", "author": {"login": "RoiEXLab"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYj3q-gH2gAyNDA4OTA1MjI2OjdiYThmNjhkNmZiOTIyZmM2MDdjZDQ0MWFiM2Y2NjlhN2ZhZmI1NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbKboSAFqTQwMDQxODYwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7ba8f68d6fb922fc607cd441ab3f669a7fafb563", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/7ba8f68d6fb922fc607cd441ab3f669a7fafb563", "committedDate": "2020-04-17T16:27:45Z", "message": "Simplify concurrent battle calculator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6acab186bed8a7828e62f6f8cafd3e38f4d3bf3", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/e6acab186bed8a7828e62f6f8cafd3e38f4d3bf3", "committedDate": "2020-04-17T16:39:19Z", "message": "Fix run count"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "374a7a62c8aa74e30b839887b23e0154dd9ab1db", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/374a7a62c8aa74e30b839887b23e0154dd9ab1db", "committedDate": "2020-04-17T16:41:32Z", "message": "Fix time counter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "130676e8f6813cfa6635eddfcd10a84c541c3e00", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/130676e8f6813cfa6635eddfcd10a84c541c3e00", "committedDate": "2020-04-17T18:15:48Z", "message": "Implement cancel ability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daa29f5cc1496a14599f1d98e41d78ded1b1d4ba", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/daa29f5cc1496a14599f1d98e41d78ded1b1d4ba", "committedDate": "2020-04-17T18:25:39Z", "message": "Properly revert changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0127f7963505e063ccd90c75778b3a152fb4a103", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/0127f7963505e063ccd90c75778b3a152fb4a103", "committedDate": "2020-04-17T18:27:57Z", "message": "Simplify interface structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c9975e579106d1ab99e627c1e0887409d1bf25e", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/8c9975e579106d1ab99e627c1e0887409d1bf25e", "committedDate": "2020-04-17T18:28:12Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc82a1dfb5fcc6c357aae74f6648ae07b1faa083", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/cc82a1dfb5fcc6c357aae74f6648ae07b1faa083", "committedDate": "2020-04-25T11:22:43Z", "message": "Synchronize calls properly\n\nThis commit makes ConcurrentBattleCalculator ThreadSafe again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65d05c996e3bb5f9df7ffa923c16b0939f3f94be", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/65d05c996e3bb5f9df7ffa923c16b0939f3f94be", "committedDate": "2020-04-25T11:29:14Z", "message": "Extract method calls to dedicated helper methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzkxOTk3", "url": "https://github.com/triplea-game/triplea/pull/6328#pullrequestreview-400391997", "createdAt": "2020-04-25T13:05:30Z", "commit": {"oid": "65d05c996e3bb5f9df7ffa923c16b0939f3f94be"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxMzowNTozMFrOGL1NXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxMzowNTozMFrOGL1NXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA1OTI5Mg==", "bodyText": "Method createBattleCalcWorker has 28 lines of code (exceeds 25 allowed). Consider refactoring.", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415059292", "createdAt": "2020-04-25T13:05:30Z", "author": {"login": "codeclimate"}, "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -70,393 +65,181 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   @Override\n   public void setGameData(final GameData data) {\n-    // increment so that a new calc doesn't take place (since they all wait on this latch)\n-    latchSetData.increment();\n-    // cancel any current setting of data\n-    cancelCurrentOperation.decrementAndGet();\n-    // cancel any existing calcing (it won't stop immediately, just quicker)\n-    cancel();\n-    synchronized (mutexSetGameData) {\n-      try {\n-        // since setting data takes place on a different thread, this is our token. wait on it since\n-        latchWorkerThreadsCreation.await();\n-        // we could have exited the synchronized block already.\n-      } catch (final InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-      cancel();\n-      isDataSet = false;\n-      isCalcSet = false;\n-      if (data == null || isShutDown) {\n-        workers.clear();\n-        cancelCurrentOperation.incrementAndGet();\n-        // allow calcing and other stuff to go ahead\n-        latchSetData.countDown();\n-      } else {\n-        cancelCurrentOperation.incrementAndGet();\n-        // increment our token, so that we can set the data in a different thread and return from\n-        // this one\n-        latchWorkerThreadsCreation.increment();\n-        executor.execute(() -> createWorkers(data));\n-      }\n+    synchronized (mutex) {\n+      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+      dataLoadedAction.run();\n     }\n   }\n \n   @Override\n   public int getThreadCount() {\n-    return currentThreads;\n-  }\n-\n-  // use both time and memory left to determine how many copies to make\n-  private static int getThreadsToUse(\n-      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n-    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n-      // just use 1 thread if we took more than 20 seconds to copy\n-      return 1;\n-    }\n-    final Runtime runtime = Runtime.getRuntime();\n-    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n-    // we cannot predict how the gc works\n-    final long memoryLeftBeforeMax =\n-        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n-    // make sure it is a decent size\n-    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n-    // regardless of how stupid the gc is we leave some memory left over just in case\n-    final int numberOfTimesWeCanCopyMax =\n-        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n-\n-    if (timeToCopyInMillis > 3000) {\n-      // use half the number of threads available if we took more than 3 seconds to copy\n-      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n-    }\n-    // use all threads\n-    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n-  }\n-\n-  private void createWorkers(final GameData data) {\n-    workers.clear();\n-    if (data != null && cancelCurrentOperation.get() >= 0) {\n-      // see how long 1 copy takes (some games can get REALLY big)\n-      final long startTime = System.currentTimeMillis();\n-      final long startMemory =\n-          Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n-      final GameData newData;\n-      try {\n-        // make first copy, then release lock on it so game can continue (ie: we don't want to lock\n-        // on it while we copy\n-        // it 16 times, when once is enough) don't let the data change while we make the first copy\n-        data.acquireWriteLock();\n-        newData = GameDataUtils.cloneGameDataWithoutHistory(data, false);\n-      } finally {\n-        data.releaseWriteLock();\n-      }\n-      currentThreads = getThreadsToUse((System.currentTimeMillis() - startTime), startMemory);\n-      try {\n-        // make sure all workers are using the same data\n-        newData.acquireReadLock();\n-        int i = 0;\n-        // we are already in 1 executor thread, so we have MAX_THREADS-1 threads left to use\n-        if (currentThreads <= 2 || MAX_THREADS <= 2) {\n-          // if 2 or fewer threads, do not multi-thread the copying (we have already copied it once\n-          // above, so at most\n-          // only 1 more copy to make)\n-          while (cancelCurrentOperation.get() >= 0 && i < currentThreads) {\n-            // the last one will use our already copied data from above, without copying it again\n-            workers.add(new BattleCalculator(newData, (currentThreads == ++i)));\n-          }\n-        } else { // multi-thread our copying, cus why the heck not (it increases the speed of\n-          // copying by about double)\n-          final CountDownLatch workerLatch = new CountDownLatch(currentThreads - 1);\n-          while (i < (currentThreads - 1)) {\n-            ++i;\n-            executor.execute(\n-                () -> {\n-                  if (cancelCurrentOperation.get() >= 0) {\n-                    workers.add(new BattleCalculator(newData, false));\n-                  }\n-                  workerLatch.countDown();\n-                });\n-          }\n-          // the last one will use our already copied data from above, without copying it again\n-          workers.add(new BattleCalculator(newData, true));\n-          Interruptibles.await(workerLatch);\n-        }\n-      } finally {\n-        newData.releaseReadLock();\n-      }\n-    }\n-    if (cancelCurrentOperation.get() < 0 || data == null) {\n-      // we could have cancelled while setting data, so clear the workers again if so\n-      workers.clear();\n-      isDataSet = false;\n-    } else {\n-      // should make sure that all workers have their game data set before we can call calculate and\n-      // other things\n-      isDataSet = true;\n-      dataLoadedAction.run();\n-    }\n-    // allow setting new data to take place if it is waiting on us\n-    latchWorkerThreadsCreation.countDown();\n-    // allow calcing and other stuff to go ahead\n-    latchSetData.countDown();\n+    return MAX_THREADS;\n   }\n \n   @Override\n   public void shutdown() {\n     isShutDown = true;\n-    cancelCurrentOperation.set(Integer.MIN_VALUE / 2);\n     cancel();\n     executor.shutdown();\n   }\n \n-  private void awaitLatch() {\n-    try {\n-      // there is a small chance calculate or setCalculateData or something could be called in\n-      // between calls to\n-      // setGameData\n-      latchSetData.await();\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    }\n-  }\n-\n+  /**\n+   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n+   * results. Then waits for all the future results and combines them together.\n+   */\n   @Override\n-  public void setCalculateData(\n+  public AggregateResults calculate(\n       final GamePlayer attacker,\n       final GamePlayer defender,\n       final Territory location,\n       final Collection<Unit> attacking,\n       final Collection<Unit> defending,\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n-      final int initialRunCount) {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      isCalcSet = false;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      for (final BattleCalculator worker : workers) {\n-        if (!isDataSet || isShutDown) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return;\n-        }\n-        worker.setCalculateData(\n-            attacker,\n-            defender,\n-            location,\n-            attacking,\n-            defending,\n-            bombarding,\n-            territoryEffects,\n-            (runCount <= 0 ? 0 : workerRunCount));\n-        runCount -= workerRunCount;\n-      }\n-      if (!isDataSet || isShutDown || workerNum <= 0) {\n-        return;\n-      }\n-      isCalcSet = true;\n-    }\n-  }\n-\n-  /**\n-   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n-   * results. Then waits for all the future results and combines them together.\n-   */\n-  @Override\n-  public AggregateResults calculate() throws IllegalStateException {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      final long start = System.currentTimeMillis();\n-      // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return new AggregateResults(0);\n-        }\n-        if (!worker.getIsReady()) {\n-          throw new IllegalStateException(\"Called calculate before setting calculate data!\");\n-        }\n-        if (worker.getRunCount() > 0) {\n-          totalRunCount += worker.getRunCount();\n-          final Future<AggregateResults> workerResult = executor.submit(worker);\n-          list.add(workerResult);\n-        }\n-      }\n-      // Wait for all worker futures to complete and combine results\n-      final AggregateResults results = new AggregateResults(totalRunCount);\n-      final Set<InterruptedException> interruptExceptions = new HashSet<>();\n-      final Map<String, Set<ExecutionException>> executionExceptions = new HashMap<>();\n-      for (final Future<AggregateResults> future : list) {\n-        try {\n-          final AggregateResults result = future.get();\n-          results.addResults(result.getResults());\n-        } catch (final InterruptedException e) {\n-          Thread.currentThread().interrupt();\n-          interruptExceptions.add(e);\n-        } catch (final ExecutionException e) {\n-          final String cause = e.getCause().getLocalizedMessage();\n-          Set<ExecutionException> exceptions = executionExceptions.get(cause);\n-          if (exceptions == null) {\n-            exceptions = new HashSet<>();\n-          }\n-          exceptions.add(e);\n-          executionExceptions.put(cause, exceptions);\n-        }\n-      }\n-      // we don't want to scare the user with 8+ errors all for the same thing\n-      if (!interruptExceptions.isEmpty()) {\n-        log.log(\n-            Level.SEVERE,\n-            interruptExceptions.size() + \" Battle results workers interrupted\",\n-            interruptExceptions.iterator().next());\n-      }\n-      if (!executionExceptions.isEmpty()) {\n-        Exception e = null;\n-        for (final Set<ExecutionException> entry : executionExceptions.values()) {\n-          if (!entry.isEmpty()) {\n-            e = entry.iterator().next();\n-            log.log(\n-                Level.SEVERE,\n-                entry.size() + \" Battle results workers aborted by exception\",\n-                e.getCause());\n-          }\n-        }\n-        if (e != null) {\n-          throw new IllegalStateException(e.getCause());\n-        }\n-      }\n-      results.setTime(System.currentTimeMillis() - start);\n-      return results;\n-    }\n-  }\n-\n-  @Override\n-  public AggregateResults setCalculateDataAndCalculate(\n+      final int runCount)\n+      throws IllegalStateException {\n+    Preconditions.checkState(!isShutDown, \"ConcurrentBattleCalculator is already shut down\");\n+    Preconditions.checkState(bytes.length != 0, \"Data has not been set yet.\");\n+    final long start = System.currentTimeMillis();\n+    final List<Future<AggregateResults>> results = new ArrayList<>();\n+    final int runsPerWorker = runCount / MAX_THREADS;\n+    synchronized (mutex) {\n+      int remainingRuns = runCount;\n+      while (remainingRuns > 0) {\n+        final int individualRemaining = Math.min(remainingRuns, runsPerWorker);\n+        remainingRuns -= runsPerWorker;\n+        results.add(\n+            createBattleCalcWorker(\n+                attacker,\n+                defender,\n+                location,\n+                attacking,\n+                defending,\n+                bombarding,\n+                territoryEffects,\n+                individualRemaining));\n+      }\n+    }\n+    final AggregateResults result = aggregateResults(results, runsPerWorker);\n+    result.setTime(System.currentTimeMillis() - start);\n+    return result;\n+  }\n+\n+  private Future<AggregateResults> createBattleCalcWorker(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65d05c996e3bb5f9df7ffa923c16b0939f3f94be"}, "originalPosition": 406}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e9468eaa1ed476b459b5adf6ce851de8ebe4519", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/1e9468eaa1ed476b459b5adf6ce851de8ebe4519", "committedDate": "2020-04-25T13:25:01Z", "message": "Add final keywords"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a85fc5ec23fb5c03a6559cda1b5518b2a678c3c6", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/a85fc5ec23fb5c03a6559cda1b5518b2a678c3c6", "committedDate": "2020-04-25T13:42:24Z", "message": "Ensure MAX_THREAD amount is respected"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4784f9ca997ea9998e2dc6cad171a21eaeadf956", "author": {"user": {"login": "RoiEXLab", "name": "RoiEX"}}, "url": "https://github.com/triplea-game/triplea/commit/4784f9ca997ea9998e2dc6cad171a21eaeadf956", "committedDate": "2020-04-25T13:43:16Z", "message": "Remove unused annotation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDE4NjA1", "url": "https://github.com/triplea-game/triplea/pull/6328#pullrequestreview-400418605", "createdAt": "2020-04-25T18:19:33Z", "commit": {"oid": "4784f9ca997ea9998e2dc6cad171a21eaeadf956"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODoxOTozM1rOGL4oaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxODoyODozNVrOGL4uiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNTM3MQ==", "bodyText": "This is an interesting way to reduce the game data serialization size. I've been thinking we'll want to eventually have a param object for calculations that has a copy of just the data it needs. In the meantime this is interesting to move us in that direction.", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415115371", "createdAt": "2020-04-25T18:19:33Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/engine/framework/GameDataUtils.java", "diffHunk": "@@ -28,6 +28,20 @@ public static GameData cloneGameDataWithoutHistory(\n     return dataCopy;\n   }\n \n+  public static byte[] serializeGameDataWithoutHistory(final GameData data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4784f9ca997ea9998e2dc6cad171a21eaeadf956"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTExNjkzNw==", "bodyText": "side-note, it seems questionable to return MAX_THREADs and to also use that same constant in this class. It looks like this 'get' is only used for display purposes. When multi-threading of the battle calc was brand new, made more sense. Now I'm more thinking it's an implementation detail that the calc is multi-threaded and we don't really need to tell the user that (it's not important to them, only that the calc completes quickly and accurately).  CC: @ron-murhammer\nIn that case, if we remove that, we could remove this interface method and implementation.", "url": "https://github.com/triplea-game/triplea/pull/6328#discussion_r415116937", "createdAt": "2020-04-25T18:28:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -70,393 +64,182 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   @Override\n   public void setGameData(final GameData data) {\n-    // increment so that a new calc doesn't take place (since they all wait on this latch)\n-    latchSetData.increment();\n-    // cancel any current setting of data\n-    cancelCurrentOperation.decrementAndGet();\n-    // cancel any existing calcing (it won't stop immediately, just quicker)\n-    cancel();\n-    synchronized (mutexSetGameData) {\n-      try {\n-        // since setting data takes place on a different thread, this is our token. wait on it since\n-        latchWorkerThreadsCreation.await();\n-        // we could have exited the synchronized block already.\n-      } catch (final InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-      cancel();\n-      isDataSet = false;\n-      isCalcSet = false;\n-      if (data == null || isShutDown) {\n-        workers.clear();\n-        cancelCurrentOperation.incrementAndGet();\n-        // allow calcing and other stuff to go ahead\n-        latchSetData.countDown();\n-      } else {\n-        cancelCurrentOperation.incrementAndGet();\n-        // increment our token, so that we can set the data in a different thread and return from\n-        // this one\n-        latchWorkerThreadsCreation.increment();\n-        executor.execute(() -> createWorkers(data));\n-      }\n+    synchronized (mutex) {\n+      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+      dataLoadedAction.run();\n     }\n   }\n \n   @Override\n   public int getThreadCount() {\n-    return currentThreads;\n-  }\n-\n-  // use both time and memory left to determine how many copies to make\n-  private static int getThreadsToUse(\n-      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n-    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n-      // just use 1 thread if we took more than 20 seconds to copy\n-      return 1;\n-    }\n-    final Runtime runtime = Runtime.getRuntime();\n-    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n-    // we cannot predict how the gc works\n-    final long memoryLeftBeforeMax =\n-        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n-    // make sure it is a decent size\n-    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n-    // regardless of how stupid the gc is we leave some memory left over just in case\n-    final int numberOfTimesWeCanCopyMax =\n-        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n-\n-    if (timeToCopyInMillis > 3000) {\n-      // use half the number of threads available if we took more than 3 seconds to copy\n-      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n-    }\n-    // use all threads\n-    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n-  }\n-\n-  private void createWorkers(final GameData data) {\n-    workers.clear();\n-    if (data != null && cancelCurrentOperation.get() >= 0) {\n-      // see how long 1 copy takes (some games can get REALLY big)\n-      final long startTime = System.currentTimeMillis();\n-      final long startMemory =\n-          Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n-      final GameData newData;\n-      try {\n-        // make first copy, then release lock on it so game can continue (ie: we don't want to lock\n-        // on it while we copy\n-        // it 16 times, when once is enough) don't let the data change while we make the first copy\n-        data.acquireWriteLock();\n-        newData = GameDataUtils.cloneGameDataWithoutHistory(data, false);\n-      } finally {\n-        data.releaseWriteLock();\n-      }\n-      currentThreads = getThreadsToUse((System.currentTimeMillis() - startTime), startMemory);\n-      try {\n-        // make sure all workers are using the same data\n-        newData.acquireReadLock();\n-        int i = 0;\n-        // we are already in 1 executor thread, so we have MAX_THREADS-1 threads left to use\n-        if (currentThreads <= 2 || MAX_THREADS <= 2) {\n-          // if 2 or fewer threads, do not multi-thread the copying (we have already copied it once\n-          // above, so at most\n-          // only 1 more copy to make)\n-          while (cancelCurrentOperation.get() >= 0 && i < currentThreads) {\n-            // the last one will use our already copied data from above, without copying it again\n-            workers.add(new BattleCalculator(newData, (currentThreads == ++i)));\n-          }\n-        } else { // multi-thread our copying, cus why the heck not (it increases the speed of\n-          // copying by about double)\n-          final CountDownLatch workerLatch = new CountDownLatch(currentThreads - 1);\n-          while (i < (currentThreads - 1)) {\n-            ++i;\n-            executor.execute(\n-                () -> {\n-                  if (cancelCurrentOperation.get() >= 0) {\n-                    workers.add(new BattleCalculator(newData, false));\n-                  }\n-                  workerLatch.countDown();\n-                });\n-          }\n-          // the last one will use our already copied data from above, without copying it again\n-          workers.add(new BattleCalculator(newData, true));\n-          Interruptibles.await(workerLatch);\n-        }\n-      } finally {\n-        newData.releaseReadLock();\n-      }\n-    }\n-    if (cancelCurrentOperation.get() < 0 || data == null) {\n-      // we could have cancelled while setting data, so clear the workers again if so\n-      workers.clear();\n-      isDataSet = false;\n-    } else {\n-      // should make sure that all workers have their game data set before we can call calculate and\n-      // other things\n-      isDataSet = true;\n-      dataLoadedAction.run();\n-    }\n-    // allow setting new data to take place if it is waiting on us\n-    latchWorkerThreadsCreation.countDown();\n-    // allow calcing and other stuff to go ahead\n-    latchSetData.countDown();\n+    return MAX_THREADS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4784f9ca997ea9998e2dc6cad171a21eaeadf956"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3520, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}