{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MzIyNzk5", "number": 7042, "title": "Unify sub step logic", "bodyText": "This unifies the logic that was in BattleSteps#get and MustFightBattle#addFightSteps on the order of first strike attacks and their ReturnFire.  Both of them used SubChecks but used the results differently that made it hard to figure out if the logic was the same or not.\nThe first commit d04f035 just takes the code from both of BattleSteps and MustFightBattle and unittests both of them together to ensure the logic was the same.  Going through the code, there was only 4 variables that affected the results.  So the unittests iterate all combinations of the 4 variables with attacking and/or defending first strike units.\nThe second commit 95f50dd is switching BattleSteps and MustFightBattle to use this new utility.\nThe third commit is refactoring and cleaning up the code so that it is smaller.  It turned out that most of the logic was already expressed through the results of returnFireAgainstAttackingSubs and returnFireAgainstDefendingSubs.\nThe only functional change is the removal of extraneous REMOVE_SNEAK_ATTACK_CASUALTIES step names.  This happens when a first strike is fighting a group of units that includes a destroyer but not another first strike.  The presence of the destroyer indicated that the non-existent first strike unit on its side has sneak attack but the actual existent first strike against it doesn't have sneak attack.  So the REMOVE_SNEAK_ATTACK_CASUALTIES would show to remove the non-existent casualties from the non-existent first strike unit.  There's a few unit tests (mostly about first strike vs air + destroyer) that showed this issue.\nFunctional Changes\n\n[] New map or map update\n[] New Feature\n[] Feature update or enhancement\n[] Feature Removal\n[x] Code Cleanup or refactor\n[] Configuration Change\n[] Problem fix\n[] Other:   \nTesting\n\nScreens Shots\n\nAdditional Notes to Reviewer\n\nRelease Note", "createdAt": "2020-07-04T20:01:51Z", "url": "https://github.com/triplea-game/triplea/pull/7042", "merged": true, "mergeCommit": {"oid": "dc43ddf8f4c9ef1a39779dab662d9da37dddf8a2"}, "closed": true, "closedAt": "2020-07-12T21:01:10Z", "author": {"login": "trevan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxp9tegH2gAyNDQ0MzIyNzk5OmQwNGYwMzVjMWQ0YmIxODE2MGZkMWRhNjAxMDE3MTczYjEyNTU1NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczycc6gFqTQ0Njc4MjUyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d04f035c1d4bb18160fd1da601017173b1255547", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d04f035c1d4bb18160fd1da601017173b1255547", "committedDate": "2020-07-04T15:41:53Z", "message": "Isolate sub order logic and unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f50dde4be832a4774bdade579a986a63dfc353", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/95f50dde4be832a4774bdade579a986a63dfc353", "committedDate": "2020-07-04T16:49:43Z", "message": "Use FirstStrikeStepOrder instead of original logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2df40088fab0891218a13dc0b5ea393b4cbd629a", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/2df40088fab0891218a13dc0b5ea393b4cbd629a", "committedDate": "2020-07-04T19:39:16Z", "message": "Simplify sub order logic and rename enums to be more descriptive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a158ac12e9a4b263f801c588273c4062e60a0ddd", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/a158ac12e9a4b263f801c588273c4062e60a0ddd", "committedDate": "2020-07-04T20:11:28Z", "message": "Simplify givenBattelState a little"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "797d6c3913596ff1cf788bcdf461327a0a728667", "author": {"user": {"login": "tripleabuilderbot", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/797d6c3913596ff1cf788bcdf461327a0a728667", "committedDate": "2020-07-04T20:14:25Z", "message": "Auto-Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cd62f92cd31e77e6c337b2b0b90ed6f0c7c0094", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/9cd62f92cd31e77e6c337b2b0b90ed6f0c7c0094", "committedDate": "2020-07-04T20:29:23Z", "message": "Break up FirstStrikeStepOrder to smaller methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d89477f41782bce8fb73ff142e29927ba791f310", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/d89477f41782bce8fb73ff142e29927ba791f310", "committedDate": "2020-07-04T21:37:52Z", "message": "Instead of a list, return an object with attacker/defender defined"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66e2d7f52533181f50fad53502964de1f8c38eca", "author": {"user": {"login": "trevan", "name": null}}, "url": "https://github.com/triplea-game/triplea/commit/66e2d7f52533181f50fad53502964de1f8c38eca", "committedDate": "2020-07-10T04:58:56Z", "message": "Merge remote-tracking branch 'upstream/master' into unify-sub-step-logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTIzMzQ4", "url": "https://github.com/triplea-game/triplea/pull/7042#pullrequestreview-446123348", "createdAt": "2020-07-10T05:04:35Z", "commit": {"oid": "66e2d7f52533181f50fad53502964de1f8c38eca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNTowNDozNVrOGvp9Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNTowNDozNVrOGvp9Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyMzY4Ng==", "bodyText": "Codacy found an issue: Avoid really long methods.", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r452623686", "createdAt": "2020-07-10T05:04:35Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/FirstStrikeStepOrderTest.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.DEFENDER_NO_SNEAK_ATTACK;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.DEFENDER_NO_SNEAK_ATTACK_BUT_BEFORE_STANDARD_ATTACK;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.DEFENDER_SNEAK_ATTACK;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.DEFENDER_SNEAK_ATTACK_WITH_OPPOSING_FIRST_STRIKE;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.OFFENDER_NO_SNEAK_ATTACK;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.OFFENDER_SNEAK_ATTACK;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.OFFENDER_SNEAK_ATTACK_WITH_OPPOSING_FIRST_STRIKE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FirstStrikeResult;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreatTest.MockGameData;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class FirstStrikeStepOrderTest {\n+\n+  enum BattleStateVariation {\n+    HAS_ATTACKING_FIRST_STRIKE,\n+    HAS_DEFENDING_FIRST_STRIKE,\n+    HAS_ATTACKING_DESTROYER,\n+    HAS_DEFENDING_DESTROYER,\n+    HAS_WW2V2,\n+    HAS_DEFENDING_SUBS_SNEAK_ATTACK\n+  }\n+\n+  BattleState givenBattleState(final List<BattleStateVariation> parameters) {\n+    final List<Unit> attackingUnits = new ArrayList<>();\n+    attackingUnits.add(givenAnyUnit());\n+    if (parameters.contains(BattleStateVariation.HAS_ATTACKING_DESTROYER)) {\n+      attackingUnits.add(givenUnitDestroyer());\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_ATTACKING_FIRST_STRIKE)) {\n+      attackingUnits.add(givenUnitFirstStrike());\n+    }\n+\n+    final List<Unit> defendingUnits = new ArrayList<>();\n+    defendingUnits.add(givenAnyUnit());\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_DESTROYER)) {\n+      defendingUnits.add(givenUnitDestroyer());\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_FIRST_STRIKE)) {\n+      defendingUnits.add(givenUnitFirstStrike());\n+    }\n+\n+    final MockGameData gameData = MockGameData.givenGameData();\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_SUBS_SNEAK_ATTACK)) {\n+      gameData.withDefendingSubsSneakAttack(true);\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_WW2V2)) {\n+      gameData.withWW2V2(true);\n+    }\n+\n+    return givenBattleStateBuilder()\n+        .attackingUnits(attackingUnits)\n+        .defendingUnits(defendingUnits)\n+        .gameData(gameData.build())\n+        .build();\n+  }\n+\n+  @Test\n+  void noFirstStrikeUnitsShouldReturnNothing() {\n+    final BattleState battleState = givenBattleState(List.of());\n+\n+    final FirstStrikeResult steps = FirstStrikeStepOrder.calculate(battleState);\n+\n+    assertThat(steps, is(FirstStrikeResult.builder().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource\n+  void getStep(final List<BattleStateVariation> parameters, final FirstStrikeResult expected) {\n+\n+    final BattleState battleState = givenBattleState(parameters);\n+\n+    final FirstStrikeResult order = FirstStrikeStepOrder.calculate(battleState);\n+\n+    assertThat(order, is(expected));\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static List<Arguments> getStep() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66e2d7f52533181f50fad53502964de1f8c38eca"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzgyNTIy", "url": "https://github.com/triplea-game/triplea/pull/7042#pullrequestreview-446782522", "createdAt": "2020-07-11T06:25:39Z", "commit": {"oid": "9cd62f92cd31e77e6c337b2b0b90ed6f0c7c0094"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwNjoyNTozOVrOGwK3Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwNjo0MTo1NVrOGwK7vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2Mjc1OQ==", "bodyText": "Do we ever expect to have any other options? If no, then throwing an exception could be valuable in case we fail to update this list.\nHave you considered the \"polymorphic switch\" refactor (I forget the real name for that kind of update), it could potentially remove the switch statement.\nEG:\nreturnFireAgainstAttackingSubs.getFirstStrikeStepOrder()\n\nThough, I do see we could get a circular dependency. This implies a static lookup method on the enum could do the trick, eg:\n  public static Optional<FirstStrikeStepOrder> lookupByReturnFireType(ReturnFire returnFire) {\n    return Arrays.stream(values())\n        .filter(firstStrikeStepOrder -> firstStrikeStepOrder.returnFire == returnFire)\n        .findAny();     \n  }\n\nYet, I see there are duplicated by offender and attacker. Have you considered splitting the enum into two, one for attacker and another for deferender? In such a case you would not have to encode attacker vs defender in the enum name. Perhaps we could even get the attacker or defender to be a flag value itself so that we do not need as many enum values.\nWDYT?", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r453162759", "createdAt": "2020-07-11T06:25:39Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/FirstStrikeStepOrder.java", "diffHunk": "@@ -69,9 +43,23 @@ private static boolean hasAttackingFirstStrike(final BattleState battleState) {\n     return battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsFirstStrike());\n   }\n \n-  private static boolean hasDefendingFirstStrike(final BattleState battleState) {\n-    return battleState.getDefendingUnits().stream()\n-        .anyMatch(Matches.unitIsFirstStrikeOnDefense(battleState.getGameData()));\n+  private static Optional<FirstStrikeStepOrder> calculateAttackerSteps(\n+      final @NonNull BattleState battleState) {\n+    final ReturnFire returnFireAgainstAttackingSubs =\n+        returnFireAgainstAttackingSubs(\n+            battleState.getAttackingUnits(),\n+            battleState.getDefendingUnits(),\n+            battleState.getGameData());\n+    switch (returnFireAgainstAttackingSubs) {\n+      case ALL:\n+        return Optional.of(OFFENDER_NO_SNEAK_ATTACK);\n+      case SUBS:\n+        return Optional.of(OFFENDER_SNEAK_ATTACK_WITH_OPPOSING_FIRST_STRIKE);\n+      case NONE:\n+        return Optional.of(OFFENDER_SNEAK_ATTACK);\n+      default:\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cd62f92cd31e77e6c337b2b0b90ed6f0c7c0094"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2MzEyOA==", "bodyText": "naming nit:\n\nFIRST_STRIKE prefix is perhaps redundant on an enum called FirstStrikeStepOrder. WDYT of this being \"FirstStrikeStepOrder.DEFENDER_FIRST_NONE`\nDEFENDER_FIRST_NONE does not initially make as much sense as it could. Can you suggest a better name perhaps? Maybe DEFENDERS_DO_NOT_RETURN_FIRE. Though, I can't help but feel that is a weird step order, it seems like a 'null' step and should just not be a step at all.. Hence, it's a bit difficult to grok what is intended by this step order from the name.", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r453163128", "createdAt": "2020-07-11T06:30:53Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1494,45 +1496,53 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       }\n     };\n \n-    final ReturnFire returnFireAgainstAttackingSubs =\n-        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n-    final ReturnFire returnFireAgainstDefendingSubs =\n-        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n-    if (SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData)) {\n+    if (firstStrikeStepOrders.contains(FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_FIRST_NONE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f50dde4be832a4774bdade579a986a63dfc353"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2MzYxMw==", "bodyText": "This looks to be getting to be quite a bit of logic for MustFightBattle to know about. Have you considered making this check be a method on FirstStrikeStepOrder?\nEG:\nFirstStrikeStepOrder.containsFirstStrikeAttackersFire(firstStrikeStepOrders)\n\nSimilar can be applied elsewhere to further remove logic from MustFightBattle.\nPerhaps it can be made even cleaner by adding a 'Type' attribute to FirstStrikeStepOrder. EG:\n\npublic enum FirstStrikeType {\n  ATTACKER_FIRE,\n  DEFENDERS_FIRE,\n  DO_NOT_FIRE,\n}\n\n\nFirstStrikeStepOrder.java\n  :\n  :\n\n  NOT_APPLICABLE(ReturnFire.ALL, FirstStrikeType.DO_NOT_FIRE\n  );\n\n  \n  @Getter private final ReturnFire returnFire;\n  private final FirstStrikeType firstStrikeType;\n\n  static boolean containsAttackerFire(Collection<FirstStrikeStepOrder> order) {\n    return order.stream()\n        .anyMatch(o -> o.firstStrikeType == FirstStrikeType.ATTACKER_FIRE);\n  }\n\n\nWDYT, could any of that help?", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r453163613", "createdAt": "2020-07-11T06:37:29Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1494,45 +1496,53 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       }\n     };\n \n-    final ReturnFire returnFireAgainstAttackingSubs =\n-        SubsChecks.returnFireAgainstAttackingSubs(attackingUnits, defendingUnits, gameData);\n-    final ReturnFire returnFireAgainstDefendingSubs =\n-        SubsChecks.returnFireAgainstDefendingSubs(attackingUnits, defendingUnits, gameData);\n-    if (SubsChecks.defenderSubsFireFirst(attackingUnits, defendingUnits, gameData)) {\n+    if (firstStrikeStepOrders.contains(FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_FIRST_NONE)) {\n       steps.add(\n           new FirstStrikeDefendersFire() {\n             private static final long serialVersionUID = 99992L;\n \n             @Override\n             public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              firstStrikeDefendersFire(returnFireAgainstDefendingSubs);\n+              firstStrikeDefendersFire(ReturnFire.NONE);\n             }\n           });\n     }\n-    steps.add(\n-        new FirstStrikeAttackersFire() {\n-          private static final long serialVersionUID = 99991L;\n+    if (firstStrikeStepOrders.contains(FirstStrikeStepOrder.FIRST_STRIKE_OFFENDER_ALL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95f50dde4be832a4774bdade579a986a63dfc353"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2Mzc3Nw==", "bodyText": "nit, the numbering is a smell/maintenance problem.\nIt's a smell as it should be pretty easy to find which parameterized test case is failing. The maintenance burden comes in though if we insert an element mid-list, then suddenly you have to renumber them all.\nFor now this is okay IMO, but if there is a good way to avoid it, we should do that", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r453163777", "createdAt": "2020-07-11T06:40:02Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/FirstStrikeStepOrderTest.java", "diffHunk": "@@ -0,0 +1,531 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitFirstStrike;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_FIRST_NONE;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_SECOND_ALL;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_SECOND_SUBS;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_DEFENDER_STANDARD_ALL;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_OFFENDER_ALL;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_OFFENDER_NONE;\n+import static games.strategy.triplea.delegate.battle.steps.FirstStrikeStepOrder.FIRST_STRIKE_OFFENDER_SUBS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.hasSize;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreatTest.MockGameData;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class FirstStrikeStepOrderTest {\n+\n+  @ParameterizedTest\n+  @MethodSource\n+  void getStep(final List<BattleStateVariation> parameters, final List<FirstStrikeStepOrder> expected, final List<FirstStrikeStepOrder> expected2) {\n+\n+    final BattleState battleState = givenBattleState(parameters);\n+\n+    final List<FirstStrikeStepOrder> steps = FirstStrikeStepOrder.calculate(battleState);\n+\n+    if (expected.isEmpty()) {\n+      assertThat(steps, hasSize(0));\n+    } else {\n+      System.out.println(steps);\n+      assertThat(steps, contains(expected.toArray()));\n+    }\n+\n+    final List<FirstStrikeStepOrder> steps2 = FirstStrikeStepOrder.calculate2(battleState);\n+    if (expected2.isEmpty()) {\n+      assertThat(steps2, hasSize(0));\n+    } else {\n+      System.out.println(steps2);\n+      assertThat(steps2, contains(expected2.toArray()));\n+    }\n+  }\n+\n+  enum BattleStateVariation {\n+    HAS_ATTACKING_FIRST_STRIKE,\n+    HAS_DEFENDING_FIRST_STRIKE,\n+    HAS_ATTACKING_DESTROYER,\n+    HAS_DEFENDING_DESTROYER,\n+    HAS_WW2V2,\n+    HAS_DEFENDING_SUBS_SNEAK_ATTACK\n+  }\n+\n+  BattleState givenBattleState(final List<BattleStateVariation> parameters) {\n+    final List<Unit> attackingUnits = new ArrayList<>();\n+    attackingUnits.add(givenAnyUnit());\n+    if (parameters.contains(BattleStateVariation.HAS_ATTACKING_DESTROYER)) {\n+      attackingUnits.add(givenUnitDestroyer());\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_ATTACKING_FIRST_STRIKE)) {\n+      attackingUnits.add(givenUnitFirstStrike());\n+    }\n+    final List<Unit> defendingUnits = new ArrayList<>();\n+    defendingUnits.add(givenAnyUnit());\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_DESTROYER)) {\n+      defendingUnits.add(givenUnitDestroyer());\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_FIRST_STRIKE)) {\n+      defendingUnits.add(givenUnitFirstStrike());\n+    }\n+    final MockGameData gameData = MockGameData.givenGameData();\n+\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_FIRST_STRIKE)\n+        && !parameters.contains(BattleStateVariation.HAS_ATTACKING_FIRST_STRIKE)) {\n+      gameData.withDefendingSuicideAndMunitionUnitsDoNotFire(false);\n+    }\n+\n+    if (parameters.contains(BattleStateVariation.HAS_DEFENDING_SUBS_SNEAK_ATTACK)) {\n+      if (!parameters.contains(BattleStateVariation.HAS_WW2V2)) {\n+        gameData.withWW2V2(false);\n+      }\n+      gameData.withDefendingSubsSneakAttack(true);\n+    }\n+    if (parameters.contains(BattleStateVariation.HAS_WW2V2)) {\n+      gameData.withWW2V2(true);\n+    }\n+\n+    return givenBattleStateBuilder()\n+        .attackingUnits(attackingUnits)\n+        .defendingUnits(defendingUnits)\n+        .gameData(gameData.build())\n+        .build();\n+  }\n+\n+  static List<Arguments> getStep() {\n+    return List.of(\n+        //1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d04f035c1d4bb18160fd1da601017173b1255547"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE2Mzk2NA==", "bodyText": "It's really good to see logic being isolated and then tested \ud83d\udc4d\nSuch actions helps improve test coverage which is an effective way to detect and lower bug counts. With test coverage in place future changes will be sure to maintain the same contract, which will make those updates easier and safer and not need manual testing. Avoiding manual testing when we simply just re-arrange code but not add new functionality will save us time, and even having a test infrastruture in place makes it eaiser to add new test cases going forward.\nAll in all, this is a good investment, thank you.", "url": "https://github.com/triplea-game/triplea/pull/7042#discussion_r453163964", "createdAt": "2020-07-11T06:41:55Z", "author": {"login": "DanVanAtta"}, "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/FirstStrikeStepOrderTest.java", "diffHunk": "@@ -0,0 +1,531 @@\n+package games.strategy.triplea.delegate.battle.steps;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d04f035c1d4bb18160fd1da601017173b1255547"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3184, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}